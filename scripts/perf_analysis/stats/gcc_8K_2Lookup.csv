
demo:     file format elf64-x86-64


Disassembly of section .init:

0000000000402168 <_init>:
  402168:	48 83 ec 08          	sub    $0x8,%rsp
  40216c:	48 8b 05 0d c1 01 00 	mov    0x1c10d(%rip),%rax        # 41e280 <_DYNAMIC+0x280>
  402173:	48 85 c0             	test   %rax,%rax
  402176:	74 05                	je     40217d <_init+0x15>
  402178:	e8 33 00 00 00       	callq  4021b0 <__gmon_start__@plt>
  40217d:	48 83 c4 08          	add    $0x8,%rsp
  402181:	c3                   	retq   

Disassembly of section .plt:

0000000000402190 <__libc_start_main@plt-0x10>:
  402190:	ff 35 4a c1 01 00    	pushq  0x1c14a(%rip)        # 41e2e0 <_GLOBAL_OFFSET_TABLE_+0x8>
  402196:	ff 25 4c c1 01 00    	jmpq   *0x1c14c(%rip)        # 41e2e8 <_GLOBAL_OFFSET_TABLE_+0x10>
  40219c:	90                   	nop
  40219d:	90                   	nop
  40219e:	90                   	nop
  40219f:	90                   	nop

00000000004021a0 <__libc_start_main@plt>:
  4021a0:	ff 25 4a c1 01 00    	jmpq   *0x1c14a(%rip)        # 41e2f0 <_GLOBAL_OFFSET_TABLE_+0x18>
  4021a6:	68 00 00 00 00       	pushq  $0x0
  4021ab:	e9 e0 ff ff ff       	jmpq   402190 <_init+0x28>

00000000004021b0 <__gmon_start__@plt>:
  4021b0:	ff 25 42 c1 01 00    	jmpq   *0x1c142(%rip)        # 41e2f8 <_GLOBAL_OFFSET_TABLE_+0x20>
  4021b6:	68 01 00 00 00       	pushq  $0x1
  4021bb:	e9 d0 ff ff ff       	jmpq   402190 <_init+0x28>

00000000004021c0 <__tls_get_addr@plt>:
  4021c0:	ff 25 3a c1 01 00    	jmpq   *0x1c13a(%rip)        # 41e300 <_GLOBAL_OFFSET_TABLE_+0x28>
  4021c6:	68 02 00 00 00       	pushq  $0x2
  4021cb:	e9 c0 ff ff ff       	jmpq   402190 <_init+0x28>

00000000004021d0 <pthread_setspecific@plt>:
  4021d0:	ff 25 32 c1 01 00    	jmpq   *0x1c132(%rip)        # 41e308 <_GLOBAL_OFFSET_TABLE_+0x30>
  4021d6:	68 03 00 00 00       	pushq  $0x3
  4021db:	e9 b0 ff ff ff       	jmpq   402190 <_init+0x28>

00000000004021e0 <getrlimit@plt>:
  4021e0:	ff 25 2a c1 01 00    	jmpq   *0x1c12a(%rip)        # 41e310 <_GLOBAL_OFFSET_TABLE_+0x38>
  4021e6:	68 04 00 00 00       	pushq  $0x4
  4021eb:	e9 a0 ff ff ff       	jmpq   402190 <_init+0x28>

00000000004021f0 <pthread_key_create@plt>:
  4021f0:	ff 25 22 c1 01 00    	jmpq   *0x1c122(%rip)        # 41e318 <_GLOBAL_OFFSET_TABLE_+0x40>
  4021f6:	68 05 00 00 00       	pushq  $0x5
  4021fb:	e9 90 ff ff ff       	jmpq   402190 <_init+0x28>

0000000000402200 <pthread_attr_getstacksize@plt>:
  402200:	ff 25 1a c1 01 00    	jmpq   *0x1c11a(%rip)        # 41e320 <_GLOBAL_OFFSET_TABLE_+0x48>
  402206:	68 06 00 00 00       	pushq  $0x6
  40220b:	e9 80 ff ff ff       	jmpq   402190 <_init+0x28>

0000000000402210 <pthread_attr_getguardsize@plt>:
  402210:	ff 25 12 c1 01 00    	jmpq   *0x1c112(%rip)        # 41e328 <_GLOBAL_OFFSET_TABLE_+0x50>
  402216:	68 07 00 00 00       	pushq  $0x7
  40221b:	e9 70 ff ff ff       	jmpq   402190 <_init+0x28>

0000000000402220 <pthread_attr_init@plt>:
  402220:	ff 25 0a c1 01 00    	jmpq   *0x1c10a(%rip)        # 41e330 <_GLOBAL_OFFSET_TABLE_+0x58>
  402226:	68 08 00 00 00       	pushq  $0x8
  40222b:	e9 60 ff ff ff       	jmpq   402190 <_init+0x28>

0000000000402230 <pthread_attr_destroy@plt>:
  402230:	ff 25 02 c1 01 00    	jmpq   *0x1c102(%rip)        # 41e338 <_GLOBAL_OFFSET_TABLE_+0x60>
  402236:	68 09 00 00 00       	pushq  $0x9
  40223b:	e9 50 ff ff ff       	jmpq   402190 <_init+0x28>

0000000000402240 <dlsym@plt>:
  402240:	ff 25 fa c0 01 00    	jmpq   *0x1c0fa(%rip)        # 41e340 <_GLOBAL_OFFSET_TABLE_+0x68>
  402246:	68 0a 00 00 00       	pushq  $0xa
  40224b:	e9 40 ff ff ff       	jmpq   402190 <_init+0x28>

0000000000402250 <dlvsym@plt>:
  402250:	ff 25 f2 c0 01 00    	jmpq   *0x1c0f2(%rip)        # 41e348 <_GLOBAL_OFFSET_TABLE_+0x70>
  402256:	68 0b 00 00 00       	pushq  $0xb
  40225b:	e9 30 ff ff ff       	jmpq   402190 <_init+0x28>

0000000000402260 <_ZN11__sanitizer19real_pthread_createEPvS0_PFS0_S0_ES0_@plt>:
  402260:	ff 25 ea c0 01 00    	jmpq   *0x1c0ea(%rip)        # 41e350 <_GLOBAL_OFFSET_TABLE_+0x78>
  402266:	68 0c 00 00 00       	pushq  $0xc
  40226b:	e9 20 ff ff ff       	jmpq   402190 <_init+0x28>

0000000000402270 <_ZN11__sanitizer17real_pthread_joinEPvPS0_@plt>:
  402270:	ff 25 e2 c0 01 00    	jmpq   *0x1c0e2(%rip)        # 41e358 <_GLOBAL_OFFSET_TABLE_+0x80>
  402276:	68 0d 00 00 00       	pushq  $0xd
  40227b:	e9 10 ff ff ff       	jmpq   402190 <_init+0x28>

0000000000402280 <printf@plt>:
  402280:	ff 25 da c0 01 00    	jmpq   *0x1c0da(%rip)        # 41e360 <_GLOBAL_OFFSET_TABLE_+0x88>
  402286:	68 0e 00 00 00       	pushq  $0xe
  40228b:	e9 00 ff ff ff       	jmpq   402190 <_init+0x28>

0000000000402290 <malloc@plt>:
  402290:	ff 25 d2 c0 01 00    	jmpq   *0x1c0d2(%rip)        # 41e368 <_GLOBAL_OFFSET_TABLE_+0x90>
  402296:	68 0f 00 00 00       	pushq  $0xf
  40229b:	e9 f0 fe ff ff       	jmpq   402190 <_init+0x28>

00000000004022a0 <perror@plt>:
  4022a0:	ff 25 ca c0 01 00    	jmpq   *0x1c0ca(%rip)        # 41e370 <_GLOBAL_OFFSET_TABLE_+0x98>
  4022a6:	68 10 00 00 00       	pushq  $0x10
  4022ab:	e9 e0 fe ff ff       	jmpq   402190 <_init+0x28>

00000000004022b0 <exit@plt>:
  4022b0:	ff 25 c2 c0 01 00    	jmpq   *0x1c0c2(%rip)        # 41e378 <_GLOBAL_OFFSET_TABLE_+0xa0>
  4022b6:	68 11 00 00 00       	pushq  $0x11
  4022bb:	e9 d0 fe ff ff       	jmpq   402190 <_init+0x28>

00000000004022c0 <putchar@plt>:
  4022c0:	ff 25 ba c0 01 00    	jmpq   *0x1c0ba(%rip)        # 41e380 <_GLOBAL_OFFSET_TABLE_+0xa8>
  4022c6:	68 12 00 00 00       	pushq  $0x12
  4022cb:	e9 c0 fe ff ff       	jmpq   402190 <_init+0x28>

00000000004022d0 <free@plt>:
  4022d0:	ff 25 b2 c0 01 00    	jmpq   *0x1c0b2(%rip)        # 41e388 <_GLOBAL_OFFSET_TABLE_+0xb0>
  4022d6:	68 13 00 00 00       	pushq  $0x13
  4022db:	e9 b0 fe ff ff       	jmpq   402190 <_init+0x28>

00000000004022e0 <memset@plt>:
  4022e0:	ff 25 aa c0 01 00    	jmpq   *0x1c0aa(%rip)        # 41e390 <_GLOBAL_OFFSET_TABLE_+0xb8>
  4022e6:	68 14 00 00 00       	pushq  $0x14
  4022eb:	e9 a0 fe ff ff       	jmpq   402190 <_init+0x28>

00000000004022f0 <is_fixed_compression@plt>:
  4022f0:	ff 25 a2 c0 01 00    	jmpq   *0x1c0a2(%rip)        # 41e398 <_GLOBAL_OFFSET_TABLE_+0xc0>
  4022f6:	68 15 00 00 00       	pushq  $0x15
  4022fb:	e9 90 fe ff ff       	jmpq   402190 <_init+0x28>

0000000000402300 <dladdr@plt>:
  402300:	ff 25 9a c0 01 00    	jmpq   *0x1c09a(%rip)        # 41e3a0 <_GLOBAL_OFFSET_TABLE_+0xc8>
  402306:	68 16 00 00 00       	pushq  $0x16
  40230b:	e9 80 fe ff ff       	jmpq   402190 <_init+0x28>

0000000000402310 <allocate_metadata@plt>:
  402310:	ff 25 92 c0 01 00    	jmpq   *0x1c092(%rip)        # 41e3a8 <_GLOBAL_OFFSET_TABLE_+0xd0>
  402316:	68 17 00 00 00       	pushq  $0x17
  40231b:	e9 70 fe ff ff       	jmpq   402190 <_init+0x28>

0000000000402320 <set_metapagetable_entries@plt>:
  402320:	ff 25 8a c0 01 00    	jmpq   *0x1c08a(%rip)        # 41e3b0 <_GLOBAL_OFFSET_TABLE_+0xd8>
  402326:	68 18 00 00 00       	pushq  $0x18
  40232b:	e9 60 fe ff ff       	jmpq   402190 <_init+0x28>

0000000000402330 <fprintf@plt>:
  402330:	ff 25 82 c0 01 00    	jmpq   *0x1c082(%rip)        # 41e3b8 <_GLOBAL_OFFSET_TABLE_+0xe0>
  402336:	68 19 00 00 00       	pushq  $0x19
  40233b:	e9 50 fe ff ff       	jmpq   402190 <_init+0x28>

0000000000402340 <deallocate_metadata@plt>:
  402340:	ff 25 7a c0 01 00    	jmpq   *0x1c07a(%rip)        # 41e3c0 <_GLOBAL_OFFSET_TABLE_+0xe8>
  402346:	68 1a 00 00 00       	pushq  $0x1a
  40234b:	e9 40 fe ff ff       	jmpq   402190 <_init+0x28>

0000000000402350 <backtrace@plt>:
  402350:	ff 25 72 c0 01 00    	jmpq   *0x1c072(%rip)        # 41e3c8 <_GLOBAL_OFFSET_TABLE_+0xf0>
  402356:	68 1b 00 00 00       	pushq  $0x1b
  40235b:	e9 30 fe ff ff       	jmpq   402190 <_init+0x28>

0000000000402360 <backtrace_symbols@plt>:
  402360:	ff 25 6a c0 01 00    	jmpq   *0x1c06a(%rip)        # 41e3d0 <_GLOBAL_OFFSET_TABLE_+0xf8>
  402366:	68 1c 00 00 00       	pushq  $0x1c
  40236b:	e9 20 fe ff ff       	jmpq   402190 <_init+0x28>

0000000000402370 <puts@plt>:
  402370:	ff 25 62 c0 01 00    	jmpq   *0x1c062(%rip)        # 41e3d8 <_GLOBAL_OFFSET_TABLE_+0x100>
  402376:	68 1d 00 00 00       	pushq  $0x1d
  40237b:	e9 10 fe ff ff       	jmpq   402190 <_init+0x28>

0000000000402380 <sigaction@plt>:
  402380:	ff 25 5a c0 01 00    	jmpq   *0x1c05a(%rip)        # 41e3e0 <_GLOBAL_OFFSET_TABLE_+0x108>
  402386:	68 1e 00 00 00       	pushq  $0x1e
  40238b:	e9 00 fe ff ff       	jmpq   402190 <_init+0x28>

0000000000402390 <_setjmp@plt>:
  402390:	ff 25 52 c0 01 00    	jmpq   *0x1c052(%rip)        # 41e3e8 <_GLOBAL_OFFSET_TABLE_+0x110>
  402396:	68 1f 00 00 00       	pushq  $0x1f
  40239b:	e9 f0 fd ff ff       	jmpq   402190 <_init+0x28>

00000000004023a0 <realloc@plt>:
  4023a0:	ff 25 4a c0 01 00    	jmpq   *0x1c04a(%rip)        # 41e3f0 <_GLOBAL_OFFSET_TABLE_+0x118>
  4023a6:	68 20 00 00 00       	pushq  $0x20
  4023ab:	e9 e0 fd ff ff       	jmpq   402190 <_init+0x28>

00000000004023b0 <sigemptyset@plt>:
  4023b0:	ff 25 42 c0 01 00    	jmpq   *0x1c042(%rip)        # 41e3f8 <_GLOBAL_OFFSET_TABLE_+0x120>
  4023b6:	68 21 00 00 00       	pushq  $0x21
  4023bb:	e9 d0 fd ff ff       	jmpq   402190 <_init+0x28>

00000000004023c0 <sigaddset@plt>:
  4023c0:	ff 25 3a c0 01 00    	jmpq   *0x1c03a(%rip)        # 41e400 <_GLOBAL_OFFSET_TABLE_+0x128>
  4023c6:	68 22 00 00 00       	pushq  $0x22
  4023cb:	e9 c0 fd ff ff       	jmpq   402190 <_init+0x28>

00000000004023d0 <pthread_sigmask@plt>:
  4023d0:	ff 25 32 c0 01 00    	jmpq   *0x1c032(%rip)        # 41e408 <_GLOBAL_OFFSET_TABLE_+0x130>
  4023d6:	68 23 00 00 00       	pushq  $0x23
  4023db:	e9 b0 fd ff ff       	jmpq   402190 <_init+0x28>

00000000004023e0 <raise@plt>:
  4023e0:	ff 25 2a c0 01 00    	jmpq   *0x1c02a(%rip)        # 41e410 <_GLOBAL_OFFSET_TABLE_+0x138>
  4023e6:	68 24 00 00 00       	pushq  $0x24
  4023eb:	e9 a0 fd ff ff       	jmpq   402190 <_init+0x28>

00000000004023f0 <longjmp@plt>:
  4023f0:	ff 25 22 c0 01 00    	jmpq   *0x1c022(%rip)        # 41e418 <_GLOBAL_OFFSET_TABLE_+0x140>
  4023f6:	68 25 00 00 00       	pushq  $0x25
  4023fb:	e9 90 fd ff ff       	jmpq   402190 <_init+0x28>

Disassembly of section .text:

0000000000402400 <_ZN11__sanitizer26MostSignificantSetBitIndexEm.part.0>:
unsigned char _BitScanReverse64(unsigned long *index, unsigned __int64 mask);  // NOLINT
#endif
}
#endif

INLINE uptr MostSignificantSetBitIndex(uptr x) {
  402400:	48 89 f9             	mov    %rdi,%rcx
  402403:	50                   	push   %rax
  CHECK_NE(x, 0U);
  402404:	48 8d 15 bc 5f 01 00 	lea    0x15fbc(%rip),%rdx        # 4183c7 <.LC0>
  40240b:	48 8d 3d fe 2b 01 00 	lea    0x12bfe(%rip),%rdi        # 415010 <.LC1>
  402412:	45 31 c0             	xor    %r8d,%r8d
  402415:	be 79 01 00 00       	mov    $0x179,%esi
  40241a:	e8 d1 2f 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40241f:	90                   	nop

0000000000402420 <_ZNK11__sanitizer15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEE3GetEm.part.8>:
    if (!map2) return 0;
    return map2[idx % kSize2];
  }

 private:
  u8 *Get(uptr idx) const {
  402420:	48 89 f9             	mov    %rdi,%rcx
  402423:	50                   	push   %rax
    CHECK_LT(idx, kSize1);
  402424:	48 8d 15 ac 5f 01 00 	lea    0x15fac(%rip),%rdx        # 4183d7 <.LC2>
  40242b:	48 8d 3d 4e 2c 01 00 	lea    0x12c4e(%rip),%rdi        # 415080 <.LC3>
  402432:	41 b8 00 80 00 00    	mov    $0x8000,%r8d
  402438:	be 82 02 00 00       	mov    $0x282,%esi
  40243d:	e8 ae 2f 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

0000000000402442 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE8AllocateEPS7_m.part.15>:
    Drain(allocator);
    if (s)
      s->Unregister(&stats_);
  }

  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {
  402442:	48 89 f9             	mov    %rdi,%rcx
  402445:	50                   	push   %rax
    CHECK_NE(class_id, 0UL);
  402446:	48 8d 15 9f 5f 01 00 	lea    0x15f9f(%rip),%rdx        # 4183ec <.LC4>
  40244d:	48 8d 3d 2c 2c 01 00 	lea    0x12c2c(%rip),%rdi        # 415080 <.LC3>
  402454:	45 31 c0             	xor    %r8d,%r8d
  402457:	be 9b 03 00 00       	mov    $0x39b,%esi
  40245c:	e8 8f 2f 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  402461:	90                   	nop

0000000000402462 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE10DeallocateEPS7_mPv.part.17>:
    void *res = c->batch[--c->count];
    PREFETCH(c->batch[c->count - 1]);
    return res;
  }

  void Deallocate(SizeClassAllocator *allocator, uptr class_id, void *p) {
  402462:	48 89 f9             	mov    %rdi,%rcx
  402465:	50                   	push   %rax
    CHECK_NE(class_id, 0UL);
  402466:	48 8d 15 7f 5f 01 00 	lea    0x15f7f(%rip),%rdx        # 4183ec <.LC4>
  40246d:	48 8d 3d 0c 2c 01 00 	lea    0x12c0c(%rip),%rdi        # 415080 <.LC3>
  402474:	45 31 c0             	xor    %r8d,%r8d
  402477:	be a7 03 00 00       	mov    $0x3a7,%esi
  40247c:	e8 6f 2f 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
	...

0000000000402482 <_ZNK11__sanitizer17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEE5checkEm.isra.16.part.17>:
    uptr i0_, i1_;
    typename BV::Iterator it1_, it2_;
  };

 private:
  void check(uptr idx) const { CHECK_LE(idx, size()); }
  402482:	48 89 f9             	mov    %rdi,%rcx
  402485:	50                   	push   %rax
  402486:	48 8d 15 2e 61 01 00 	lea    0x1612e(%rip),%rdx        # 4185bb <.LC0>
  40248d:	48 8d 3d fc 31 01 00 	lea    0x131fc(%rip),%rdi        # 415690 <.LC1>
  402494:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  40249a:	be 45 01 00 00       	mov    $0x145,%esi
  40249f:	e8 4c 2f 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

00000000004024a4 <_ZNK11__sanitizer14BasicBitVectorImE4maskEm.isra.19.part.20>:
   private:
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
  4024a4:	48 89 f9             	mov    %rdi,%rcx
  4024a7:	50                   	push   %rax
    CHECK_LT(idx, size());
  4024a8:	48 8d 15 22 61 01 00 	lea    0x16122(%rip),%rdx        # 4185d1 <.LC2>
  4024af:	48 8d 3d da 31 01 00 	lea    0x131da(%rip),%rdi        # 415690 <.LC1>
  4024b6:	41 b8 40 00 00 00    	mov    $0x40,%r8d
  4024bc:	be 65 00 00 00       	mov    $0x65,%esi
  4024c1:	e8 2a 2f 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

00000000004024c6 <_ZN11__sanitizerL22ReadNullSepFileToArrayEPKcPPPci.constprop.6>:
extern "C" {
  SANITIZER_WEAK_ATTRIBUTE extern void *__libc_stack_end;
}

#if !SANITIZER_GO
static void ReadNullSepFileToArray(const char *path, char ***arr,
  4024c6:	55                   	push   %rbp
  4024c7:	48 89 fd             	mov    %rdi,%rbp
                                   int arr_size) {
  char *buff;
  uptr buff_size;
  uptr buff_len;
  *arr = (char **)MmapOrDie(arr_size * sizeof(char *), "NullSepFileArray");
  4024ca:	bf 80 3e 00 00       	mov    $0x3e80,%edi
extern "C" {
  SANITIZER_WEAK_ATTRIBUTE extern void *__libc_stack_end;
}

#if !SANITIZER_GO
static void ReadNullSepFileToArray(const char *path, char ***arr,
  4024cf:	53                   	push   %rbx
  4024d0:	48 89 f3             	mov    %rsi,%rbx
                                   int arr_size) {
  char *buff;
  uptr buff_size;
  uptr buff_len;
  *arr = (char **)MmapOrDie(arr_size * sizeof(char *), "NullSepFileArray");
  4024d3:	48 8d 35 dd 66 01 00 	lea    0x166dd(%rip),%rsi        # 418bb7 <.LC0>
extern "C" {
  SANITIZER_WEAK_ATTRIBUTE extern void *__libc_stack_end;
}

#if !SANITIZER_GO
static void ReadNullSepFileToArray(const char *path, char ***arr,
  4024da:	48 83 ec 28          	sub    $0x28,%rsp
                                   int arr_size) {
  char *buff;
  uptr buff_size;
  uptr buff_len;
  *arr = (char **)MmapOrDie(arr_size * sizeof(char *), "NullSepFileArray");
  4024de:	e8 bd 9e 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  if (!ReadFileToBuffer(path, &buff, &buff_size, &buff_len, 1024 * 1024)) {
  4024e3:	48 8d 4c 24 18       	lea    0x18(%rsp),%rcx
  4024e8:	48 8d 54 24 10       	lea    0x10(%rsp),%rdx
  4024ed:	45 31 c9             	xor    %r9d,%r9d
static void ReadNullSepFileToArray(const char *path, char ***arr,
                                   int arr_size) {
  char *buff;
  uptr buff_size;
  uptr buff_len;
  *arr = (char **)MmapOrDie(arr_size * sizeof(char *), "NullSepFileArray");
  4024f0:	48 89 03             	mov    %rax,(%rbx)
  if (!ReadFileToBuffer(path, &buff, &buff_size, &buff_len, 1024 * 1024)) {
  4024f3:	48 89 e6             	mov    %rsp,%rsi
  4024f6:	41 b8 00 00 10 00    	mov    $0x100000,%r8d
  4024fc:	48 89 ef             	mov    %rbp,%rdi
  4024ff:	e8 ec 30 00 00       	callq  4055f0 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi>
  402504:	84 c0                	test   %al,%al
  402506:	48 8b 03             	mov    (%rbx),%rax
  402509:	75 09                	jne    402514 <_ZN11__sanitizerL22ReadNullSepFileToArrayEPKcPPPci.constprop.6+0x4e>
    (*arr)[0] = nullptr;
  40250b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  402512:	eb 64                	jmp    402578 <_ZN11__sanitizerL22ReadNullSepFileToArrayEPKcPPPci.constprop.6+0xb2>
    return;
  }
  (*arr)[0] = buff;
  402514:	48 8b 14 24          	mov    (%rsp),%rdx
  int count, i;
  for (count = 1, i = 1; ; i++) {
  402518:	bf 01 00 00 00       	mov    $0x1,%edi
  *arr = (char **)MmapOrDie(arr_size * sizeof(char *), "NullSepFileArray");
  if (!ReadFileToBuffer(path, &buff, &buff_size, &buff_len, 1024 * 1024)) {
    (*arr)[0] = nullptr;
    return;
  }
  (*arr)[0] = buff;
  40251d:	48 89 10             	mov    %rdx,(%rax)
  402520:	b8 01 00 00 00       	mov    $0x1,%eax
  int count, i;
  for (count = 1, i = 1; ; i++) {
    if (buff[i] == 0) {
  402525:	48 8b 14 24          	mov    (%rsp),%rdx
  402529:	80 3c 02 00          	cmpb   $0x0,(%rdx,%rax,1)
  40252d:	48 8d 40 01          	lea    0x1(%rax),%rax
  402531:	75 f2                	jne    402525 <_ZN11__sanitizerL22ReadNullSepFileToArrayEPKcPPPci.constprop.6+0x5f>
      if (buff[i+1] == 0) break;
  402533:	48 01 c2             	add    %rax,%rdx
  402536:	4c 8b 03             	mov    (%rbx),%r8
  402539:	48 63 cf             	movslq %edi,%rcx
  40253c:	80 3a 00             	cmpb   $0x0,(%rdx)
  40253f:	74 2f                	je     402570 <_ZN11__sanitizerL22ReadNullSepFileToArrayEPKcPPPci.constprop.6+0xaa>
      (*arr)[count] = &buff[i+1];
      CHECK_LE(count, arr_size - 1);  // FIXME: make this more flexible.
  402541:	48 81 f9 cf 07 00 00 	cmp    $0x7cf,%rcx
  (*arr)[0] = buff;
  int count, i;
  for (count = 1, i = 1; ; i++) {
    if (buff[i] == 0) {
      if (buff[i+1] == 0) break;
      (*arr)[count] = &buff[i+1];
  402548:	49 89 14 c8          	mov    %rdx,(%r8,%rcx,8)
      CHECK_LE(count, arr_size - 1);  // FIXME: make this more flexible.
  40254c:	76 1e                	jbe    40256c <_ZN11__sanitizerL22ReadNullSepFileToArrayEPKcPPPci.constprop.6+0xa6>
  40254e:	48 8d 15 73 66 01 00 	lea    0x16673(%rip),%rdx        # 418bc8 <.LC1>
  402555:	48 8d 3d ec 4b 01 00 	lea    0x14bec(%rip),%rdi        # 417148 <.LC2>
  40255c:	41 b8 cf 07 00 00    	mov    $0x7cf,%r8d
  402562:	be a2 01 00 00       	mov    $0x1a2,%esi
  402567:	e8 84 2e 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
      count++;
  40256c:	ff c7                	inc    %edi
  40256e:	eb b5                	jmp    402525 <_ZN11__sanitizerL22ReadNullSepFileToArrayEPKcPPPci.constprop.6+0x5f>
    }
  }
  (*arr)[count] = nullptr;
  402570:	49 c7 04 c8 00 00 00 	movq   $0x0,(%r8,%rcx,8)
  402577:	00 
}
  402578:	48 83 c4 28          	add    $0x28,%rsp
  40257c:	5b                   	pop    %rbx
  40257d:	5d                   	pop    %rbp
  40257e:	c3                   	retq   

000000000040257f <_ZN11__sanitizer10UnmapOrDieEPvm.part.0>:
    ReportMmapFailureAndDie(size, mem_type, reserrno);
  IncreaseTotalMmap(size);
  return (void *)res;
}

void UnmapOrDie(void *addr, uptr size) {
  40257f:	50                   	push   %rax
  if (!addr || !size) return;
  uptr res = internal_munmap(addr, size);
  if (internal_iserror(res)) {
    Report("ERROR: %s failed to deallocate 0x%zx (%zd) bytes at address %p\n",
           SanitizerToolName, size, size, addr);
  402580:	48 8b 05 29 bd 01 00 	mov    0x1bd29(%rip),%rax        # 41e2b0 <_DYNAMIC+0x2b0>
    ReportMmapFailureAndDie(size, mem_type, reserrno);
  IncreaseTotalMmap(size);
  return (void *)res;
}

void UnmapOrDie(void *addr, uptr size) {
  402587:	48 89 f2             	mov    %rsi,%rdx
  if (!addr || !size) return;
  uptr res = internal_munmap(addr, size);
  if (internal_iserror(res)) {
    Report("ERROR: %s failed to deallocate 0x%zx (%zd) bytes at address %p\n",
           SanitizerToolName, size, size, addr);
  40258a:	48 89 f1             	mov    %rsi,%rcx
    ReportMmapFailureAndDie(size, mem_type, reserrno);
  IncreaseTotalMmap(size);
  return (void *)res;
}

void UnmapOrDie(void *addr, uptr size) {
  40258d:	49 89 f8             	mov    %rdi,%r8
  if (!addr || !size) return;
  uptr res = internal_munmap(addr, size);
  if (internal_iserror(res)) {
    Report("ERROR: %s failed to deallocate 0x%zx (%zd) bytes at address %p\n",
           SanitizerToolName, size, size, addr);
  402590:	48 8d 3d c9 4d 01 00 	lea    0x14dc9(%rip),%rdi        # 417360 <.LC0>
  402597:	48 8b 30             	mov    (%rax),%rsi
  40259a:	31 c0                	xor    %eax,%eax
  40259c:	e8 ef b4 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
    CHECK("unable to unmap" && 0);
  4025a1:	48 8d 15 f8 4d 01 00 	lea    0x14df8(%rip),%rdx        # 4173a0 <.LC1>
  4025a8:	48 8d 3d 19 4e 01 00 	lea    0x14e19(%rip),%rdi        # 4173c8 <.LC2>
  4025af:	45 31 c0             	xor    %r8d,%r8d
  4025b2:	31 c9                	xor    %ecx,%ecx
  4025b4:	be 85 00 00 00       	mov    $0x85,%esi
  4025b9:	e8 32 2e 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
	...

00000000004025c0 <_start>:
  4025c0:	31 ed                	xor    %ebp,%ebp
  4025c2:	49 89 d1             	mov    %rdx,%r9
  4025c5:	5e                   	pop    %rsi
  4025c6:	48 89 e2             	mov    %rsp,%rdx
  4025c9:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  4025cd:	50                   	push   %rax
  4025ce:	54                   	push   %rsp
  4025cf:	49 c7 c0 30 4e 41 00 	mov    $0x414e30,%r8
  4025d6:	48 c7 c1 c0 4d 41 00 	mov    $0x414dc0,%rcx
  4025dd:	48 c7 c7 60 26 41 00 	mov    $0x412660,%rdi
  4025e4:	e8 b7 fb ff ff       	callq  4021a0 <__libc_start_main@plt>
  4025e9:	f4                   	hlt    
  4025ea:	66 90                	xchg   %ax,%ax
  4025ec:	0f 1f 40 00          	nopl   0x0(%rax)

00000000004025f0 <deregister_tm_clones>:
  4025f0:	b8 ef 0c 42 00       	mov    $0x420cef,%eax
  4025f5:	55                   	push   %rbp
  4025f6:	48 2d e8 0c 42 00    	sub    $0x420ce8,%rax
  4025fc:	48 83 f8 0e          	cmp    $0xe,%rax
  402600:	48 89 e5             	mov    %rsp,%rbp
  402603:	77 02                	ja     402607 <deregister_tm_clones+0x17>
  402605:	5d                   	pop    %rbp
  402606:	c3                   	retq   
  402607:	b8 00 00 00 00       	mov    $0x0,%eax
  40260c:	48 85 c0             	test   %rax,%rax
  40260f:	74 f4                	je     402605 <deregister_tm_clones+0x15>
  402611:	5d                   	pop    %rbp
  402612:	bf e8 0c 42 00       	mov    $0x420ce8,%edi
  402617:	ff e0                	jmpq   *%rax
  402619:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000402620 <register_tm_clones>:
  402620:	b8 e8 0c 42 00       	mov    $0x420ce8,%eax
  402625:	55                   	push   %rbp
  402626:	48 2d e8 0c 42 00    	sub    $0x420ce8,%rax
  40262c:	48 c1 f8 03          	sar    $0x3,%rax
  402630:	48 89 e5             	mov    %rsp,%rbp
  402633:	48 89 c2             	mov    %rax,%rdx
  402636:	48 c1 ea 3f          	shr    $0x3f,%rdx
  40263a:	48 01 d0             	add    %rdx,%rax
  40263d:	48 d1 f8             	sar    %rax
  402640:	75 02                	jne    402644 <register_tm_clones+0x24>
  402642:	5d                   	pop    %rbp
  402643:	c3                   	retq   
  402644:	ba 00 00 00 00       	mov    $0x0,%edx
  402649:	48 85 d2             	test   %rdx,%rdx
  40264c:	74 f4                	je     402642 <register_tm_clones+0x22>
  40264e:	5d                   	pop    %rbp
  40264f:	48 89 c6             	mov    %rax,%rsi
  402652:	bf e8 0c 42 00       	mov    $0x420ce8,%edi
  402657:	ff e2                	jmpq   *%rdx
  402659:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000402660 <__do_global_dtors_aux>:
  402660:	80 3d d9 e8 01 00 00 	cmpb   $0x0,0x1e8d9(%rip)        # 420f40 <completed.6337>
  402667:	75 11                	jne    40267a <__do_global_dtors_aux+0x1a>
  402669:	55                   	push   %rbp
  40266a:	48 89 e5             	mov    %rsp,%rbp
  40266d:	e8 7e ff ff ff       	callq  4025f0 <deregister_tm_clones>
  402672:	5d                   	pop    %rbp
  402673:	c6 05 c6 e8 01 00 01 	movb   $0x1,0x1e8c6(%rip)        # 420f40 <completed.6337>
  40267a:	f3 c3                	repz retq 
  40267c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000402680 <frame_dummy>:
  402680:	48 83 3d 58 e6 01 00 	cmpq   $0x0,0x1e658(%rip)        # 420ce0 <__JCR_END__>
  402687:	00 
  402688:	74 1e                	je     4026a8 <frame_dummy+0x28>
  40268a:	b8 00 00 00 00       	mov    $0x0,%eax
  40268f:	48 85 c0             	test   %rax,%rax
  402692:	74 14                	je     4026a8 <frame_dummy+0x28>
  402694:	55                   	push   %rbp
  402695:	bf e0 0c 42 00       	mov    $0x420ce0,%edi
  40269a:	48 89 e5             	mov    %rsp,%rbp
  40269d:	ff d0                	callq  *%rax
  40269f:	5d                   	pop    %rbp
  4026a0:	e9 7b ff ff ff       	jmpq   402620 <register_tm_clones>
  4026a5:	0f 1f 00             	nopl   (%rax)
  4026a8:	e9 73 ff ff ff       	jmpq   402620 <register_tm_clones>
  4026ad:	0f 1f 00             	nopl   (%rax)

00000000004026b0 <_ZL22thread_cleanup_handlerPv>:
  // We want to free the unsafe stack only after all other destructors
  // have already run. We force this function to be called multiple times.
  // User destructors that might run more then PTHREAD_DESTRUCTOR_ITERATIONS-1
  // times might still end up executing after the unsafe stack is deallocated.
  size_t iter = (size_t)_iter;
  if (iter < PTHREAD_DESTRUCTOR_ITERATIONS) {
  4026b0:	48 83 ff 03          	cmp    $0x3,%rdi
  4026b4:	0f 86 e6 00 00 00    	jbe    4027a0 <_ZL22thread_cleanup_handlerPv+0xf0>

  return start_routine(start_routine_arg);
}

/// Thread-specific data destructor
static void thread_cleanup_handler(void *_iter) {
  4026ba:	53                   	push   %rbx
  4026bb:	48 83 ec 10          	sub    $0x10,%rsp
  __safestack_unsafe_stack_ptr_large = stack_ptr;
  unsafe_stack_start_large = start;
}

static void unsafe_stack_free() {
  if (unsafe_stack_start) {
  4026bf:	66 66 66 64 48 8b 04 	data16 data16 data16 mov %fs:0x0,%rax
  4026c6:	25 00 00 00 00 
  4026cb:	48 8b b8 c0 fe ff ff 	mov    -0x140(%rax),%rdi
  4026d2:	48 89 c3             	mov    %rax,%rbx
  4026d5:	48 85 ff             	test   %rdi,%rdi
  4026d8:	74 2e                	je     402708 <_ZL22thread_cleanup_handlerPv+0x58>
    UnmapOrDie((char *)unsafe_stack_start - unsafe_stack_guard,
               unsafe_stack_size + unsafe_stack_guard);
  4026da:	48 8b 80 a0 fe ff ff 	mov    -0x160(%rax),%rax
  4026e1:	48 89 c6             	mov    %rax,%rsi
  4026e4:	48 03 b3 b0 fe ff ff 	add    -0x150(%rbx),%rsi
  unsafe_stack_start_large = start;
}

static void unsafe_stack_free() {
  if (unsafe_stack_start) {
    UnmapOrDie((char *)unsafe_stack_start - unsafe_stack_guard,
  4026eb:	48 29 c7             	sub    %rax,%rdi
               unsafe_stack_size + unsafe_stack_guard);
  4026ee:	e8 4d 9d 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
    unsafe_stack_free_meta(unsafe_stack_start, unsafe_stack_size, false);
  4026f3:	48 8b b3 b0 fe ff ff 	mov    -0x150(%rbx),%rsi
  4026fa:	48 8b bb c0 fe ff ff 	mov    -0x140(%rbx),%rdi
  402701:	31 d2                	xor    %edx,%edx
  402703:	e8 48 1a 01 00       	callq  414150 <unsafe_stack_free_meta>
  }
  unsafe_stack_start = nullptr;
  402708:	66 66 66 64 48 8b 04 	data16 data16 data16 mov %fs:0x0,%rax
  40270f:	25 00 00 00 00 
  if (iter < PTHREAD_DESTRUCTOR_ITERATIONS) {
    pthread_setspecific(thread_cleanup_key, (void *)(iter + 1));
  } else {
    // This is the last iteration
    unsafe_stack_free();
    if (__safestack::flags()->largestack)
  402714:	48 8b 15 6d bb 01 00 	mov    0x1bb6d(%rip),%rdx        # 41e288 <_DYNAMIC+0x288>
  if (unsafe_stack_start) {
    UnmapOrDie((char *)unsafe_stack_start - unsafe_stack_guard,
               unsafe_stack_size + unsafe_stack_guard);
    unsafe_stack_free_meta(unsafe_stack_start, unsafe_stack_size, false);
  }
  unsafe_stack_start = nullptr;
  40271b:	48 c7 80 c0 fe ff ff 	movq   $0x0,-0x140(%rax)
  402722:	00 00 00 00 
  if (iter < PTHREAD_DESTRUCTOR_ITERATIONS) {
    pthread_setspecific(thread_cleanup_key, (void *)(iter + 1));
  } else {
    // This is the last iteration
    unsafe_stack_free();
    if (__safestack::flags()->largestack)
  402726:	80 3a 00             	cmpb   $0x0,(%rdx)
  402729:	75 0d                	jne    402738 <_ZL22thread_cleanup_handlerPv+0x88>
      unsafe_stack_free_large();
  }
}
  40272b:	48 83 c4 10          	add    $0x10,%rsp
  40272f:	5b                   	pop    %rbx
  402730:	c3                   	retq   
  402731:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  }
  unsafe_stack_start = nullptr;
}

static void unsafe_stack_free_large() {
  if (unsafe_stack_start_large) {
  402738:	48 8b b8 90 fe ff ff 	mov    -0x170(%rax),%rdi
  40273f:	48 85 ff             	test   %rdi,%rdi
  402742:	74 3b                	je     40277f <_ZL22thread_cleanup_handlerPv+0xcf>
    UnmapOrDie((char *)unsafe_stack_start_large - unsafe_stack_guard,
               unsafe_stack_size + unsafe_stack_guard);
  402744:	48 8b 90 a0 fe ff ff 	mov    -0x160(%rax),%rdx
  40274b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  402750:	48 89 d6             	mov    %rdx,%rsi
  402753:	48 03 b0 b0 fe ff ff 	add    -0x150(%rax),%rsi
  unsafe_stack_start = nullptr;
}

static void unsafe_stack_free_large() {
  if (unsafe_stack_start_large) {
    UnmapOrDie((char *)unsafe_stack_start_large - unsafe_stack_guard,
  40275a:	48 29 d7             	sub    %rdx,%rdi
               unsafe_stack_size + unsafe_stack_guard);
  40275d:	e8 de 9c 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
    unsafe_stack_free_meta(unsafe_stack_start_large, unsafe_stack_size, true);
  402762:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  402767:	ba 01 00 00 00       	mov    $0x1,%edx
  40276c:	48 8b b0 b0 fe ff ff 	mov    -0x150(%rax),%rsi
  402773:	48 8b b8 90 fe ff ff 	mov    -0x170(%rax),%rdi
  40277a:	e8 d1 19 01 00       	callq  414150 <unsafe_stack_free_meta>
  }
  unsafe_stack_start = nullptr;
  40277f:	66 66 66 64 48 8b 04 	data16 data16 data16 mov %fs:0x0,%rax
  402786:	25 00 00 00 00 
  40278b:	48 c7 80 c0 fe ff ff 	movq   $0x0,-0x140(%rax)
  402792:	00 00 00 00 
    // This is the last iteration
    unsafe_stack_free();
    if (__safestack::flags()->largestack)
      unsafe_stack_free_large();
  }
}
  402796:	48 83 c4 10          	add    $0x10,%rsp
  40279a:	5b                   	pop    %rbx
  40279b:	c3                   	retq   
  40279c:	0f 1f 40 00          	nopl   0x0(%rax)
  // have already run. We force this function to be called multiple times.
  // User destructors that might run more then PTHREAD_DESTRUCTOR_ITERATIONS-1
  // times might still end up executing after the unsafe stack is deallocated.
  size_t iter = (size_t)_iter;
  if (iter < PTHREAD_DESTRUCTOR_ITERATIONS) {
    pthread_setspecific(thread_cleanup_key, (void *)(iter + 1));
  4027a0:	48 8d 77 01          	lea    0x1(%rdi),%rsi
  4027a4:	8b 3d b6 e7 01 00    	mov    0x1e7b6(%rip),%edi        # 420f60 <_ZL18thread_cleanup_key>
  4027aa:	e9 21 fa ff ff       	jmpq   4021d0 <pthread_setspecific@plt>
  4027af:	90                   	nop

00000000004027b0 <_ZL12thread_startPv>:
  void *unsafe_stack_start_large;
};

/// Wrap the thread function in order to deallocate the unsafe stack when the
/// thread terminates by returning from its main function.
static void *thread_start(void *arg) {
  4027b0:	41 57                	push   %r15
  4027b2:	41 56                	push   %r14
  4027b4:	41 55                	push   %r13
  4027b6:	41 54                	push   %r12
  4027b8:	55                   	push   %rbp
  4027b9:	48 89 fd             	mov    %rdi,%rbp
  4027bc:	53                   	push   %rbx
  4027bd:	48 83 ec 18          	sub    $0x18,%rsp
  void *(*start_routine)(void *) = tinfo->start_routine;
  void *start_routine_arg = tinfo->start_routine_arg;

  // Setup the unsafe stack; this will destroy tinfo content
  unsafe_stack_setup(tinfo->unsafe_stack_start, tinfo->unsafe_stack_size,
                     tinfo->unsafe_stack_guard);
  4027c1:	48 8b 5f 10          	mov    0x10(%rdi),%rbx
  4027c5:	4c 8b 67 18          	mov    0x18(%rdi),%r12
/// Wrap the thread function in order to deallocate the unsafe stack when the
/// thread terminates by returning from its main function.
static void *thread_start(void *arg) {
  struct tinfo *tinfo = (struct tinfo *)arg;

  void *(*start_routine)(void *) = tinfo->start_routine;
  4027c9:	48 8b 07             	mov    (%rdi),%rax
  void *start_routine_arg = tinfo->start_routine_arg;
  4027cc:	4c 8b 7f 08          	mov    0x8(%rdi),%r15

  // Setup the unsafe stack; this will destroy tinfo content
  unsafe_stack_setup(tinfo->unsafe_stack_start, tinfo->unsafe_stack_size,
                     tinfo->unsafe_stack_guard);
  4027d0:	4c 8b 6f 20          	mov    0x20(%rdi),%r13
  MprotectNoAccess((uptr)addr, (uptr)guard);
  return (char *)addr + guard;
}

static inline void unsafe_stack_setup(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  4027d4:	49 89 de             	mov    %rbx,%r14
  4027d7:	4d 01 e6             	add    %r12,%r14
/// Wrap the thread function in order to deallocate the unsafe stack when the
/// thread terminates by returning from its main function.
static void *thread_start(void *arg) {
  struct tinfo *tinfo = (struct tinfo *)arg;

  void *(*start_routine)(void *) = tinfo->start_routine;
  4027da:	48 89 04 24          	mov    %rax,(%rsp)
  MprotectNoAccess((uptr)addr, (uptr)guard);
  return (char *)addr + guard;
}

static inline void unsafe_stack_setup(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  4027de:	0f 82 0d 01 00 00    	jb     4028f1 <_ZL12thread_startPv+0x141>
  CHECK_GE((char *)start + guard, (char *)start);
  4027e4:	48 89 d9             	mov    %rbx,%rcx
  4027e7:	4c 01 e9             	add    %r13,%rcx
  4027ea:	0f 82 e6 00 00 00    	jb     4028d6 <_ZL12thread_startPv+0x126>
  void *stack_ptr = (char *)start + size;
  CHECK_EQ((((size_t)stack_ptr) & (kStackAlign - 1)), 0);
  4027f0:	4c 89 f1             	mov    %r14,%rcx
  4027f3:	83 e1 0f             	and    $0xf,%ecx
  4027f6:	0f 85 bf 00 00 00    	jne    4028bb <_ZL12thread_startPv+0x10b>
  4027fc:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  402803:	00 00 

  __safestack_unsafe_stack_ptr = stack_ptr;
  402805:	48 8d 80 e0 fe ff ff 	lea    -0x120(%rax),%rax
  40280c:	4c 89 30             	mov    %r14,(%rax)
  unsafe_stack_start = start;
  40280f:	66 66 66 64 48 8b 04 	data16 data16 data16 mov %fs:0x0,%rax
  402816:	25 00 00 00 00 
  40281b:	48 89 c2             	mov    %rax,%rdx
  40281e:	48 89 98 c0 fe ff ff 	mov    %rbx,-0x140(%rax)
  unsafe_stack_size = size;
  402825:	4c 89 a0 b0 fe ff ff 	mov    %r12,-0x150(%rax)
  unsafe_stack_guard = guard;
  40282c:	4c 89 a8 a0 fe ff ff 	mov    %r13,-0x160(%rax)
  void *start_routine_arg = tinfo->start_routine_arg;

  // Setup the unsafe stack; this will destroy tinfo content
  unsafe_stack_setup(tinfo->unsafe_stack_start, tinfo->unsafe_stack_size,
                     tinfo->unsafe_stack_guard);
  if (__safestack::flags()->largestack)
  402833:	48 8b 05 4e ba 01 00 	mov    0x1ba4e(%rip),%rax        # 41e288 <_DYNAMIC+0x288>
  40283a:	80 38 00             	cmpb   $0x0,(%rax)
  40283d:	75 31                	jne    402870 <_ZL12thread_startPv+0xc0>
                     tinfo->unsafe_stack_guard);

  // Make sure out thread-specific destructor will be called
  // FIXME: we can do this only any other specific key is set by
  // intercepting the pthread_setspecific function itself
  pthread_setspecific(thread_cleanup_key, (void *)1);
  40283f:	8b 3d 1b e7 01 00    	mov    0x1e71b(%rip),%edi        # 420f60 <_ZL18thread_cleanup_key>
  402845:	be 01 00 00 00       	mov    $0x1,%esi
  40284a:	e8 81 f9 ff ff       	callq  4021d0 <pthread_setspecific@plt>

  return start_routine(start_routine_arg);
  40284f:	48 8b 04 24          	mov    (%rsp),%rax
}
  402853:	48 83 c4 18          	add    $0x18,%rsp
  // Make sure out thread-specific destructor will be called
  // FIXME: we can do this only any other specific key is set by
  // intercepting the pthread_setspecific function itself
  pthread_setspecific(thread_cleanup_key, (void *)1);

  return start_routine(start_routine_arg);
  402857:	4c 89 ff             	mov    %r15,%rdi
}
  40285a:	5b                   	pop    %rbx
  40285b:	5d                   	pop    %rbp
  40285c:	41 5c                	pop    %r12
  40285e:	41 5d                	pop    %r13
  402860:	41 5e                	pop    %r14
  402862:	41 5f                	pop    %r15
  // Make sure out thread-specific destructor will be called
  // FIXME: we can do this only any other specific key is set by
  // intercepting the pthread_setspecific function itself
  pthread_setspecific(thread_cleanup_key, (void *)1);

  return start_routine(start_routine_arg);
  402864:	ff e0                	jmpq   *%rax
  402866:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40286d:	00 00 00 
  // Setup the unsafe stack; this will destroy tinfo content
  unsafe_stack_setup(tinfo->unsafe_stack_start, tinfo->unsafe_stack_size,
                     tinfo->unsafe_stack_guard);
  if (__safestack::flags()->largestack)
    unsafe_stack_setup_large(tinfo->unsafe_stack_start_large, tinfo->unsafe_stack_size,
                     tinfo->unsafe_stack_guard);
  402870:	48 8b 5d 28          	mov    0x28(%rbp),%rbx
  unsafe_stack_size = size;
  unsafe_stack_guard = guard;
}

static inline void unsafe_stack_setup_large(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  402874:	49 01 dc             	add    %rbx,%r12
  402877:	0f 82 92 00 00 00    	jb     40290f <_ZL12thread_startPv+0x15f>
  CHECK_GE((char *)start + guard, (char *)start);
  40287d:	4c 89 e9             	mov    %r13,%rcx
  402880:	48 01 d9             	add    %rbx,%rcx
  402883:	0f 82 a4 00 00 00    	jb     40292d <_ZL12thread_startPv+0x17d>
  void *stack_ptr = (char *)start + size;
  CHECK_EQ((((size_t)stack_ptr) & (kStackAlign - 1)), 0);
  402889:	4c 89 e1             	mov    %r12,%rcx
  40288c:	83 e1 0f             	and    $0xf,%ecx
  40288f:	0f 85 b3 00 00 00    	jne    402948 <_ZL12thread_startPv+0x198>
  402895:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
  40289a:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  4028a1:	00 00 

  __safestack_unsafe_stack_ptr_large = stack_ptr;
  4028a3:	48 8d 80 d0 fe ff ff 	lea    -0x130(%rax),%rax
  unsafe_stack_start_large = start;
  4028aa:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  CHECK_GE((char *)start + size, (char *)start);
  CHECK_GE((char *)start + guard, (char *)start);
  void *stack_ptr = (char *)start + size;
  CHECK_EQ((((size_t)stack_ptr) & (kStackAlign - 1)), 0);

  __safestack_unsafe_stack_ptr_large = stack_ptr;
  4028af:	4c 89 20             	mov    %r12,(%rax)
  unsafe_stack_start_large = start;
  4028b2:	48 89 9a 90 fe ff ff 	mov    %rbx,-0x170(%rdx)
  4028b9:	eb 84                	jmp    40283f <_ZL12thread_startPv+0x8f>

static inline void unsafe_stack_setup(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  CHECK_GE((char *)start + guard, (char *)start);
  void *stack_ptr = (char *)start + size;
  CHECK_EQ((((size_t)stack_ptr) & (kStackAlign - 1)), 0);
  4028bb:	48 8d 15 56 26 01 00 	lea    0x12656(%rip),%rdx        # 414f18 <.LC3>
  4028c2:	48 8d 3d b7 25 01 00 	lea    0x125b7(%rip),%rdi        # 414e80 <.LC1>
  4028c9:	45 31 c0             	xor    %r8d,%r8d
  4028cc:	be 77 00 00 00       	mov    $0x77,%esi
  4028d1:	e8 1a 2b 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  return (char *)addr + guard;
}

static inline void unsafe_stack_setup(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  CHECK_GE((char *)start + guard, (char *)start);
  4028d6:	48 8d 15 0b 26 01 00 	lea    0x1260b(%rip),%rdx        # 414ee8 <.LC2>
  4028dd:	48 8d 3d 9c 25 01 00 	lea    0x1259c(%rip),%rdi        # 414e80 <.LC1>
  4028e4:	49 89 d8             	mov    %rbx,%r8
  4028e7:	be 75 00 00 00       	mov    $0x75,%esi
  4028ec:	e8 ff 2a 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  MprotectNoAccess((uptr)addr, (uptr)guard);
  return (char *)addr + guard;
}

static inline void unsafe_stack_setup(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  4028f1:	48 8d 15 58 25 01 00 	lea    0x12558(%rip),%rdx        # 414e50 <.LC0>
  4028f8:	48 8d 3d 81 25 01 00 	lea    0x12581(%rip),%rdi        # 414e80 <.LC1>
  4028ff:	49 89 d8             	mov    %rbx,%r8
  402902:	4c 89 f1             	mov    %r14,%rcx
  402905:	be 74 00 00 00       	mov    $0x74,%esi
  40290a:	e8 e1 2a 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  unsafe_stack_size = size;
  unsafe_stack_guard = guard;
}

static inline void unsafe_stack_setup_large(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  40290f:	48 8d 15 3a 25 01 00 	lea    0x1253a(%rip),%rdx        # 414e50 <.LC0>
  402916:	48 8d 3d 63 25 01 00 	lea    0x12563(%rip),%rdi        # 414e80 <.LC1>
  40291d:	49 89 d8             	mov    %rbx,%r8
  402920:	4c 89 e1             	mov    %r12,%rcx
  402923:	be 80 00 00 00       	mov    $0x80,%esi
  402928:	e8 c3 2a 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  CHECK_GE((char *)start + guard, (char *)start);
  40292d:	48 8d 15 b4 25 01 00 	lea    0x125b4(%rip),%rdx        # 414ee8 <.LC2>
  402934:	48 8d 3d 45 25 01 00 	lea    0x12545(%rip),%rdi        # 414e80 <.LC1>
  40293b:	49 89 d8             	mov    %rbx,%r8
  40293e:	be 81 00 00 00       	mov    $0x81,%esi
  402943:	e8 a8 2a 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  void *stack_ptr = (char *)start + size;
  CHECK_EQ((((size_t)stack_ptr) & (kStackAlign - 1)), 0);
  402948:	48 8d 15 c9 25 01 00 	lea    0x125c9(%rip),%rdx        # 414f18 <.LC3>
  40294f:	48 8d 3d 2a 25 01 00 	lea    0x1252a(%rip),%rdi        # 414e80 <.LC1>
  402956:	45 31 c0             	xor    %r8d,%r8d
  402959:	be 83 00 00 00       	mov    $0x83,%esi
  40295e:	e8 8d 2a 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  402963:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40296a:	84 00 00 00 00 00 

0000000000402970 <__safestack_init>:
extern "C" __attribute__((visibility("default")))
#if !SANITIZER_CAN_USE_PREINIT_ARRAY
// On ELF platforms, the constructor is invoked using .preinit_array (see below)
__attribute__((constructor(0)))
#endif
void __safestack_init() {
  402970:	41 57                	push   %r15
  402972:	41 56                	push   %r14
  402974:	41 55                	push   %r13
  402976:	41 54                	push   %r12
  402978:	55                   	push   %rbp
  402979:	53                   	push   %rbx
  40297a:	48 83 ec 18          	sub    $0x18,%rsp
  __safestack::InitializeFlags();
  40297e:	e8 1d 05 00 00       	callq  402ea0 <_ZN11__safestack15InitializeFlagsEv>
  // Determine the stack size for the main thread.
  size_t size = kDefaultUnsafeStackSize;
  size_t guard = 4096;

  struct rlimit limit;
  if (getrlimit(RLIMIT_STACK, &limit) == 0 && limit.rlim_cur != RLIM_INFINITY)
  402983:	48 89 e6             	mov    %rsp,%rsi
  402986:	bf 03 00 00 00       	mov    $0x3,%edi
  40298b:	e8 50 f8 ff ff       	callq  4021e0 <getrlimit@plt>
  402990:	85 c0                	test   %eax,%eax
  402992:	75 3c                	jne    4029d0 <__safestack_init+0x60>
  402994:	48 8b 1c 24          	mov    (%rsp),%rbx
  402998:	48 83 fb ff          	cmp    $0xffffffffffffffff,%rbx
  40299c:	74 32                	je     4029d0 <__safestack_init+0x60>
__attribute__((weak)) void unsafe_stack_free_meta(void *unsafe_stack_start, size_t unsafe_stack_size, bool islarge);

}

static inline void *unsafe_stack_alloc(size_t size, size_t guard, bool islarge) {
  CHECK_GE(size + guard, size);
  40299e:	4c 8d b3 00 10 00 00 	lea    0x1000(%rbx),%r14
  4029a5:	4c 39 f3             	cmp    %r14,%rbx
  4029a8:	76 31                	jbe    4029db <__safestack_init+0x6b>
  4029aa:	48 8d 15 92 59 01 00 	lea    0x15992(%rip),%rdx        # 418343 <.LC4>
  4029b1:	48 8d 3d c8 24 01 00 	lea    0x124c8(%rip),%rdi        # 414e80 <.LC1>
  4029b8:	49 89 d8             	mov    %rbx,%r8
  4029bb:	4c 89 f1             	mov    %r14,%rcx
  4029be:	be 69 00 00 00       	mov    $0x69,%esi
  4029c3:	e8 28 2a 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  4029c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4029cf:	00 
  4029d0:	41 be 00 10 80 02    	mov    $0x2801000,%r14d
__attribute__((constructor(0)))
#endif
void __safestack_init() {
  __safestack::InitializeFlags();
  // Determine the stack size for the main thread.
  size_t size = kDefaultUnsafeStackSize;
  4029d6:	bb 00 00 80 02       	mov    $0x2800000,%ebx
}

static inline void *unsafe_stack_alloc(size_t size, size_t guard, bool islarge) {
  CHECK_GE(size + guard, size);
  void *addr;
  addr = MmapOrDie(size + guard, "unsafe_stack_alloc");
  4029db:	48 8d 35 7e 59 01 00 	lea    0x1597e(%rip),%rsi        # 418360 <.LC5>
  4029e2:	4c 89 f7             	mov    %r14,%rdi
  4029e5:	e8 b6 99 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  if (unsafe_stack_alloc_meta != nullptr) {
  4029ea:	4c 8b 3d 9f b8 01 00 	mov    0x1b89f(%rip),%r15        # 41e290 <_DYNAMIC+0x290>
}

static inline void *unsafe_stack_alloc(size_t size, size_t guard, bool islarge) {
  CHECK_GE(size + guard, size);
  void *addr;
  addr = MmapOrDie(size + guard, "unsafe_stack_alloc");
  4029f1:	49 89 c4             	mov    %rax,%r12
  if (unsafe_stack_alloc_meta != nullptr) {
    unsafe_stack_alloc_meta((char *)addr + guard, size, islarge);
  4029f4:	48 8d a8 00 10 00 00 	lea    0x1000(%rax),%rbp

static inline void *unsafe_stack_alloc(size_t size, size_t guard, bool islarge) {
  CHECK_GE(size + guard, size);
  void *addr;
  addr = MmapOrDie(size + guard, "unsafe_stack_alloc");
  if (unsafe_stack_alloc_meta != nullptr) {
  4029fb:	4d 85 ff             	test   %r15,%r15
  4029fe:	74 0d                	je     402a0d <__safestack_init+0x9d>
    unsafe_stack_alloc_meta((char *)addr + guard, size, islarge);
  402a00:	31 d2                	xor    %edx,%edx
  402a02:	48 89 de             	mov    %rbx,%rsi
  402a05:	48 89 ef             	mov    %rbp,%rdi
  402a08:	e8 d3 16 01 00       	callq  4140e0 <unsafe_stack_alloc_meta>
  }
  MprotectNoAccess((uptr)addr, (uptr)guard);
  402a0d:	be 00 10 00 00       	mov    $0x1000,%esi
  402a12:	4c 89 e7             	mov    %r12,%rdi
  return (char *)addr + guard;
}

static inline void unsafe_stack_setup(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  402a15:	49 89 ed             	mov    %rbp,%r13
  void *addr;
  addr = MmapOrDie(size + guard, "unsafe_stack_alloc");
  if (unsafe_stack_alloc_meta != nullptr) {
    unsafe_stack_alloc_meta((char *)addr + guard, size, islarge);
  }
  MprotectNoAccess((uptr)addr, (uptr)guard);
  402a18:	e8 13 9c 00 00       	callq  40c630 <_ZN11__sanitizer16MprotectNoAccessEmm>
  return (char *)addr + guard;
}

static inline void unsafe_stack_setup(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  402a1d:	49 01 dd             	add    %rbx,%r13
  402a20:	0f 82 71 01 00 00    	jb     402b97 <__safestack_init+0x227>
  CHECK_GE((char *)start + guard, (char *)start);
  402a26:	49 8d 8c 24 00 20 00 	lea    0x2000(%r12),%rcx
  402a2d:	00 
  402a2e:	48 39 cd             	cmp    %rcx,%rbp
  402a31:	0f 87 45 01 00 00    	ja     402b7c <__safestack_init+0x20c>
  void *stack_ptr = (char *)start + size;
  CHECK_EQ((((size_t)stack_ptr) & (kStackAlign - 1)), 0);
  402a37:	4c 89 e9             	mov    %r13,%rcx
  402a3a:	83 e1 0f             	and    $0xf,%ecx
  402a3d:	0f 85 1e 01 00 00    	jne    402b61 <__safestack_init+0x1f1>
  402a43:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  402a4a:	00 00 

  __safestack_unsafe_stack_ptr = stack_ptr;
  402a4c:	48 8d 80 e0 fe ff ff 	lea    -0x120(%rax),%rax
  402a53:	4c 89 28             	mov    %r13,(%rax)
  unsafe_stack_start = start;
  402a56:	66 66 66 64 48 8b 04 	data16 data16 data16 mov %fs:0x0,%rax
  402a5d:	25 00 00 00 00 
  402a62:	48 89 a8 c0 fe ff ff 	mov    %rbp,-0x140(%rax)
  unsafe_stack_size = size;
  402a69:	48 89 98 b0 fe ff ff 	mov    %rbx,-0x150(%rax)
  unsafe_stack_guard = guard;
  402a70:	48 c7 80 a0 fe ff ff 	movq   $0x1000,-0x160(%rax)
  402a77:	00 10 00 00 
    size = limit.rlim_cur;

  // Allocate unsafe stack for main thread
  void *addr = unsafe_stack_alloc(size, guard, false);
  unsafe_stack_setup(addr, size, guard);
  if (__safestack::flags()->largestack) {
  402a7b:	48 8b 05 06 b8 01 00 	mov    0x1b806(%rip),%rax        # 41e288 <_DYNAMIC+0x288>
  402a82:	80 38 00             	cmpb   $0x0,(%rax)
  402a85:	75 49                	jne    402ad0 <__safestack_init+0x160>
    void *addr_large = unsafe_stack_alloc(size, guard, true);
    unsafe_stack_setup_large(addr_large, size, guard);
  }

  // Initialize pthread interceptors for thread allocation
  INTERCEPT_FUNCTION(pthread_create);
  402a87:	48 8b 0d 0a b8 01 00 	mov    0x1b80a(%rip),%rcx        # 41e298 <_DYNAMIC+0x298>
  402a8e:	48 8b 15 0b b8 01 00 	mov    0x1b80b(%rip),%rdx        # 41e2a0 <_DYNAMIC+0x2a0>
  402a95:	48 8d 35 b4 e4 01 00 	lea    0x1e4b4(%rip),%rsi        # 420f50 <_ZN14__interception19real_pthread_createE>
  402a9c:	48 8d 3d d0 58 01 00 	lea    0x158d0(%rip),%rdi        # 418373 <.LC6>
  402aa3:	e8 48 05 00 00       	callq  402ff0 <_ZN14__interception22GetRealFunctionAddressEPKcPmmm>

  // Setup the cleanup handler
  pthread_key_create(&thread_cleanup_key, thread_cleanup_handler);
  402aa8:	48 8d 35 01 fc ff ff 	lea    -0x3ff(%rip),%rsi        # 4026b0 <_ZL22thread_cleanup_handlerPv>
  402aaf:	48 8d 3d aa e4 01 00 	lea    0x1e4aa(%rip),%rdi        # 420f60 <_ZL18thread_cleanup_key>
  402ab6:	e8 35 f7 ff ff       	callq  4021f0 <pthread_key_create@plt>
}
  402abb:	48 83 c4 18          	add    $0x18,%rsp
  402abf:	5b                   	pop    %rbx
  402ac0:	5d                   	pop    %rbp
  402ac1:	41 5c                	pop    %r12
  402ac3:	41 5d                	pop    %r13
  402ac5:	41 5e                	pop    %r14
  402ac7:	41 5f                	pop    %r15
  402ac9:	c3                   	retq   
  402aca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
__attribute__((weak)) void unsafe_stack_free_meta(void *unsafe_stack_start, size_t unsafe_stack_size, bool islarge);

}

static inline void *unsafe_stack_alloc(size_t size, size_t guard, bool islarge) {
  CHECK_GE(size + guard, size);
  402ad0:	4c 39 f3             	cmp    %r14,%rbx
  402ad3:	0f 87 d1 fe ff ff    	ja     4029aa <__safestack_init+0x3a>
  void *addr;
  addr = MmapOrDie(size + guard, "unsafe_stack_alloc");
  402ad9:	48 8d 35 80 58 01 00 	lea    0x15880(%rip),%rsi        # 418360 <.LC5>
  402ae0:	4c 89 f7             	mov    %r14,%rdi
  402ae3:	e8 b8 98 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  if (unsafe_stack_alloc_meta != nullptr) {
  402ae8:	4d 85 ff             	test   %r15,%r15
}

static inline void *unsafe_stack_alloc(size_t size, size_t guard, bool islarge) {
  CHECK_GE(size + guard, size);
  void *addr;
  addr = MmapOrDie(size + guard, "unsafe_stack_alloc");
  402aeb:	49 89 c4             	mov    %rax,%r12
  if (unsafe_stack_alloc_meta != nullptr) {
    unsafe_stack_alloc_meta((char *)addr + guard, size, islarge);
  402aee:	48 8d a8 00 10 00 00 	lea    0x1000(%rax),%rbp

static inline void *unsafe_stack_alloc(size_t size, size_t guard, bool islarge) {
  CHECK_GE(size + guard, size);
  void *addr;
  addr = MmapOrDie(size + guard, "unsafe_stack_alloc");
  if (unsafe_stack_alloc_meta != nullptr) {
  402af5:	74 10                	je     402b07 <__safestack_init+0x197>
    unsafe_stack_alloc_meta((char *)addr + guard, size, islarge);
  402af7:	ba 01 00 00 00       	mov    $0x1,%edx
  402afc:	48 89 de             	mov    %rbx,%rsi
  402aff:	48 89 ef             	mov    %rbp,%rdi
  402b02:	e8 d9 15 01 00       	callq  4140e0 <unsafe_stack_alloc_meta>
  }
  MprotectNoAccess((uptr)addr, (uptr)guard);
  402b07:	be 00 10 00 00       	mov    $0x1000,%esi
  402b0c:	4c 89 e7             	mov    %r12,%rdi
  402b0f:	e8 1c 9b 00 00       	callq  40c630 <_ZN11__sanitizer16MprotectNoAccessEmm>
  unsafe_stack_size = size;
  unsafe_stack_guard = guard;
}

static inline void unsafe_stack_setup_large(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  402b14:	48 01 eb             	add    %rbp,%rbx
  402b17:	0f 82 b3 00 00 00    	jb     402bd0 <__safestack_init+0x260>
  CHECK_GE((char *)start + guard, (char *)start);
  402b1d:	49 8d 8c 24 00 20 00 	lea    0x2000(%r12),%rcx
  402b24:	00 
  402b25:	48 39 cd             	cmp    %rcx,%rbp
  402b28:	0f 87 c0 00 00 00    	ja     402bee <__safestack_init+0x27e>
  void *stack_ptr = (char *)start + size;
  CHECK_EQ((((size_t)stack_ptr) & (kStackAlign - 1)), 0);
  402b2e:	48 89 d9             	mov    %rbx,%rcx
  402b31:	83 e1 0f             	and    $0xf,%ecx
  402b34:	75 7f                	jne    402bb5 <__safestack_init+0x245>
  402b36:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  402b3d:	00 00 

  __safestack_unsafe_stack_ptr_large = stack_ptr;
  402b3f:	48 8d 80 d0 fe ff ff 	lea    -0x130(%rax),%rax
  402b46:	48 89 18             	mov    %rbx,(%rax)
  unsafe_stack_start_large = start;
  402b49:	66 66 66 64 48 8b 04 	data16 data16 data16 mov %fs:0x0,%rax
  402b50:	25 00 00 00 00 
  402b55:	48 89 a8 90 fe ff ff 	mov    %rbp,-0x170(%rax)
  402b5c:	e9 26 ff ff ff       	jmpq   402a87 <__safestack_init+0x117>

static inline void unsafe_stack_setup(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  CHECK_GE((char *)start + guard, (char *)start);
  void *stack_ptr = (char *)start + size;
  CHECK_EQ((((size_t)stack_ptr) & (kStackAlign - 1)), 0);
  402b61:	48 8d 15 b0 23 01 00 	lea    0x123b0(%rip),%rdx        # 414f18 <.LC3>
  402b68:	48 8d 3d 11 23 01 00 	lea    0x12311(%rip),%rdi        # 414e80 <.LC1>
  402b6f:	45 31 c0             	xor    %r8d,%r8d
  402b72:	be 77 00 00 00       	mov    $0x77,%esi
  402b77:	e8 74 28 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  return (char *)addr + guard;
}

static inline void unsafe_stack_setup(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  CHECK_GE((char *)start + guard, (char *)start);
  402b7c:	48 8d 15 65 23 01 00 	lea    0x12365(%rip),%rdx        # 414ee8 <.LC2>
  402b83:	48 8d 3d f6 22 01 00 	lea    0x122f6(%rip),%rdi        # 414e80 <.LC1>
  402b8a:	49 89 e8             	mov    %rbp,%r8
  402b8d:	be 75 00 00 00       	mov    $0x75,%esi
  402b92:	e8 59 28 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  MprotectNoAccess((uptr)addr, (uptr)guard);
  return (char *)addr + guard;
}

static inline void unsafe_stack_setup(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  402b97:	48 8d 15 b2 22 01 00 	lea    0x122b2(%rip),%rdx        # 414e50 <.LC0>
  402b9e:	48 8d 3d db 22 01 00 	lea    0x122db(%rip),%rdi        # 414e80 <.LC1>
  402ba5:	49 89 e8             	mov    %rbp,%r8
  402ba8:	4c 89 e9             	mov    %r13,%rcx
  402bab:	be 74 00 00 00       	mov    $0x74,%esi
  402bb0:	e8 3b 28 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

static inline void unsafe_stack_setup_large(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  CHECK_GE((char *)start + guard, (char *)start);
  void *stack_ptr = (char *)start + size;
  CHECK_EQ((((size_t)stack_ptr) & (kStackAlign - 1)), 0);
  402bb5:	48 8d 15 5c 23 01 00 	lea    0x1235c(%rip),%rdx        # 414f18 <.LC3>
  402bbc:	48 8d 3d bd 22 01 00 	lea    0x122bd(%rip),%rdi        # 414e80 <.LC1>
  402bc3:	45 31 c0             	xor    %r8d,%r8d
  402bc6:	be 83 00 00 00       	mov    $0x83,%esi
  402bcb:	e8 20 28 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  unsafe_stack_size = size;
  unsafe_stack_guard = guard;
}

static inline void unsafe_stack_setup_large(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  402bd0:	48 8d 15 79 22 01 00 	lea    0x12279(%rip),%rdx        # 414e50 <.LC0>
  402bd7:	48 8d 3d a2 22 01 00 	lea    0x122a2(%rip),%rdi        # 414e80 <.LC1>
  402bde:	49 89 e8             	mov    %rbp,%r8
  402be1:	48 89 d9             	mov    %rbx,%rcx
  402be4:	be 80 00 00 00       	mov    $0x80,%esi
  402be9:	e8 02 28 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  CHECK_GE((char *)start + guard, (char *)start);
  402bee:	48 8d 15 f3 22 01 00 	lea    0x122f3(%rip),%rdx        # 414ee8 <.LC2>
  402bf5:	48 8d 3d 84 22 01 00 	lea    0x12284(%rip),%rdi        # 414e80 <.LC1>
  402bfc:	49 89 e8             	mov    %rbp,%r8
  402bff:	be 81 00 00 00       	mov    $0x81,%esi
  402c04:	e8 e7 27 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  402c09:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000402c10 <__interceptor_pthread_create>:
}

/// Intercept thread creation operation to allocate and setup the unsafe stack
INTERCEPTOR(int, pthread_create, pthread_t *thread,
            const pthread_attr_t *attr,
            void *(*start_routine)(void*), void *arg) {
  402c10:	41 57                	push   %r15
  402c12:	49 89 d7             	mov    %rdx,%r15
  402c15:	41 56                	push   %r14
  402c17:	49 89 ce             	mov    %rcx,%r14
  402c1a:	41 55                	push   %r13
  402c1c:	41 54                	push   %r12
  402c1e:	55                   	push   %rbp
  402c1f:	48 89 f5             	mov    %rsi,%rbp
  402c22:	53                   	push   %rbx
  402c23:	48 83 ec 78          	sub    $0x78,%rsp

  size_t size = 0;
  size_t guard = 0;

  if (attr) {
  402c27:	48 85 f6             	test   %rsi,%rsi
}

/// Intercept thread creation operation to allocate and setup the unsafe stack
INTERCEPTOR(int, pthread_create, pthread_t *thread,
            const pthread_attr_t *attr,
            void *(*start_routine)(void*), void *arg) {
  402c2a:	48 89 3c 24          	mov    %rdi,(%rsp)

  size_t size = 0;
  402c2e:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
  402c35:	00 00 
  size_t guard = 0;
  402c37:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
  402c3e:	00 00 

  if (attr) {
  402c40:	0f 84 3a 01 00 00    	je     402d80 <__interceptor_pthread_create+0x170>
    pthread_attr_getstacksize(attr, &size);
  402c46:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
  402c4b:	48 89 ef             	mov    %rbp,%rdi
  402c4e:	e8 ad f5 ff ff       	callq  402200 <pthread_attr_getstacksize@plt>
    pthread_attr_getguardsize(attr, &guard);
  402c53:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  402c58:	48 89 ef             	mov    %rbp,%rdi
  402c5b:	e8 b0 f5 ff ff       	callq  402210 <pthread_attr_getguardsize@plt>
    pthread_attr_getstacksize(&tmpattr, &size);
    pthread_attr_getguardsize(&tmpattr, &guard);
    pthread_attr_destroy(&tmpattr);
  }

  CHECK_NE(size, 0);
  402c60:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  402c65:	4d 85 ed             	test   %r13,%r13
  402c68:	0f 84 64 01 00 00    	je     402dd2 <__interceptor_pthread_create+0x1c2>
  CHECK_EQ((size & (kStackAlign - 1)), 0);
  402c6e:	4c 89 e9             	mov    %r13,%rcx
  402c71:	83 e1 0f             	and    $0xf,%ecx
  402c74:	0f 85 90 01 00 00    	jne    402e0a <__interceptor_pthread_create+0x1fa>
  CHECK_EQ((guard & (PAGE_SIZE - 1)), 0);
  402c7a:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx
  402c7f:	48 89 d9             	mov    %rbx,%rcx
  402c82:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  402c88:	0f 85 61 01 00 00    	jne    402def <__interceptor_pthread_create+0x1df>
__attribute__((weak)) void unsafe_stack_free_meta(void *unsafe_stack_start, size_t unsafe_stack_size, bool islarge);

}

static inline void *unsafe_stack_alloc(size_t size, size_t guard, bool islarge) {
  CHECK_GE(size + guard, size);
  402c8e:	48 89 df             	mov    %rbx,%rdi
  402c91:	4c 01 ef             	add    %r13,%rdi
  402c94:	0f 82 1a 01 00 00    	jb     402db4 <__interceptor_pthread_create+0x1a4>
  void *addr;
  addr = MmapOrDie(size + guard, "unsafe_stack_alloc");
  402c9a:	48 8d 35 bf 56 01 00 	lea    0x156bf(%rip),%rsi        # 418360 <.LC5>
  402ca1:	e8 fa 96 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  if (unsafe_stack_alloc_meta != nullptr) {
  402ca6:	48 83 3d e2 b5 01 00 	cmpq   $0x0,0x1b5e2(%rip)        # 41e290 <_DYNAMIC+0x290>
  402cad:	00 
    unsafe_stack_alloc_meta((char *)addr + guard, size, islarge);
  402cae:	4c 8d 24 18          	lea    (%rax,%rbx,1),%r12

static inline void *unsafe_stack_alloc(size_t size, size_t guard, bool islarge) {
  CHECK_GE(size + guard, size);
  void *addr;
  addr = MmapOrDie(size + guard, "unsafe_stack_alloc");
  if (unsafe_stack_alloc_meta != nullptr) {
  402cb2:	74 17                	je     402ccb <__interceptor_pthread_create+0xbb>
    unsafe_stack_alloc_meta((char *)addr + guard, size, islarge);
  402cb4:	31 d2                	xor    %edx,%edx
  402cb6:	4c 89 ee             	mov    %r13,%rsi
  402cb9:	4c 89 e7             	mov    %r12,%rdi
  402cbc:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  402cc1:	e8 1a 14 01 00       	callq  4140e0 <unsafe_stack_alloc_meta>
  402cc6:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  }
  MprotectNoAccess((uptr)addr, (uptr)guard);
  402ccb:	48 89 de             	mov    %rbx,%rsi
  402cce:	48 89 c7             	mov    %rax,%rdi
  402cd1:	e8 5a 99 00 00       	callq  40c630 <_ZN11__sanitizer16MprotectNoAccessEmm>
  CHECK_EQ((size & (kStackAlign - 1)), 0);
  CHECK_EQ((guard & (PAGE_SIZE - 1)), 0);

  void *addr = unsafe_stack_alloc(size, guard, false);
  struct tinfo *tinfo =
      (struct tinfo *)(((char *)addr) + size - sizeof(struct tinfo));
  402cd6:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
  tinfo->start_routine = start_routine;
  tinfo->start_routine_arg = arg;
  tinfo->unsafe_stack_start = addr;
  tinfo->unsafe_stack_size = size;
  tinfo->unsafe_stack_guard = guard;
  if (__safestack::flags()->largestack) {
  402cdb:	48 8b 05 a6 b5 01 00 	mov    0x1b5a6(%rip),%rax        # 41e288 <_DYNAMIC+0x288>
  CHECK_EQ((size & (kStackAlign - 1)), 0);
  CHECK_EQ((guard & (PAGE_SIZE - 1)), 0);

  void *addr = unsafe_stack_alloc(size, guard, false);
  struct tinfo *tinfo =
      (struct tinfo *)(((char *)addr) + size - sizeof(struct tinfo));
  402ce2:	4b 8d 5c 04 d0       	lea    -0x30(%r12,%r8,1),%rbx
  tinfo->start_routine = start_routine;
  tinfo->start_routine_arg = arg;
  tinfo->unsafe_stack_start = addr;
  tinfo->unsafe_stack_size = size;
  tinfo->unsafe_stack_guard = guard;
  if (__safestack::flags()->largestack) {
  402ce7:	80 38 00             	cmpb   $0x0,(%rax)

  void *addr = unsafe_stack_alloc(size, guard, false);
  struct tinfo *tinfo =
      (struct tinfo *)(((char *)addr) + size - sizeof(struct tinfo));
  tinfo->start_routine = start_routine;
  tinfo->start_routine_arg = arg;
  402cea:	4c 89 73 08          	mov    %r14,0x8(%rbx)
  tinfo->unsafe_stack_start = addr;
  tinfo->unsafe_stack_size = size;
  tinfo->unsafe_stack_guard = guard;
  402cee:	4c 8b 74 24 20       	mov    0x20(%rsp),%r14
  CHECK_EQ((guard & (PAGE_SIZE - 1)), 0);

  void *addr = unsafe_stack_alloc(size, guard, false);
  struct tinfo *tinfo =
      (struct tinfo *)(((char *)addr) + size - sizeof(struct tinfo));
  tinfo->start_routine = start_routine;
  402cf3:	4c 89 3b             	mov    %r15,(%rbx)
  tinfo->start_routine_arg = arg;
  tinfo->unsafe_stack_start = addr;
  402cf6:	4c 89 63 10          	mov    %r12,0x10(%rbx)
  tinfo->unsafe_stack_size = size;
  402cfa:	4c 89 43 18          	mov    %r8,0x18(%rbx)
  tinfo->unsafe_stack_guard = guard;
  402cfe:	4c 89 73 20          	mov    %r14,0x20(%rbx)
  if (__safestack::flags()->largestack) {
  402d02:	75 2c                	jne    402d30 <__interceptor_pthread_create+0x120>
    void *addr_large = unsafe_stack_alloc(size, guard, true);
    tinfo->unsafe_stack_start_large = addr_large;
  }

  return REAL(pthread_create)(thread, attr, thread_start, tinfo);
  402d04:	48 89 d9             	mov    %rbx,%rcx
  402d07:	48 89 ee             	mov    %rbp,%rsi
  402d0a:	48 8b 3c 24          	mov    (%rsp),%rdi
  402d0e:	48 8d 15 9b fa ff ff 	lea    -0x565(%rip),%rdx        # 4027b0 <_ZL12thread_startPv>
  402d15:	ff 15 35 e2 01 00    	callq  *0x1e235(%rip)        # 420f50 <_ZN14__interception19real_pthread_createE>
}
  402d1b:	48 83 c4 78          	add    $0x78,%rsp
  402d1f:	5b                   	pop    %rbx
  402d20:	5d                   	pop    %rbp
  402d21:	41 5c                	pop    %r12
  402d23:	41 5d                	pop    %r13
  402d25:	41 5e                	pop    %r14
  402d27:	41 5f                	pop    %r15
  402d29:	c3                   	retq   
  402d2a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
__attribute__((weak)) void unsafe_stack_free_meta(void *unsafe_stack_start, size_t unsafe_stack_size, bool islarge);

}

static inline void *unsafe_stack_alloc(size_t size, size_t guard, bool islarge) {
  CHECK_GE(size + guard, size);
  402d30:	4c 89 f7             	mov    %r14,%rdi
  402d33:	4c 01 c7             	add    %r8,%rdi
  402d36:	72 7f                	jb     402db7 <__interceptor_pthread_create+0x1a7>
  void *addr;
  addr = MmapOrDie(size + guard, "unsafe_stack_alloc");
  402d38:	48 8d 35 21 56 01 00 	lea    0x15621(%rip),%rsi        # 418360 <.LC5>
  402d3f:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  402d44:	e8 57 96 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  if (unsafe_stack_alloc_meta != nullptr) {
  402d49:	48 83 3d 3f b5 01 00 	cmpq   $0x0,0x1b53f(%rip)        # 41e290 <_DYNAMIC+0x290>
  402d50:	00 
}

static inline void *unsafe_stack_alloc(size_t size, size_t guard, bool islarge) {
  CHECK_GE(size + guard, size);
  void *addr;
  addr = MmapOrDie(size + guard, "unsafe_stack_alloc");
  402d51:	49 89 c7             	mov    %rax,%r15
  if (unsafe_stack_alloc_meta != nullptr) {
    unsafe_stack_alloc_meta((char *)addr + guard, size, islarge);
  402d54:	4e 8d 24 30          	lea    (%rax,%r14,1),%r12

static inline void *unsafe_stack_alloc(size_t size, size_t guard, bool islarge) {
  CHECK_GE(size + guard, size);
  void *addr;
  addr = MmapOrDie(size + guard, "unsafe_stack_alloc");
  if (unsafe_stack_alloc_meta != nullptr) {
  402d58:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
  402d5d:	74 10                	je     402d6f <__interceptor_pthread_create+0x15f>
    unsafe_stack_alloc_meta((char *)addr + guard, size, islarge);
  402d5f:	ba 01 00 00 00       	mov    $0x1,%edx
  402d64:	4c 89 c6             	mov    %r8,%rsi
  402d67:	4c 89 e7             	mov    %r12,%rdi
  402d6a:	e8 71 13 01 00       	callq  4140e0 <unsafe_stack_alloc_meta>
  }
  MprotectNoAccess((uptr)addr, (uptr)guard);
  402d6f:	4c 89 f6             	mov    %r14,%rsi
  402d72:	4c 89 ff             	mov    %r15,%rdi
  402d75:	e8 b6 98 00 00       	callq  40c630 <_ZN11__sanitizer16MprotectNoAccessEmm>
  tinfo->unsafe_stack_start = addr;
  tinfo->unsafe_stack_size = size;
  tinfo->unsafe_stack_guard = guard;
  if (__safestack::flags()->largestack) {
    void *addr_large = unsafe_stack_alloc(size, guard, true);
    tinfo->unsafe_stack_start_large = addr_large;
  402d7a:	4c 89 63 28          	mov    %r12,0x28(%rbx)
  402d7e:	eb 84                	jmp    402d04 <__interceptor_pthread_create+0xf4>
    pthread_attr_getstacksize(attr, &size);
    pthread_attr_getguardsize(attr, &guard);
  } else {
    // get pthread default stack size
    pthread_attr_t tmpattr;
    pthread_attr_init(&tmpattr);
  402d80:	48 8d 5c 24 30       	lea    0x30(%rsp),%rbx
  402d85:	48 89 df             	mov    %rbx,%rdi
  402d88:	e8 93 f4 ff ff       	callq  402220 <pthread_attr_init@plt>
    pthread_attr_getstacksize(&tmpattr, &size);
  402d8d:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
  402d92:	48 89 df             	mov    %rbx,%rdi
  402d95:	e8 66 f4 ff ff       	callq  402200 <pthread_attr_getstacksize@plt>
    pthread_attr_getguardsize(&tmpattr, &guard);
  402d9a:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  402d9f:	48 89 df             	mov    %rbx,%rdi
  402da2:	e8 69 f4 ff ff       	callq  402210 <pthread_attr_getguardsize@plt>
    pthread_attr_destroy(&tmpattr);
  402da7:	48 89 df             	mov    %rbx,%rdi
  402daa:	e8 81 f4 ff ff       	callq  402230 <pthread_attr_destroy@plt>
  402daf:	e9 ac fe ff ff       	jmpq   402c60 <__interceptor_pthread_create+0x50>
__attribute__((weak)) void unsafe_stack_free_meta(void *unsafe_stack_start, size_t unsafe_stack_size, bool islarge);

}

static inline void *unsafe_stack_alloc(size_t size, size_t guard, bool islarge) {
  CHECK_GE(size + guard, size);
  402db4:	4d 89 e8             	mov    %r13,%r8
  402db7:	48 89 f9             	mov    %rdi,%rcx
  402dba:	48 8d 15 82 55 01 00 	lea    0x15582(%rip),%rdx        # 418343 <.LC4>
  402dc1:	48 8d 3d b8 20 01 00 	lea    0x120b8(%rip),%rdi        # 414e80 <.LC1>
  402dc8:	be 69 00 00 00       	mov    $0x69,%esi
  402dcd:	e8 1e 26 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    pthread_attr_getstacksize(&tmpattr, &size);
    pthread_attr_getguardsize(&tmpattr, &guard);
    pthread_attr_destroy(&tmpattr);
  }

  CHECK_NE(size, 0);
  402dd2:	48 8d 15 a9 55 01 00 	lea    0x155a9(%rip),%rdx        # 418382 <.LC7>
  402dd9:	48 8d 3d a0 20 01 00 	lea    0x120a0(%rip),%rdi        # 414e80 <.LC1>
  402de0:	45 31 c0             	xor    %r8d,%r8d
  402de3:	31 c9                	xor    %ecx,%ecx
  402de5:	be e5 00 00 00       	mov    $0xe5,%esi
  402dea:	e8 01 26 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  CHECK_EQ((size & (kStackAlign - 1)), 0);
  CHECK_EQ((guard & (PAGE_SIZE - 1)), 0);
  402def:	48 8d 15 82 21 01 00 	lea    0x12182(%rip),%rdx        # 414f78 <.LC9>
  402df6:	48 8d 3d 83 20 01 00 	lea    0x12083(%rip),%rdi        # 414e80 <.LC1>
  402dfd:	45 31 c0             	xor    %r8d,%r8d
  402e00:	be e7 00 00 00       	mov    $0xe7,%esi
  402e05:	e8 e6 25 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    pthread_attr_getguardsize(&tmpattr, &guard);
    pthread_attr_destroy(&tmpattr);
  }

  CHECK_NE(size, 0);
  CHECK_EQ((size & (kStackAlign - 1)), 0);
  402e0a:	48 8d 15 3f 21 01 00 	lea    0x1213f(%rip),%rdx        # 414f50 <.LC8>
  402e11:	48 8d 3d 68 20 01 00 	lea    0x12068(%rip),%rdi        # 414e80 <.LC1>
  402e18:	45 31 c0             	xor    %r8d,%r8d
  402e1b:	be e6 00 00 00       	mov    $0xe6,%esi
  402e20:	e8 cb 25 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  402e25:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  402e2c:	00 00 00 00 

0000000000402e30 <__get_unsafe_stack_start>:
}
#endif

extern "C"
    __attribute__((visibility("default"))) void *__get_unsafe_stack_start() {
  return unsafe_stack_start;
  402e30:	66 66 66 64 48 8b 04 	data16 data16 data16 mov %fs:0x0,%rax
  402e37:	25 00 00 00 00 
  402e3c:	48 8b 80 c0 fe ff ff 	mov    -0x140(%rax),%rax
}
  402e43:	c3                   	retq   
  402e44:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  402e4b:	00 00 00 00 00 

0000000000402e50 <__get_unsafe_stack_ptr>:

extern "C"
    __attribute__((visibility("default"))) void *__get_unsafe_stack_ptr() {
  402e50:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  402e57:	00 00 
  return __safestack_unsafe_stack_ptr;
  402e59:	48 8d 80 e0 fe ff ff 	lea    -0x120(%rax),%rax
  402e60:	48 8b 00             	mov    (%rax),%rax
}
  402e63:	c3                   	retq   
  402e64:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  402e6b:	00 00 00 00 00 

0000000000402e70 <__get_unsafe_stack_ptr_large>:

extern "C"
    __attribute__((visibility("default"))) void *__get_unsafe_stack_ptr_large() {
  402e70:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  402e77:	00 00 
  return __safestack_unsafe_stack_ptr_large;
  402e79:	48 8d 80 d0 fe ff ff 	lea    -0x130(%rax),%rax
  402e80:	48 8b 00             	mov    (%rax),%rax
}
  402e83:	c3                   	retq   
  402e84:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  402e8b:	00 00 00 00 00 

0000000000402e90 <_ZN11__safestack5Flags11SetDefaultsEv>:
#endif

// SAFESTACK_FLAG(Type, Name, DefaultValue, Description)
// See COMMON_FLAG in sanitizer_flags.inc for more details.

SAFESTACK_FLAG(bool, largestack, false,
  402e90:	c6 07 00             	movb   $0x0,(%rdi)
  402e93:	c3                   	retq   
  402e94:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  402e9b:	00 00 00 00 00 

0000000000402ea0 <_ZN11__safestack15InitializeFlagsEv>:
  RegisterFlag(parser, #Name, Description, &f->Name);
#include "safestack_flags.inc"
#undef SAFESTACK_FLAG
}

void InitializeFlags() {
  402ea0:	53                   	push   %rbx
  402ea1:	48 83 ec 20          	sub    $0x20,%rsp
  402ea5:	c6 05 c4 e0 01 00 00 	movb   $0x0,0x1e0c4(%rip)        # 420f70 <_ZN11__safestack33safestack_flags_dont_use_directlyE>
  Flags *f = flags();
  f->SetDefaults();

  FlagParser safestack_parser;
  402eac:	48 89 e7             	mov    %rsp,%rdi
  402eaf:	e8 5c 6f 00 00       	callq  409e10 <_ZN11__sanitizer10FlagParserC1Ev>

}  // namespace __sanitizer

inline void *operator new(__sanitizer::operator_new_size_type size,
                          __sanitizer::LowLevelAllocator &alloc) {
  return alloc.Allocate(size);
  402eb4:	48 8b 3d ed b3 01 00 	mov    0x1b3ed(%rip),%rdi        # 41e2a8 <_DYNAMIC+0x2a8>
  402ebb:	be 10 00 00 00       	mov    $0x10,%esi
  402ec0:	e8 4b 03 00 00       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  402ec5:	48 8d 0d a4 e0 01 00 	lea    0x1e0a4(%rip),%rcx        # 420f70 <_ZN11__safestack33safestack_flags_dont_use_directlyE>
  402ecc:	48 8d 15 7d de 01 00 	lea    0x1de7d(%rip),%rdx        # 420d50 <_ZTVN11__sanitizer11FlagHandlerIbEE+0x10>

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  402ed3:	48 8d 35 d0 54 01 00 	lea    0x154d0(%rip),%rsi        # 4183aa <.LC8>
  402eda:	48 89 e7             	mov    %rsp,%rdi
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  402edd:	48 89 48 08          	mov    %rcx,0x8(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  402ee1:	48 8d 0d f0 20 01 00 	lea    0x120f0(%rip),%rcx        # 414fd8 <.LC7>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  402ee8:	48 89 10             	mov    %rdx,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  402eeb:	48 89 c2             	mov    %rax,%rdx
  402eee:	e8 cd 6e 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  RegisterSafeStackFlags(&safestack_parser, f);
  
  // Override from command line.
  safestack_parser.ParseString(GetEnv("SAFESTACK_OPTIONS"));
  402ef3:	48 8d 3d bb 54 01 00 	lea    0x154bb(%rip),%rdi        # 4183b5 <.LC9>
  402efa:	e8 e1 87 00 00       	callq  40b6e0 <_ZN11__sanitizer6GetEnvEPKc>
  402eff:	48 89 e7             	mov    %rsp,%rdi
  402f02:	48 89 c6             	mov    %rax,%rsi
  402f05:	e8 46 6c 00 00       	callq  409b50 <_ZN11__sanitizer10FlagParser11ParseStringEPKc>
}
  402f0a:	48 83 c4 20          	add    $0x20,%rsp
  402f0e:	5b                   	pop    %rbx
  402f0f:	c3                   	retq   

0000000000402f10 <_ZN11__sanitizer15FlagHandlerBase5ParseEPKc>:

namespace __sanitizer {

class FlagHandlerBase {
 public:
  virtual bool Parse(const char *value) { return false; }
  402f10:	31 c0                	xor    %eax,%eax
  402f12:	c3                   	retq   
  402f13:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  402f1a:	84 00 00 00 00 00 

0000000000402f20 <_ZN11__sanitizer11FlagHandlerIbE5ParseEPKc>:
  explicit FlagHandler(T *t) : t_(t) {}
  bool Parse(const char *value) final;
};

template <>
inline bool FlagHandler<bool>::Parse(const char *value) {
  402f20:	55                   	push   %rbp
  402f21:	48 89 fd             	mov    %rdi,%rbp
  402f24:	53                   	push   %rbx
  402f25:	48 89 f3             	mov    %rsi,%rbx
  if (internal_strcmp(value, "0") == 0 ||
  402f28:	48 8d 35 65 54 01 00 	lea    0x15465(%rip),%rsi        # 418394 <.LC0>
  402f2f:	48 89 df             	mov    %rbx,%rdi
  explicit FlagHandler(T *t) : t_(t) {}
  bool Parse(const char *value) final;
};

template <>
inline bool FlagHandler<bool>::Parse(const char *value) {
  402f32:	48 83 ec 08          	sub    $0x8,%rsp
  if (internal_strcmp(value, "0") == 0 ||
  402f36:	e8 a5 78 00 00       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
      internal_strcmp(value, "no") == 0 ||
  402f3b:	85 c0                	test   %eax,%eax
  402f3d:	75 19                	jne    402f58 <_ZN11__sanitizer11FlagHandlerIbE5ParseEPKc+0x38>
      internal_strcmp(value, "false") == 0) {
    *t_ = false;
  402f3f:	48 8b 45 08          	mov    0x8(%rbp),%rax
  402f43:	c6 00 00             	movb   $0x0,(%rax)
    return true;
  402f46:	b8 01 00 00 00       	mov    $0x1,%eax
    *t_ = true;
    return true;
  }
  Printf("ERROR: Invalid value for bool option: '%s'\n", value);
  return false;
}
  402f4b:	48 83 c4 08          	add    $0x8,%rsp
  402f4f:	5b                   	pop    %rbx
  402f50:	5d                   	pop    %rbp
  402f51:	c3                   	retq   
  402f52:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
};

template <>
inline bool FlagHandler<bool>::Parse(const char *value) {
  if (internal_strcmp(value, "0") == 0 ||
      internal_strcmp(value, "no") == 0 ||
  402f58:	48 8d 35 37 54 01 00 	lea    0x15437(%rip),%rsi        # 418396 <.LC1>
  402f5f:	48 89 df             	mov    %rbx,%rdi
  402f62:	e8 79 78 00 00       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
  bool Parse(const char *value) final;
};

template <>
inline bool FlagHandler<bool>::Parse(const char *value) {
  if (internal_strcmp(value, "0") == 0 ||
  402f67:	85 c0                	test   %eax,%eax
  402f69:	74 d4                	je     402f3f <_ZN11__sanitizer11FlagHandlerIbE5ParseEPKc+0x1f>
      internal_strcmp(value, "no") == 0 ||
      internal_strcmp(value, "false") == 0) {
  402f6b:	48 8d 35 27 54 01 00 	lea    0x15427(%rip),%rsi        # 418399 <.LC2>
  402f72:	48 89 df             	mov    %rbx,%rdi
  402f75:	e8 66 78 00 00       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
};

template <>
inline bool FlagHandler<bool>::Parse(const char *value) {
  if (internal_strcmp(value, "0") == 0 ||
      internal_strcmp(value, "no") == 0 ||
  402f7a:	85 c0                	test   %eax,%eax
  402f7c:	74 c1                	je     402f3f <_ZN11__sanitizer11FlagHandlerIbE5ParseEPKc+0x1f>
      internal_strcmp(value, "false") == 0) {
    *t_ = false;
    return true;
  }
  if (internal_strcmp(value, "1") == 0 ||
  402f7e:	48 8d 35 23 54 01 00 	lea    0x15423(%rip),%rsi        # 4183a8 <.LC5>
  402f85:	48 89 df             	mov    %rbx,%rdi
  402f88:	e8 53 78 00 00       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
      internal_strcmp(value, "yes") == 0 ||
  402f8d:	85 c0                	test   %eax,%eax
  402f8f:	75 13                	jne    402fa4 <_ZN11__sanitizer11FlagHandlerIbE5ParseEPKc+0x84>
      internal_strcmp(value, "true") == 0) {
    *t_ = true;
  402f91:	48 8b 45 08          	mov    0x8(%rbp),%rax
  402f95:	c6 00 01             	movb   $0x1,(%rax)
    return true;
  }
  Printf("ERROR: Invalid value for bool option: '%s'\n", value);
  return false;
}
  402f98:	48 83 c4 08          	add    $0x8,%rsp
  }
  if (internal_strcmp(value, "1") == 0 ||
      internal_strcmp(value, "yes") == 0 ||
      internal_strcmp(value, "true") == 0) {
    *t_ = true;
    return true;
  402f9c:	b8 01 00 00 00       	mov    $0x1,%eax
  }
  Printf("ERROR: Invalid value for bool option: '%s'\n", value);
  return false;
}
  402fa1:	5b                   	pop    %rbx
  402fa2:	5d                   	pop    %rbp
  402fa3:	c3                   	retq   
      internal_strcmp(value, "false") == 0) {
    *t_ = false;
    return true;
  }
  if (internal_strcmp(value, "1") == 0 ||
      internal_strcmp(value, "yes") == 0 ||
  402fa4:	48 8d 35 f4 53 01 00 	lea    0x153f4(%rip),%rsi        # 41839f <.LC3>
  402fab:	48 89 df             	mov    %rbx,%rdi
  402fae:	e8 2d 78 00 00       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
      internal_strcmp(value, "no") == 0 ||
      internal_strcmp(value, "false") == 0) {
    *t_ = false;
    return true;
  }
  if (internal_strcmp(value, "1") == 0 ||
  402fb3:	85 c0                	test   %eax,%eax
  402fb5:	74 da                	je     402f91 <_ZN11__sanitizer11FlagHandlerIbE5ParseEPKc+0x71>
      internal_strcmp(value, "yes") == 0 ||
      internal_strcmp(value, "true") == 0) {
  402fb7:	48 8d 35 e5 53 01 00 	lea    0x153e5(%rip),%rsi        # 4183a3 <.LC4>
  402fbe:	48 89 df             	mov    %rbx,%rdi
  402fc1:	e8 1a 78 00 00       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
      internal_strcmp(value, "false") == 0) {
    *t_ = false;
    return true;
  }
  if (internal_strcmp(value, "1") == 0 ||
      internal_strcmp(value, "yes") == 0 ||
  402fc6:	85 c0                	test   %eax,%eax
  402fc8:	74 c7                	je     402f91 <_ZN11__sanitizer11FlagHandlerIbE5ParseEPKc+0x71>
      internal_strcmp(value, "true") == 0) {
    *t_ = true;
    return true;
  }
  Printf("ERROR: Invalid value for bool option: '%s'\n", value);
  402fca:	48 8d 3d d7 1f 01 00 	lea    0x11fd7(%rip),%rdi        # 414fa8 <.LC6>
  402fd1:	31 c0                	xor    %eax,%eax
  402fd3:	48 89 de             	mov    %rbx,%rsi
  402fd6:	e8 15 aa 00 00       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  return false;
  402fdb:	31 c0                	xor    %eax,%eax
  402fdd:	e9 69 ff ff ff       	jmpq   402f4b <_ZN11__sanitizer11FlagHandlerIbE5ParseEPKc+0x2b>
  402fe2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  402fe9:	1f 84 00 00 00 00 00 

0000000000402ff0 <_ZN14__interception22GetRealFunctionAddressEPKcPmmm>:

#include <dlfcn.h>   // for dlsym() and dlvsym()

namespace __interception {
bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,
    uptr real, uptr wrapper) {
  402ff0:	41 54                	push   %r12
  402ff2:	49 89 f4             	mov    %rsi,%r12
  *func_addr = (uptr)dlsym(RTLD_NEXT, func_name);
  402ff5:	48 89 fe             	mov    %rdi,%rsi
  402ff8:	48 c7 c7 ff ff ff ff 	mov    $0xffffffffffffffff,%rdi

#include <dlfcn.h>   // for dlsym() and dlvsym()

namespace __interception {
bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,
    uptr real, uptr wrapper) {
  402fff:	55                   	push   %rbp
  403000:	48 89 d5             	mov    %rdx,%rbp
  403003:	53                   	push   %rbx
  403004:	48 89 cb             	mov    %rcx,%rbx
  *func_addr = (uptr)dlsym(RTLD_NEXT, func_name);
  403007:	e8 34 f2 ff ff       	callq  402240 <dlsym@plt>
  return real == wrapper;
  40300c:	48 39 dd             	cmp    %rbx,%rbp
#include <dlfcn.h>   // for dlsym() and dlvsym()

namespace __interception {
bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,
    uptr real, uptr wrapper) {
  *func_addr = (uptr)dlsym(RTLD_NEXT, func_name);
  40300f:	49 89 04 24          	mov    %rax,(%r12)
  return real == wrapper;
}
  403013:	5b                   	pop    %rbx
  403014:	5d                   	pop    %rbp

namespace __interception {
bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,
    uptr real, uptr wrapper) {
  *func_addr = (uptr)dlsym(RTLD_NEXT, func_name);
  return real == wrapper;
  403015:	0f 94 c0             	sete   %al
}
  403018:	41 5c                	pop    %r12
  40301a:	c3                   	retq   
  40301b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000403020 <_ZN14__interception14GetFuncAddrVerEPKcS1_>:

#if !defined(__ANDROID__)  // android does not have dlvsym
void *GetFuncAddrVer(const char *func_name, const char *ver) {
  403020:	48 89 f2             	mov    %rsi,%rdx
  return dlvsym(RTLD_NEXT, func_name, ver);
  403023:	48 89 fe             	mov    %rdi,%rsi
  403026:	48 c7 c7 ff ff ff ff 	mov    $0xffffffffffffffff,%rdi
  40302d:	e9 1e f2 ff ff       	jmpq   402250 <dlvsym@plt>
  403032:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  403039:	1f 84 00 00 00 00 00 

0000000000403040 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E15DeallocateBatchEPNS_14AllocatorStatsEmPNS2_13TransferBatchE.isra.14>:
    Batch *b = sci->free_list.front();
    sci->free_list.pop_front();
    return b;
  }

  NOINLINE void DeallocateBatch(AllocatorStats *stat, uptr class_id, Batch *b) {
  403040:	41 54                	push   %r12
    CHECK_LT(class_id, kNumClasses);
  403042:	48 83 fe 34          	cmp    $0x34,%rsi
    Batch *b = sci->free_list.front();
    sci->free_list.pop_front();
    return b;
  }

  NOINLINE void DeallocateBatch(AllocatorStats *stat, uptr class_id, Batch *b) {
  403046:	55                   	push   %rbp
  403047:	53                   	push   %rbx
    CHECK_LT(class_id, kNumClasses);
  403048:	0f 87 a2 00 00 00    	ja     4030f0 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E15DeallocateBatchEPNS_14AllocatorStatsEmPNS2_13TransferBatchE.isra.14+0xb0>
    SizeClassInfo *sci = GetSizeClassInfo(class_id);
  40304e:	48 81 c6 00 10 00 00 	add    $0x1000,%rsi
  403055:	48 89 d5             	mov    %rdx,%rbp
INLINE typename T::Type atomic_exchange(volatile T *a,
    typename T::Type v, memory_order mo) {
  DCHECK(!((uptr)a % sizeof(*a)));
  if (mo & (memory_order_release | memory_order_acq_rel | memory_order_seq_cst))
    __sync_synchronize();
  v = __sync_lock_test_and_set(&a->val_dont_use, v);
  403058:	b8 01 00 00 00       	mov    $0x1,%eax
  40305d:	48 c1 e6 06          	shl    $0x6,%rsi
  403061:	4c 8d 24 37          	lea    (%rdi,%rsi,1),%r12
  403065:	49 8d 5c 24 08       	lea    0x8(%r12),%rbx
  40306a:	86 03                	xchg   %al,(%rbx)
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  40306c:	84 c0                	test   %al,%al
  40306e:	74 08                	je     403078 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E15DeallocateBatchEPNS_14AllocatorStatsEmPNS2_13TransferBatchE.isra.14+0x38>
      return;
    LockSlow();
  403070:	48 89 df             	mov    %rbx,%rdi
  403073:	e8 d8 14 00 00       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
    SpinMutexLock l(&sci->mutex);
    CHECK_GT(b->count, 0);
  403078:	48 83 7d 08 00       	cmpq   $0x0,0x8(%rbp)
  40307d:	74 54                	je     4030d3 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E15DeallocateBatchEPNS_14AllocatorStatsEmPNS2_13TransferBatchE.isra.14+0x93>
      last_ = x;
      size_++;
    }
  }

  void push_front(Item *x) {
  40307f:	48 8b 43 08          	mov    0x8(%rbx),%rax
    if (empty()) {
  403083:	48 85 c0             	test   %rax,%rax
  403086:	74 28                	je     4030b0 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E15DeallocateBatchEPNS_14AllocatorStatsEmPNS2_13TransferBatchE.isra.14+0x70>
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = first_;
  403088:	48 8b 53 10          	mov    0x10(%rbx),%rdx
      first_ = x;
      size_++;
  40308c:	48 83 c0 01          	add    $0x1,%rax
    if (empty()) {
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = first_;
  403090:	48 89 55 00          	mov    %rdx,0x0(%rbp)
      first_ = x;
  403094:	48 89 6b 10          	mov    %rbp,0x10(%rbx)
      size_++;
  403098:	48 89 43 08          	mov    %rax,0x8(%rbx)
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  40309c:	41 c6 44 24 08 00    	movb   $0x0,0x8(%r12)
    sci->free_list.push_front(b);
  }
  4030a2:	5b                   	pop    %rbx
  4030a3:	5d                   	pop    %rbp
  4030a4:	41 5c                	pop    %r12
  4030a6:	c3                   	retq   
  4030a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4030ae:	00 00 
    }
  }

  void push_front(Item *x) {
    if (empty()) {
      x->next = nullptr;
  4030b0:	48 c7 45 00 00 00 00 	movq   $0x0,0x0(%rbp)
  4030b7:	00 
      first_ = last_ = x;
  4030b8:	48 89 6b 18          	mov    %rbp,0x18(%rbx)
  4030bc:	48 89 6b 10          	mov    %rbp,0x10(%rbx)
      size_ = 1;
  4030c0:	48 c7 43 08 01 00 00 	movq   $0x1,0x8(%rbx)
  4030c7:	00 
  4030c8:	41 c6 44 24 08 00    	movb   $0x0,0x8(%r12)
  4030ce:	5b                   	pop    %rbx
  4030cf:	5d                   	pop    %rbp
  4030d0:	41 5c                	pop    %r12
  4030d2:	c3                   	retq   

  NOINLINE void DeallocateBatch(AllocatorStats *stat, uptr class_id, Batch *b) {
    CHECK_LT(class_id, kNumClasses);
    SizeClassInfo *sci = GetSizeClassInfo(class_id);
    SpinMutexLock l(&sci->mutex);
    CHECK_GT(b->count, 0);
  4030d3:	48 8d 15 2a 53 01 00 	lea    0x1532a(%rip),%rdx        # 418404 <.LC6>
  4030da:	48 8d 3d 9f 1f 01 00 	lea    0x11f9f(%rip),%rdi        # 415080 <.LC3>
  4030e1:	45 31 c0             	xor    %r8d,%r8d
  4030e4:	31 c9                	xor    %ecx,%ecx
  4030e6:	be eb 02 00 00       	mov    $0x2eb,%esi
  4030eb:	e8 00 23 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    sci->free_list.pop_front();
    return b;
  }

  NOINLINE void DeallocateBatch(AllocatorStats *stat, uptr class_id, Batch *b) {
    CHECK_LT(class_id, kNumClasses);
  4030f0:	48 8d 15 01 20 01 00 	lea    0x12001(%rip),%rdx        # 4150f8 <.LC5>
  4030f7:	48 8d 3d 82 1f 01 00 	lea    0x11f82(%rip),%rdi        # 415080 <.LC3>
  4030fe:	48 89 f1             	mov    %rsi,%rcx
  403101:	41 b8 35 00 00 00    	mov    $0x35,%r8d
  403107:	be e8 02 00 00       	mov    $0x2e8,%esi
  40310c:	e8 df 22 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  403111:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  403118:	0f 1f 84 00 00 00 00 
  40311f:	00 

0000000000403120 <_ZN11__sanitizer18internal_allocatorEv>:
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
      __asm__ __volatile__("" ::: "memory");
    } else if (mo == memory_order_acquire) {
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  403120:	0f b6 05 ea b5 02 00 	movzbl 0x2b5ea(%rip),%eax        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
static StaticSpinMutex internal_allocator_cache_mu;

InternalAllocator *internal_allocator() {
  InternalAllocator *internal_allocator_instance =
      reinterpret_cast<InternalAllocator *>(&internal_alloc_placeholder);
  if (atomic_load(&internal_allocator_initialized, memory_order_acquire) == 0) {
  403127:	84 c0                	test   %al,%al
  403129:	74 0d                	je     403138 <_ZN11__sanitizer18internal_allocatorEv+0x18>
      internal_allocator_instance->Init(/* may_return_null*/ false);
      atomic_store(&internal_allocator_initialized, 1, memory_order_release);
    }
  }
  return internal_allocator_instance;
}
  40312b:	48 8d 05 0e b6 02 00 	lea    0x2b60e(%rip),%rax        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
  403132:	c3                   	retq   
  403133:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
static StaticSpinMutex internal_alloc_init_mu;

static InternalAllocatorCache internal_allocator_cache;
static StaticSpinMutex internal_allocator_cache_mu;

InternalAllocator *internal_allocator() {
  403138:	48 83 ec 08          	sub    $0x8,%rsp
  40313c:	b8 01 00 00 00       	mov    $0x1,%eax
  403141:	86 05 c9 b5 02 00    	xchg   %al,0x2b5c9(%rip)        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  403147:	84 c0                	test   %al,%al
  403149:	74 0c                	je     403157 <_ZN11__sanitizer18internal_allocatorEv+0x37>
      return;
    LockSlow();
  40314b:	48 8d 3d be b5 02 00 	lea    0x2b5be(%rip),%rdi        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
  403152:	e8 f9 13 00 00       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  403157:	0f b6 05 b3 b5 02 00 	movzbl 0x2b5b3(%rip),%eax        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
  InternalAllocator *internal_allocator_instance =
      reinterpret_cast<InternalAllocator *>(&internal_alloc_placeholder);
  if (atomic_load(&internal_allocator_initialized, memory_order_acquire) == 0) {
    SpinMutexLock l(&internal_alloc_init_mu);
    if (atomic_load(&internal_allocator_initialized, memory_order_relaxed) ==
  40315e:	84 c0                	test   %al,%al
  403160:	74 16                	je     403178 <_ZN11__sanitizer18internal_allocatorEv+0x58>
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  403162:	c6 05 a7 b5 02 00 00 	movb   $0x0,0x2b5a7(%rip)        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
      internal_allocator_instance->Init(/* may_return_null*/ false);
      atomic_store(&internal_allocator_initialized, 1, memory_order_release);
    }
  }
  return internal_allocator_instance;
}
  403169:	48 8d 05 d0 b5 02 00 	lea    0x2b5d0(%rip),%rax        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
  403170:	48 83 c4 08          	add    $0x8,%rsp
  403174:	c3                   	retq   
  403175:	0f 1f 00             	nopl   (%rax)
    page_size_ = GetPageSizeCached();
    atomic_store(&may_return_null_, may_return_null, memory_order_relaxed);
  }

  void Init(bool may_return_null) {
    internal_memset(this, 0, sizeof(*this));
  403178:	48 8d 3d 09 c3 06 00 	lea    0x6c309(%rip),%rdi        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
  40317f:	31 f6                	xor    %esi,%esi
  403181:	ba 50 02 20 00       	mov    $0x200250,%edx
  403186:	e8 b5 71 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).
template <class MapUnmapCallback = NoOpMapUnmapCallback>
class LargeMmapAllocator {
 public:
  void InitLinkerInitialized(bool may_return_null) {
    page_size_ = GetPageSizeCached();
  40318b:	e8 20 1f 00 00       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
  void InitLinkerInitialized() {
    next_ = this;
    prev_ = this;
  }
  void Init() {
    internal_memset(this, 0, sizeof(*this));
  403190:	48 8d 3d 41 c5 26 00 	lea    0x26c541(%rip),%rdi        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
  403197:	31 f6                	xor    %esi,%esi
  403199:	ba 28 00 00 00       	mov    $0x28,%edx
// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).
template <class MapUnmapCallback = NoOpMapUnmapCallback>
class LargeMmapAllocator {
 public:
  void InitLinkerInitialized(bool may_return_null) {
    page_size_ = GetPageSizeCached();
  40319e:	48 89 05 e3 c2 06 00 	mov    %rax,0x6c2e3(%rip)        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  4031a5:	c6 05 24 c5 26 00 00 	movb   $0x0,0x26c524(%rip)        # 66f6d0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f90>
  void InitLinkerInitialized() {
    next_ = this;
    prev_ = this;
  }
  void Init() {
    internal_memset(this, 0, sizeof(*this));
  4031ac:	e8 8f 71 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>

// Global stats, used for aggregation and querying.
class AllocatorGlobalStats : public AllocatorStats {
 public:
  void InitLinkerInitialized() {
    next_ = this;
  4031b1:	48 8d 05 20 c5 26 00 	lea    0x26c520(%rip),%rax        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
// Setting and getting values from multiple threads is safe w/o extra locking.
template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>
class TwoLevelByteMap {
 public:
  void TestOnlyInit() {
    internal_memset(map1_, 0, sizeof(map1_));
  4031b8:	48 8d 3d 81 b5 02 00 	lea    0x2b581(%rip),%rdi        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
  4031bf:	31 f6                	xor    %esi,%esi
  4031c1:	ba 00 00 04 00       	mov    $0x40000,%edx

// Global stats, used for aggregation and querying.
class AllocatorGlobalStats : public AllocatorStats {
 public:
  void InitLinkerInitialized() {
    next_ = this;
  4031c6:	48 89 05 0b c5 26 00 	mov    %rax,0x26c50b(%rip)        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
    prev_ = this;
  4031cd:	48 89 05 0c c5 26 00 	mov    %rax,0x26c50c(%rip)        # 66f6e0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fa0>
// Setting and getting values from multiple threads is safe w/o extra locking.
template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>
class TwoLevelByteMap {
 public:
  void TestOnlyInit() {
    internal_memset(map1_, 0, sizeof(map1_));
  4031d4:	e8 67 71 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
      SizeClassMap, kRegionSizeLog, ByteMap, MapUnmapCallback> ThisT;
  typedef SizeClassAllocatorLocalCache<ThisT> AllocatorCache;

  void Init() {
    possible_regions.TestOnlyInit();
    internal_memset(size_class_info_array, 0, sizeof(size_class_info_array));
  4031d9:	48 8d 3d 68 b5 06 00 	lea    0x6b568(%rip),%rdi        # 46e748 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40008>
  4031e0:	ba 40 0d 00 00       	mov    $0xd40,%edx
  4031e5:	31 f6                	xor    %esi,%esi
  4031e7:	c6 05 52 b5 06 00 00 	movb   $0x0,0x6b552(%rip)        # 46e740 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40000>
  4031ee:	e8 4d 71 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  4031f3:	c6 05 06 c5 26 00 00 	movb   $0x0,0x26c506(%rip)        # 66f700 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fc0>
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  4031fa:	c6 05 10 b5 02 00 01 	movb   $0x1,0x2b510(%rip)        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
      __asm__ __volatile__("" ::: "memory");
  403201:	e9 5c ff ff ff       	jmpq   403162 <_ZN11__sanitizer18internal_allocatorEv+0x42>
  403206:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40320d:	00 00 00 

0000000000403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>:
}

// LowLevelAllocator
static LowLevelAllocateCallback low_level_alloc_callback;

void *LowLevelAllocator::Allocate(uptr size) {
  403210:	41 54                	push   %r12
  403212:	55                   	push   %rbp
  403213:	48 89 fd             	mov    %rdi,%rbp
  403216:	53                   	push   %rbx
  // Align allocation size.
  size = RoundUpTo(size, 8);
  if (allocated_end_ - allocated_current_ < (sptr)size) {
  403217:	48 8b 47 08          	mov    0x8(%rdi),%rax
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  return (size + boundary - 1) & ~(boundary - 1);
  40321b:	48 8d 5e 07          	lea    0x7(%rsi),%rbx
  40321f:	48 8b 17             	mov    (%rdi),%rdx
  403222:	48 83 e3 f8          	and    $0xfffffffffffffff8,%rbx
  403226:	48 29 c2             	sub    %rax,%rdx
  403229:	48 39 da             	cmp    %rbx,%rdx
  40322c:	7c 12                	jl     403240 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm+0x30>
                               size_to_allocate);
    }
  }
  CHECK(allocated_end_ - allocated_current_ >= (sptr)size);
  void *res = allocated_current_;
  allocated_current_ += size;
  40322e:	48 01 c3             	add    %rax,%rbx
  403231:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
  return res;
}
  403235:	5b                   	pop    %rbx
  403236:	5d                   	pop    %rbp
  403237:	41 5c                	pop    %r12
  403239:	c3                   	retq   
  40323a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

void *LowLevelAllocator::Allocate(uptr size) {
  // Align allocation size.
  size = RoundUpTo(size, 8);
  if (allocated_end_ - allocated_current_ < (sptr)size) {
    uptr size_to_allocate = Max(size, GetPageSizeCached());
  403240:	e8 6b 1e 00 00       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
  403245:	48 39 d8             	cmp    %rbx,%rax
    allocated_current_ =
        (char*)MmapOrDie(size_to_allocate, __func__);
  403248:	48 8d 35 d8 5e 01 00 	lea    0x15ed8(%rip),%rsi        # 419127 <_ZZN11__sanitizer17LowLevelAllocator8AllocateEmE8__func__>
  40324f:	48 0f 42 c3          	cmovb  %rbx,%rax
  403253:	48 89 c7             	mov    %rax,%rdi
  403256:	49 89 c4             	mov    %rax,%r12
  403259:	e8 42 91 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
    allocated_end_ = allocated_current_ + size_to_allocate;
    if (low_level_alloc_callback) {
  40325e:	48 8b 0d 1b dd 01 00 	mov    0x1dd1b(%rip),%rcx        # 420f80 <_ZN11__sanitizerL24low_level_alloc_callbackE>
  size = RoundUpTo(size, 8);
  if (allocated_end_ - allocated_current_ < (sptr)size) {
    uptr size_to_allocate = Max(size, GetPageSizeCached());
    allocated_current_ =
        (char*)MmapOrDie(size_to_allocate, __func__);
    allocated_end_ = allocated_current_ + size_to_allocate;
  403265:	4a 8d 14 20          	lea    (%rax,%r12,1),%rdx
  // Align allocation size.
  size = RoundUpTo(size, 8);
  if (allocated_end_ - allocated_current_ < (sptr)size) {
    uptr size_to_allocate = Max(size, GetPageSizeCached());
    allocated_current_ =
        (char*)MmapOrDie(size_to_allocate, __func__);
  403269:	48 89 45 08          	mov    %rax,0x8(%rbp)
    allocated_end_ = allocated_current_ + size_to_allocate;
  40326d:	48 89 55 00          	mov    %rdx,0x0(%rbp)
    if (low_level_alloc_callback) {
  403271:	48 85 c9             	test   %rcx,%rcx
  403274:	74 10                	je     403286 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm+0x76>
      low_level_alloc_callback((uptr)allocated_current_,
                               size_to_allocate);
  403276:	48 89 c7             	mov    %rax,%rdi
  403279:	4c 89 e6             	mov    %r12,%rsi
  40327c:	ff d1                	callq  *%rcx
  40327e:	48 8b 45 08          	mov    0x8(%rbp),%rax
  403282:	48 8b 55 00          	mov    0x0(%rbp),%rdx
  403286:	48 29 c2             	sub    %rax,%rdx
    }
  }
  CHECK(allocated_end_ - allocated_current_ >= (sptr)size);
  403289:	48 39 d3             	cmp    %rdx,%rbx
  40328c:	7e a0                	jle    40322e <_ZN11__sanitizer17LowLevelAllocator8AllocateEm+0x1e>
  40328e:	48 8d 15 83 1e 01 00 	lea    0x11e83(%rip),%rdx        # 415118 <.LC7>
  403295:	48 8d 3d bc 1e 01 00 	lea    0x11ebc(%rip),%rdi        # 415158 <.LC8>
  40329c:	45 31 c0             	xor    %r8d,%r8d
  40329f:	31 c9                	xor    %ecx,%ecx
  4032a1:	be 7f 00 00 00       	mov    $0x7f,%esi
  4032a6:	e8 45 21 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  4032ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000004032b0 <_ZN11__sanitizer27SetLowLevelAllocateCallbackEPFvmmE>:
  allocated_current_ += size;
  return res;
}

void SetLowLevelAllocateCallback(LowLevelAllocateCallback callback) {
  low_level_alloc_callback = callback;
  4032b0:	48 89 3d c9 dc 01 00 	mov    %rdi,0x1dcc9(%rip)        # 420f80 <_ZN11__sanitizerL24low_level_alloc_callbackE>
  4032b7:	c3                   	retq   
  4032b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4032bf:	00 

00000000004032c0 <_ZN11__sanitizer35CallocShouldReturnNullDueToOverflowEmm>:
}

bool CallocShouldReturnNullDueToOverflow(uptr size, uptr n) {
  if (!size) return false;
  4032c0:	31 c0                	xor    %eax,%eax
  4032c2:	48 85 ff             	test   %rdi,%rdi
  4032c5:	74 12                	je     4032d9 <_ZN11__sanitizer35CallocShouldReturnNullDueToOverflowEmm+0x19>
  uptr max = (uptr)-1L;
  return (max / size) < n;
  4032c7:	31 d2                	xor    %edx,%edx
  4032c9:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  4032d0:	48 f7 f7             	div    %rdi
  4032d3:	48 39 f0             	cmp    %rsi,%rax
  4032d6:	0f 92 c0             	setb   %al
}
  4032d9:	f3 c3                	repz retq 
  4032db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000004032e0 <_ZN11__sanitizer31ReportAllocatorCannotReturnNullEv>:

void NORETURN ReportAllocatorCannotReturnNull() {
  4032e0:	48 83 ec 08          	sub    $0x8,%rsp
  Report("%s's allocator is terminating the process instead of returning 0\n",
         SanitizerToolName);
  4032e4:	48 8b 05 c5 af 01 00 	mov    0x1afc5(%rip),%rax        # 41e2b0 <_DYNAMIC+0x2b0>
  4032eb:	48 8d 3d de 1e 01 00 	lea    0x11ede(%rip),%rdi        # 4151d0 <.LC9>
  4032f2:	48 8b 30             	mov    (%rax),%rsi
  4032f5:	31 c0                	xor    %eax,%eax
  4032f7:	e8 94 a7 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
  Report("If you don't like this behavior set allocator_may_return_null=1\n");
  4032fc:	48 8d 3d 15 1f 01 00 	lea    0x11f15(%rip),%rdi        # 415218 <.LC10>
  403303:	31 c0                	xor    %eax,%eax
  403305:	e8 86 a7 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
  CHECK(0);
  40330a:	48 8d 15 08 51 01 00 	lea    0x15108(%rip),%rdx        # 418419 <.LC0>
  403311:	48 8d 3d 40 1e 01 00 	lea    0x11e40(%rip),%rdi        # 415158 <.LC8>
  403318:	45 31 c0             	xor    %r8d,%r8d
  40331b:	31 c9                	xor    %ecx,%ecx
  40331d:	be 93 00 00 00       	mov    $0x93,%esi
  403322:	e8 c9 20 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  403327:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40332e:	00 00 

0000000000403330 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE>:

#endif // SANITIZER_GO

const u64 kBlockMagic = 0x6A6CB03ABCEBC041ull;

void *InternalAlloc(uptr size, InternalAllocatorCache *cache) {
  403330:	41 55                	push   %r13
  403332:	41 54                	push   %r12
  403334:	55                   	push   %rbp
  403335:	48 89 fd             	mov    %rdi,%rbp
  403338:	53                   	push   %rbx
  if (size + sizeof(u64) < size)
  403339:	48 8d 5f 08          	lea    0x8(%rdi),%rbx

#endif // SANITIZER_GO

const u64 kBlockMagic = 0x6A6CB03ABCEBC041ull;

void *InternalAlloc(uptr size, InternalAllocatorCache *cache) {
  40333d:	48 83 ec 08          	sub    $0x8,%rsp
  if (size + sizeof(u64) < size)
  403341:	48 39 df             	cmp    %rbx,%rdi
  403344:	0f 87 b2 00 00 00    	ja     4033fc <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0xcc>
  }
  return internal_allocator_instance;
}

static void *RawInternalAlloc(uptr size, InternalAllocatorCache *cache) {
  if (cache == 0) {
  40334a:	48 85 f6             	test   %rsi,%rsi
  40334d:	49 89 f4             	mov    %rsi,%r12
  403350:	0f 84 7a 02 00 00    	je     4035d0 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x2a0>
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
      __asm__ __volatile__("" ::: "memory");
    } else if (mo == memory_order_acquire) {
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  403356:	0f b6 05 b4 b3 02 00 	movzbl 0x2b3b4(%rip),%eax        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
static StaticSpinMutex internal_allocator_cache_mu;

InternalAllocator *internal_allocator() {
  InternalAllocator *internal_allocator_instance =
      reinterpret_cast<InternalAllocator *>(&internal_alloc_placeholder);
  if (atomic_load(&internal_allocator_initialized, memory_order_acquire) == 0) {
  40335d:	84 c0                	test   %al,%al
  40335f:	0f 84 ab 00 00 00    	je     403410 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0xe0>
  }

  void *Allocate(AllocatorCache *cache, uptr size, uptr alignment,
                 bool cleared = false, bool check_rss_limit = false) {
    // Returning 0 on malloc(0) may break a lot of code.
    if (size == 0)
  403365:	48 85 db             	test   %rbx,%rbx
  403368:	75 76                	jne    4033e0 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0xb0>
  40336a:	bd 01 00 00 00       	mov    $0x1,%ebp
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
  40336f:	48 89 e8             	mov    %rbp,%rax
  403372:	48 c1 e0 04          	shl    $0x4,%rax
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  403376:	49 8b 94 24 60 d7 00 	mov    0xd760(%r12),%rdx
  40337d:	00 

  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {
    CHECK_NE(class_id, 0UL);
    CHECK_LT(class_id, kNumClasses);
    stats_.Add(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
  40337e:	48 89 eb             	mov    %rbp,%rbx
  403381:	48 c1 e3 04          	shl    $0x4,%rbx
    internal_memset(this, 0, sizeof(*this));
  }
  void InitLinkerInitialized() {}

  void Add(AllocatorStat i, uptr v) {
    v += atomic_load(&stats_[i], memory_order_relaxed);
  403385:	48 01 d0             	add    %rdx,%rax
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  403388:	49 89 84 24 60 d7 00 	mov    %rax,0xd760(%r12)
  40338f:	00 

  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {
    CHECK_NE(class_id, 0UL);
    CHECK_LT(class_id, kNumClasses);
    stats_.Add(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
  403390:	48 89 e8             	mov    %rbp,%rax
  403393:	48 c1 e0 0a          	shl    $0xa,%rax
  403397:	48 01 c3             	add    %rax,%rbx
  40339a:	4c 01 e3             	add    %r12,%rbx
    if (UNLIKELY(c->count == 0))
  40339d:	48 8b 13             	mov    (%rbx),%rdx
  4033a0:	48 85 d2             	test   %rdx,%rdx
  4033a3:	0f 84 87 08 00 00    	je     403c30 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x900>
      Refill(allocator, class_id);
    void *res = c->batch[--c->count];
  4033a9:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
  4033ad:	48 89 03             	mov    %rax,(%rbx)
  4033b0:	48 8b 44 d3 08       	mov    0x8(%rbx,%rdx,8),%rax
    PREFETCH(c->batch[c->count - 1]);
  4033b5:	48 8b 14 d3          	mov    (%rbx,%rdx,8),%rdx
  4033b9:	0f 18 02             	prefetchnta (%rdx)

void *InternalAlloc(uptr size, InternalAllocatorCache *cache) {
  if (size + sizeof(u64) < size)
    return nullptr;
  void *p = RawInternalAlloc(size + sizeof(u64), cache);
  if (!p)
  4033bc:	48 85 c0             	test   %rax,%rax
  4033bf:	74 3b                	je     4033fc <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0xcc>
    return nullptr;
  ((u64*)p)[0] = kBlockMagic;
  4033c1:	48 b9 41 c0 eb bc 3a 	movabs $0x6a6cb03abcebc041,%rcx
  4033c8:	b0 6c 6a 
  return (char*)p + sizeof(u64);
  4033cb:	48 83 c0 08          	add    $0x8,%rax
  if (size + sizeof(u64) < size)
    return nullptr;
  void *p = RawInternalAlloc(size + sizeof(u64), cache);
  if (!p)
    return nullptr;
  ((u64*)p)[0] = kBlockMagic;
  4033cf:	48 89 48 f8          	mov    %rcx,-0x8(%rax)
  return (char*)p + sizeof(u64);
}
  4033d3:	48 83 c4 08          	add    $0x8,%rsp
  4033d7:	5b                   	pop    %rbx
  4033d8:	5d                   	pop    %rbp
  4033d9:	41 5c                	pop    %r12
  4033db:	41 5d                	pop    %r13
  4033dd:	c3                   	retq   
  4033de:	66 90                	xchg   %ax,%ax
  void *Allocate(AllocatorCache *cache, uptr size, uptr alignment,
                 bool cleared = false, bool check_rss_limit = false) {
    // Returning 0 on malloc(0) may break a lot of code.
    if (size == 0)
      size = 1;
    if (size + alignment < size)
  4033e0:	48 8d 45 10          	lea    0x10(%rbp),%rax
  4033e4:	48 39 c3             	cmp    %rax,%rbx
  4033e7:	0f 86 f1 00 00 00    	jbe    4034de <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x1ae>
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
      __asm__ __volatile__("" ::: "memory");
    } else if (mo == memory_order_acquire) {
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  4033ed:	0f b6 05 0c c3 26 00 	movzbl 0x26c30c(%rip),%eax        # 66f700 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fc0>
  bool MayReturnNull() const {
    return atomic_load(&may_return_null_, memory_order_acquire);
  }

  void *ReturnNullOrDie() {
    if (MayReturnNull())
  4033f4:	84 c0                	test   %al,%al
  4033f6:	0f 84 cb 01 00 00    	je     4035c7 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x297>
  4033fc:	48 83 c4 08          	add    $0x8,%rsp

const u64 kBlockMagic = 0x6A6CB03ABCEBC041ull;

void *InternalAlloc(uptr size, InternalAllocatorCache *cache) {
  if (size + sizeof(u64) < size)
    return nullptr;
  403400:	31 c0                	xor    %eax,%eax
  void *p = RawInternalAlloc(size + sizeof(u64), cache);
  if (!p)
    return nullptr;
  ((u64*)p)[0] = kBlockMagic;
  return (char*)p + sizeof(u64);
}
  403402:	5b                   	pop    %rbx
  403403:	5d                   	pop    %rbp
  403404:	41 5c                	pop    %r12
  403406:	41 5d                	pop    %r13
  403408:	c3                   	retq   
  403409:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  403410:	b8 01 00 00 00       	mov    $0x1,%eax
  403415:	86 05 f5 b2 02 00    	xchg   %al,0x2b2f5(%rip)        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  40341b:	84 c0                	test   %al,%al
  40341d:	75 21                	jne    403440 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x110>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  40341f:	0f b6 05 eb b2 02 00 	movzbl 0x2b2eb(%rip),%eax        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
InternalAllocator *internal_allocator() {
  InternalAllocator *internal_allocator_instance =
      reinterpret_cast<InternalAllocator *>(&internal_alloc_placeholder);
  if (atomic_load(&internal_allocator_initialized, memory_order_acquire) == 0) {
    SpinMutexLock l(&internal_alloc_init_mu);
    if (atomic_load(&internal_allocator_initialized, memory_order_relaxed) ==
  403426:	84 c0                	test   %al,%al
  403428:	74 26                	je     403450 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x120>
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  40342a:	c6 05 df b2 02 00 00 	movb   $0x0,0x2b2df(%rip)        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
      __asm__ __volatile__("" ::: "memory");
  403431:	e9 2f ff ff ff       	jmpq   403365 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x35>
  403436:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40343d:	00 00 00 
      return;
    LockSlow();
  403440:	48 8d 3d c9 b2 02 00 	lea    0x2b2c9(%rip),%rdi        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
  403447:	e8 04 11 00 00       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  40344c:	eb d1                	jmp    40341f <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0xef>
  40344e:	66 90                	xchg   %ax,%ax
    page_size_ = GetPageSizeCached();
    atomic_store(&may_return_null_, may_return_null, memory_order_relaxed);
  }

  void Init(bool may_return_null) {
    internal_memset(this, 0, sizeof(*this));
  403450:	48 8d 3d 31 c0 06 00 	lea    0x6c031(%rip),%rdi        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
  403457:	31 f6                	xor    %esi,%esi
  403459:	ba 50 02 20 00       	mov    $0x200250,%edx
  40345e:	e8 dd 6e 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).
template <class MapUnmapCallback = NoOpMapUnmapCallback>
class LargeMmapAllocator {
 public:
  void InitLinkerInitialized(bool may_return_null) {
    page_size_ = GetPageSizeCached();
  403463:	e8 48 1c 00 00       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
  void InitLinkerInitialized() {
    next_ = this;
    prev_ = this;
  }
  void Init() {
    internal_memset(this, 0, sizeof(*this));
  403468:	48 8d 3d 69 c2 26 00 	lea    0x26c269(%rip),%rdi        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
  40346f:	31 f6                	xor    %esi,%esi
  403471:	ba 28 00 00 00       	mov    $0x28,%edx
// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).
template <class MapUnmapCallback = NoOpMapUnmapCallback>
class LargeMmapAllocator {
 public:
  void InitLinkerInitialized(bool may_return_null) {
    page_size_ = GetPageSizeCached();
  403476:	48 89 05 0b c0 06 00 	mov    %rax,0x6c00b(%rip)        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  40347d:	c6 05 4c c2 26 00 00 	movb   $0x0,0x26c24c(%rip)        # 66f6d0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f90>
  void InitLinkerInitialized() {
    next_ = this;
    prev_ = this;
  }
  void Init() {
    internal_memset(this, 0, sizeof(*this));
  403484:	e8 b7 6e 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>

// Global stats, used for aggregation and querying.
class AllocatorGlobalStats : public AllocatorStats {
 public:
  void InitLinkerInitialized() {
    next_ = this;
  403489:	48 8d 05 48 c2 26 00 	lea    0x26c248(%rip),%rax        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
// Setting and getting values from multiple threads is safe w/o extra locking.
template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>
class TwoLevelByteMap {
 public:
  void TestOnlyInit() {
    internal_memset(map1_, 0, sizeof(map1_));
  403490:	48 8d 3d a9 b2 02 00 	lea    0x2b2a9(%rip),%rdi        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
  403497:	31 f6                	xor    %esi,%esi
  403499:	ba 00 00 04 00       	mov    $0x40000,%edx

// Global stats, used for aggregation and querying.
class AllocatorGlobalStats : public AllocatorStats {
 public:
  void InitLinkerInitialized() {
    next_ = this;
  40349e:	48 89 05 33 c2 26 00 	mov    %rax,0x26c233(%rip)        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
    prev_ = this;
  4034a5:	48 89 05 34 c2 26 00 	mov    %rax,0x26c234(%rip)        # 66f6e0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fa0>
// Setting and getting values from multiple threads is safe w/o extra locking.
template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>
class TwoLevelByteMap {
 public:
  void TestOnlyInit() {
    internal_memset(map1_, 0, sizeof(map1_));
  4034ac:	e8 8f 6e 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
      SizeClassMap, kRegionSizeLog, ByteMap, MapUnmapCallback> ThisT;
  typedef SizeClassAllocatorLocalCache<ThisT> AllocatorCache;

  void Init() {
    possible_regions.TestOnlyInit();
    internal_memset(size_class_info_array, 0, sizeof(size_class_info_array));
  4034b1:	48 8d 3d 90 b2 06 00 	lea    0x6b290(%rip),%rdi        # 46e748 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40008>
  4034b8:	ba 40 0d 00 00       	mov    $0xd40,%edx
  4034bd:	31 f6                	xor    %esi,%esi
  4034bf:	c6 05 7a b2 06 00 00 	movb   $0x0,0x6b27a(%rip)        # 46e740 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40000>
  4034c6:	e8 75 6e 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  4034cb:	c6 05 2e c2 26 00 00 	movb   $0x0,0x26c22e(%rip)        # 66f700 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fc0>
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  4034d2:	c6 05 38 b2 02 00 01 	movb   $0x1,0x2b238(%rip)        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
      __asm__ __volatile__("" ::: "memory");
  4034d9:	e9 4c ff ff ff       	jmpq   40342a <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0xfa>
      return ReturnNullOrDie();
    if (alignment > 8)
      size = RoundUpTo(size, alignment);
    void *res;
    bool from_primary = primary_.CanAllocate(size, alignment);
    if (from_primary)
  4034de:	48 81 fb 00 00 02 00 	cmp    $0x20000,%rbx
  4034e5:	0f 87 95 00 00 00    	ja     403580 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x250>
  4034eb:	48 83 c5 17          	add    $0x17,%rbp
  4034ef:	48 c1 ed 04          	shr    $0x4,%rbp
    uptr t = kMidSize << (class_id >> S);
    return t + (t >> S) * (class_id & M);
  }

  static uptr ClassID(uptr size) {
    if (size <= kMidSize)
  4034f3:	48 81 fb 00 01 00 00 	cmp    $0x100,%rbx
  4034fa:	76 41                	jbe    40353d <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x20d>
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  4034fc:	48 0f bd c3          	bsr    %rbx,%rax
  403500:	b9 3f 00 00 00       	mov    $0x3f,%ecx
    if (size > kMaxSize) return 0;
    uptr l = MostSignificantSetBitIndex(size);
    uptr hbits = (size >> (l - S)) & M;
    uptr lbits = size & ((1 << (l - S)) - 1);
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  403505:	31 ed                	xor    %ebp,%ebp
  403507:	48 83 f0 3f          	xor    $0x3f,%rax
  40350b:	29 c1                	sub    %eax,%ecx
  static uptr ClassID(uptr size) {
    if (size <= kMidSize)
      return (size + kMinSize - 1) >> kMinSizeLog;
    if (size > kMaxSize) return 0;
    uptr l = MostSignificantSetBitIndex(size);
    uptr hbits = (size >> (l - S)) & M;
  40350d:	48 89 d8             	mov    %rbx,%rax
  403510:	48 63 d1             	movslq %ecx,%rdx
  403513:	83 e9 02             	sub    $0x2,%ecx
  403516:	48 d3 e8             	shr    %cl,%rax
  403519:	83 e0 03             	and    $0x3,%eax
    uptr lbits = size & ((1 << (l - S)) - 1);
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  40351c:	48 8d 54 90 f0       	lea    -0x10(%rax,%rdx,4),%rdx
    if (size <= kMidSize)
      return (size + kMinSize - 1) >> kMinSizeLog;
    if (size > kMaxSize) return 0;
    uptr l = MostSignificantSetBitIndex(size);
    uptr hbits = (size >> (l - S)) & M;
    uptr lbits = size & ((1 << (l - S)) - 1);
  403521:	b8 01 00 00 00       	mov    $0x1,%eax
  403526:	d3 e0                	shl    %cl,%eax
  403528:	83 e8 01             	sub    $0x1,%eax
  40352b:	48 98                	cltq   
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  40352d:	48 85 d8             	test   %rbx,%rax
  403530:	40 0f 95 c5          	setne  %bpl
    if (s)
      s->Unregister(&stats_);
  }

  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {
    CHECK_NE(class_id, 0UL);
  403534:	48 01 d5             	add    %rdx,%rbp
  403537:	0f 84 ec 06 00 00    	je     403c29 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x8f9>
    CHECK_LT(class_id, kNumClasses);
  40353d:	48 83 fd 34          	cmp    $0x34,%rbp
  403541:	0f 87 c1 06 00 00    	ja     403c08 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x8d8>
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  403547:	48 83 fd 10          	cmp    $0x10,%rbp
  40354b:	0f 86 1e fe ff ff    	jbe    40336f <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x3f>
      return kMinSize * class_id;
    class_id -= kMidClass;
  403551:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
    uptr t = kMidSize << (class_id >> S);
  403555:	b8 00 01 00 00       	mov    $0x100,%eax
  40355a:	48 89 f1             	mov    %rsi,%rcx
    return t + (t >> S) * (class_id & M);
  40355d:	83 e6 03             	and    $0x3,%esi

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  403560:	48 c1 e9 02          	shr    $0x2,%rcx
  403564:	48 d3 e0             	shl    %cl,%rax
    return t + (t >> S) * (class_id & M);
  403567:	48 89 c2             	mov    %rax,%rdx
  40356a:	48 c1 ea 02          	shr    $0x2,%rdx
  40356e:	48 0f af d6          	imul   %rsi,%rdx
  403572:	48 01 d0             	add    %rdx,%rax
  403575:	e9 fc fd ff ff       	jmpq   403376 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x46>
  40357a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    CHECK(IsAligned((uptr)h, page_size_));
    return reinterpret_cast<void*>(reinterpret_cast<uptr>(h) + page_size_);
  }

  uptr RoundUpMapSize(uptr size) {
    return RoundUpTo(size, page_size_) + page_size_;
  403580:	48 8b 05 01 bf 06 00 	mov    0x6bf01(%rip),%rax        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
#endif
  return up;
}

INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
  403587:	48 8d 68 ff          	lea    -0x1(%rax),%rbp
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40358b:	48 85 c5             	test   %rax,%rbp
  40358e:	0f 85 3a 06 00 00    	jne    403bce <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x89e>
  return (size + boundary - 1) & ~(boundary - 1);
  403594:	48 89 c2             	mov    %rax,%rdx
  403597:	48 01 dd             	add    %rbx,%rbp
  40359a:	48 f7 da             	neg    %rdx
  40359d:	48 21 d5             	and    %rdx,%rbp
  4035a0:	48 01 c5             	add    %rax,%rbp

  void *Allocate(AllocatorStats *stat, uptr size, uptr alignment) {
    CHECK(IsPowerOfTwo(alignment));
    uptr map_size = RoundUpMapSize(size);
    if (alignment > page_size_)
      map_size += alignment;
  4035a3:	48 83 f8 07          	cmp    $0x7,%rax
  4035a7:	48 8d 55 08          	lea    0x8(%rbp),%rdx
  4035ab:	48 0f 46 ea          	cmovbe %rdx,%rbp
    // Overflow.
    if (map_size < size)
  4035af:	48 39 eb             	cmp    %rbp,%rbx
  4035b2:	0f 86 20 01 00 00    	jbe    4036d8 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x3a8>
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
      __asm__ __volatile__("" ::: "memory");
    } else if (mo == memory_order_acquire) {
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  4035b8:	0f b6 05 11 c1 26 00 	movzbl 0x26c111(%rip),%eax        # 66f6d0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f90>
    }
    return reinterpret_cast<void*>(res);
  }

  void *ReturnNullOrDie() {
    if (atomic_load(&may_return_null_, memory_order_acquire))
  4035bf:	84 c0                	test   %al,%al
  4035c1:	0f 85 35 fe ff ff    	jne    4033fc <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0xcc>
  }

  void *ReturnNullOrDie() {
    if (MayReturnNull())
      return nullptr;
    ReportAllocatorCannotReturnNull();
  4035c7:	e8 14 fd ff ff       	callq  4032e0 <_ZN11__sanitizer31ReportAllocatorCannotReturnNullEv>
  4035cc:	0f 1f 40 00          	nopl   0x0(%rax)
  4035d0:	b8 01 00 00 00       	mov    $0x1,%eax
  4035d5:	86 05 ad d9 01 00    	xchg   %al,0x1d9ad(%rip)        # 420f88 <_ZN11__sanitizerL27internal_allocator_cache_muE>
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  4035db:	84 c0                	test   %al,%al
  4035dd:	0f 85 dd 00 00 00    	jne    4036c0 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x390>
  4035e3:	0f b6 05 27 b1 02 00 	movzbl 0x2b127(%rip),%eax        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
static StaticSpinMutex internal_allocator_cache_mu;

InternalAllocator *internal_allocator() {
  InternalAllocator *internal_allocator_instance =
      reinterpret_cast<InternalAllocator *>(&internal_alloc_placeholder);
  if (atomic_load(&internal_allocator_initialized, memory_order_acquire) == 0) {
  4035ea:	84 c0                	test   %al,%al
  4035ec:	0f 84 96 00 00 00    	je     403688 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x358>
  }

  void *Allocate(AllocatorCache *cache, uptr size, uptr alignment,
                 bool cleared = false, bool check_rss_limit = false) {
    // Returning 0 on malloc(0) may break a lot of code.
    if (size == 0)
  4035f2:	48 85 db             	test   %rbx,%rbx
  4035f5:	75 61                	jne    403658 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x328>
  4035f7:	ba 01 00 00 00       	mov    $0x1,%edx
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
  4035fc:	48 89 d0             	mov    %rdx,%rax
  4035ff:	48 c1 e0 04          	shl    $0x4,%rax
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  403603:	48 8b 0d f6 b0 02 00 	mov    0x2b0f6(%rip),%rcx        # 42e700 <_ZN11__sanitizerL24internal_allocator_cacheE+0xd760>

  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {
    CHECK_NE(class_id, 0UL);
    CHECK_LT(class_id, kNumClasses);
    stats_.Add(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
  40360a:	48 89 d3             	mov    %rdx,%rbx
  40360d:	48 8d 3d 8c d9 01 00 	lea    0x1d98c(%rip),%rdi        # 420fa0 <_ZN11__sanitizerL24internal_allocator_cacheE>
  403614:	48 c1 e3 04          	shl    $0x4,%rbx
    internal_memset(this, 0, sizeof(*this));
  }
  void InitLinkerInitialized() {}

  void Add(AllocatorStat i, uptr v) {
    v += atomic_load(&stats_[i], memory_order_relaxed);
  403618:	48 01 c8             	add    %rcx,%rax
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  40361b:	48 89 05 de b0 02 00 	mov    %rax,0x2b0de(%rip)        # 42e700 <_ZN11__sanitizerL24internal_allocator_cacheE+0xd760>

  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {
    CHECK_NE(class_id, 0UL);
    CHECK_LT(class_id, kNumClasses);
    stats_.Add(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
  403622:	48 89 d0             	mov    %rdx,%rax
  403625:	48 c1 e0 0a          	shl    $0xa,%rax
  403629:	48 01 c3             	add    %rax,%rbx
  40362c:	48 01 fb             	add    %rdi,%rbx
    if (UNLIKELY(c->count == 0))
  40362f:	48 8b 03             	mov    (%rbx),%rax
  403632:	48 85 c0             	test   %rax,%rax
  403635:	0f 84 7f 05 00 00    	je     403bba <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x88a>
  40363b:	48 89 c2             	mov    %rax,%rdx
      Refill(allocator, class_id);
    void *res = c->batch[--c->count];
  40363e:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
  403642:	48 89 03             	mov    %rax,(%rbx)
  403645:	48 8b 44 d3 08       	mov    0x8(%rbx,%rdx,8),%rax
    PREFETCH(c->batch[c->count - 1]);
  40364a:	48 8b 14 d3          	mov    (%rbx,%rdx,8),%rdx
  40364e:	0f 18 02             	prefetchnta (%rdx)
  403651:	eb 23                	jmp    403676 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x346>
  403653:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  void *Allocate(AllocatorCache *cache, uptr size, uptr alignment,
                 bool cleared = false, bool check_rss_limit = false) {
    // Returning 0 on malloc(0) may break a lot of code.
    if (size == 0)
      size = 1;
    if (size + alignment < size)
  403658:	48 8d 45 10          	lea    0x10(%rbp),%rax
  40365c:	48 39 c3             	cmp    %rax,%rbx
  40365f:	0f 86 c9 01 00 00    	jbe    40382e <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x4fe>
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
      __asm__ __volatile__("" ::: "memory");
    } else if (mo == memory_order_acquire) {
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  403665:	0f b6 05 94 c0 26 00 	movzbl 0x26c094(%rip),%eax        # 66f700 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fc0>
  bool MayReturnNull() const {
    return atomic_load(&may_return_null_, memory_order_acquire);
  }

  void *ReturnNullOrDie() {
    if (MayReturnNull())
  40366c:	84 c0                	test   %al,%al
  40366e:	0f 84 53 ff ff ff    	je     4035c7 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x297>
                 bool cleared = false, bool check_rss_limit = false) {
    // Returning 0 on malloc(0) may break a lot of code.
    if (size == 0)
      size = 1;
    if (size + alignment < size)
      return ReturnNullOrDie();
  403674:	31 c0                	xor    %eax,%eax
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  403676:	c6 05 0b d9 01 00 00 	movb   $0x0,0x1d90b(%rip)        # 420f88 <_ZN11__sanitizerL27internal_allocator_cache_muE>
      __asm__ __volatile__("" ::: "memory");
  40367d:	e9 3a fd ff ff       	jmpq   4033bc <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x8c>
  403682:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  403688:	b8 01 00 00 00       	mov    $0x1,%eax
  40368d:	86 05 7d b0 02 00    	xchg   %al,0x2b07d(%rip)        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
  403693:	84 c0                	test   %al,%al
  403695:	74 0c                	je     4036a3 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x373>
      return;
    LockSlow();
  403697:	48 8d 3d 72 b0 02 00 	lea    0x2b072(%rip),%rdi        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
  40369e:	e8 ad 0e 00 00       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  4036a3:	0f b6 05 67 b0 02 00 	movzbl 0x2b067(%rip),%eax        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
    SpinMutexLock l(&internal_alloc_init_mu);
    if (atomic_load(&internal_allocator_initialized, memory_order_relaxed) ==
  4036aa:	84 c0                	test   %al,%al
  4036ac:	0f 84 6e 02 00 00    	je     403920 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x5f0>
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  4036b2:	c6 05 57 b0 02 00 00 	movb   $0x0,0x2b057(%rip)        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
      __asm__ __volatile__("" ::: "memory");
  4036b9:	e9 34 ff ff ff       	jmpq   4035f2 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x2c2>
  4036be:	66 90                	xchg   %ax,%ax
  4036c0:	48 8d 3d c1 d8 01 00 	lea    0x1d8c1(%rip),%rdi        # 420f88 <_ZN11__sanitizerL27internal_allocator_cache_muE>
  4036c7:	e8 84 0e 00 00       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  4036cc:	e9 12 ff ff ff       	jmpq   4035e3 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x2b3>
  4036d1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      map_size += alignment;
    // Overflow.
    if (map_size < size)
      return ReturnNullOrDie();
    uptr map_beg = reinterpret_cast<uptr>(
        MmapOrDie(map_size, "LargeMmapAllocator"));
  4036d8:	48 8d 35 88 4d 01 00 	lea    0x14d88(%rip),%rsi        # 418467 <.LC20>
  4036df:	48 89 ef             	mov    %rbp,%rdi
  4036e2:	e8 b9 8c 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
    CHECK(IsAligned(map_beg, page_size_));
  4036e7:	48 8b 15 9a bd 06 00 	mov    0x6bd9a(%rip),%rdx        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
INLINE uptr RoundDownTo(uptr x, uptr boundary) {
  return x & ~(boundary - 1);
}

INLINE bool IsAligned(uptr a, uptr alignment) {
  return (a & (alignment - 1)) == 0;
  4036ee:	48 8d 4a ff          	lea    -0x1(%rdx),%rcx
  4036f2:	48 85 c8             	test   %rcx,%rax
  4036f5:	0f 85 81 04 00 00    	jne    403b7c <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x84c>
    MapUnmapCallback().OnMap(map_beg, map_size);
    uptr map_end = map_beg + map_size;
    uptr res = map_beg + page_size_;
  4036fb:	4c 8d 24 10          	lea    (%rax,%rdx,1),%r12
      return ReturnNullOrDie();
    uptr map_beg = reinterpret_cast<uptr>(
        MmapOrDie(map_size, "LargeMmapAllocator"));
    CHECK(IsAligned(map_beg, page_size_));
    MapUnmapCallback().OnMap(map_beg, map_size);
    uptr map_end = map_beg + map_size;
  4036ff:	4c 8d 04 28          	lea    (%rax,%rbp,1),%r8
    uptr res = map_beg + page_size_;
    if (res & (alignment - 1))  // Align.
  403703:	4c 89 e6             	mov    %r12,%rsi
  403706:	83 e6 07             	and    $0x7,%esi
  403709:	74 11                	je     40371c <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x3ec>
      res += alignment - (res & (alignment - 1));
  40370b:	49 83 c4 08          	add    $0x8,%r12
  40370f:	49 29 f4             	sub    %rsi,%r12
    CHECK(IsAligned(res, alignment));
  403712:	41 f6 c4 07          	test   $0x7,%r12b
  403716:	0f 85 cf 04 00 00    	jne    403beb <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x8bb>
    CHECK(IsAligned(res, page_size_));
  40371c:	49 85 cc             	test   %rcx,%r12
  40371f:	0f 85 3a 04 00 00    	jne    403b5f <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x82f>
    CHECK_GE(res + size, map_beg);
  403725:	49 8d 0c 1c          	lea    (%r12,%rbx,1),%rcx
  403729:	48 39 c8             	cmp    %rcx,%rax
  40372c:	0f 87 12 04 00 00    	ja     403b44 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x814>
    CHECK_LE(res + size, map_end);
  403732:	49 39 c8             	cmp    %rcx,%r8
  403735:	0f 82 f1 03 00 00    	jb     403b2c <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x7fc>
    uptr chunk_idx;
  };

  Header *GetHeader(uptr p) {
    CHECK(IsAligned(p, page_size_));
    return reinterpret_cast<Header*>(p - page_size_);
  40373b:	4d 89 e5             	mov    %r12,%r13
  40373e:	49 29 d5             	sub    %rdx,%r13
#endif
}
#endif

INLINE uptr MostSignificantSetBitIndex(uptr x) {
  CHECK_NE(x, 0U);
  403741:	48 85 ed             	test   %rbp,%rbp
    CHECK(IsAligned(res, alignment));
    CHECK(IsAligned(res, page_size_));
    CHECK_GE(res + size, map_beg);
    CHECK_LE(res + size, map_end);
    Header *h = GetHeader(res);
    h->size = size;
  403744:	49 89 5d 10          	mov    %rbx,0x10(%r13)
    h->map_beg = map_beg;
  403748:	49 89 45 00          	mov    %rax,0x0(%r13)
    h->map_size = map_size;
  40374c:	49 89 6d 08          	mov    %rbp,0x8(%r13)
  403750:	0f 84 cf 03 00 00    	je     403b25 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x7f5>
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  403756:	48 0f bd c5          	bsr    %rbp,%rax
  40375a:	bb 3f 00 00 00       	mov    $0x3f,%ebx
  40375f:	48 83 f0 3f          	xor    $0x3f,%rax
  403763:	29 c3                	sub    %eax,%ebx
  403765:	48 63 db             	movslq %ebx,%rbx
    uptr size_log = MostSignificantSetBitIndex(map_size);
    CHECK_LT(size_log, ARRAY_SIZE(stats.by_size_log));
  403768:	48 83 fb 3f          	cmp    $0x3f,%rbx
  40376c:	0f 87 92 03 00 00    	ja     403b04 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x7d4>
  403772:	b8 01 00 00 00       	mov    $0x1,%eax
  403777:	86 05 54 bf 26 00    	xchg   %al,0x26bf54(%rip)        # 66f6d1 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f91>
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  40377d:	84 c0                	test   %al,%al
  40377f:	74 0c                	je     40378d <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x45d>
      return;
    LockSlow();
  403781:	48 8d 3d 49 bf 26 00 	lea    0x26bf49(%rip),%rdi        # 66f6d1 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f91>
  403788:	e8 c3 0d 00 00       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
    {
      SpinMutexLock l(&mutex_);
      uptr idx = n_chunks_++;
  40378d:	48 8b 0d fc bc 26 00 	mov    0x26bcfc(%rip),%rcx        # 66f490 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d50>
      chunks_sorted_ = false;
  403794:	c6 05 0d bd 26 00 00 	movb   $0x0,0x26bd0d(%rip)        # 66f4a8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d68>
    h->map_size = map_size;
    uptr size_log = MostSignificantSetBitIndex(map_size);
    CHECK_LT(size_log, ARRAY_SIZE(stats.by_size_log));
    {
      SpinMutexLock l(&mutex_);
      uptr idx = n_chunks_++;
  40379b:	48 8d 51 01          	lea    0x1(%rcx),%rdx
      chunks_sorted_ = false;
      CHECK_LT(idx, kMaxNumChunks);
  40379f:	48 81 f9 ff ff 03 00 	cmp    $0x3ffff,%rcx
    h->map_size = map_size;
    uptr size_log = MostSignificantSetBitIndex(map_size);
    CHECK_LT(size_log, ARRAY_SIZE(stats.by_size_log));
    {
      SpinMutexLock l(&mutex_);
      uptr idx = n_chunks_++;
  4037a6:	48 89 15 e3 bc 26 00 	mov    %rdx,0x26bce3(%rip)        # 66f490 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d50>
      chunks_sorted_ = false;
      CHECK_LT(idx, kMaxNumChunks);
  4037ad:	0f 87 97 04 00 00    	ja     403c4a <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x91a>
      h->chunk_idx = idx;
      chunks_[idx] = h;
  4037b3:	48 8d 15 86 af 02 00 	lea    0x2af86(%rip),%rdx        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
    {
      SpinMutexLock l(&mutex_);
      uptr idx = n_chunks_++;
      chunks_sorted_ = false;
      CHECK_LT(idx, kMaxNumChunks);
      h->chunk_idx = idx;
  4037ba:	49 89 4d 18          	mov    %rcx,0x18(%r13)
      chunks_[idx] = h;
      stats.n_allocs++;
      stats.currently_allocated += map_size;
  4037be:	48 89 e8             	mov    %rbp,%rax
  4037c1:	48 03 05 f8 bc 26 00 	add    0x26bcf8(%rip),%rax        # 66f4c0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d80>
      uptr idx = n_chunks_++;
      chunks_sorted_ = false;
      CHECK_LT(idx, kMaxNumChunks);
      h->chunk_idx = idx;
      chunks_[idx] = h;
      stats.n_allocs++;
  4037c8:	48 83 05 e0 bc 26 00 	addq   $0x1,0x26bce0(%rip)        # 66f4b0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d70>
  4037cf:	01 
      SpinMutexLock l(&mutex_);
      uptr idx = n_chunks_++;
      chunks_sorted_ = false;
      CHECK_LT(idx, kMaxNumChunks);
      h->chunk_idx = idx;
      chunks_[idx] = h;
  4037d0:	4c 89 ac ca 50 0d 04 	mov    %r13,0x40d50(%rdx,%rcx,8)
  4037d7:	00 
  4037d8:	48 8b 0d e9 bc 26 00 	mov    0x26bce9(%rip),%rcx        # 66f4c8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d88>
  4037df:	48 39 c8             	cmp    %rcx,%rax
      stats.n_allocs++;
      stats.currently_allocated += map_size;
  4037e2:	48 89 05 d7 bc 26 00 	mov    %rax,0x26bcd7(%rip)        # 66f4c0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d80>
  4037e9:	48 0f 42 c1          	cmovb  %rcx,%rax
      stats.max_allocated = Max(stats.max_allocated, stats.currently_allocated);
      stats.by_size_log[size_log]++;
  4037ed:	48 83 84 da 90 0d 24 	addq   $0x1,0x240d90(%rdx,%rbx,8)
  4037f4:	00 01 
      CHECK_LT(idx, kMaxNumChunks);
      h->chunk_idx = idx;
      chunks_[idx] = h;
      stats.n_allocs++;
      stats.currently_allocated += map_size;
      stats.max_allocated = Max(stats.max_allocated, stats.currently_allocated);
  4037f6:	48 89 05 cb bc 26 00 	mov    %rax,0x26bccb(%rip)        # 66f4c8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d88>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  4037fd:	48 8b 05 e4 be 26 00 	mov    0x26bee4(%rip),%rax        # 66f6e8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fa8>
    internal_memset(this, 0, sizeof(*this));
  }
  void InitLinkerInitialized() {}

  void Add(AllocatorStat i, uptr v) {
    v += atomic_load(&stats_[i], memory_order_relaxed);
  403804:	48 01 e8             	add    %rbp,%rax
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  403807:	48 89 05 da be 26 00 	mov    %rax,0x26beda(%rip)        # 66f6e8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fa8>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  40380e:	48 8b 05 db be 26 00 	mov    0x26bedb(%rip),%rax        # 66f6f0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fb0>
  403815:	48 01 c5             	add    %rax,%rbp
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  403818:	48 89 2d d1 be 26 00 	mov    %rbp,0x26bed1(%rip)        # 66f6f0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fb0>
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  40381f:	c6 05 ab be 26 00 00 	movb   $0x0,0x26beab(%rip)        # 66f6d1 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f91>
      stats.max_allocated = Max(stats.max_allocated, stats.currently_allocated);
      stats.by_size_log[size_log]++;
      stat->Add(AllocatorStatAllocated, map_size);
      stat->Add(AllocatorStatMapped, map_size);
    }
    return reinterpret_cast<void*>(res);
  403826:	4c 89 e0             	mov    %r12,%rax
  403829:	e9 8e fb ff ff       	jmpq   4033bc <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x8c>
      return ReturnNullOrDie();
    if (alignment > 8)
      size = RoundUpTo(size, alignment);
    void *res;
    bool from_primary = primary_.CanAllocate(size, alignment);
    if (from_primary)
  40382e:	48 81 fb 00 00 02 00 	cmp    $0x20000,%rbx
  403835:	0f 87 8f 00 00 00    	ja     4038ca <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x59a>
  40383b:	48 8d 55 17          	lea    0x17(%rbp),%rdx
  40383f:	48 c1 ea 04          	shr    $0x4,%rdx
    uptr t = kMidSize << (class_id >> S);
    return t + (t >> S) * (class_id & M);
  }

  static uptr ClassID(uptr size) {
    if (size <= kMidSize)
  403843:	48 81 fb 00 01 00 00 	cmp    $0x100,%rbx
  40384a:	76 41                	jbe    40388d <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x55d>
  40384c:	48 0f bd d3          	bsr    %rbx,%rdx
  403850:	b8 3f 00 00 00       	mov    $0x3f,%eax
  403855:	48 83 f2 3f          	xor    $0x3f,%rdx
  403859:	29 d0                	sub    %edx,%eax
      return (size + kMinSize - 1) >> kMinSizeLog;
    if (size > kMaxSize) return 0;
    uptr l = MostSignificantSetBitIndex(size);
    uptr hbits = (size >> (l - S)) & M;
  40385b:	48 89 da             	mov    %rbx,%rdx
  40385e:	8d 48 fe             	lea    -0x2(%rax),%ecx
  403861:	48 63 f0             	movslq %eax,%rsi
  403864:	48 d3 ea             	shr    %cl,%rdx
  403867:	83 e2 03             	and    $0x3,%edx
    uptr lbits = size & ((1 << (l - S)) - 1);
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  40386a:	48 8d 54 b2 f0       	lea    -0x10(%rdx,%rsi,4),%rdx
    if (size <= kMidSize)
      return (size + kMinSize - 1) >> kMinSizeLog;
    if (size > kMaxSize) return 0;
    uptr l = MostSignificantSetBitIndex(size);
    uptr hbits = (size >> (l - S)) & M;
    uptr lbits = size & ((1 << (l - S)) - 1);
  40386f:	be 01 00 00 00       	mov    $0x1,%esi
  403874:	d3 e6                	shl    %cl,%esi
  403876:	8d 46 ff             	lea    -0x1(%rsi),%eax
  403879:	48 98                	cltq   
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  40387b:	48 85 d8             	test   %rbx,%rax
  40387e:	0f 95 c0             	setne  %al
  403881:	0f b6 c0             	movzbl %al,%eax
    if (s)
      s->Unregister(&stats_);
  }

  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {
    CHECK_NE(class_id, 0UL);
  403884:	48 01 c2             	add    %rax,%rdx
  403887:	0f 84 9c 03 00 00    	je     403c29 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x8f9>
    CHECK_LT(class_id, kNumClasses);
  40388d:	48 83 fa 34          	cmp    $0x34,%rdx
  403891:	0f 87 02 03 00 00    	ja     403b99 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x869>
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  403897:	48 83 fa 10          	cmp    $0x10,%rdx
  40389b:	0f 86 5b fd ff ff    	jbe    4035fc <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x2cc>
      return kMinSize * class_id;
    class_id -= kMidClass;
  4038a1:	48 8d 72 f0          	lea    -0x10(%rdx),%rsi
    uptr t = kMidSize << (class_id >> S);
  4038a5:	b8 00 01 00 00       	mov    $0x100,%eax
  4038aa:	48 89 f1             	mov    %rsi,%rcx
    return t + (t >> S) * (class_id & M);
  4038ad:	83 e6 03             	and    $0x3,%esi

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  4038b0:	48 c1 e9 02          	shr    $0x2,%rcx
  4038b4:	48 d3 e0             	shl    %cl,%rax
    return t + (t >> S) * (class_id & M);
  4038b7:	48 89 c1             	mov    %rax,%rcx
  4038ba:	48 c1 e9 02          	shr    $0x2,%rcx
  4038be:	48 0f af ce          	imul   %rsi,%rcx
  4038c2:	48 01 c8             	add    %rcx,%rax
  4038c5:	e9 39 fd ff ff       	jmpq   403603 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x2d3>
    CHECK(IsAligned((uptr)h, page_size_));
    return reinterpret_cast<void*>(reinterpret_cast<uptr>(h) + page_size_);
  }

  uptr RoundUpMapSize(uptr size) {
    return RoundUpTo(size, page_size_) + page_size_;
  4038ca:	48 8b 05 b7 bb 06 00 	mov    0x6bbb7(%rip),%rax        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
#endif
  return up;
}

INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
  4038d1:	48 8d 68 ff          	lea    -0x1(%rax),%rbp
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  4038d5:	48 85 c5             	test   %rax,%rbp
  4038d8:	0f 85 f0 02 00 00    	jne    403bce <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x89e>
  return (size + boundary - 1) & ~(boundary - 1);
  4038de:	48 89 c2             	mov    %rax,%rdx
  4038e1:	48 01 dd             	add    %rbx,%rbp
  4038e4:	48 f7 da             	neg    %rdx
  4038e7:	48 21 d5             	and    %rdx,%rbp
  4038ea:	48 01 c5             	add    %rax,%rbp

  void *Allocate(AllocatorStats *stat, uptr size, uptr alignment) {
    CHECK(IsPowerOfTwo(alignment));
    uptr map_size = RoundUpMapSize(size);
    if (alignment > page_size_)
      map_size += alignment;
  4038ed:	48 83 f8 07          	cmp    $0x7,%rax
  4038f1:	48 8d 55 08          	lea    0x8(%rbp),%rdx
  4038f5:	48 0f 46 ea          	cmovbe %rdx,%rbp
    // Overflow.
    if (map_size < size)
  4038f9:	48 39 eb             	cmp    %rbp,%rbx
  4038fc:	0f 86 ac 00 00 00    	jbe    4039ae <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x67e>
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
      __asm__ __volatile__("" ::: "memory");
    } else if (mo == memory_order_acquire) {
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  403902:	0f b6 05 c7 bd 26 00 	movzbl 0x26bdc7(%rip),%eax        # 66f6d0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f90>
    }
    return reinterpret_cast<void*>(res);
  }

  void *ReturnNullOrDie() {
    if (atomic_load(&may_return_null_, memory_order_acquire))
  403909:	84 c0                	test   %al,%al
  40390b:	0f 85 63 fd ff ff    	jne    403674 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x344>
  403911:	e9 b1 fc ff ff       	jmpq   4035c7 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x297>
  403916:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40391d:	00 00 00 
    page_size_ = GetPageSizeCached();
    atomic_store(&may_return_null_, may_return_null, memory_order_relaxed);
  }

  void Init(bool may_return_null) {
    internal_memset(this, 0, sizeof(*this));
  403920:	48 8d 3d 61 bb 06 00 	lea    0x6bb61(%rip),%rdi        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
  403927:	31 f6                	xor    %esi,%esi
  403929:	ba 50 02 20 00       	mov    $0x200250,%edx
  40392e:	e8 0d 6a 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).
template <class MapUnmapCallback = NoOpMapUnmapCallback>
class LargeMmapAllocator {
 public:
  void InitLinkerInitialized(bool may_return_null) {
    page_size_ = GetPageSizeCached();
  403933:	e8 78 17 00 00       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
  void InitLinkerInitialized() {
    next_ = this;
    prev_ = this;
  }
  void Init() {
    internal_memset(this, 0, sizeof(*this));
  403938:	48 8d 3d 99 bd 26 00 	lea    0x26bd99(%rip),%rdi        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
  40393f:	31 f6                	xor    %esi,%esi
  403941:	ba 28 00 00 00       	mov    $0x28,%edx
// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).
template <class MapUnmapCallback = NoOpMapUnmapCallback>
class LargeMmapAllocator {
 public:
  void InitLinkerInitialized(bool may_return_null) {
    page_size_ = GetPageSizeCached();
  403946:	48 89 05 3b bb 06 00 	mov    %rax,0x6bb3b(%rip)        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  40394d:	c6 05 7c bd 26 00 00 	movb   $0x0,0x26bd7c(%rip)        # 66f6d0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f90>
  void InitLinkerInitialized() {
    next_ = this;
    prev_ = this;
  }
  void Init() {
    internal_memset(this, 0, sizeof(*this));
  403954:	e8 e7 69 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>

// Global stats, used for aggregation and querying.
class AllocatorGlobalStats : public AllocatorStats {
 public:
  void InitLinkerInitialized() {
    next_ = this;
  403959:	48 8d 05 78 bd 26 00 	lea    0x26bd78(%rip),%rax        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
// Setting and getting values from multiple threads is safe w/o extra locking.
template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>
class TwoLevelByteMap {
 public:
  void TestOnlyInit() {
    internal_memset(map1_, 0, sizeof(map1_));
  403960:	48 8d 3d d9 ad 02 00 	lea    0x2add9(%rip),%rdi        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
  403967:	31 f6                	xor    %esi,%esi
  403969:	ba 00 00 04 00       	mov    $0x40000,%edx

// Global stats, used for aggregation and querying.
class AllocatorGlobalStats : public AllocatorStats {
 public:
  void InitLinkerInitialized() {
    next_ = this;
  40396e:	48 89 05 63 bd 26 00 	mov    %rax,0x26bd63(%rip)        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
    prev_ = this;
  403975:	48 89 05 64 bd 26 00 	mov    %rax,0x26bd64(%rip)        # 66f6e0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fa0>
// Setting and getting values from multiple threads is safe w/o extra locking.
template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>
class TwoLevelByteMap {
 public:
  void TestOnlyInit() {
    internal_memset(map1_, 0, sizeof(map1_));
  40397c:	e8 bf 69 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
      SizeClassMap, kRegionSizeLog, ByteMap, MapUnmapCallback> ThisT;
  typedef SizeClassAllocatorLocalCache<ThisT> AllocatorCache;

  void Init() {
    possible_regions.TestOnlyInit();
    internal_memset(size_class_info_array, 0, sizeof(size_class_info_array));
  403981:	48 8d 3d c0 ad 06 00 	lea    0x6adc0(%rip),%rdi        # 46e748 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40008>
  403988:	ba 40 0d 00 00       	mov    $0xd40,%edx
  40398d:	31 f6                	xor    %esi,%esi
  40398f:	c6 05 aa ad 06 00 00 	movb   $0x0,0x6adaa(%rip)        # 46e740 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40000>
  403996:	e8 a5 69 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  40399b:	c6 05 5e bd 26 00 00 	movb   $0x0,0x26bd5e(%rip)        # 66f700 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fc0>
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  4039a2:	c6 05 68 ad 02 00 01 	movb   $0x1,0x2ad68(%rip)        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
      __asm__ __volatile__("" ::: "memory");
  4039a9:	e9 04 fd ff ff       	jmpq   4036b2 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x382>
      map_size += alignment;
    // Overflow.
    if (map_size < size)
      return ReturnNullOrDie();
    uptr map_beg = reinterpret_cast<uptr>(
        MmapOrDie(map_size, "LargeMmapAllocator"));
  4039ae:	48 8d 35 b2 4a 01 00 	lea    0x14ab2(%rip),%rsi        # 418467 <.LC20>
  4039b5:	48 89 ef             	mov    %rbp,%rdi
  4039b8:	e8 e3 89 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
    CHECK(IsAligned(map_beg, page_size_));
  4039bd:	48 8b 15 c4 ba 06 00 	mov    0x6bac4(%rip),%rdx        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
INLINE uptr RoundDownTo(uptr x, uptr boundary) {
  return x & ~(boundary - 1);
}

INLINE bool IsAligned(uptr a, uptr alignment) {
  return (a & (alignment - 1)) == 0;
  4039c4:	48 8d 4a ff          	lea    -0x1(%rdx),%rcx
  4039c8:	48 85 c8             	test   %rcx,%rax
  4039cb:	0f 85 ab 01 00 00    	jne    403b7c <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x84c>
    MapUnmapCallback().OnMap(map_beg, map_size);
    uptr map_end = map_beg + map_size;
    uptr res = map_beg + page_size_;
  4039d1:	4c 8d 24 10          	lea    (%rax,%rdx,1),%r12
      return ReturnNullOrDie();
    uptr map_beg = reinterpret_cast<uptr>(
        MmapOrDie(map_size, "LargeMmapAllocator"));
    CHECK(IsAligned(map_beg, page_size_));
    MapUnmapCallback().OnMap(map_beg, map_size);
    uptr map_end = map_beg + map_size;
  4039d5:	4c 8d 04 28          	lea    (%rax,%rbp,1),%r8
    uptr res = map_beg + page_size_;
    if (res & (alignment - 1))  // Align.
  4039d9:	4c 89 e6             	mov    %r12,%rsi
  4039dc:	83 e6 07             	and    $0x7,%esi
  4039df:	74 11                	je     4039f2 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x6c2>
      res += alignment - (res & (alignment - 1));
  4039e1:	49 83 c4 08          	add    $0x8,%r12
  4039e5:	49 29 f4             	sub    %rsi,%r12
    CHECK(IsAligned(res, alignment));
  4039e8:	41 f6 c4 07          	test   $0x7,%r12b
  4039ec:	0f 85 f9 01 00 00    	jne    403beb <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x8bb>
    CHECK(IsAligned(res, page_size_));
  4039f2:	49 85 cc             	test   %rcx,%r12
  4039f5:	0f 85 64 01 00 00    	jne    403b5f <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x82f>
    CHECK_GE(res + size, map_beg);
  4039fb:	49 8d 0c 1c          	lea    (%r12,%rbx,1),%rcx
  4039ff:	48 39 c8             	cmp    %rcx,%rax
  403a02:	0f 87 3c 01 00 00    	ja     403b44 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x814>
    CHECK_LE(res + size, map_end);
  403a08:	49 39 c8             	cmp    %rcx,%r8
  403a0b:	0f 82 1b 01 00 00    	jb     403b2c <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x7fc>
    uptr chunk_idx;
  };

  Header *GetHeader(uptr p) {
    CHECK(IsAligned(p, page_size_));
    return reinterpret_cast<Header*>(p - page_size_);
  403a11:	4d 89 e5             	mov    %r12,%r13
  403a14:	49 29 d5             	sub    %rdx,%r13
#endif
}
#endif

INLINE uptr MostSignificantSetBitIndex(uptr x) {
  CHECK_NE(x, 0U);
  403a17:	48 85 ed             	test   %rbp,%rbp
    CHECK(IsAligned(res, alignment));
    CHECK(IsAligned(res, page_size_));
    CHECK_GE(res + size, map_beg);
    CHECK_LE(res + size, map_end);
    Header *h = GetHeader(res);
    h->size = size;
  403a1a:	49 89 5d 10          	mov    %rbx,0x10(%r13)
    h->map_beg = map_beg;
  403a1e:	49 89 45 00          	mov    %rax,0x0(%r13)
    h->map_size = map_size;
  403a22:	49 89 6d 08          	mov    %rbp,0x8(%r13)
  403a26:	0f 84 f9 00 00 00    	je     403b25 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x7f5>
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  403a2c:	48 0f bd c5          	bsr    %rbp,%rax
  403a30:	bb 3f 00 00 00       	mov    $0x3f,%ebx
  403a35:	48 83 f0 3f          	xor    $0x3f,%rax
  403a39:	29 c3                	sub    %eax,%ebx
  403a3b:	48 63 db             	movslq %ebx,%rbx
    uptr size_log = MostSignificantSetBitIndex(map_size);
    CHECK_LT(size_log, ARRAY_SIZE(stats.by_size_log));
  403a3e:	48 83 fb 3f          	cmp    $0x3f,%rbx
  403a42:	0f 87 bc 00 00 00    	ja     403b04 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x7d4>
  403a48:	b8 01 00 00 00       	mov    $0x1,%eax
  403a4d:	86 05 7e bc 26 00    	xchg   %al,0x26bc7e(%rip)        # 66f6d1 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f91>
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  403a53:	84 c0                	test   %al,%al
  403a55:	74 0c                	je     403a63 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x733>
      return;
    LockSlow();
  403a57:	48 8d 3d 73 bc 26 00 	lea    0x26bc73(%rip),%rdi        # 66f6d1 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f91>
  403a5e:	e8 ed 0a 00 00       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
    {
      SpinMutexLock l(&mutex_);
      uptr idx = n_chunks_++;
  403a63:	48 8b 0d 26 ba 26 00 	mov    0x26ba26(%rip),%rcx        # 66f490 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d50>
      chunks_sorted_ = false;
  403a6a:	c6 05 37 ba 26 00 00 	movb   $0x0,0x26ba37(%rip)        # 66f4a8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d68>
    h->map_size = map_size;
    uptr size_log = MostSignificantSetBitIndex(map_size);
    CHECK_LT(size_log, ARRAY_SIZE(stats.by_size_log));
    {
      SpinMutexLock l(&mutex_);
      uptr idx = n_chunks_++;
  403a71:	48 8d 51 01          	lea    0x1(%rcx),%rdx
      chunks_sorted_ = false;
      CHECK_LT(idx, kMaxNumChunks);
  403a75:	48 81 f9 ff ff 03 00 	cmp    $0x3ffff,%rcx
    h->map_size = map_size;
    uptr size_log = MostSignificantSetBitIndex(map_size);
    CHECK_LT(size_log, ARRAY_SIZE(stats.by_size_log));
    {
      SpinMutexLock l(&mutex_);
      uptr idx = n_chunks_++;
  403a7c:	48 89 15 0d ba 26 00 	mov    %rdx,0x26ba0d(%rip)        # 66f490 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d50>
      chunks_sorted_ = false;
      CHECK_LT(idx, kMaxNumChunks);
  403a83:	0f 87 c1 01 00 00    	ja     403c4a <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x91a>
      h->chunk_idx = idx;
      chunks_[idx] = h;
  403a89:	48 8d 15 b0 ac 02 00 	lea    0x2acb0(%rip),%rdx        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
    {
      SpinMutexLock l(&mutex_);
      uptr idx = n_chunks_++;
      chunks_sorted_ = false;
      CHECK_LT(idx, kMaxNumChunks);
      h->chunk_idx = idx;
  403a90:	49 89 4d 18          	mov    %rcx,0x18(%r13)
      chunks_[idx] = h;
      stats.n_allocs++;
      stats.currently_allocated += map_size;
  403a94:	48 89 e8             	mov    %rbp,%rax
  403a97:	48 03 05 22 ba 26 00 	add    0x26ba22(%rip),%rax        # 66f4c0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d80>
      uptr idx = n_chunks_++;
      chunks_sorted_ = false;
      CHECK_LT(idx, kMaxNumChunks);
      h->chunk_idx = idx;
      chunks_[idx] = h;
      stats.n_allocs++;
  403a9e:	48 83 05 0a ba 26 00 	addq   $0x1,0x26ba0a(%rip)        # 66f4b0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d70>
  403aa5:	01 
      SpinMutexLock l(&mutex_);
      uptr idx = n_chunks_++;
      chunks_sorted_ = false;
      CHECK_LT(idx, kMaxNumChunks);
      h->chunk_idx = idx;
      chunks_[idx] = h;
  403aa6:	4c 89 ac ca 50 0d 04 	mov    %r13,0x40d50(%rdx,%rcx,8)
  403aad:	00 
  403aae:	48 8b 0d 13 ba 26 00 	mov    0x26ba13(%rip),%rcx        # 66f4c8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d88>
  403ab5:	48 39 c8             	cmp    %rcx,%rax
      stats.n_allocs++;
      stats.currently_allocated += map_size;
  403ab8:	48 89 05 01 ba 26 00 	mov    %rax,0x26ba01(%rip)        # 66f4c0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d80>
  403abf:	48 0f 42 c1          	cmovb  %rcx,%rax
      stats.max_allocated = Max(stats.max_allocated, stats.currently_allocated);
      stats.by_size_log[size_log]++;
  403ac3:	48 83 84 da 90 0d 24 	addq   $0x1,0x240d90(%rdx,%rbx,8)
  403aca:	00 01 
      CHECK_LT(idx, kMaxNumChunks);
      h->chunk_idx = idx;
      chunks_[idx] = h;
      stats.n_allocs++;
      stats.currently_allocated += map_size;
      stats.max_allocated = Max(stats.max_allocated, stats.currently_allocated);
  403acc:	48 89 05 f5 b9 26 00 	mov    %rax,0x26b9f5(%rip)        # 66f4c8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d88>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  403ad3:	48 8b 05 0e bc 26 00 	mov    0x26bc0e(%rip),%rax        # 66f6e8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fa8>
    internal_memset(this, 0, sizeof(*this));
  }
  void InitLinkerInitialized() {}

  void Add(AllocatorStat i, uptr v) {
    v += atomic_load(&stats_[i], memory_order_relaxed);
  403ada:	48 01 e8             	add    %rbp,%rax
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  403add:	48 89 05 04 bc 26 00 	mov    %rax,0x26bc04(%rip)        # 66f6e8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fa8>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  403ae4:	48 8b 05 05 bc 26 00 	mov    0x26bc05(%rip),%rax        # 66f6f0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fb0>
  403aeb:	48 01 c5             	add    %rax,%rbp
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  403aee:	48 89 2d fb bb 26 00 	mov    %rbp,0x26bbfb(%rip)        # 66f6f0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fb0>
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  403af5:	c6 05 d5 bb 26 00 00 	movb   $0x0,0x26bbd5(%rip)        # 66f6d1 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f91>
      stats.max_allocated = Max(stats.max_allocated, stats.currently_allocated);
      stats.by_size_log[size_log]++;
      stat->Add(AllocatorStatAllocated, map_size);
      stat->Add(AllocatorStatMapped, map_size);
    }
    return reinterpret_cast<void*>(res);
  403afc:	4c 89 e0             	mov    %r12,%rax
  403aff:	e9 72 fb ff ff       	jmpq   403676 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x346>
    Header *h = GetHeader(res);
    h->size = size;
    h->map_beg = map_beg;
    h->map_size = map_size;
    uptr size_log = MostSignificantSetBitIndex(map_size);
    CHECK_LT(size_log, ARRAY_SIZE(stats.by_size_log));
  403b04:	48 8d 15 9d 18 01 00 	lea    0x1189d(%rip),%rdx        # 4153a8 <.LC26>
  403b0b:	48 8d 3d 6e 15 01 00 	lea    0x1156e(%rip),%rdi        # 415080 <.LC3>
  403b12:	41 b8 40 00 00 00    	mov    $0x40,%r8d
  403b18:	48 89 d9             	mov    %rbx,%rcx
  403b1b:	be 19 04 00 00       	mov    $0x419,%esi
  403b20:	e8 cb 18 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  403b25:	31 ff                	xor    %edi,%edi
  403b27:	e8 d4 e8 ff ff       	callq  402400 <_ZN11__sanitizer26MostSignificantSetBitIndexEm.part.0>
    if (res & (alignment - 1))  // Align.
      res += alignment - (res & (alignment - 1));
    CHECK(IsAligned(res, alignment));
    CHECK(IsAligned(res, page_size_));
    CHECK_GE(res + size, map_beg);
    CHECK_LE(res + size, map_end);
  403b2c:	48 8d 15 65 49 01 00 	lea    0x14965(%rip),%rdx        # 418498 <.LC25>
  403b33:	48 8d 3d 46 15 01 00 	lea    0x11546(%rip),%rdi        # 415080 <.LC3>
  403b3a:	be 13 04 00 00       	mov    $0x413,%esi
  403b3f:	e8 ac 18 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    uptr res = map_beg + page_size_;
    if (res & (alignment - 1))  // Align.
      res += alignment - (res & (alignment - 1));
    CHECK(IsAligned(res, alignment));
    CHECK(IsAligned(res, page_size_));
    CHECK_GE(res + size, map_beg);
  403b44:	48 8d 15 2f 49 01 00 	lea    0x1492f(%rip),%rdx        # 41847a <.LC24>
  403b4b:	48 8d 3d 2e 15 01 00 	lea    0x1152e(%rip),%rdi        # 415080 <.LC3>
  403b52:	49 89 c0             	mov    %rax,%r8
  403b55:	be 12 04 00 00       	mov    $0x412,%esi
  403b5a:	e8 91 18 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    uptr map_end = map_beg + map_size;
    uptr res = map_beg + page_size_;
    if (res & (alignment - 1))  // Align.
      res += alignment - (res & (alignment - 1));
    CHECK(IsAligned(res, alignment));
    CHECK(IsAligned(res, page_size_));
  403b5f:	48 8d 15 1a 18 01 00 	lea    0x1181a(%rip),%rdx        # 415380 <.LC23>
  403b66:	48 8d 3d 13 15 01 00 	lea    0x11513(%rip),%rdi        # 415080 <.LC3>
  403b6d:	45 31 c0             	xor    %r8d,%r8d
  403b70:	31 c9                	xor    %ecx,%ecx
  403b72:	be 11 04 00 00       	mov    $0x411,%esi
  403b77:	e8 74 18 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    // Overflow.
    if (map_size < size)
      return ReturnNullOrDie();
    uptr map_beg = reinterpret_cast<uptr>(
        MmapOrDie(map_size, "LargeMmapAllocator"));
    CHECK(IsAligned(map_beg, page_size_));
  403b7c:	48 8d 15 a5 17 01 00 	lea    0x117a5(%rip),%rdx        # 415328 <.LC21>
  403b83:	48 8d 3d f6 14 01 00 	lea    0x114f6(%rip),%rdi        # 415080 <.LC3>
  403b8a:	45 31 c0             	xor    %r8d,%r8d
  403b8d:	31 c9                	xor    %ecx,%ecx
  403b8f:	be 0a 04 00 00       	mov    $0x40a,%esi
  403b94:	e8 57 18 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
      s->Unregister(&stats_);
  }

  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {
    CHECK_NE(class_id, 0UL);
    CHECK_LT(class_id, kNumClasses);
  403b99:	48 89 d1             	mov    %rdx,%rcx
  403b9c:	48 8d 3d dd 14 01 00 	lea    0x114dd(%rip),%rdi        # 415080 <.LC3>
  403ba3:	48 8d 15 4e 15 01 00 	lea    0x1154e(%rip),%rdx        # 4150f8 <.LC5>
  403baa:	41 b8 35 00 00 00    	mov    $0x35,%r8d
  403bb0:	be 9c 03 00 00       	mov    $0x39c,%esi
  403bb5:	e8 36 18 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    stats_.Add(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
    if (UNLIKELY(c->count == 0))
      Refill(allocator, class_id);
  403bba:	48 8d 35 7f ab 02 00 	lea    0x2ab7f(%rip),%rsi        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
  403bc1:	e8 8a 0f 00 00       	callq  404b50 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m>
  403bc6:	48 8b 13             	mov    (%rbx),%rdx
  403bc9:	e9 70 fa ff ff       	jmpq   40363e <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x30e>
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  403bce:	48 8d 15 2b 17 01 00 	lea    0x1172b(%rip),%rdx        # 415300 <.LC19>
  403bd5:	48 8d 3d 34 14 01 00 	lea    0x11434(%rip),%rdi        # 415010 <.LC1>
  403bdc:	45 31 c0             	xor    %r8d,%r8d
  403bdf:	31 c9                	xor    %ecx,%ecx
  403be1:	be a9 01 00 00       	mov    $0x1a9,%esi
  403be6:	e8 05 18 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    MapUnmapCallback().OnMap(map_beg, map_size);
    uptr map_end = map_beg + map_size;
    uptr res = map_beg + page_size_;
    if (res & (alignment - 1))  // Align.
      res += alignment - (res & (alignment - 1));
    CHECK(IsAligned(res, alignment));
  403beb:	48 8d 15 66 17 01 00 	lea    0x11766(%rip),%rdx        # 415358 <.LC22>
  403bf2:	48 8d 3d 87 14 01 00 	lea    0x11487(%rip),%rdi        # 415080 <.LC3>
  403bf9:	45 31 c0             	xor    %r8d,%r8d
  403bfc:	31 c9                	xor    %ecx,%ecx
  403bfe:	be 10 04 00 00       	mov    $0x410,%esi
  403c03:	e8 e8 17 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
      s->Unregister(&stats_);
  }

  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {
    CHECK_NE(class_id, 0UL);
    CHECK_LT(class_id, kNumClasses);
  403c08:	48 8d 15 e9 14 01 00 	lea    0x114e9(%rip),%rdx        # 4150f8 <.LC5>
  403c0f:	48 8d 3d 6a 14 01 00 	lea    0x1146a(%rip),%rdi        # 415080 <.LC3>
  403c16:	41 b8 35 00 00 00    	mov    $0x35,%r8d
  403c1c:	48 89 e9             	mov    %rbp,%rcx
  403c1f:	be 9c 03 00 00       	mov    $0x39c,%esi
  403c24:	e8 c7 17 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  403c29:	31 ff                	xor    %edi,%edi
  403c2b:	e8 12 e8 ff ff       	callq  402442 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE8AllocateEPS7_m.part.15>
    stats_.Add(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
    if (UNLIKELY(c->count == 0))
      Refill(allocator, class_id);
  403c30:	48 8d 35 09 ab 02 00 	lea    0x2ab09(%rip),%rsi        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
  403c37:	48 89 ea             	mov    %rbp,%rdx
  403c3a:	4c 89 e7             	mov    %r12,%rdi
  403c3d:	e8 0e 0f 00 00       	callq  404b50 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m>
  403c42:	48 8b 13             	mov    (%rbx),%rdx
  403c45:	e9 5f f7 ff ff       	jmpq   4033a9 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE+0x79>
    CHECK_LT(size_log, ARRAY_SIZE(stats.by_size_log));
    {
      SpinMutexLock l(&mutex_);
      uptr idx = n_chunks_++;
      chunks_sorted_ = false;
      CHECK_LT(idx, kMaxNumChunks);
  403c4a:	48 8d 15 65 48 01 00 	lea    0x14865(%rip),%rdx        # 4184b6 <.LC27>
  403c51:	48 8d 3d 28 14 01 00 	lea    0x11428(%rip),%rdi        # 415080 <.LC3>
  403c58:	41 b8 00 00 04 00    	mov    $0x40000,%r8d
  403c5e:	be 1e 04 00 00       	mov    $0x41e,%esi
  403c63:	e8 88 17 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  403c68:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  403c6f:	00 

0000000000403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>:
  ((u64*)p)[0] = kBlockMagic;
  return (char*)p + sizeof(u64);
}

void InternalFree(void *addr, InternalAllocatorCache *cache) {
  if (!addr)
  403c70:	48 85 ff             	test   %rdi,%rdi
  403c73:	0f 84 10 02 00 00    	je     403e89 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x219>
    return nullptr;
  ((u64*)p)[0] = kBlockMagic;
  return (char*)p + sizeof(u64);
}

void InternalFree(void *addr, InternalAllocatorCache *cache) {
  403c79:	41 55                	push   %r13
  if (!addr)
    return;
  addr = (char*)addr - sizeof(u64);
  CHECK_EQ(kBlockMagic, ((u64*)addr)[0]);
  403c7b:	48 b9 41 c0 eb bc 3a 	movabs $0x6a6cb03abcebc041,%rcx
  403c82:	b0 6c 6a 
    return nullptr;
  ((u64*)p)[0] = kBlockMagic;
  return (char*)p + sizeof(u64);
}

void InternalFree(void *addr, InternalAllocatorCache *cache) {
  403c85:	41 54                	push   %r12
  403c87:	55                   	push   %rbp
  403c88:	53                   	push   %rbx
  if (!addr)
    return;
  addr = (char*)addr - sizeof(u64);
  403c89:	48 8d 5f f8          	lea    -0x8(%rdi),%rbx
    return nullptr;
  ((u64*)p)[0] = kBlockMagic;
  return (char*)p + sizeof(u64);
}

void InternalFree(void *addr, InternalAllocatorCache *cache) {
  403c8d:	48 83 ec 08          	sub    $0x8,%rsp
  if (!addr)
    return;
  addr = (char*)addr - sizeof(u64);
  CHECK_EQ(kBlockMagic, ((u64*)addr)[0]);
  403c91:	4c 8b 47 f8          	mov    -0x8(%rdi),%r8
  403c95:	49 39 c8             	cmp    %rcx,%r8
  403c98:	0f 85 2f 07 00 00    	jne    4043cd <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x75d>
  }
  return internal_allocator()->Allocate(cache, size, 8, false);
}

static void RawInternalFree(void *ptr, InternalAllocatorCache *cache) {
  if (!cache) {
  403c9e:	48 85 f6             	test   %rsi,%rsi
  403ca1:	48 89 f5             	mov    %rsi,%rbp
void InternalFree(void *addr, InternalAllocatorCache *cache) {
  if (!addr)
    return;
  addr = (char*)addr - sizeof(u64);
  CHECK_EQ(kBlockMagic, ((u64*)addr)[0]);
  ((u64*)addr)[0] = 0;
  403ca4:	48 c7 47 f8 00 00 00 	movq   $0x0,-0x8(%rdi)
  403cab:	00 
  }
  return internal_allocator()->Allocate(cache, size, 8, false);
}

static void RawInternalFree(void *ptr, InternalAllocatorCache *cache) {
  if (!cache) {
  403cac:	0f 84 7e 03 00 00    	je     404030 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x3c0>
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
      __asm__ __volatile__("" ::: "memory");
    } else if (mo == memory_order_acquire) {
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  403cb2:	0f b6 05 58 aa 02 00 	movzbl 0x2aa58(%rip),%eax        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
static StaticSpinMutex internal_allocator_cache_mu;

InternalAllocator *internal_allocator() {
  InternalAllocator *internal_allocator_instance =
      reinterpret_cast<InternalAllocator *>(&internal_alloc_placeholder);
  if (atomic_load(&internal_allocator_initialized, memory_order_acquire) == 0) {
  403cb9:	84 c0                	test   %al,%al
  403cbb:	0f 84 cf 01 00 00    	je     403e90 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x220>
    atomic_store(&rss_limit_is_exceeded_, rss_limit_is_exceeded,
                 memory_order_release);
  }

  void Deallocate(AllocatorCache *cache, void *p) {
    if (!p) return;
  403cc1:	48 85 db             	test   %rbx,%rbx
  403cc4:	0f 84 b5 01 00 00    	je     403e7f <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x20f>
    char padding[kCacheLineSize - sizeof(uptr) - sizeof(IntrusiveList<Batch>)];
  };
  COMPILER_CHECK(sizeof(SizeClassInfo) == kCacheLineSize);

  uptr ComputeRegionId(uptr mem) {
    uptr res = mem >> kRegionSizeLog;
  403cca:	48 89 d9             	mov    %rbx,%rcx
  403ccd:	48 c1 e9 14          	shr    $0x14,%rcx
    CHECK_LT(res, kNumPossibleRegions);
  403cd1:	48 81 f9 ff ff ff 07 	cmp    $0x7ffffff,%rcx
  403cd8:	0f 87 d1 06 00 00    	ja     4043af <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x73f>
    map2[idx % kSize2] = val;
  }

  u8 operator[] (uptr idx) const {
    CHECK_LT(idx, kSize1 * kSize2);
    u8 *map2 = Get(idx / kSize2);
  403cde:	48 89 d8             	mov    %rbx,%rax

 private:
  u8 *Get(uptr idx) const {
    CHECK_LT(idx, kSize1);
    return reinterpret_cast<u8 *>(
        atomic_load(&map1_[idx], memory_order_acquire));
  403ce1:	4c 8d 25 58 aa 02 00 	lea    0x2aa58(%rip),%r12        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
    map2[idx % kSize2] = val;
  }

  u8 operator[] (uptr idx) const {
    CHECK_LT(idx, kSize1 * kSize2);
    u8 *map2 = Get(idx / kSize2);
  403ce8:	48 c1 e8 20          	shr    $0x20,%rax

 private:
  u8 *Get(uptr idx) const {
    CHECK_LT(idx, kSize1);
    return reinterpret_cast<u8 *>(
        atomic_load(&map1_[idx], memory_order_acquire));
  403cec:	49 8d 14 c4          	lea    (%r12,%rax,8),%rdx
  403cf0:	48 8b 02             	mov    (%rdx),%rax
  }

  u8 operator[] (uptr idx) const {
    CHECK_LT(idx, kSize1 * kSize2);
    u8 *map2 = Get(idx / kSize2);
    if (!map2) return 0;
  403cf3:	48 85 c0             	test   %rax,%rax
  403cf6:	74 10                	je     403d08 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x98>
    return map2[idx % kSize2];
  403cf8:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
                 memory_order_release);
  }

  void Deallocate(AllocatorCache *cache, void *p) {
    if (!p) return;
    if (primary_.PointerIsMine(p))
  403cfe:	80 3c 08 00          	cmpb   $0x0,(%rax,%rcx,1)
  403d02:	0f 85 e8 00 00 00    	jne    403df0 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x180>
    uptr size;
    uptr chunk_idx;
  };

  Header *GetHeader(uptr p) {
    CHECK(IsAligned(p, page_size_));
  403d08:	48 8b 05 79 b7 06 00 	mov    0x6b779(%rip),%rax        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
INLINE uptr RoundDownTo(uptr x, uptr boundary) {
  return x & ~(boundary - 1);
}

INLINE bool IsAligned(uptr a, uptr alignment) {
  return (a & (alignment - 1)) == 0;
  403d0f:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  403d13:	48 85 d3             	test   %rdx,%rbx
  403d16:	0f 85 cf 07 00 00    	jne    4044eb <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x87b>
    return reinterpret_cast<Header*>(p - page_size_);
  403d1c:	48 29 c3             	sub    %rax,%rbx
  403d1f:	b8 01 00 00 00       	mov    $0x1,%eax
  403d24:	86 05 a7 b9 26 00    	xchg   %al,0x26b9a7(%rip)        # 66f6d1 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f91>
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  403d2a:	84 c0                	test   %al,%al
  403d2c:	74 0c                	je     403d3a <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0xca>
      return;
    LockSlow();
  403d2e:	48 8d 3d 9c b9 26 00 	lea    0x26b99c(%rip),%rdi        # 66f6d1 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f91>
  403d35:	e8 16 08 00 00       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>

  void Deallocate(AllocatorStats *stat, void *p) {
    Header *h = GetHeader(p);
    {
      SpinMutexLock l(&mutex_);
      uptr idx = h->chunk_idx;
  403d3a:	48 8b 43 18          	mov    0x18(%rbx),%rax
      CHECK_EQ(chunks_[idx], h);
  403d3e:	48 8d 35 fb a9 02 00 	lea    0x2a9fb(%rip),%rsi        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
  403d45:	49 8b 8c c4 50 0d 04 	mov    0x40d50(%r12,%rax,8),%rcx
  403d4c:	00 
  403d4d:	48 39 d9             	cmp    %rbx,%rcx
  403d50:	0f 85 d3 07 00 00    	jne    404529 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x8b9>
      CHECK_LT(idx, n_chunks_);
  403d56:	4c 8b 05 33 b7 26 00 	mov    0x26b733(%rip),%r8        # 66f490 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d50>
  403d5d:	4c 39 c0             	cmp    %r8,%rax
  403d60:	0f 83 25 07 00 00    	jae    40448b <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x81b>
      chunks_[idx] = chunks_[n_chunks_ - 1];
  403d66:	49 83 e8 01          	sub    $0x1,%r8
  403d6a:	4a 8b 94 c6 50 0d 04 	mov    0x40d50(%rsi,%r8,8),%rdx
  403d71:	00 
  403d72:	48 89 94 c6 50 0d 04 	mov    %rdx,0x40d50(%rsi,%rax,8)
  403d79:	00 
      chunks_[idx]->chunk_idx = idx;
  403d7a:	48 89 42 18          	mov    %rax,0x18(%rdx)
      n_chunks_--;
      chunks_sorted_ = false;
      stats.n_frees++;
  403d7e:	48 83 05 32 b7 26 00 	addq   $0x1,0x26b732(%rip)        # 66f4b8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d78>
  403d85:	01 
      uptr idx = h->chunk_idx;
      CHECK_EQ(chunks_[idx], h);
      CHECK_LT(idx, n_chunks_);
      chunks_[idx] = chunks_[n_chunks_ - 1];
      chunks_[idx]->chunk_idx = idx;
      n_chunks_--;
  403d86:	4c 89 05 03 b7 26 00 	mov    %r8,0x26b703(%rip)        # 66f490 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d50>
      chunks_sorted_ = false;
      stats.n_frees++;
      stats.currently_allocated -= h->map_size;
  403d8d:	48 8b 05 2c b7 26 00 	mov    0x26b72c(%rip),%rax        # 66f4c0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d80>
  403d94:	48 2b 43 08          	sub    0x8(%rbx),%rax
      CHECK_EQ(chunks_[idx], h);
      CHECK_LT(idx, n_chunks_);
      chunks_[idx] = chunks_[n_chunks_ - 1];
      chunks_[idx]->chunk_idx = idx;
      n_chunks_--;
      chunks_sorted_ = false;
  403d98:	c6 05 09 b7 26 00 00 	movb   $0x0,0x26b709(%rip)        # 66f4a8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d68>
      stats.n_frees++;
      stats.currently_allocated -= h->map_size;
  403d9f:	48 89 05 1a b7 26 00 	mov    %rax,0x26b71a(%rip)        # 66f4c0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d80>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  403da6:	48 8b 05 3b b9 26 00 	mov    0x26b93b(%rip),%rax        # 66f6e8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fa8>
      stat->Sub(AllocatorStatAllocated, h->map_size);
  403dad:	48 8b 53 08          	mov    0x8(%rbx),%rdx
    v += atomic_load(&stats_[i], memory_order_relaxed);
    atomic_store(&stats_[i], v, memory_order_relaxed);
  }

  void Sub(AllocatorStat i, uptr v) {
    v = atomic_load(&stats_[i], memory_order_relaxed) - v;
  403db1:	48 29 d0             	sub    %rdx,%rax
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  403db4:	48 89 05 2d b9 26 00 	mov    %rax,0x26b92d(%rip)        # 66f6e8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fa8>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  403dbb:	48 8b 05 2e b9 26 00 	mov    0x26b92e(%rip),%rax        # 66f6f0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fb0>
  403dc2:	48 29 d0             	sub    %rdx,%rax
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  403dc5:	48 89 05 24 b9 26 00 	mov    %rax,0x26b924(%rip)        # 66f6f0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fb0>
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  403dcc:	c6 05 fe b8 26 00 00 	movb   $0x0,0x26b8fe(%rip)        # 66f6d1 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f91>
      stats.currently_allocated -= h->map_size;
      stat->Sub(AllocatorStatAllocated, h->map_size);
      stat->Sub(AllocatorStatMapped, h->map_size);
    }
    MapUnmapCallback().OnUnmap(h->map_beg, h->map_size);
    UnmapOrDie(reinterpret_cast<void*>(h->map_beg), h->map_size);
  403dd3:	48 8b 73 08          	mov    0x8(%rbx),%rsi
  403dd7:	48 8b 3b             	mov    (%rbx),%rdi
    return;
  addr = (char*)addr - sizeof(u64);
  CHECK_EQ(kBlockMagic, ((u64*)addr)[0]);
  ((u64*)addr)[0] = 0;
  RawInternalFree(addr, cache);
}
  403dda:	48 83 c4 08          	add    $0x8,%rsp
  403dde:	5b                   	pop    %rbx
  403ddf:	5d                   	pop    %rbp
  403de0:	41 5c                	pop    %r12
  403de2:	41 5d                	pop    %r13
  403de4:	e9 57 86 00 00       	jmpq   40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  403de9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
      __asm__ __volatile__("" ::: "memory");
    } else if (mo == memory_order_acquire) {
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  403df0:	48 8b 02             	mov    (%rdx),%rax
  }

  u8 operator[] (uptr idx) const {
    CHECK_LT(idx, kSize1 * kSize2);
    u8 *map2 = Get(idx / kSize2);
    if (!map2) return 0;
  403df3:	48 85 c0             	test   %rax,%rax
  403df6:	0f 84 c7 03 00 00    	je     4041c3 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x553>
  bool PointerIsMine(const void *p) {
    return GetSizeClass(p) != 0;
  }

  uptr GetSizeClass(const void *p) {
    return possible_regions[ComputeRegionId(reinterpret_cast<uptr>(p))];
  403dfc:	0f b6 34 08          	movzbl (%rax,%rcx,1),%esi
    PREFETCH(c->batch[c->count - 1]);
    return res;
  }

  void Deallocate(SizeClassAllocator *allocator, uptr class_id, void *p) {
    CHECK_NE(class_id, 0UL);
  403e00:	48 85 f6             	test   %rsi,%rsi
  403e03:	0f 84 ba 03 00 00    	je     4041c3 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x553>
    CHECK_LT(class_id, kNumClasses);
  403e09:	48 83 fe 34          	cmp    $0x34,%rsi
  403e0d:	0f 87 f5 06 00 00    	ja     404508 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x898>
  };
  PerClass per_class_[kNumClasses];
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
  403e13:	48 83 bd 18 04 00 00 	cmpq   $0x0,0x418(%rbp)
  403e1a:	00 
  403e1b:	0f 84 df 00 00 00    	je     403f00 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x290>
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
  403e21:	48 89 f2             	mov    %rsi,%rdx
  403e24:	48 c1 e2 04          	shl    $0x4,%rdx
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  403e28:	48 83 fe 10          	cmp    $0x10,%rsi
  403e2c:	0f 87 8e 00 00 00    	ja     403ec0 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x250>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  403e32:	48 8b 85 60 d7 00 00 	mov    0xd760(%rbp),%rax
    CHECK_LT(class_id, kNumClasses);
    // If the first allocator call on a new thread is a deallocation, then
    // max_count will be zero, leading to check failure.
    InitCache();
    stats_.Sub(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
  403e39:	49 89 f4             	mov    %rsi,%r12
  403e3c:	49 c1 e4 04          	shl    $0x4,%r12
    v += atomic_load(&stats_[i], memory_order_relaxed);
    atomic_store(&stats_[i], v, memory_order_relaxed);
  }

  void Sub(AllocatorStat i, uptr v) {
    v = atomic_load(&stats_[i], memory_order_relaxed) - v;
  403e40:	48 29 d0             	sub    %rdx,%rax
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  403e43:	48 89 85 60 d7 00 00 	mov    %rax,0xd760(%rbp)
    CHECK_LT(class_id, kNumClasses);
    // If the first allocator call on a new thread is a deallocation, then
    // max_count will be zero, leading to check failure.
    InitCache();
    stats_.Sub(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
  403e4a:	48 89 f0             	mov    %rsi,%rax
  403e4d:	48 c1 e0 0a          	shl    $0xa,%rax
  403e51:	49 01 c4             	add    %rax,%r12
  403e54:	49 01 ec             	add    %rbp,%r12
    CHECK_NE(c->max_count, 0UL);
  403e57:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
  403e5c:	48 85 d2             	test   %rdx,%rdx
  403e5f:	0f 84 c3 05 00 00    	je     404428 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x7b8>
    if (UNLIKELY(c->count == c->max_count))
  403e65:	49 8b 04 24          	mov    (%r12),%rax
  403e69:	48 39 c2             	cmp    %rax,%rdx
  403e6c:	0f 84 5e 06 00 00    	je     4044d0 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x860>
      Drain(allocator, class_id);
    c->batch[c->count++] = p;
  403e72:	48 8d 50 01          	lea    0x1(%rax),%rdx
  403e76:	49 89 14 24          	mov    %rdx,(%r12)
  403e7a:	49 89 5c c4 10       	mov    %rbx,0x10(%r12,%rax,8)
  403e7f:	48 83 c4 08          	add    $0x8,%rsp
  403e83:	5b                   	pop    %rbx
  403e84:	5d                   	pop    %rbp
  403e85:	41 5c                	pop    %r12
  403e87:	41 5d                	pop    %r13
  403e89:	f3 c3                	repz retq 
  403e8b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  403e90:	b8 01 00 00 00       	mov    $0x1,%eax
  403e95:	86 05 75 a8 02 00    	xchg   %al,0x2a875(%rip)        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  403e9b:	84 c0                	test   %al,%al
  403e9d:	75 51                	jne    403ef0 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x280>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  403e9f:	0f b6 05 6b a8 02 00 	movzbl 0x2a86b(%rip),%eax        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
InternalAllocator *internal_allocator() {
  InternalAllocator *internal_allocator_instance =
      reinterpret_cast<InternalAllocator *>(&internal_alloc_placeholder);
  if (atomic_load(&internal_allocator_initialized, memory_order_acquire) == 0) {
    SpinMutexLock l(&internal_alloc_init_mu);
    if (atomic_load(&internal_allocator_initialized, memory_order_relaxed) ==
  403ea6:	84 c0                	test   %al,%al
  403ea8:	0f 84 f2 00 00 00    	je     403fa0 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x330>
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  403eae:	c6 05 5b a8 02 00 00 	movb   $0x0,0x2a85b(%rip)        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
      __asm__ __volatile__("" ::: "memory");
  403eb5:	e9 07 fe ff ff       	jmpq   403cc1 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x51>
  403eba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
  403ec0:	48 8d 7e f0          	lea    -0x10(%rsi),%rdi
    uptr t = kMidSize << (class_id >> S);
  403ec4:	b8 00 01 00 00       	mov    $0x100,%eax
  403ec9:	48 89 f9             	mov    %rdi,%rcx
    return t + (t >> S) * (class_id & M);
  403ecc:	83 e7 03             	and    $0x3,%edi

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  403ecf:	48 c1 e9 02          	shr    $0x2,%rcx
  403ed3:	48 d3 e0             	shl    %cl,%rax
    return t + (t >> S) * (class_id & M);
  403ed6:	48 89 c2             	mov    %rax,%rdx
  403ed9:	48 c1 ea 02          	shr    $0x2,%rdx
  403edd:	48 0f af d7          	imul   %rdi,%rdx
  403ee1:	48 01 c2             	add    %rax,%rdx
  403ee4:	e9 49 ff ff ff       	jmpq   403e32 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x1c2>
  403ee9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      return;
    LockSlow();
  403ef0:	48 8d 3d 19 a8 02 00 	lea    0x2a819(%rip),%rdi        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
  403ef7:	e8 54 06 00 00       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  403efc:	eb a1                	jmp    403e9f <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x22f>
  403efe:	66 90                	xchg   %ax,%ax
  403f00:	49 89 e9             	mov    %rbp,%r9
  };
  PerClass per_class_[kNumClasses];
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
  403f03:	41 ba 01 00 00 00    	mov    $0x1,%r10d
  403f09:	45 31 c0             	xor    %r8d,%r8d
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  403f0c:	bf 00 40 00 00       	mov    $0x4000,%edi

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  403f11:	41 bc 00 01 00 00    	mov    $0x100,%r12d
  403f17:	eb 4c                	jmp    403f65 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x2f5>
  403f19:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
  403f20:	4c 89 c1             	mov    %r8,%rcx
  403f23:	48 c1 e1 04          	shl    $0x4,%rcx
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  403f27:	31 d2                	xor    %edx,%edx
  403f29:	48 89 f8             	mov    %rdi,%rax
  403f2c:	48 f7 f1             	div    %rcx
  return LeastSignificantSetBitIndex(x);
}

// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
  403f2f:	b9 80 00 00 00       	mov    $0x80,%ecx
  403f34:	48 83 f8 40          	cmp    $0x40,%rax
  403f38:	77 0e                	ja     403f48 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x2d8>
template<class T> T Max(T a, T b) { return a > b ? a : b; }
  403f3a:	48 85 c0             	test   %rax,%rax
  403f3d:	0f 85 02 05 00 00    	jne    404445 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x7d5>
  403f43:	b9 02 00 00 00       	mov    $0x2,%ecx
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
      return;
    for (uptr i = 0; i < kNumClasses; i++) {
  403f48:	49 83 fa 35          	cmp    $0x35,%r10
      PerClass *c = &per_class_[i];
      c->max_count = 2 * SizeClassMap::MaxCached(i);
  403f4c:	49 89 49 08          	mov    %rcx,0x8(%r9)
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
      return;
    for (uptr i = 0; i < kNumClasses; i++) {
  403f50:	0f 84 cb fe ff ff    	je     403e21 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x1b1>
  403f56:	49 83 c0 01          	add    $0x1,%r8
  403f5a:	49 83 c2 01          	add    $0x1,%r10
  403f5e:	49 81 c1 10 04 00 00 	add    $0x410,%r9
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
  403f65:	4d 85 c0             	test   %r8,%r8
  403f68:	0f 84 34 04 00 00    	je     4043a2 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x732>
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  403f6e:	49 83 f8 10          	cmp    $0x10,%r8
  403f72:	76 ac                	jbe    403f20 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x2b0>
  403f74:	49 8d 50 f0          	lea    -0x10(%r8),%rdx
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  403f78:	4c 89 e0             	mov    %r12,%rax
  403f7b:	48 89 d1             	mov    %rdx,%rcx
    return t + (t >> S) * (class_id & M);
  403f7e:	83 e2 03             	and    $0x3,%edx

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  403f81:	48 c1 e9 02          	shr    $0x2,%rcx
  403f85:	48 d3 e0             	shl    %cl,%rax
  403f88:	48 89 c1             	mov    %rax,%rcx
    return t + (t >> S) * (class_id & M);
  403f8b:	48 c1 e8 02          	shr    $0x2,%rax
  403f8f:	48 0f af c2          	imul   %rdx,%rax
  403f93:	48 01 c1             	add    %rax,%rcx
  403f96:	eb 8f                	jmp    403f27 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x2b7>
  403f98:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  403f9f:	00 
    page_size_ = GetPageSizeCached();
    atomic_store(&may_return_null_, may_return_null, memory_order_relaxed);
  }

  void Init(bool may_return_null) {
    internal_memset(this, 0, sizeof(*this));
  403fa0:	48 8d 3d e1 b4 06 00 	lea    0x6b4e1(%rip),%rdi        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
  403fa7:	31 f6                	xor    %esi,%esi
  403fa9:	ba 50 02 20 00       	mov    $0x200250,%edx
  403fae:	e8 8d 63 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).
template <class MapUnmapCallback = NoOpMapUnmapCallback>
class LargeMmapAllocator {
 public:
  void InitLinkerInitialized(bool may_return_null) {
    page_size_ = GetPageSizeCached();
  403fb3:	e8 f8 10 00 00       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
  void InitLinkerInitialized() {
    next_ = this;
    prev_ = this;
  }
  void Init() {
    internal_memset(this, 0, sizeof(*this));
  403fb8:	48 8d 3d 19 b7 26 00 	lea    0x26b719(%rip),%rdi        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
  403fbf:	31 f6                	xor    %esi,%esi
  403fc1:	ba 28 00 00 00       	mov    $0x28,%edx
// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).
template <class MapUnmapCallback = NoOpMapUnmapCallback>
class LargeMmapAllocator {
 public:
  void InitLinkerInitialized(bool may_return_null) {
    page_size_ = GetPageSizeCached();
  403fc6:	48 89 05 bb b4 06 00 	mov    %rax,0x6b4bb(%rip)        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  403fcd:	c6 05 fc b6 26 00 00 	movb   $0x0,0x26b6fc(%rip)        # 66f6d0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f90>
  void InitLinkerInitialized() {
    next_ = this;
    prev_ = this;
  }
  void Init() {
    internal_memset(this, 0, sizeof(*this));
  403fd4:	e8 67 63 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>

// Global stats, used for aggregation and querying.
class AllocatorGlobalStats : public AllocatorStats {
 public:
  void InitLinkerInitialized() {
    next_ = this;
  403fd9:	48 8d 05 f8 b6 26 00 	lea    0x26b6f8(%rip),%rax        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
// Setting and getting values from multiple threads is safe w/o extra locking.
template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>
class TwoLevelByteMap {
 public:
  void TestOnlyInit() {
    internal_memset(map1_, 0, sizeof(map1_));
  403fe0:	48 8d 3d 59 a7 02 00 	lea    0x2a759(%rip),%rdi        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
  403fe7:	31 f6                	xor    %esi,%esi
  403fe9:	ba 00 00 04 00       	mov    $0x40000,%edx

// Global stats, used for aggregation and querying.
class AllocatorGlobalStats : public AllocatorStats {
 public:
  void InitLinkerInitialized() {
    next_ = this;
  403fee:	48 89 05 e3 b6 26 00 	mov    %rax,0x26b6e3(%rip)        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
    prev_ = this;
  403ff5:	48 89 05 e4 b6 26 00 	mov    %rax,0x26b6e4(%rip)        # 66f6e0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fa0>
// Setting and getting values from multiple threads is safe w/o extra locking.
template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>
class TwoLevelByteMap {
 public:
  void TestOnlyInit() {
    internal_memset(map1_, 0, sizeof(map1_));
  403ffc:	e8 3f 63 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
      SizeClassMap, kRegionSizeLog, ByteMap, MapUnmapCallback> ThisT;
  typedef SizeClassAllocatorLocalCache<ThisT> AllocatorCache;

  void Init() {
    possible_regions.TestOnlyInit();
    internal_memset(size_class_info_array, 0, sizeof(size_class_info_array));
  404001:	48 8d 3d 40 a7 06 00 	lea    0x6a740(%rip),%rdi        # 46e748 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40008>
  404008:	ba 40 0d 00 00       	mov    $0xd40,%edx
  40400d:	31 f6                	xor    %esi,%esi
  40400f:	c6 05 2a a7 06 00 00 	movb   $0x0,0x6a72a(%rip)        # 46e740 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40000>
  404016:	e8 25 63 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  40401b:	c6 05 de b6 26 00 00 	movb   $0x0,0x26b6de(%rip)        # 66f700 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fc0>
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  404022:	c6 05 e8 a6 02 00 01 	movb   $0x1,0x2a6e8(%rip)        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
      __asm__ __volatile__("" ::: "memory");
  404029:	e9 80 fe ff ff       	jmpq   403eae <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x23e>
  40402e:	66 90                	xchg   %ax,%ax
  404030:	b8 01 00 00 00       	mov    $0x1,%eax
  404035:	86 05 4d cf 01 00    	xchg   %al,0x1cf4d(%rip)        # 420f88 <_ZN11__sanitizerL27internal_allocator_cache_muE>
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  40403b:	84 c0                	test   %al,%al
  40403d:	0f 85 6f 01 00 00    	jne    4041b2 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x542>
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
      __asm__ __volatile__("" ::: "memory");
    } else if (mo == memory_order_acquire) {
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  404043:	0f b6 05 c7 a6 02 00 	movzbl 0x2a6c7(%rip),%eax        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
static StaticSpinMutex internal_allocator_cache_mu;

InternalAllocator *internal_allocator() {
  InternalAllocator *internal_allocator_instance =
      reinterpret_cast<InternalAllocator *>(&internal_alloc_placeholder);
  if (atomic_load(&internal_allocator_initialized, memory_order_acquire) == 0) {
  40404a:	84 c0                	test   %al,%al
  40404c:	0f 84 2a 01 00 00    	je     40417c <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x50c>
    atomic_store(&rss_limit_is_exceeded_, rss_limit_is_exceeded,
                 memory_order_release);
  }

  void Deallocate(AllocatorCache *cache, void *p) {
    if (!p) return;
  404052:	48 85 db             	test   %rbx,%rbx
  404055:	0f 84 15 01 00 00    	je     404170 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x500>
    char padding[kCacheLineSize - sizeof(uptr) - sizeof(IntrusiveList<Batch>)];
  };
  COMPILER_CHECK(sizeof(SizeClassInfo) == kCacheLineSize);

  uptr ComputeRegionId(uptr mem) {
    uptr res = mem >> kRegionSizeLog;
  40405b:	48 89 d9             	mov    %rbx,%rcx
  40405e:	48 c1 e9 14          	shr    $0x14,%rcx
    CHECK_LT(res, kNumPossibleRegions);
  404062:	48 81 f9 ff ff ff 07 	cmp    $0x7ffffff,%rcx
  404069:	0f 87 fe 03 00 00    	ja     40446d <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x7fd>
    map2[idx % kSize2] = val;
  }

  u8 operator[] (uptr idx) const {
    CHECK_LT(idx, kSize1 * kSize2);
    u8 *map2 = Get(idx / kSize2);
  40406f:	48 89 d8             	mov    %rbx,%rax

 private:
  u8 *Get(uptr idx) const {
    CHECK_LT(idx, kSize1);
    return reinterpret_cast<u8 *>(
        atomic_load(&map1_[idx], memory_order_acquire));
  404072:	4c 8d 25 c7 a6 02 00 	lea    0x2a6c7(%rip),%r12        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
    map2[idx % kSize2] = val;
  }

  u8 operator[] (uptr idx) const {
    CHECK_LT(idx, kSize1 * kSize2);
    u8 *map2 = Get(idx / kSize2);
  404079:	48 c1 e8 20          	shr    $0x20,%rax

 private:
  u8 *Get(uptr idx) const {
    CHECK_LT(idx, kSize1);
    return reinterpret_cast<u8 *>(
        atomic_load(&map1_[idx], memory_order_acquire));
  40407d:	49 8d 14 c4          	lea    (%r12,%rax,8),%rdx
  404081:	48 8b 02             	mov    (%rdx),%rax
  }

  u8 operator[] (uptr idx) const {
    CHECK_LT(idx, kSize1 * kSize2);
    u8 *map2 = Get(idx / kSize2);
    if (!map2) return 0;
  404084:	48 85 c0             	test   %rax,%rax
  404087:	74 10                	je     404099 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x429>
    return map2[idx % kSize2];
  404089:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
                 memory_order_release);
  }

  void Deallocate(AllocatorCache *cache, void *p) {
    if (!p) return;
    if (primary_.PointerIsMine(p))
  40408f:	80 3c 08 00          	cmpb   $0x0,(%rax,%rcx,1)
  404093:	0f 85 31 01 00 00    	jne    4041ca <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x55a>
    uptr size;
    uptr chunk_idx;
  };

  Header *GetHeader(uptr p) {
    CHECK(IsAligned(p, page_size_));
  404099:	48 8b 05 e8 b3 06 00 	mov    0x6b3e8(%rip),%rax        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
INLINE uptr RoundDownTo(uptr x, uptr boundary) {
  return x & ~(boundary - 1);
}

INLINE bool IsAligned(uptr a, uptr alignment) {
  return (a & (alignment - 1)) == 0;
  4040a0:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  4040a4:	48 85 d3             	test   %rdx,%rbx
  4040a7:	0f 85 3e 04 00 00    	jne    4044eb <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x87b>
    return reinterpret_cast<Header*>(p - page_size_);
  4040ad:	48 29 c3             	sub    %rax,%rbx
  4040b0:	b8 01 00 00 00       	mov    $0x1,%eax
  4040b5:	86 05 16 b6 26 00    	xchg   %al,0x26b616(%rip)        # 66f6d1 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f91>
  4040bb:	84 c0                	test   %al,%al
  4040bd:	74 0c                	je     4040cb <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x45b>
      return;
    LockSlow();
  4040bf:	48 8d 3d 0b b6 26 00 	lea    0x26b60b(%rip),%rdi        # 66f6d1 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f91>
  4040c6:	e8 85 04 00 00       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>

  void Deallocate(AllocatorStats *stat, void *p) {
    Header *h = GetHeader(p);
    {
      SpinMutexLock l(&mutex_);
      uptr idx = h->chunk_idx;
  4040cb:	48 8b 43 18          	mov    0x18(%rbx),%rax
      CHECK_EQ(chunks_[idx], h);
  4040cf:	48 8d 35 6a a6 02 00 	lea    0x2a66a(%rip),%rsi        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
  4040d6:	49 8b 8c c4 50 0d 04 	mov    0x40d50(%r12,%rax,8),%rcx
  4040dd:	00 
  4040de:	48 39 d9             	cmp    %rbx,%rcx
  4040e1:	0f 85 19 03 00 00    	jne    404400 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x790>
      CHECK_LT(idx, n_chunks_);
  4040e7:	4c 8b 05 a2 b3 26 00 	mov    0x26b3a2(%rip),%r8        # 66f490 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d50>
  4040ee:	4c 39 c0             	cmp    %r8,%rax
  4040f1:	0f 83 ee 02 00 00    	jae    4043e5 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x775>
      chunks_[idx] = chunks_[n_chunks_ - 1];
  4040f7:	49 83 e8 01          	sub    $0x1,%r8
  4040fb:	4a 8b 94 c6 50 0d 04 	mov    0x40d50(%rsi,%r8,8),%rdx
  404102:	00 
  404103:	48 89 94 c6 50 0d 04 	mov    %rdx,0x40d50(%rsi,%rax,8)
  40410a:	00 
      chunks_[idx]->chunk_idx = idx;
  40410b:	48 89 42 18          	mov    %rax,0x18(%rdx)
      n_chunks_--;
      chunks_sorted_ = false;
      stats.n_frees++;
  40410f:	48 83 05 a1 b3 26 00 	addq   $0x1,0x26b3a1(%rip)        # 66f4b8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d78>
  404116:	01 
      uptr idx = h->chunk_idx;
      CHECK_EQ(chunks_[idx], h);
      CHECK_LT(idx, n_chunks_);
      chunks_[idx] = chunks_[n_chunks_ - 1];
      chunks_[idx]->chunk_idx = idx;
      n_chunks_--;
  404117:	4c 89 05 72 b3 26 00 	mov    %r8,0x26b372(%rip)        # 66f490 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d50>
      chunks_sorted_ = false;
      stats.n_frees++;
      stats.currently_allocated -= h->map_size;
  40411e:	48 8b 05 9b b3 26 00 	mov    0x26b39b(%rip),%rax        # 66f4c0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d80>
  404125:	48 2b 43 08          	sub    0x8(%rbx),%rax
      CHECK_EQ(chunks_[idx], h);
      CHECK_LT(idx, n_chunks_);
      chunks_[idx] = chunks_[n_chunks_ - 1];
      chunks_[idx]->chunk_idx = idx;
      n_chunks_--;
      chunks_sorted_ = false;
  404129:	c6 05 78 b3 26 00 00 	movb   $0x0,0x26b378(%rip)        # 66f4a8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d68>
      stats.n_frees++;
      stats.currently_allocated -= h->map_size;
  404130:	48 89 05 89 b3 26 00 	mov    %rax,0x26b389(%rip)        # 66f4c0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240d80>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  404137:	48 8b 05 aa b5 26 00 	mov    0x26b5aa(%rip),%rax        # 66f6e8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fa8>
      stat->Sub(AllocatorStatAllocated, h->map_size);
  40413e:	48 8b 53 08          	mov    0x8(%rbx),%rdx
    v += atomic_load(&stats_[i], memory_order_relaxed);
    atomic_store(&stats_[i], v, memory_order_relaxed);
  }

  void Sub(AllocatorStat i, uptr v) {
    v = atomic_load(&stats_[i], memory_order_relaxed) - v;
  404142:	48 29 d0             	sub    %rdx,%rax
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  404145:	48 89 05 9c b5 26 00 	mov    %rax,0x26b59c(%rip)        # 66f6e8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fa8>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  40414c:	48 8b 05 9d b5 26 00 	mov    0x26b59d(%rip),%rax        # 66f6f0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fb0>
  404153:	48 29 d0             	sub    %rdx,%rax
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  404156:	48 89 05 93 b5 26 00 	mov    %rax,0x26b593(%rip)        # 66f6f0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fb0>
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  40415d:	c6 05 6d b5 26 00 00 	movb   $0x0,0x26b56d(%rip)        # 66f6d1 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f91>
      stats.currently_allocated -= h->map_size;
      stat->Sub(AllocatorStatAllocated, h->map_size);
      stat->Sub(AllocatorStatMapped, h->map_size);
    }
    MapUnmapCallback().OnUnmap(h->map_beg, h->map_size);
    UnmapOrDie(reinterpret_cast<void*>(h->map_beg), h->map_size);
  404164:	48 8b 73 08          	mov    0x8(%rbx),%rsi
  404168:	48 8b 3b             	mov    (%rbx),%rdi
  40416b:	e8 d0 82 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  404170:	c6 05 11 ce 01 00 00 	movb   $0x0,0x1ce11(%rip)        # 420f88 <_ZN11__sanitizerL27internal_allocator_cache_muE>
      __asm__ __volatile__("" ::: "memory");
  404177:	e9 03 fd ff ff       	jmpq   403e7f <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x20f>
  40417c:	b8 01 00 00 00       	mov    $0x1,%eax
  404181:	86 05 89 a5 02 00    	xchg   %al,0x2a589(%rip)        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  404187:	84 c0                	test   %al,%al
  404189:	74 0c                	je     404197 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x527>
      return;
    LockSlow();
  40418b:	48 8d 3d 7e a5 02 00 	lea    0x2a57e(%rip),%rdi        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
  404192:	e8 b9 03 00 00       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  404197:	0f b6 05 73 a5 02 00 	movzbl 0x2a573(%rip),%eax        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
    SpinMutexLock l(&internal_alloc_init_mu);
    if (atomic_load(&internal_allocator_initialized, memory_order_relaxed) ==
  40419e:	84 c0                	test   %al,%al
  4041a0:	0f 84 d8 00 00 00    	je     40427e <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x60e>
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  4041a6:	c6 05 63 a5 02 00 00 	movb   $0x0,0x2a563(%rip)        # 42e710 <_ZN11__sanitizerL22internal_alloc_init_muE>
      __asm__ __volatile__("" ::: "memory");
  4041ad:	e9 a0 fe ff ff       	jmpq   404052 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x3e2>
  4041b2:	48 8d 3d cf cd 01 00 	lea    0x1cdcf(%rip),%rdi        # 420f88 <_ZN11__sanitizerL27internal_allocator_cache_muE>
  4041b9:	e8 92 03 00 00       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  4041be:	e9 80 fe ff ff       	jmpq   404043 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x3d3>
  4041c3:	31 ff                	xor    %edi,%edi
  4041c5:	e8 98 e2 ff ff       	callq  402462 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE10DeallocateEPS7_mPv.part.17>
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
      __asm__ __volatile__("" ::: "memory");
    } else if (mo == memory_order_acquire) {
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  4041ca:	48 8b 02             	mov    (%rdx),%rax
  }

  u8 operator[] (uptr idx) const {
    CHECK_LT(idx, kSize1 * kSize2);
    u8 *map2 = Get(idx / kSize2);
    if (!map2) return 0;
  4041cd:	48 85 c0             	test   %rax,%rax
  4041d0:	74 f1                	je     4041c3 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x553>
  bool PointerIsMine(const void *p) {
    return GetSizeClass(p) != 0;
  }

  uptr GetSizeClass(const void *p) {
    return possible_regions[ComputeRegionId(reinterpret_cast<uptr>(p))];
  4041d2:	44 0f b6 24 08       	movzbl (%rax,%rcx,1),%r12d
    PREFETCH(c->batch[c->count - 1]);
    return res;
  }

  void Deallocate(SizeClassAllocator *allocator, uptr class_id, void *p) {
    CHECK_NE(class_id, 0UL);
  4041d7:	4d 85 e4             	test   %r12,%r12
  4041da:	74 e7                	je     4041c3 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x553>
    CHECK_LT(class_id, kNumClasses);
  4041dc:	49 83 fc 34          	cmp    $0x34,%r12
  4041e0:	0f 87 c0 02 00 00    	ja     4044a6 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x836>
  };
  PerClass per_class_[kNumClasses];
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
  4041e6:	48 83 3d ca d1 01 00 	cmpq   $0x0,0x1d1ca(%rip)        # 4213b8 <_ZN11__sanitizerL24internal_allocator_cacheE+0x418>
  4041ed:	00 
  4041ee:	4c 8d 2d ab cd 01 00 	lea    0x1cdab(%rip),%r13        # 420fa0 <_ZN11__sanitizerL24internal_allocator_cacheE>
  4041f5:	0f 84 11 01 00 00    	je     40430c <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x69c>
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
  4041fb:	4c 89 e2             	mov    %r12,%rdx
  4041fe:	48 c1 e2 04          	shl    $0x4,%rdx
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  404202:	49 83 fc 10          	cmp    $0x10,%r12
  404206:	76 25                	jbe    40422d <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x5bd>
      return kMinSize * class_id;
    class_id -= kMidClass;
  404208:	49 8d 74 24 f0       	lea    -0x10(%r12),%rsi
    uptr t = kMidSize << (class_id >> S);
  40420d:	b8 00 01 00 00       	mov    $0x100,%eax
  404212:	48 89 f1             	mov    %rsi,%rcx
    return t + (t >> S) * (class_id & M);
  404215:	83 e6 03             	and    $0x3,%esi

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  404218:	48 c1 e9 02          	shr    $0x2,%rcx
  40421c:	48 d3 e0             	shl    %cl,%rax
    return t + (t >> S) * (class_id & M);
  40421f:	48 89 c2             	mov    %rax,%rdx
  404222:	48 c1 ea 02          	shr    $0x2,%rdx
  404226:	48 0f af d6          	imul   %rsi,%rdx
  40422a:	48 01 c2             	add    %rax,%rdx
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  40422d:	48 8b 05 cc a4 02 00 	mov    0x2a4cc(%rip),%rax        # 42e700 <_ZN11__sanitizerL24internal_allocator_cacheE+0xd760>
    v += atomic_load(&stats_[i], memory_order_relaxed);
    atomic_store(&stats_[i], v, memory_order_relaxed);
  }

  void Sub(AllocatorStat i, uptr v) {
    v = atomic_load(&stats_[i], memory_order_relaxed) - v;
  404234:	48 29 d0             	sub    %rdx,%rax
    CHECK_LT(class_id, kNumClasses);
    // If the first allocator call on a new thread is a deallocation, then
    // max_count will be zero, leading to check failure.
    InitCache();
    stats_.Sub(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
  404237:	4c 89 e2             	mov    %r12,%rdx
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  40423a:	48 89 05 bf a4 02 00 	mov    %rax,0x2a4bf(%rip)        # 42e700 <_ZN11__sanitizerL24internal_allocator_cacheE+0xd760>
  404241:	4c 89 e0             	mov    %r12,%rax
  404244:	48 c1 e2 04          	shl    $0x4,%rdx
  404248:	48 c1 e0 0a          	shl    $0xa,%rax
  40424c:	48 01 d0             	add    %rdx,%rax
  40424f:	49 01 c5             	add    %rax,%r13
    CHECK_NE(c->max_count, 0UL);
  404252:	49 8b 55 08          	mov    0x8(%r13),%rdx
  404256:	48 85 d2             	test   %rdx,%rdx
  404259:	0f 84 c9 01 00 00    	je     404428 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x7b8>
    if (UNLIKELY(c->count == c->max_count))
  40425f:	49 8b 45 00          	mov    0x0(%r13),%rax
  404263:	48 39 c2             	cmp    %rax,%rdx
  404266:	0f 84 e2 01 00 00    	je     40444e <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x7de>
      Drain(allocator, class_id);
    c->batch[c->count++] = p;
  40426c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  404270:	49 89 55 00          	mov    %rdx,0x0(%r13)
  404274:	49 89 5c c5 10       	mov    %rbx,0x10(%r13,%rax,8)
  404279:	e9 f2 fe ff ff       	jmpq   404170 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x500>
    page_size_ = GetPageSizeCached();
    atomic_store(&may_return_null_, may_return_null, memory_order_relaxed);
  }

  void Init(bool may_return_null) {
    internal_memset(this, 0, sizeof(*this));
  40427e:	48 8d 3d 03 b2 06 00 	lea    0x6b203(%rip),%rdi        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
  404285:	31 f6                	xor    %esi,%esi
  404287:	ba 50 02 20 00       	mov    $0x200250,%edx
  40428c:	e8 af 60 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).
template <class MapUnmapCallback = NoOpMapUnmapCallback>
class LargeMmapAllocator {
 public:
  void InitLinkerInitialized(bool may_return_null) {
    page_size_ = GetPageSizeCached();
  404291:	e8 1a 0e 00 00       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
  void InitLinkerInitialized() {
    next_ = this;
    prev_ = this;
  }
  void Init() {
    internal_memset(this, 0, sizeof(*this));
  404296:	48 8d 3d 3b b4 26 00 	lea    0x26b43b(%rip),%rdi        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
  40429d:	31 f6                	xor    %esi,%esi
  40429f:	ba 28 00 00 00       	mov    $0x28,%edx
// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).
template <class MapUnmapCallback = NoOpMapUnmapCallback>
class LargeMmapAllocator {
 public:
  void InitLinkerInitialized(bool may_return_null) {
    page_size_ = GetPageSizeCached();
  4042a4:	48 89 05 dd b1 06 00 	mov    %rax,0x6b1dd(%rip)        # 46f488 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40d48>
  4042ab:	c6 05 1e b4 26 00 00 	movb   $0x0,0x26b41e(%rip)        # 66f6d0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f90>
  void InitLinkerInitialized() {
    next_ = this;
    prev_ = this;
  }
  void Init() {
    internal_memset(this, 0, sizeof(*this));
  4042b2:	e8 89 60 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>

// Global stats, used for aggregation and querying.
class AllocatorGlobalStats : public AllocatorStats {
 public:
  void InitLinkerInitialized() {
    next_ = this;
  4042b7:	48 8d 05 1a b4 26 00 	lea    0x26b41a(%rip),%rax        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
// Setting and getting values from multiple threads is safe w/o extra locking.
template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>
class TwoLevelByteMap {
 public:
  void TestOnlyInit() {
    internal_memset(map1_, 0, sizeof(map1_));
  4042be:	48 8d 3d 7b a4 02 00 	lea    0x2a47b(%rip),%rdi        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
  4042c5:	31 f6                	xor    %esi,%esi
  4042c7:	ba 00 00 04 00       	mov    $0x40000,%edx

// Global stats, used for aggregation and querying.
class AllocatorGlobalStats : public AllocatorStats {
 public:
  void InitLinkerInitialized() {
    next_ = this;
  4042cc:	48 89 05 05 b4 26 00 	mov    %rax,0x26b405(%rip)        # 66f6d8 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240f98>
    prev_ = this;
  4042d3:	48 89 05 06 b4 26 00 	mov    %rax,0x26b406(%rip)        # 66f6e0 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fa0>
// Setting and getting values from multiple threads is safe w/o extra locking.
template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>
class TwoLevelByteMap {
 public:
  void TestOnlyInit() {
    internal_memset(map1_, 0, sizeof(map1_));
  4042da:	e8 61 60 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
      SizeClassMap, kRegionSizeLog, ByteMap, MapUnmapCallback> ThisT;
  typedef SizeClassAllocatorLocalCache<ThisT> AllocatorCache;

  void Init() {
    possible_regions.TestOnlyInit();
    internal_memset(size_class_info_array, 0, sizeof(size_class_info_array));
  4042df:	48 8d 3d 62 a4 06 00 	lea    0x6a462(%rip),%rdi        # 46e748 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40008>
  4042e6:	ba 40 0d 00 00       	mov    $0xd40,%edx
  4042eb:	31 f6                	xor    %esi,%esi
  4042ed:	c6 05 4c a4 06 00 00 	movb   $0x0,0x6a44c(%rip)        # 46e740 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x40000>
  4042f4:	e8 47 60 00 00       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  4042f9:	c6 05 00 b4 26 00 00 	movb   $0x0,0x26b400(%rip)        # 66f700 <_ZN11__sanitizerL26internal_alloc_placeholderE+0x240fc0>
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  404300:	c6 05 0a a4 02 00 01 	movb   $0x1,0x2a40a(%rip)        # 42e711 <_ZN11__sanitizerL30internal_allocator_initializedE>
      __asm__ __volatile__("" ::: "memory");
  404307:	e9 9a fe ff ff       	jmpq   4041a6 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x536>
  40430c:	4c 89 ef             	mov    %r13,%rdi
  };
  PerClass per_class_[kNumClasses];
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
  40430f:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  404315:	31 f6                	xor    %esi,%esi
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  404317:	41 bb 00 40 00 00    	mov    $0x4000,%r11d

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  40431d:	bd 00 01 00 00       	mov    $0x100,%ebp
  404322:	eb 4b                	jmp    40436f <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x6ff>
  404324:	0f 1f 40 00          	nopl   0x0(%rax)
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
  404328:	49 89 f0             	mov    %rsi,%r8
  40432b:	49 c1 e0 04          	shl    $0x4,%r8
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  40432f:	31 d2                	xor    %edx,%edx
  404331:	4c 89 d8             	mov    %r11,%rax
  return LeastSignificantSetBitIndex(x);
}

// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
  404334:	41 ba 80 00 00 00    	mov    $0x80,%r10d
  40433a:	49 f7 f0             	div    %r8
  40433d:	48 83 f8 40          	cmp    $0x40,%rax
  404341:	77 0f                	ja     404352 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x6e2>
template<class T> T Max(T a, T b) { return a > b ? a : b; }
  404343:	48 85 c0             	test   %rax,%rax
  404346:	0f 85 7b 01 00 00    	jne    4044c7 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x857>
  40434c:	41 ba 02 00 00 00    	mov    $0x2,%r10d
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
      return;
    for (uptr i = 0; i < kNumClasses; i++) {
  404352:	49 83 f9 35          	cmp    $0x35,%r9
      PerClass *c = &per_class_[i];
      c->max_count = 2 * SizeClassMap::MaxCached(i);
  404356:	4c 89 57 08          	mov    %r10,0x8(%rdi)
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
      return;
    for (uptr i = 0; i < kNumClasses; i++) {
  40435a:	0f 84 9b fe ff ff    	je     4041fb <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x58b>
  404360:	48 83 c6 01          	add    $0x1,%rsi
  404364:	49 83 c1 01          	add    $0x1,%r9
  404368:	48 81 c7 10 04 00 00 	add    $0x410,%rdi
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
  40436f:	48 85 f6             	test   %rsi,%rsi
  404372:	0f 84 a3 00 00 00    	je     40441b <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x7ab>
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  404378:	48 83 fe 10          	cmp    $0x10,%rsi
  40437c:	76 aa                	jbe    404328 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x6b8>
  40437e:	48 8d 56 f0          	lea    -0x10(%rsi),%rdx
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  404382:	49 89 e8             	mov    %rbp,%r8
  404385:	48 89 d1             	mov    %rdx,%rcx
    return t + (t >> S) * (class_id & M);
  404388:	83 e2 03             	and    $0x3,%edx

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  40438b:	48 c1 e9 02          	shr    $0x2,%rcx
  40438f:	49 d3 e0             	shl    %cl,%r8
    return t + (t >> S) * (class_id & M);
  404392:	4c 89 c0             	mov    %r8,%rax
  404395:	48 c1 e8 02          	shr    $0x2,%rax
  404399:	48 0f af c2          	imul   %rdx,%rax
  40439d:	49 01 c0             	add    %rax,%r8
  4043a0:	eb 8d                	jmp    40432f <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x6bf>
  void InitCache() {
    if (per_class_[1].max_count)
      return;
    for (uptr i = 0; i < kNumClasses; i++) {
      PerClass *c = &per_class_[i];
      c->max_count = 2 * SizeClassMap::MaxCached(i);
  4043a2:	49 c7 41 08 00 00 00 	movq   $0x0,0x8(%r9)
  4043a9:	00 
  4043aa:	e9 a7 fb ff ff       	jmpq   403f56 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x2e6>
  };
  COMPILER_CHECK(sizeof(SizeClassInfo) == kCacheLineSize);

  uptr ComputeRegionId(uptr mem) {
    uptr res = mem >> kRegionSizeLog;
    CHECK_LT(res, kNumPossibleRegions);
  4043af:	48 8d 15 d2 0e 01 00 	lea    0x10ed2(%rip),%rdx        # 415288 <.LC14>
  4043b6:	48 8d 3d c3 0c 01 00 	lea    0x10cc3(%rip),%rdi        # 415080 <.LC3>
  4043bd:	41 b8 00 00 00 08    	mov    $0x8000000,%r8d
  4043c3:	be 4e 03 00 00       	mov    $0x34e,%esi
  4043c8:	e8 23 10 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

void InternalFree(void *addr, InternalAllocatorCache *cache) {
  if (!addr)
    return;
  addr = (char*)addr - sizeof(u64);
  CHECK_EQ(kBlockMagic, ((u64*)addr)[0]);
  4043cd:	48 8d 15 24 10 01 00 	lea    0x11024(%rip),%rdx        # 4153f8 <.LC28>
  4043d4:	48 8d 3d 7d 0d 01 00 	lea    0x10d7d(%rip),%rdi        # 415158 <.LC8>
  4043db:	be 6a 00 00 00       	mov    $0x6a,%esi
  4043e0:	e8 0b 10 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    Header *h = GetHeader(p);
    {
      SpinMutexLock l(&mutex_);
      uptr idx = h->chunk_idx;
      CHECK_EQ(chunks_[idx], h);
      CHECK_LT(idx, n_chunks_);
  4043e5:	48 8d 15 00 41 01 00 	lea    0x14100(%rip),%rdx        # 4184ec <.LC31>
  4043ec:	48 8d 3d 8d 0c 01 00 	lea    0x10c8d(%rip),%rdi        # 415080 <.LC3>
  4043f3:	48 89 c1             	mov    %rax,%rcx
  4043f6:	be 3b 04 00 00       	mov    $0x43b,%esi
  4043fb:	e8 f0 0f 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  void Deallocate(AllocatorStats *stat, void *p) {
    Header *h = GetHeader(p);
    {
      SpinMutexLock l(&mutex_);
      uptr idx = h->chunk_idx;
      CHECK_EQ(chunks_[idx], h);
  404400:	48 8d 15 cb 40 01 00 	lea    0x140cb(%rip),%rdx        # 4184d2 <.LC30>
  404407:	48 8d 3d 72 0c 01 00 	lea    0x10c72(%rip),%rdi        # 415080 <.LC3>
  40440e:	49 89 d8             	mov    %rbx,%r8
  404411:	be 3a 04 00 00       	mov    $0x43a,%esi
  404416:	e8 d5 0f 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  void InitCache() {
    if (per_class_[1].max_count)
      return;
    for (uptr i = 0; i < kNumClasses; i++) {
      PerClass *c = &per_class_[i];
      c->max_count = 2 * SizeClassMap::MaxCached(i);
  40441b:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  404422:	00 
  404423:	e9 38 ff ff ff       	jmpq   404360 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x6f0>
    // If the first allocator call on a new thread is a deallocation, then
    // max_count will be zero, leading to check failure.
    InitCache();
    stats_.Sub(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
    CHECK_NE(c->max_count, 0UL);
  404428:	48 8d 15 1c 40 01 00 	lea    0x1401c(%rip),%rdx        # 41844b <.LC18>
  40442f:	48 8d 3d 4a 0c 01 00 	lea    0x10c4a(%rip),%rdi        # 415080 <.LC3>
  404436:	45 31 c0             	xor    %r8d,%r8d
  404439:	31 c9                	xor    %ecx,%ecx
  40443b:	be ae 03 00 00       	mov    $0x3ae,%esi
  404440:	e8 ab 0f 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  404445:	48 8d 0c 00          	lea    (%rax,%rax,1),%rcx
  404449:	e9 fa fa ff ff       	jmpq   403f48 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x2d8>
    if (UNLIKELY(c->count == c->max_count))
      Drain(allocator, class_id);
  40444e:	48 8d 35 eb a2 02 00 	lea    0x2a2eb(%rip),%rsi        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
  404455:	48 8d 3d 44 cb 01 00 	lea    0x1cb44(%rip),%rdi        # 420fa0 <_ZN11__sanitizerL24internal_allocator_cacheE>
  40445c:	4c 89 e2             	mov    %r12,%rdx
  40445f:	e8 ec 09 00 00       	callq  404e50 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m>
  404464:	49 8b 45 00          	mov    0x0(%r13),%rax
  404468:	e9 ff fd ff ff       	jmpq   40426c <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x5fc>
  };
  COMPILER_CHECK(sizeof(SizeClassInfo) == kCacheLineSize);

  uptr ComputeRegionId(uptr mem) {
    uptr res = mem >> kRegionSizeLog;
    CHECK_LT(res, kNumPossibleRegions);
  40446d:	48 8d 15 14 0e 01 00 	lea    0x10e14(%rip),%rdx        # 415288 <.LC14>
  404474:	48 8d 3d 05 0c 01 00 	lea    0x10c05(%rip),%rdi        # 415080 <.LC3>
  40447b:	41 b8 00 00 00 08    	mov    $0x8000000,%r8d
  404481:	be 4e 03 00 00       	mov    $0x34e,%esi
  404486:	e8 65 0f 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    Header *h = GetHeader(p);
    {
      SpinMutexLock l(&mutex_);
      uptr idx = h->chunk_idx;
      CHECK_EQ(chunks_[idx], h);
      CHECK_LT(idx, n_chunks_);
  40448b:	48 8d 15 5a 40 01 00 	lea    0x1405a(%rip),%rdx        # 4184ec <.LC31>
  404492:	48 8d 3d e7 0b 01 00 	lea    0x10be7(%rip),%rdi        # 415080 <.LC3>
  404499:	48 89 c1             	mov    %rax,%rcx
  40449c:	be 3b 04 00 00       	mov    $0x43b,%esi
  4044a1:	e8 4a 0f 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    return res;
  }

  void Deallocate(SizeClassAllocator *allocator, uptr class_id, void *p) {
    CHECK_NE(class_id, 0UL);
    CHECK_LT(class_id, kNumClasses);
  4044a6:	48 8d 15 4b 0c 01 00 	lea    0x10c4b(%rip),%rdx        # 4150f8 <.LC5>
  4044ad:	48 8d 3d cc 0b 01 00 	lea    0x10bcc(%rip),%rdi        # 415080 <.LC3>
  4044b4:	41 b8 35 00 00 00    	mov    $0x35,%r8d
  4044ba:	4c 89 e1             	mov    %r12,%rcx
  4044bd:	be a8 03 00 00       	mov    $0x3a8,%esi
  4044c2:	e8 29 0f 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  4044c7:	4c 8d 14 00          	lea    (%rax,%rax,1),%r10
  4044cb:	e9 82 fe ff ff       	jmpq   404352 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x6e2>
    InitCache();
    stats_.Sub(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
    CHECK_NE(c->max_count, 0UL);
    if (UNLIKELY(c->count == c->max_count))
      Drain(allocator, class_id);
  4044d0:	48 89 f2             	mov    %rsi,%rdx
  4044d3:	48 8d 35 66 a2 02 00 	lea    0x2a266(%rip),%rsi        # 42e740 <_ZN11__sanitizerL26internal_alloc_placeholderE>
  4044da:	48 89 ef             	mov    %rbp,%rdi
  4044dd:	e8 6e 09 00 00       	callq  404e50 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m>
  4044e2:	49 8b 04 24          	mov    (%r12),%rax
  4044e6:	e9 87 f9 ff ff       	jmpq   403e72 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE+0x202>
    uptr size;
    uptr chunk_idx;
  };

  Header *GetHeader(uptr p) {
    CHECK(IsAligned(p, page_size_));
  4044eb:	48 8d 15 2e 0f 01 00 	lea    0x10f2e(%rip),%rdx        # 415420 <.LC29>
  4044f2:	48 8d 3d 87 0b 01 00 	lea    0x10b87(%rip),%rdi        # 415080 <.LC3>
  4044f9:	45 31 c0             	xor    %r8d,%r8d
  4044fc:	31 c9                	xor    %ecx,%ecx
  4044fe:	be cf 04 00 00       	mov    $0x4cf,%esi
  404503:	e8 e8 0e 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    return res;
  }

  void Deallocate(SizeClassAllocator *allocator, uptr class_id, void *p) {
    CHECK_NE(class_id, 0UL);
    CHECK_LT(class_id, kNumClasses);
  404508:	48 8d 15 e9 0b 01 00 	lea    0x10be9(%rip),%rdx        # 4150f8 <.LC5>
  40450f:	48 8d 3d 6a 0b 01 00 	lea    0x10b6a(%rip),%rdi        # 415080 <.LC3>
  404516:	48 89 f1             	mov    %rsi,%rcx
  404519:	41 b8 35 00 00 00    	mov    $0x35,%r8d
  40451f:	be a8 03 00 00       	mov    $0x3a8,%esi
  404524:	e8 c7 0e 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  void Deallocate(AllocatorStats *stat, void *p) {
    Header *h = GetHeader(p);
    {
      SpinMutexLock l(&mutex_);
      uptr idx = h->chunk_idx;
      CHECK_EQ(chunks_[idx], h);
  404529:	48 8d 15 a2 3f 01 00 	lea    0x13fa2(%rip),%rdx        # 4184d2 <.LC30>
  404530:	48 8d 3d 49 0b 01 00 	lea    0x10b49(%rip),%rdi        # 415080 <.LC3>
  404537:	49 89 d8             	mov    %rbx,%r8
  40453a:	be 3a 04 00 00       	mov    $0x43a,%esi
  40453f:	e8 ac 0e 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  404544:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  40454b:	00 00 00 00 
	...

0000000000404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>:
  }

 private:
  atomic_uint8_t state_;

  void NOINLINE LockSlow() {
  404550:	55                   	push   %rbp
  404551:	bd 01 00 00 00       	mov    $0x1,%ebp
  404556:	53                   	push   %rbx
    for (int i = 0;; i++) {
  404557:	31 db                	xor    %ebx,%ebx
  }

 private:
  atomic_uint8_t state_;

  void NOINLINE LockSlow() {
  404559:	48 83 ec 18          	sub    $0x18,%rsp
  40455d:	eb 04                	jmp    404563 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv+0x13>
  40455f:	90                   	nop
    for (int i = 0;; i++) {
  404560:	83 c3 01             	add    $0x1,%ebx
      if (i < 10)
  404563:	83 fb 09             	cmp    $0x9,%ebx
  404566:	7f 2a                	jg     404592 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv+0x42>
namespace __sanitizer {

INLINE void proc_yield(int cnt) {
  __asm__ __volatile__("" ::: "memory");
  for (int i = 0; i < cnt; i++)
    __asm__ __volatile__("pause");
  404568:	f3 90                	pause  
  40456a:	f3 90                	pause  
  40456c:	f3 90                	pause  
  40456e:	f3 90                	pause  
  404570:	f3 90                	pause  
  404572:	f3 90                	pause  
  404574:	f3 90                	pause  
  404576:	f3 90                	pause  
  404578:	f3 90                	pause  
  40457a:	f3 90                	pause  
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  40457c:	0f b6 07             	movzbl (%rdi),%eax
        proc_yield(10);
      else
        internal_sched_yield();
      if (atomic_load(&state_, memory_order_relaxed) == 0
          && atomic_exchange(&state_, 1, memory_order_acquire) == 0)
  40457f:	84 c0                	test   %al,%al
  404581:	75 dd                	jne    404560 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv+0x10>
  404583:	89 e8                	mov    %ebp,%eax
  404585:	86 07                	xchg   %al,(%rdi)
  404587:	84 c0                	test   %al,%al
  404589:	75 d5                	jne    404560 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv+0x10>
        return;
    }
  }
  40458b:	48 83 c4 18          	add    $0x18,%rsp
  40458f:	5b                   	pop    %rbx
  404590:	5d                   	pop    %rbp
  404591:	c3                   	retq   
  404592:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  void NOINLINE LockSlow() {
    for (int i = 0;; i++) {
      if (i < 10)
        proc_yield(10);
      else
        internal_sched_yield();
  404597:	e8 84 70 00 00       	callq  40b620 <_ZN11__sanitizer20internal_sched_yieldEv>
  40459c:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  4045a1:	eb d9                	jmp    40457c <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv+0x2c>
  4045a3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4045aa:	84 00 00 00 00 00 

00000000004045b0 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm>:
    uptr n = offset / (u32)size;  // 32-bit division
    uptr meta = (beg + kRegionSize) - (n + 1) * kMetadataSize;
    return reinterpret_cast<void*>(meta);
  }

  NOINLINE Batch* AllocateBatch(AllocatorStats *stat, AllocatorCache *c,
  4045b0:	41 57                	push   %r15
  4045b2:	49 89 cf             	mov    %rcx,%r15
  4045b5:	41 56                	push   %r14
  4045b7:	41 55                	push   %r13
  4045b9:	41 54                	push   %r12
  4045bb:	55                   	push   %rbp
  4045bc:	53                   	push   %rbx
  4045bd:	48 83 ec 38          	sub    $0x38,%rsp
                                uptr class_id) {
    CHECK_LT(class_id, kNumClasses);
  4045c1:	48 83 f9 34          	cmp    $0x34,%rcx
  4045c5:	0f 87 8e 04 00 00    	ja     404a59 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x4a9>
    SizeClassInfo *sci = GetSizeClassInfo(class_id);
  4045cb:	4c 8d 89 00 10 00 00 	lea    0x1000(%rcx),%r9
  4045d2:	49 89 fb             	mov    %rdi,%r11
  4045d5:	49 89 f4             	mov    %rsi,%r12
  4045d8:	49 89 d2             	mov    %rdx,%r10
  4045db:	b8 01 00 00 00       	mov    $0x1,%eax
  4045e0:	49 c1 e1 06          	shl    $0x6,%r9
  4045e4:	49 01 f9             	add    %rdi,%r9
  4045e7:	49 8d 69 08          	lea    0x8(%r9),%rbp
  4045eb:	86 45 00             	xchg   %al,0x0(%rbp)
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  4045ee:	84 c0                	test   %al,%al
  4045f0:	74 24                	je     404616 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x66>
  4045f2:	48 89 3c 24          	mov    %rdi,(%rsp)
      return;
    LockSlow();
  4045f6:	48 89 ef             	mov    %rbp,%rdi
  4045f9:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
  4045fe:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
  404603:	e8 48 ff ff ff       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  404608:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
  40460d:	4c 8b 54 24 08       	mov    0x8(%rsp),%r10
  404612:	4c 8b 1c 24          	mov    (%rsp),%r11
    SpinMutexLock l(&sci->mutex);
    if (sci->free_list.empty())
  404616:	48 8b 55 08          	mov    0x8(%rbp),%rdx
  40461a:	48 85 d2             	test   %rdx,%rdx
  40461d:	74 31                	je     404650 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0xa0>
  40461f:	48 8b 45 10          	mov    0x10(%rbp),%rax
    }
  }

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
  404623:	48 8b 08             	mov    (%rax),%rcx
    if (!first_)
  404626:	48 85 c9             	test   %rcx,%rcx
    }
  }

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
  404629:	48 89 4d 10          	mov    %rcx,0x10(%rbp)
    if (!first_)
  40462d:	0f 84 45 02 00 00    	je     404878 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x2c8>
      last_ = nullptr;
    size_--;
  404633:	48 83 ea 01          	sub    $0x1,%rdx
  404637:	48 89 55 08          	mov    %rdx,0x8(%rbp)
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  40463b:	41 c6 41 08 00       	movb   $0x0,0x8(%r9)
      PopulateFreeList(stat, c, sci, class_id);
    CHECK(!sci->free_list.empty());
    Batch *b = sci->free_list.front();
    sci->free_list.pop_front();
    return b;
  }
  404640:	48 83 c4 38          	add    $0x38,%rsp
  404644:	5b                   	pop    %rbx
  404645:	5d                   	pop    %rbp
  404646:	41 5c                	pop    %r12
  404648:	41 5d                	pop    %r13
  40464a:	41 5e                	pop    %r14
  40464c:	41 5f                	pop    %r15
  40464e:	c3                   	retq   
  40464f:	90                   	nop
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  404650:	49 83 ff 10          	cmp    $0x10,%r15
  404654:	0f 86 2e 02 00 00    	jbe    404888 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x2d8>
      return kMinSize * class_id;
    class_id -= kMidClass;
  40465a:	49 8d 57 f0          	lea    -0x10(%r15),%rdx
    uptr t = kMidSize << (class_id >> S);
  40465e:	b8 00 01 00 00       	mov    $0x100,%eax
  404663:	48 89 d1             	mov    %rdx,%rcx
    return t + (t >> S) * (class_id & M);
  404666:	83 e2 03             	and    $0x3,%edx

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  404669:	48 c1 e9 02          	shr    $0x2,%rcx
  40466d:	48 d3 e0             	shl    %cl,%rax
    return t + (t >> S) * (class_id & M);
  404670:	49 89 c5             	mov    %rax,%r13
  404673:	49 c1 ed 02          	shr    $0x2,%r13
  404677:	4c 0f af ea          	imul   %rdx,%r13
  40467b:	49 01 c5             	add    %rax,%r13
  }

  uptr AllocateRegion(AllocatorStats *stat, uptr class_id) {
    CHECK_LT(class_id, kNumClasses);
    uptr res = reinterpret_cast<uptr>(MmapAlignedOrDie(kRegionSize, kRegionSize,
                                      "SizeClassAllocator32"));
  40467e:	48 8d 15 a1 3d 01 00 	lea    0x13da1(%rip),%rdx        # 418426 <.LC12>
  404685:	be 00 00 10 00       	mov    $0x100000,%esi
  40468a:	bf 00 00 10 00       	mov    $0x100000,%edi
  40468f:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
  404694:	4c 89 54 24 08       	mov    %r10,0x8(%rsp)
  404699:	4c 89 1c 24          	mov    %r11,(%rsp)
  40469d:	e8 ae 11 00 00       	callq  405850 <_ZN11__sanitizer16MmapAlignedOrDieEmmPKc>
  4046a2:	48 89 c3             	mov    %rax,%rbx
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  4046a5:	49 8b 44 24 18       	mov    0x18(%r12),%rax
    MapUnmapCallback().OnMap(res, kRegionSize);
    stat->Add(AllocatorStatMapped, kRegionSize);
    CHECK_EQ(0U, (res & (kRegionSize - 1)));
  4046aa:	4c 8b 1c 24          	mov    (%rsp),%r11
  4046ae:	49 89 d8             	mov    %rbx,%r8
  4046b1:	4c 8b 54 24 08       	mov    0x8(%rsp),%r10
  4046b6:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
    internal_memset(this, 0, sizeof(*this));
  }
  void InitLinkerInitialized() {}

  void Add(AllocatorStat i, uptr v) {
    v += atomic_load(&stats_[i], memory_order_relaxed);
  4046bb:	48 05 00 00 10 00    	add    $0x100000,%rax
    CHECK_LT(class_id, kNumClasses);
    uptr res = reinterpret_cast<uptr>(MmapAlignedOrDie(kRegionSize, kRegionSize,
                                      "SizeClassAllocator32"));
    MapUnmapCallback().OnMap(res, kRegionSize);
    stat->Add(AllocatorStatMapped, kRegionSize);
    CHECK_EQ(0U, (res & (kRegionSize - 1)));
  4046c1:	41 81 e0 ff ff 0f 00 	and    $0xfffff,%r8d
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  4046c8:	49 89 44 24 18       	mov    %rax,0x18(%r12)
  4046cd:	0f 85 5b 04 00 00    	jne    404b2e <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x57e>
    char padding[kCacheLineSize - sizeof(uptr) - sizeof(IntrusiveList<Batch>)];
  };
  COMPILER_CHECK(sizeof(SizeClassInfo) == kCacheLineSize);

  uptr ComputeRegionId(uptr mem) {
    uptr res = mem >> kRegionSizeLog;
  4046d3:	49 89 dc             	mov    %rbx,%r12
  4046d6:	49 c1 ec 14          	shr    $0x14,%r12
    CHECK_LT(res, kNumPossibleRegions);
  4046da:	49 81 fc ff ff ff 07 	cmp    $0x7ffffff,%r12
  4046e1:	0f 87 26 04 00 00    	ja     404b0d <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x55d>
  uptr size1() const { return kSize1; }
  uptr size2() const { return kSize2; }

  void set(uptr idx, u8 val) {
    CHECK_LT(idx, kSize1 * kSize2);
    u8 *map2 = GetOrCreate(idx / kSize2);
  4046e7:	48 89 d8             	mov    %rbx,%rax
  4046ea:	48 c1 e8 20          	shr    $0x20,%rax

 private:
  u8 *Get(uptr idx) const {
    CHECK_LT(idx, kSize1);
    return reinterpret_cast<u8 *>(
        atomic_load(&map1_[idx], memory_order_acquire));
  4046ee:	4d 8d 34 c3          	lea    (%r11,%rax,8),%r14
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
      __asm__ __volatile__("" ::: "memory");
    } else if (mo == memory_order_acquire) {
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  4046f2:	49 8b 06             	mov    (%r14),%rax
  }

  u8 *GetOrCreate(uptr idx) {
    u8 *res = Get(idx);
    if (!res) {
  4046f5:	48 85 c0             	test   %rax,%rax
  4046f8:	0f 84 c4 02 00 00    	je     4049c2 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x412>
  uptr size2() const { return kSize2; }

  void set(uptr idx, u8 val) {
    CHECK_LT(idx, kSize1 * kSize2);
    u8 *map2 = GetOrCreate(idx / kSize2);
    CHECK_EQ(0U, map2[idx % kSize2]);
  4046fe:	41 81 e4 ff 0f 00 00 	and    $0xfff,%r12d
  404705:	4c 01 e0             	add    %r12,%rax
  404708:	44 0f b6 00          	movzbl (%rax),%r8d
  40470c:	4d 85 c0             	test   %r8,%r8
  40470f:	0f 85 93 03 00 00    	jne    404aa8 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x4f8>

  void PopulateFreeList(AllocatorStats *stat, AllocatorCache *c,
                        SizeClassInfo *sci, uptr class_id) {
    uptr size = SizeClassMap::Size(class_id);
    uptr reg = AllocateRegion(stat, class_id);
    uptr n_chunks = kRegionSize / (size + kMetadataSize);
  404715:	31 d2                	xor    %edx,%edx

  void set(uptr idx, u8 val) {
    CHECK_LT(idx, kSize1 * kSize2);
    u8 *map2 = GetOrCreate(idx / kSize2);
    CHECK_EQ(0U, map2[idx % kSize2]);
    map2[idx % kSize2] = val;
  404717:	44 88 38             	mov    %r15b,(%rax)

  void PopulateFreeList(AllocatorStats *stat, AllocatorCache *c,
                        SizeClassInfo *sci, uptr class_id) {
    uptr size = SizeClassMap::Size(class_id);
    uptr reg = AllocateRegion(stat, class_id);
    uptr n_chunks = kRegionSize / (size + kMetadataSize);
  40471a:	b8 00 00 10 00       	mov    $0x100000,%eax
  40471f:	49 f7 f5             	div    %r13
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
  404722:	45 31 e4             	xor    %r12d,%r12d
  404725:	4d 85 ff             	test   %r15,%r15

  void PopulateFreeList(AllocatorStats *stat, AllocatorCache *c,
                        SizeClassInfo *sci, uptr class_id) {
    uptr size = SizeClassMap::Size(class_id);
    uptr reg = AllocateRegion(stat, class_id);
    uptr n_chunks = kRegionSize / (size + kMetadataSize);
  404728:	49 89 c6             	mov    %rax,%r14
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
  40472b:	74 31                	je     40475e <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x1ae>
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  40472d:	49 83 ff 10          	cmp    $0x10,%r15
  404731:	0f 87 59 02 00 00    	ja     404990 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x3e0>
      return kMinSize * class_id;
  404737:	4c 89 f9             	mov    %r15,%rcx
  40473a:	48 c1 e1 04          	shl    $0x4,%rcx
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  40473e:	31 d2                	xor    %edx,%edx
  404740:	b8 00 40 00 00       	mov    $0x4000,%eax
  return LeastSignificantSetBitIndex(x);
}

// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
  404745:	41 bc 40 00 00 00    	mov    $0x40,%r12d
  40474b:	48 f7 f1             	div    %rcx
  40474e:	48 83 f8 40          	cmp    $0x40,%rax
  404752:	77 0a                	ja     40475e <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x1ae>
template<class T> T Max(T a, T b) { return a > b ? a : b; }
  404754:	41 b4 01             	mov    $0x1,%r12b
  404757:	48 85 c0             	test   %rax,%rax
  40475a:	4c 0f 45 e0          	cmovne %rax,%r12
    uptr size = SizeClassMap::Size(class_id);
    uptr reg = AllocateRegion(stat, class_id);
    uptr n_chunks = kRegionSize / (size + kMetadataSize);
    uptr max_count = SizeClassMap::MaxCached(class_id);
    Batch *b = nullptr;
    for (uptr i = reg; i < reg + n_chunks * size; i += size) {
  40475e:	4d 0f af f5          	imul   %r13,%r14
  404762:	49 01 de             	add    %rbx,%r14
  404765:	49 39 de             	cmp    %rbx,%r14
  404768:	0f 86 4b 02 00 00    	jbe    4049b9 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x409>
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
  40476e:	49 8d 77 f0          	lea    -0x10(%r15),%rsi
    uptr t = kMidSize << (class_id >> S);
  404772:	b8 00 01 00 00       	mov    $0x100,%eax
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
  404777:	4d 89 f8             	mov    %r15,%r8
  40477a:	49 c1 e0 04          	shl    $0x4,%r8
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  40477e:	48 89 f1             	mov    %rsi,%rcx
    return t + (t >> S) * (class_id & M);
  404781:	83 e6 03             	and    $0x3,%esi

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  404784:	48 c1 e9 02          	shr    $0x2,%rcx
  404788:	48 d3 e0             	shl    %cl,%rax
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  40478b:	b9 00 40 00 00       	mov    $0x4000,%ecx
  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
    return t + (t >> S) * (class_id & M);
  404790:	48 89 c2             	mov    %rax,%rdx
  404793:	48 c1 ea 02          	shr    $0x2,%rdx
  404797:	48 0f af d6          	imul   %rsi,%rdx
  40479b:	48 01 d0             	add    %rdx,%rax
  40479e:	48 89 04 24          	mov    %rax,(%rsp)
                        SizeClassInfo *sci, uptr class_id) {
    uptr size = SizeClassMap::Size(class_id);
    uptr reg = AllocateRegion(stat, class_id);
    uptr n_chunks = kRegionSize / (size + kMetadataSize);
    uptr max_count = SizeClassMap::MaxCached(class_id);
    Batch *b = nullptr;
  4047a2:	31 c0                	xor    %eax,%eax
  4047a4:	eb 12                	jmp    4047b8 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x208>
  4047a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4047ad:	00 00 00 
    for (uptr i = reg; i < reg + n_chunks * size; i += size) {
  4047b0:	4c 01 eb             	add    %r13,%rbx
  4047b3:	49 39 de             	cmp    %rbx,%r14
  4047b6:	76 58                	jbe    404810 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x260>
      if (!b) {
  4047b8:	48 85 c0             	test   %rax,%rax
  4047bb:	0f 84 d7 00 00 00    	je     404898 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x2e8>
          b = (Batch*)c->Allocate(this, SizeClassMap::ClassID(sizeof(Batch)));
        else
          b = (Batch*)i;
        b->count = 0;
      }
      b->batch[b->count++] = (void*)i;
  4047c1:	48 8b 70 08          	mov    0x8(%rax),%rsi
  4047c5:	48 8d 56 01          	lea    0x1(%rsi),%rdx
      if (b->count == max_count) {
  4047c9:	4c 39 e2             	cmp    %r12,%rdx
          b = (Batch*)c->Allocate(this, SizeClassMap::ClassID(sizeof(Batch)));
        else
          b = (Batch*)i;
        b->count = 0;
      }
      b->batch[b->count++] = (void*)i;
  4047cc:	48 89 50 08          	mov    %rdx,0x8(%rax)
  4047d0:	48 89 5c f0 10       	mov    %rbx,0x10(%rax,%rsi,8)
      if (b->count == max_count) {
  4047d5:	75 d9                	jne    4047b0 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x200>
        CHECK_GT(b->count, 0);
  4047d7:	4d 85 e4             	test   %r12,%r12
  4047da:	0f 84 5c 02 00 00    	je     404a3c <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x48c>
  }

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
  4047e0:	48 8b 55 08          	mov    0x8(%rbp),%rdx
    if (empty()) {
      x->next = nullptr;
  4047e4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
    if (empty()) {
  4047eb:	48 85 d2             	test   %rdx,%rdx
  4047ee:	0f 85 ec 00 00 00    	jne    4048e0 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x330>
    uptr size = SizeClassMap::Size(class_id);
    uptr reg = AllocateRegion(stat, class_id);
    uptr n_chunks = kRegionSize / (size + kMetadataSize);
    uptr max_count = SizeClassMap::MaxCached(class_id);
    Batch *b = nullptr;
    for (uptr i = reg; i < reg + n_chunks * size; i += size) {
  4047f4:	4c 01 eb             	add    %r13,%rbx
      x->next = nullptr;
      first_ = last_ = x;
  4047f7:	48 89 45 18          	mov    %rax,0x18(%rbp)
  4047fb:	48 89 45 10          	mov    %rax,0x10(%rbp)
      }
      b->batch[b->count++] = (void*)i;
      if (b->count == max_count) {
        CHECK_GT(b->count, 0);
        sci->free_list.push_back(b);
        b = nullptr;
  4047ff:	31 c0                	xor    %eax,%eax
    uptr size = SizeClassMap::Size(class_id);
    uptr reg = AllocateRegion(stat, class_id);
    uptr n_chunks = kRegionSize / (size + kMetadataSize);
    uptr max_count = SizeClassMap::MaxCached(class_id);
    Batch *b = nullptr;
    for (uptr i = reg; i < reg + n_chunks * size; i += size) {
  404801:	49 39 de             	cmp    %rbx,%r14
      size_ = 1;
  404804:	48 c7 45 08 01 00 00 	movq   $0x1,0x8(%rbp)
  40480b:	00 
  40480c:	77 aa                	ja     4047b8 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x208>
  40480e:	66 90                	xchg   %ax,%ax
        CHECK_GT(b->count, 0);
        sci->free_list.push_back(b);
        b = nullptr;
      }
    }
    if (b) {
  404810:	48 85 c0             	test   %rax,%rax
  404813:	0f 84 a0 01 00 00    	je     4049b9 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x409>
      CHECK_GT(b->count, 0);
  404819:	48 83 78 08 00       	cmpq   $0x0,0x8(%rax)
  40481e:	0f 84 53 02 00 00    	je     404a77 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x4c7>
  }

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
  404824:	48 8b 55 08          	mov    0x8(%rbp),%rdx
    if (empty()) {
      x->next = nullptr;
  404828:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
    if (empty()) {
  40482f:	48 85 d2             	test   %rdx,%rdx
  404832:	0f 84 40 01 00 00    	je     404978 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x3c8>
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = nullptr;
      last_->next = x;
  404838:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
      last_ = x;
      size_++;
  40483c:	48 83 c2 01          	add    $0x1,%rdx
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = nullptr;
      last_->next = x;
  404840:	48 89 01             	mov    %rax,(%rcx)
      last_ = x;
  404843:	48 89 45 18          	mov    %rax,0x18(%rbp)
      size_++;
  404847:	48 89 55 08          	mov    %rdx,0x8(%rbp)
    CHECK_LT(class_id, kNumClasses);
    SizeClassInfo *sci = GetSizeClassInfo(class_id);
    SpinMutexLock l(&sci->mutex);
    if (sci->free_list.empty())
      PopulateFreeList(stat, c, sci, class_id);
    CHECK(!sci->free_list.empty());
  40484b:	48 85 d2             	test   %rdx,%rdx
  40484e:	0f 85 cb fd ff ff    	jne    40461f <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x6f>
  404854:	48 8d 15 7d 0a 01 00 	lea    0x10a7d(%rip),%rdx        # 4152d8 <.LC17>
  40485b:	48 8d 3d 1e 08 01 00 	lea    0x1081e(%rip),%rdi        # 415080 <.LC3>
  404862:	45 31 c0             	xor    %r8d,%r8d
  404865:	31 c9                	xor    %ecx,%ecx
  404867:	be e1 02 00 00       	mov    $0x2e1,%esi
  40486c:	e8 7f 0b 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  404871:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
    if (!first_)
      last_ = nullptr;
  404878:	48 c7 45 18 00 00 00 	movq   $0x0,0x18(%rbp)
  40487f:	00 
  404880:	e9 ae fd ff ff       	jmpq   404633 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x83>
  404885:	0f 1f 00             	nopl   (%rax)
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
  404888:	4d 89 fd             	mov    %r15,%r13
  40488b:	49 c1 e5 04          	shl    $0x4,%r13
  40488f:	e9 ea fd ff ff       	jmpq   40467e <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0xce>
  404894:	0f 1f 40 00          	nopl   0x0(%rax)
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  404898:	49 83 ff 10          	cmp    $0x10,%r15
  40489c:	77 62                	ja     404900 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x350>
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
  40489e:	4d 85 ff             	test   %r15,%r15
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
  4048a1:	4c 89 c6             	mov    %r8,%rsi
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
  4048a4:	ba 10 00 00 00       	mov    $0x10,%edx
  4048a9:	75 59                	jne    404904 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x354>
    uptr n_chunks = kRegionSize / (size + kMetadataSize);
    uptr max_count = SizeClassMap::MaxCached(class_id);
    Batch *b = nullptr;
    for (uptr i = reg; i < reg + n_chunks * size; i += size) {
      if (!b) {
        if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))
  4048ab:	48 39 f2             	cmp    %rsi,%rdx
          b = (Batch*)c->Allocate(this, SizeClassMap::ClassID(sizeof(Batch)));
        else
          b = (Batch*)i;
  4048ae:	48 89 d8             	mov    %rbx,%rax
    uptr n_chunks = kRegionSize / (size + kMetadataSize);
    uptr max_count = SizeClassMap::MaxCached(class_id);
    Batch *b = nullptr;
    for (uptr i = reg; i < reg + n_chunks * size; i += size) {
      if (!b) {
        if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))
  4048b1:	77 7a                	ja     40492d <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x37d>
        else
          b = (Batch*)i;
        b->count = 0;
      }
      b->batch[b->count++] = (void*)i;
      if (b->count == max_count) {
  4048b3:	49 83 fc 01          	cmp    $0x1,%r12
          b = (Batch*)c->Allocate(this, SizeClassMap::ClassID(sizeof(Batch)));
        else
          b = (Batch*)i;
        b->count = 0;
      }
      b->batch[b->count++] = (void*)i;
  4048b7:	48 c7 40 08 01 00 00 	movq   $0x1,0x8(%rax)
  4048be:	00 
  4048bf:	48 89 58 10          	mov    %rbx,0x10(%rax)
      if (b->count == max_count) {
  4048c3:	0f 85 e7 fe ff ff    	jne    4047b0 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x200>
  }

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
  4048c9:	48 8b 55 08          	mov    0x8(%rbp),%rdx
    if (empty()) {
      x->next = nullptr;
  4048cd:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
    if (empty()) {
  4048d4:	48 85 d2             	test   %rdx,%rdx
  4048d7:	0f 84 17 ff ff ff    	je     4047f4 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x244>
  4048dd:	0f 1f 00             	nopl   (%rax)
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = nullptr;
      last_->next = x;
  4048e0:	48 8b 75 18          	mov    0x18(%rbp),%rsi
      last_ = x;
      size_++;
  4048e4:	48 83 c2 01          	add    $0x1,%rdx
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = nullptr;
      last_->next = x;
  4048e8:	48 89 06             	mov    %rax,(%rsi)
      last_ = x;
  4048eb:	48 89 45 18          	mov    %rax,0x18(%rbp)
        CHECK_GT(b->count, 0);
        sci->free_list.push_back(b);
        b = nullptr;
  4048ef:	31 c0                	xor    %eax,%eax
      size_++;
  4048f1:	48 89 55 08          	mov    %rdx,0x8(%rbp)
  4048f5:	e9 b6 fe ff ff       	jmpq   4047b0 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x200>
  4048fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  404900:	48 8b 34 24          	mov    (%rsp),%rsi
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  404904:	31 d2                	xor    %edx,%edx
  404906:	48 89 c8             	mov    %rcx,%rax
  404909:	48 f7 f6             	div    %rsi
  return LeastSignificantSetBitIndex(x);
}

// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
  40490c:	ba 10 02 00 00       	mov    $0x210,%edx
  404911:	48 83 f8 40          	cmp    $0x40,%rax
  404915:	77 94                	ja     4048ab <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x2fb>
template<class T> T Max(T a, T b) { return a > b ? a : b; }
  404917:	48 85 c0             	test   %rax,%rax
  40491a:	0f 85 74 01 00 00    	jne    404a94 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x4e4>
  404920:	ba 18 00 00 00       	mov    $0x18,%edx
    for (uptr i = reg; i < reg + n_chunks * size; i += size) {
      if (!b) {
        if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))
          b = (Batch*)c->Allocate(this, SizeClassMap::ClassID(sizeof(Batch)));
        else
          b = (Batch*)i;
  404925:	48 89 d8             	mov    %rbx,%rax
    uptr n_chunks = kRegionSize / (size + kMetadataSize);
    uptr max_count = SizeClassMap::MaxCached(class_id);
    Batch *b = nullptr;
    for (uptr i = reg; i < reg + n_chunks * size; i += size) {
      if (!b) {
        if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))
  404928:	48 39 f2             	cmp    %rsi,%rdx
  40492b:	76 86                	jbe    4048b3 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x303>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  40492d:	49 8b 82 60 d7 00 00 	mov    0xd760(%r10),%rax
  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {
    CHECK_NE(class_id, 0UL);
    CHECK_LT(class_id, kNumClasses);
    stats_.Add(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
    if (UNLIKELY(c->count == 0))
  404934:	49 8b 92 50 55 00 00 	mov    0x5550(%r10),%rdx
    internal_memset(this, 0, sizeof(*this));
  }
  void InitLinkerInitialized() {}

  void Add(AllocatorStat i, uptr v) {
    v += atomic_load(&stats_[i], memory_order_relaxed);
  40493b:	48 05 80 02 00 00    	add    $0x280,%rax
  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {
    CHECK_NE(class_id, 0UL);
    CHECK_LT(class_id, kNumClasses);
    stats_.Add(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
    if (UNLIKELY(c->count == 0))
  404941:	48 85 d2             	test   %rdx,%rdx
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  404944:	49 89 82 60 d7 00 00 	mov    %rax,0xd760(%r10)
  40494b:	0f 84 71 01 00 00    	je     404ac2 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x512>
      Refill(allocator, class_id);
    void *res = c->batch[--c->count];
  404951:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
  404955:	49 89 82 50 55 00 00 	mov    %rax,0x5550(%r10)
  40495c:	49 8b 84 d2 58 55 00 	mov    0x5558(%r10,%rdx,8),%rax
  404963:	00 
    PREFETCH(c->batch[c->count - 1]);
  404964:	49 8b 94 d2 50 55 00 	mov    0x5550(%r10,%rdx,8),%rdx
  40496b:	00 
  40496c:	0f 18 02             	prefetchnta (%rdx)
  40496f:	e9 3f ff ff ff       	jmpq   4048b3 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x303>
  404974:	0f 1f 40 00          	nopl   0x0(%rax)
  uptr size() const { return size_; }

  void push_back(Item *x) {
    if (empty()) {
      x->next = nullptr;
      first_ = last_ = x;
  404978:	48 89 45 18          	mov    %rax,0x18(%rbp)
  40497c:	48 89 45 10          	mov    %rax,0x10(%rbp)
      size_ = 1;
  404980:	b2 01                	mov    $0x1,%dl
  404982:	48 c7 45 08 01 00 00 	movq   $0x1,0x8(%rbp)
  404989:	00 
  40498a:	e9 90 fc ff ff       	jmpq   40461f <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x6f>
  40498f:	90                   	nop
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
  404990:	49 8d 57 f0          	lea    -0x10(%r15),%rdx
    uptr t = kMidSize << (class_id >> S);
  404994:	b8 00 01 00 00       	mov    $0x100,%eax
  404999:	48 89 d1             	mov    %rdx,%rcx
    return t + (t >> S) * (class_id & M);
  40499c:	83 e2 03             	and    $0x3,%edx

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  40499f:	48 c1 e9 02          	shr    $0x2,%rcx
  4049a3:	48 d3 e0             	shl    %cl,%rax
    return t + (t >> S) * (class_id & M);
  4049a6:	48 89 c1             	mov    %rax,%rcx
  4049a9:	48 c1 e9 02          	shr    $0x2,%rcx
  4049ad:	48 0f af ca          	imul   %rdx,%rcx
  4049b1:	48 01 c1             	add    %rax,%rcx
  4049b4:	e9 85 fd ff ff       	jmpq   40473e <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x18e>
  4049b9:	48 8b 55 08          	mov    0x8(%rbp),%rdx
  4049bd:	e9 89 fe ff ff       	jmpq   40484b <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x29b>
  }

  u8 *GetOrCreate(uptr idx) {
    u8 *res = Get(idx);
    if (!res) {
      SpinMutexLock l(&mu_);
  4049c2:	49 8d bb 00 00 04 00 	lea    0x40000(%r11),%rdi
  4049c9:	b8 01 00 00 00       	mov    $0x1,%eax
  4049ce:	86 07                	xchg   %al,(%rdi)
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  4049d0:	84 c0                	test   %al,%al
  4049d2:	74 21                	je     4049f5 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x445>
  4049d4:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
  4049d9:	4c 89 54 24 08       	mov    %r10,0x8(%rsp)
  4049de:	4c 89 1c 24          	mov    %r11,(%rsp)
      return;
    LockSlow();
  4049e2:	e8 69 fb ff ff       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  4049e7:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
  4049ec:	4c 8b 54 24 08       	mov    0x8(%rsp),%r10
  4049f1:	4c 8b 1c 24          	mov    (%rsp),%r11
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
      __asm__ __volatile__("" ::: "memory");
    } else if (mo == memory_order_acquire) {
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  4049f5:	49 8b 06             	mov    (%r14),%rax
      if (!(res = Get(idx))) {
  4049f8:	48 85 c0             	test   %rax,%rax
  4049fb:	74 0d                	je     404a0a <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x45a>
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  4049fd:	41 c6 83 00 00 04 00 	movb   $0x0,0x40000(%r11)
  404a04:	00 
      __asm__ __volatile__("" ::: "memory");
  404a05:	e9 f4 fc ff ff       	jmpq   4046fe <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x14e>
        res = (u8*)MmapOrDie(kSize2, "TwoLevelByteMap");
  404a0a:	48 8d 35 2a 3a 01 00 	lea    0x13a2a(%rip),%rsi        # 41843b <.LC15>
  404a11:	bf 00 10 00 00       	mov    $0x1000,%edi
  404a16:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
  404a1b:	4c 89 54 24 08       	mov    %r10,0x8(%rsp)
  404a20:	4c 89 1c 24          	mov    %r11,(%rsp)
  404a24:	e8 77 79 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  404a29:	49 89 06             	mov    %rax,(%r14)
      __asm__ __volatile__("" ::: "memory");
  404a2c:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
  404a31:	4c 8b 54 24 08       	mov    0x8(%rsp),%r10
  404a36:	4c 8b 1c 24          	mov    (%rsp),%r11
  404a3a:	eb c1                	jmp    4049fd <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x44d>
          b = (Batch*)i;
        b->count = 0;
      }
      b->batch[b->count++] = (void*)i;
      if (b->count == max_count) {
        CHECK_GT(b->count, 0);
  404a3c:	48 8d 15 c1 39 01 00 	lea    0x139c1(%rip),%rdx        # 418404 <.LC6>
  404a43:	48 8d 3d 36 06 01 00 	lea    0x10636(%rip),%rdi        # 415080 <.LC3>
  404a4a:	45 31 c0             	xor    %r8d,%r8d
  404a4d:	31 c9                	xor    %ecx,%ecx
  404a4f:	be 77 03 00 00       	mov    $0x377,%esi
  404a54:	e8 97 09 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    return reinterpret_cast<void*>(meta);
  }

  NOINLINE Batch* AllocateBatch(AllocatorStats *stat, AllocatorCache *c,
                                uptr class_id) {
    CHECK_LT(class_id, kNumClasses);
  404a59:	48 8d 15 98 06 01 00 	lea    0x10698(%rip),%rdx        # 4150f8 <.LC5>
  404a60:	48 8d 3d 19 06 01 00 	lea    0x10619(%rip),%rdi        # 415080 <.LC3>
  404a67:	41 b8 35 00 00 00    	mov    $0x35,%r8d
  404a6d:	be dc 02 00 00       	mov    $0x2dc,%esi
  404a72:	e8 79 09 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
        sci->free_list.push_back(b);
        b = nullptr;
      }
    }
    if (b) {
      CHECK_GT(b->count, 0);
  404a77:	48 8d 15 86 39 01 00 	lea    0x13986(%rip),%rdx        # 418404 <.LC6>
  404a7e:	48 8d 3d fb 05 01 00 	lea    0x105fb(%rip),%rdi        # 415080 <.LC3>
  404a85:	45 31 c0             	xor    %r8d,%r8d
  404a88:	31 c9                	xor    %ecx,%ecx
  404a8a:	be 7d 03 00 00       	mov    $0x37d,%esi
  404a8f:	e8 5c 09 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  404a94:	bf 40 00 00 00       	mov    $0x40,%edi
  404a99:	48 29 c7             	sub    %rax,%rdi
  404a9c:	48 c1 e7 03          	shl    $0x3,%rdi
  404aa0:	48 29 fa             	sub    %rdi,%rdx
  404aa3:	e9 03 fe ff ff       	jmpq   4048ab <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x2fb>
  uptr size2() const { return kSize2; }

  void set(uptr idx, u8 val) {
    CHECK_LT(idx, kSize1 * kSize2);
    u8 *map2 = GetOrCreate(idx / kSize2);
    CHECK_EQ(0U, map2[idx % kSize2]);
  404aa8:	48 8d 15 01 08 01 00 	lea    0x10801(%rip),%rdx        # 4152b0 <.LC16>
  404aaf:	48 8d 3d ca 05 01 00 	lea    0x105ca(%rip),%rdi        # 415080 <.LC3>
  404ab6:	31 c9                	xor    %ecx,%ecx
  404ab8:	be 75 02 00 00       	mov    $0x275,%esi
  404abd:	e8 2e 09 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    CHECK_NE(class_id, 0UL);
    CHECK_LT(class_id, kNumClasses);
    stats_.Add(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
    if (UNLIKELY(c->count == 0))
      Refill(allocator, class_id);
  404ac2:	b2 15                	mov    $0x15,%dl
  404ac4:	4c 89 de             	mov    %r11,%rsi
  404ac7:	4c 89 d7             	mov    %r10,%rdi
  404aca:	4c 89 4c 24 28       	mov    %r9,0x28(%rsp)
  404acf:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  404ad4:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  404ad9:	4c 89 5c 24 10       	mov    %r11,0x10(%rsp)
  404ade:	4c 89 54 24 08       	mov    %r10,0x8(%rsp)
  404ae3:	e8 68 00 00 00       	callq  404b50 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m>
  404ae8:	4c 8b 54 24 08       	mov    0x8(%rsp),%r10
  404aed:	4c 8b 5c 24 10       	mov    0x10(%rsp),%r11
  404af2:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  404af7:	4c 8b 44 24 20       	mov    0x20(%rsp),%r8
  404afc:	4c 8b 4c 24 28       	mov    0x28(%rsp),%r9
  404b01:	49 8b 92 50 55 00 00 	mov    0x5550(%r10),%rdx
  404b08:	e9 44 fe ff ff       	jmpq   404951 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm+0x3a1>
  };
  COMPILER_CHECK(sizeof(SizeClassInfo) == kCacheLineSize);

  uptr ComputeRegionId(uptr mem) {
    uptr res = mem >> kRegionSizeLog;
    CHECK_LT(res, kNumPossibleRegions);
  404b0d:	48 8d 15 74 07 01 00 	lea    0x10774(%rip),%rdx        # 415288 <.LC14>
  404b14:	48 8d 3d 65 05 01 00 	lea    0x10565(%rip),%rdi        # 415080 <.LC3>
  404b1b:	41 b8 00 00 00 08    	mov    $0x8000000,%r8d
  404b21:	4c 89 e1             	mov    %r12,%rcx
  404b24:	be 4e 03 00 00       	mov    $0x34e,%esi
  404b29:	e8 c2 08 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    CHECK_LT(class_id, kNumClasses);
    uptr res = reinterpret_cast<uptr>(MmapAlignedOrDie(kRegionSize, kRegionSize,
                                      "SizeClassAllocator32"));
    MapUnmapCallback().OnMap(res, kRegionSize);
    stat->Add(AllocatorStatMapped, kRegionSize);
    CHECK_EQ(0U, (res & (kRegionSize - 1)));
  404b2e:	48 8d 15 2b 07 01 00 	lea    0x1072b(%rip),%rdx        # 415260 <.LC13>
  404b35:	48 8d 3d 44 05 01 00 	lea    0x10544(%rip),%rdi        # 415080 <.LC3>
  404b3c:	31 c9                	xor    %ecx,%ecx
  404b3e:	be 5c 03 00 00       	mov    $0x35c,%esi
  404b43:	e8 a8 08 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  404b48:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  404b4f:	00 

0000000000404b50 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m>:
      PerClass *c = &per_class_[i];
      c->max_count = 2 * SizeClassMap::MaxCached(i);
    }
  }

  NOINLINE void Refill(SizeClassAllocator *allocator, uptr class_id) {
  404b50:	41 56                	push   %r14
  404b52:	49 89 d6             	mov    %rdx,%r14
  404b55:	41 55                	push   %r13
  404b57:	49 89 fd             	mov    %rdi,%r13
  404b5a:	41 54                	push   %r12
  404b5c:	49 89 f4             	mov    %rsi,%r12
  404b5f:	55                   	push   %rbp
  404b60:	53                   	push   %rbx
  };
  PerClass per_class_[kNumClasses];
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
  404b61:	48 83 bf 18 04 00 00 	cmpq   $0x0,0x418(%rdi)
  404b68:	00 
  404b69:	0f 84 28 01 00 00    	je     404c97 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x147>
    }
  }

  NOINLINE void Refill(SizeClassAllocator *allocator, uptr class_id) {
    InitCache();
    PerClass *c = &per_class_[class_id];
  404b6f:	4c 89 f5             	mov    %r14,%rbp
  404b72:	4c 89 f0             	mov    %r14,%rax
    Batch *b = allocator->AllocateBatch(&stats_, this, class_id);
  404b75:	49 8d b5 50 d7 00 00 	lea    0xd750(%r13),%rsi
    }
  }

  NOINLINE void Refill(SizeClassAllocator *allocator, uptr class_id) {
    InitCache();
    PerClass *c = &per_class_[class_id];
  404b7c:	48 c1 e0 0a          	shl    $0xa,%rax
  404b80:	48 c1 e5 04          	shl    $0x4,%rbp
    Batch *b = allocator->AllocateBatch(&stats_, this, class_id);
  404b84:	4c 89 f1             	mov    %r14,%rcx
  404b87:	4c 89 ea             	mov    %r13,%rdx
  404b8a:	4c 89 e7             	mov    %r12,%rdi
    }
  }

  NOINLINE void Refill(SizeClassAllocator *allocator, uptr class_id) {
    InitCache();
    PerClass *c = &per_class_[class_id];
  404b8d:	48 01 c5             	add    %rax,%rbp
    Batch *b = allocator->AllocateBatch(&stats_, this, class_id);
  404b90:	e8 1b fa ff ff       	callq  4045b0 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E13AllocateBatchEPNS_14AllocatorStatsEPNS_28SizeClassAllocatorLocalCacheIS6_EEm>
  404b95:	48 89 c3             	mov    %rax,%rbx
    CHECK_GT(b->count, 0);
  404b98:	48 8b 40 08          	mov    0x8(%rax),%rax
    }
  }

  NOINLINE void Refill(SizeClassAllocator *allocator, uptr class_id) {
    InitCache();
    PerClass *c = &per_class_[class_id];
  404b9c:	4c 01 ed             	add    %r13,%rbp
    Batch *b = allocator->AllocateBatch(&stats_, this, class_id);
    CHECK_GT(b->count, 0);
  404b9f:	48 85 c0             	test   %rax,%rax
  404ba2:	0f 84 66 02 00 00    	je     404e0e <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x2be>
  404ba8:	45 31 c0             	xor    %r8d,%r8d
  404bab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    for (uptr i = 0; i < b->count; i++)
      c->batch[i] = b->batch[i];
  404bb0:	4e 8b 4c c3 10       	mov    0x10(%rbx,%r8,8),%r9
  404bb5:	4e 89 4c c5 10       	mov    %r9,0x10(%rbp,%r8,8)
  NOINLINE void Refill(SizeClassAllocator *allocator, uptr class_id) {
    InitCache();
    PerClass *c = &per_class_[class_id];
    Batch *b = allocator->AllocateBatch(&stats_, this, class_id);
    CHECK_GT(b->count, 0);
    for (uptr i = 0; i < b->count; i++)
  404bba:	49 83 c0 01          	add    $0x1,%r8
  404bbe:	49 39 c0             	cmp    %rax,%r8
  404bc1:	75 ed                	jne    404bb0 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x60>
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  404bc3:	49 83 fe 10          	cmp    $0x10,%r14
    PerClass *c = &per_class_[class_id];
    Batch *b = allocator->AllocateBatch(&stats_, this, class_id);
    CHECK_GT(b->count, 0);
    for (uptr i = 0; i < b->count; i++)
      c->batch[i] = b->batch[i];
    c->count = b->count;
  404bc7:	4c 89 45 00          	mov    %r8,0x0(%rbp)
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  404bcb:	77 1f                	ja     404bec <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x9c>
      return kMinSize * class_id;
  404bcd:	4c 89 f1             	mov    %r14,%rcx
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
  404bd0:	ba 10 00 00 00       	mov    $0x10,%edx
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
  404bd5:	48 c1 e1 04          	shl    $0x4,%rcx
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
  404bd9:	4d 85 f6             	test   %r14,%r14
  404bdc:	75 33                	jne    404c11 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0xc1>
    Batch *b = allocator->AllocateBatch(&stats_, this, class_id);
    CHECK_GT(b->count, 0);
    for (uptr i = 0; i < b->count; i++)
      c->batch[i] = b->batch[i];
    c->count = b->count;
    if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))
  404bde:	48 39 ca             	cmp    %rcx,%rdx
  404be1:	77 56                	ja     404c39 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0xe9>
      Deallocate(allocator, SizeClassMap::ClassID(sizeof(Batch)), b);
  }
  404be3:	5b                   	pop    %rbx
  404be4:	5d                   	pop    %rbp
  404be5:	41 5c                	pop    %r12
  404be7:	41 5d                	pop    %r13
  404be9:	41 5e                	pop    %r14
  404beb:	c3                   	retq   
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
  404bec:	49 83 ee 10          	sub    $0x10,%r14
    uptr t = kMidSize << (class_id >> S);
  404bf0:	b8 00 01 00 00       	mov    $0x100,%eax
  404bf5:	4c 89 f1             	mov    %r14,%rcx
    return t + (t >> S) * (class_id & M);
  404bf8:	41 83 e6 03          	and    $0x3,%r14d

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  404bfc:	48 c1 e9 02          	shr    $0x2,%rcx
  404c00:	48 d3 e0             	shl    %cl,%rax
    return t + (t >> S) * (class_id & M);
  404c03:	48 89 c1             	mov    %rax,%rcx
  404c06:	48 c1 e9 02          	shr    $0x2,%rcx
  404c0a:	49 0f af ce          	imul   %r14,%rcx
  404c0e:	48 01 c1             	add    %rax,%rcx
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  404c11:	31 d2                	xor    %edx,%edx
  404c13:	b8 00 40 00 00       	mov    $0x4000,%eax
  404c18:	48 f7 f1             	div    %rcx
  return LeastSignificantSetBitIndex(x);
}

// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
  404c1b:	ba 10 02 00 00       	mov    $0x210,%edx
  404c20:	48 83 f8 40          	cmp    $0x40,%rax
  404c24:	77 b8                	ja     404bde <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x8e>
template<class T> T Max(T a, T b) { return a > b ? a : b; }
  404c26:	48 85 c0             	test   %rax,%rax
  404c29:	0f 85 fc 01 00 00    	jne    404e2b <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x2db>
  404c2f:	ba 18 00 00 00       	mov    $0x18,%edx
    Batch *b = allocator->AllocateBatch(&stats_, this, class_id);
    CHECK_GT(b->count, 0);
    for (uptr i = 0; i < b->count; i++)
      c->batch[i] = b->batch[i];
    c->count = b->count;
    if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))
  404c34:	48 39 ca             	cmp    %rcx,%rdx
  404c37:	76 aa                	jbe    404be3 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x93>
  };
  PerClass per_class_[kNumClasses];
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
  404c39:	49 83 bd 18 04 00 00 	cmpq   $0x0,0x418(%r13)
  404c40:	00 
  404c41:	0f 84 e1 00 00 00    	je     404d28 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x1d8>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  404c47:	49 8b 85 60 d7 00 00 	mov    0xd760(%r13),%rax
    // If the first allocator call on a new thread is a deallocation, then
    // max_count will be zero, leading to check failure.
    InitCache();
    stats_.Sub(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
    CHECK_NE(c->max_count, 0UL);
  404c4e:	49 8b 95 58 55 00 00 	mov    0x5558(%r13),%rdx
    v += atomic_load(&stats_[i], memory_order_relaxed);
    atomic_store(&stats_[i], v, memory_order_relaxed);
  }

  void Sub(AllocatorStat i, uptr v) {
    v = atomic_load(&stats_[i], memory_order_relaxed) - v;
  404c55:	48 2d 80 02 00 00    	sub    $0x280,%rax
    // If the first allocator call on a new thread is a deallocation, then
    // max_count will be zero, leading to check failure.
    InitCache();
    stats_.Sub(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
    CHECK_NE(c->max_count, 0UL);
  404c5b:	48 85 d2             	test   %rdx,%rdx
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  404c5e:	49 89 85 60 d7 00 00 	mov    %rax,0xd760(%r13)
  404c65:	0f 84 6a 01 00 00    	je     404dd5 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x285>
    if (UNLIKELY(c->count == c->max_count))
  404c6b:	49 8b 85 50 55 00 00 	mov    0x5550(%r13),%rax
  404c72:	48 39 c2             	cmp    %rax,%rdx
  404c75:	0f 84 77 01 00 00    	je     404df2 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x2a2>
      Drain(allocator, class_id);
    c->batch[c->count++] = p;
  404c7b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  404c7f:	49 89 95 50 55 00 00 	mov    %rdx,0x5550(%r13)
  404c86:	49 89 9c c5 60 55 00 	mov    %rbx,0x5560(%r13,%rax,8)
  404c8d:	00 
    for (uptr i = 0; i < b->count; i++)
      c->batch[i] = b->batch[i];
    c->count = b->count;
    if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))
      Deallocate(allocator, SizeClassMap::ClassID(sizeof(Batch)), b);
  }
  404c8e:	5b                   	pop    %rbx
  404c8f:	5d                   	pop    %rbp
  404c90:	41 5c                	pop    %r12
  404c92:	41 5d                	pop    %r13
  404c94:	41 5e                	pop    %r14
  404c96:	c3                   	retq   
  };
  PerClass per_class_[kNumClasses];
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
  404c97:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  404c9d:	45 31 c0             	xor    %r8d,%r8d
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  404ca0:	41 ba 00 40 00 00    	mov    $0x4000,%r10d

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  404ca6:	41 bb 00 01 00 00    	mov    $0x100,%r11d
  404cac:	eb 47                	jmp    404cf5 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x1a5>
  404cae:	66 90                	xchg   %ax,%ax
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
  404cb0:	4c 89 c6             	mov    %r8,%rsi
  404cb3:	48 c1 e6 04          	shl    $0x4,%rsi
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  404cb7:	31 d2                	xor    %edx,%edx
  404cb9:	4c 89 d0             	mov    %r10,%rax
  404cbc:	48 f7 f6             	div    %rsi
  return LeastSignificantSetBitIndex(x);
}

// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
  404cbf:	ba 80 00 00 00       	mov    $0x80,%edx
  404cc4:	48 83 f8 40          	cmp    $0x40,%rax
  404cc8:	77 0e                	ja     404cd8 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x188>
template<class T> T Max(T a, T b) { return a > b ? a : b; }
  404cca:	48 85 c0             	test   %rax,%rax
  404ccd:	0f 85 6c 01 00 00    	jne    404e3f <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x2ef>
  404cd3:	ba 02 00 00 00       	mov    $0x2,%edx
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
      return;
    for (uptr i = 0; i < kNumClasses; i++) {
  404cd8:	49 83 f9 35          	cmp    $0x35,%r9
      PerClass *c = &per_class_[i];
      c->max_count = 2 * SizeClassMap::MaxCached(i);
  404cdc:	48 89 57 08          	mov    %rdx,0x8(%rdi)
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
      return;
    for (uptr i = 0; i < kNumClasses; i++) {
  404ce0:	0f 84 89 fe ff ff    	je     404b6f <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x1f>
  404ce6:	49 83 c0 01          	add    $0x1,%r8
  404cea:	49 83 c1 01          	add    $0x1,%r9
  404cee:	48 81 c7 10 04 00 00 	add    $0x410,%rdi
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
  404cf5:	4d 85 c0             	test   %r8,%r8
  404cf8:	0f 84 ba 00 00 00    	je     404db8 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x268>
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  404cfe:	49 83 f8 10          	cmp    $0x10,%r8
  404d02:	76 ac                	jbe    404cb0 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x160>
  404d04:	49 8d 50 f0          	lea    -0x10(%r8),%rdx
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  404d08:	4c 89 de             	mov    %r11,%rsi
  404d0b:	48 89 d1             	mov    %rdx,%rcx
    return t + (t >> S) * (class_id & M);
  404d0e:	83 e2 03             	and    $0x3,%edx

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  404d11:	48 c1 e9 02          	shr    $0x2,%rcx
  404d15:	48 d3 e6             	shl    %cl,%rsi
    return t + (t >> S) * (class_id & M);
  404d18:	48 89 f0             	mov    %rsi,%rax
  404d1b:	48 c1 e8 02          	shr    $0x2,%rax
  404d1f:	48 0f af c2          	imul   %rdx,%rax
  404d23:	48 01 c6             	add    %rax,%rsi
  404d26:	eb 8f                	jmp    404cb7 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x167>
  404d28:	4c 89 ef             	mov    %r13,%rdi
  };
  PerClass per_class_[kNumClasses];
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
  404d2b:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  404d31:	31 f6                	xor    %esi,%esi
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  404d33:	41 b9 00 40 00 00    	mov    $0x4000,%r9d

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  404d39:	41 ba 00 01 00 00    	mov    $0x100,%r10d
  404d3f:	eb 48                	jmp    404d89 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x239>
  404d41:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
  404d48:	48 89 f1             	mov    %rsi,%rcx
  404d4b:	48 c1 e1 04          	shl    $0x4,%rcx
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  404d4f:	31 d2                	xor    %edx,%edx
  404d51:	4c 89 c8             	mov    %r9,%rax
  404d54:	48 f7 f1             	div    %rcx
  return LeastSignificantSetBitIndex(x);
}

// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
  404d57:	ba 80 00 00 00       	mov    $0x80,%edx
  404d5c:	48 83 f8 40          	cmp    $0x40,%rax
  404d60:	77 0a                	ja     404d6c <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x21c>
template<class T> T Max(T a, T b) { return a > b ? a : b; }
  404d62:	48 85 c0             	test   %rax,%rax
  404d65:	75 5e                	jne    404dc5 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x275>
  404d67:	ba 02 00 00 00       	mov    $0x2,%edx
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
      return;
    for (uptr i = 0; i < kNumClasses; i++) {
  404d6c:	49 83 f8 35          	cmp    $0x35,%r8
      PerClass *c = &per_class_[i];
      c->max_count = 2 * SizeClassMap::MaxCached(i);
  404d70:	48 89 57 08          	mov    %rdx,0x8(%rdi)
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
      return;
    for (uptr i = 0; i < kNumClasses; i++) {
  404d74:	0f 84 cd fe ff ff    	je     404c47 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0xf7>
  404d7a:	48 83 c6 01          	add    $0x1,%rsi
  404d7e:	49 83 c0 01          	add    $0x1,%r8
  404d82:	48 81 c7 10 04 00 00 	add    $0x410,%rdi
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
  404d89:	48 85 f6             	test   %rsi,%rsi
  404d8c:	74 3d                	je     404dcb <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x27b>
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  404d8e:	48 83 fe 10          	cmp    $0x10,%rsi
  404d92:	76 b4                	jbe    404d48 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x1f8>
  404d94:	48 8d 56 f0          	lea    -0x10(%rsi),%rdx
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  404d98:	4c 89 d0             	mov    %r10,%rax
  404d9b:	48 89 d1             	mov    %rdx,%rcx
    return t + (t >> S) * (class_id & M);
  404d9e:	83 e2 03             	and    $0x3,%edx

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  404da1:	48 c1 e9 02          	shr    $0x2,%rcx
  404da5:	48 d3 e0             	shl    %cl,%rax
  404da8:	48 89 c1             	mov    %rax,%rcx
    return t + (t >> S) * (class_id & M);
  404dab:	48 c1 e8 02          	shr    $0x2,%rax
  404daf:	48 0f af c2          	imul   %rdx,%rax
  404db3:	48 01 c1             	add    %rax,%rcx
  404db6:	eb 97                	jmp    404d4f <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x1ff>
  void InitCache() {
    if (per_class_[1].max_count)
      return;
    for (uptr i = 0; i < kNumClasses; i++) {
      PerClass *c = &per_class_[i];
      c->max_count = 2 * SizeClassMap::MaxCached(i);
  404db8:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  404dbf:	00 
  404dc0:	e9 21 ff ff ff       	jmpq   404ce6 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x196>
  404dc5:	48 8d 14 00          	lea    (%rax,%rax,1),%rdx
  404dc9:	eb a1                	jmp    404d6c <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x21c>
  404dcb:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  404dd2:	00 
  404dd3:	eb a5                	jmp    404d7a <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x22a>
    // If the first allocator call on a new thread is a deallocation, then
    // max_count will be zero, leading to check failure.
    InitCache();
    stats_.Sub(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
    CHECK_NE(c->max_count, 0UL);
  404dd5:	48 8d 15 6f 36 01 00 	lea    0x1366f(%rip),%rdx        # 41844b <.LC18>
  404ddc:	48 8d 3d 9d 02 01 00 	lea    0x1029d(%rip),%rdi        # 415080 <.LC3>
  404de3:	45 31 c0             	xor    %r8d,%r8d
  404de6:	31 c9                	xor    %ecx,%ecx
  404de8:	be ae 03 00 00       	mov    $0x3ae,%esi
  404ded:	e8 fe 05 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    if (UNLIKELY(c->count == c->max_count))
      Drain(allocator, class_id);
  404df2:	ba 15 00 00 00       	mov    $0x15,%edx
  404df7:	4c 89 e6             	mov    %r12,%rsi
  404dfa:	4c 89 ef             	mov    %r13,%rdi
  404dfd:	e8 4e 00 00 00       	callq  404e50 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m>
  404e02:	49 8b 85 50 55 00 00 	mov    0x5550(%r13),%rax
  404e09:	e9 6d fe ff ff       	jmpq   404c7b <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x12b>

  NOINLINE void Refill(SizeClassAllocator *allocator, uptr class_id) {
    InitCache();
    PerClass *c = &per_class_[class_id];
    Batch *b = allocator->AllocateBatch(&stats_, this, class_id);
    CHECK_GT(b->count, 0);
  404e0e:	48 8d 15 ef 35 01 00 	lea    0x135ef(%rip),%rdx        # 418404 <.LC6>
  404e15:	48 8d 3d 64 02 01 00 	lea    0x10264(%rip),%rdi        # 415080 <.LC3>
  404e1c:	45 31 c0             	xor    %r8d,%r8d
  404e1f:	31 c9                	xor    %ecx,%ecx
  404e21:	be d4 03 00 00       	mov    $0x3d4,%esi
  404e26:	e8 c5 05 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  404e2b:	be 40 00 00 00       	mov    $0x40,%esi
  404e30:	48 29 c6             	sub    %rax,%rsi
  404e33:	48 c1 e6 03          	shl    $0x3,%rsi
  404e37:	48 29 f2             	sub    %rsi,%rdx
  404e3a:	e9 9f fd ff ff       	jmpq   404bde <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x8e>
  404e3f:	48 8d 14 00          	lea    (%rax,%rax,1),%rdx
  404e43:	e9 90 fe ff ff       	jmpq   404cd8 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m+0x188>
  404e48:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  404e4f:	00 

0000000000404e50 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m>:
    c->count = b->count;
    if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))
      Deallocate(allocator, SizeClassMap::ClassID(sizeof(Batch)), b);
  }

  NOINLINE void Drain(SizeClassAllocator *allocator, uptr class_id) {
  404e50:	41 55                	push   %r13
  404e52:	49 89 fd             	mov    %rdi,%r13
  404e55:	41 54                	push   %r12
  404e57:	49 89 f4             	mov    %rsi,%r12
  404e5a:	55                   	push   %rbp
  404e5b:	48 89 d5             	mov    %rdx,%rbp
  404e5e:	53                   	push   %rbx
  404e5f:	48 83 ec 08          	sub    $0x8,%rsp
  };
  PerClass per_class_[kNumClasses];
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
  404e63:	48 83 bf 18 04 00 00 	cmpq   $0x0,0x418(%rdi)
  404e6a:	00 
  404e6b:	0f 84 36 01 00 00    	je     404fa7 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x157>
      Deallocate(allocator, SizeClassMap::ClassID(sizeof(Batch)), b);
  }

  NOINLINE void Drain(SizeClassAllocator *allocator, uptr class_id) {
    InitCache();
    PerClass *c = &per_class_[class_id];
  404e71:	48 89 e9             	mov    %rbp,%rcx
  404e74:	48 89 eb             	mov    %rbp,%rbx
  404e77:	48 c1 e1 04          	shl    $0x4,%rcx
  404e7b:	48 c1 e3 0a          	shl    $0xa,%rbx
  404e7f:	48 01 cb             	add    %rcx,%rbx
  404e82:	4c 01 eb             	add    %r13,%rbx
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  404e85:	48 83 fd 10          	cmp    $0x10,%rbp
  404e89:	0f 87 7d 00 00 00    	ja     404f0c <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0xbc>
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
  404e8f:	48 85 ed             	test   %rbp,%rbp
  404e92:	ba 10 00 00 00       	mov    $0x10,%edx
  404e97:	0f 85 93 00 00 00    	jne    404f30 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0xe0>

  NOINLINE void Drain(SizeClassAllocator *allocator, uptr class_id) {
    InitCache();
    PerClass *c = &per_class_[class_id];
    Batch *b;
    if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))
  404e9d:	48 39 d1             	cmp    %rdx,%rcx
  404ea0:	0f 82 ba 00 00 00    	jb     404f60 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x110>
      b = (Batch*)Allocate(allocator, SizeClassMap::ClassID(sizeof(Batch)));
    else
      b = (Batch*)c->batch[0];
  404ea6:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    uptr cnt = Min(c->max_count / 2, c->count);
  404eaa:	48 8b 43 08          	mov    0x8(%rbx),%rax
  404eae:	48 8b 33             	mov    (%rbx),%rsi
  404eb1:	48 d1 e8             	shr    %rax
  404eb4:	49 89 f0             	mov    %rsi,%r8
  404eb7:	48 39 f0             	cmp    %rsi,%rax
  404eba:	4c 0f 46 c0          	cmovbe %rax,%r8
    for (uptr i = 0; i < cnt; i++) {
  404ebe:	4d 85 c0             	test   %r8,%r8
  404ec1:	0f 84 6d 01 00 00    	je     405034 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x1e4>
  404ec7:	4c 8d 0c c3          	lea    (%rbx,%rax,8),%r9
  404ecb:	31 c0                	xor    %eax,%eax
  404ecd:	0f 1f 00             	nopl   (%rax)
      b->batch[i] = c->batch[i];
  404ed0:	48 8b 4c c3 10       	mov    0x10(%rbx,%rax,8),%rcx
  404ed5:	48 89 4c c2 10       	mov    %rcx,0x10(%rdx,%rax,8)
      c->batch[i] = c->batch[i + c->max_count / 2];
  404eda:	49 8b 4c c1 10       	mov    0x10(%r9,%rax,8),%rcx
  404edf:	48 89 4c c3 10       	mov    %rcx,0x10(%rbx,%rax,8)
    if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))
      b = (Batch*)Allocate(allocator, SizeClassMap::ClassID(sizeof(Batch)));
    else
      b = (Batch*)c->batch[0];
    uptr cnt = Min(c->max_count / 2, c->count);
    for (uptr i = 0; i < cnt; i++) {
  404ee4:	48 83 c0 01          	add    $0x1,%rax
  404ee8:	4c 39 c0             	cmp    %r8,%rax
  404eeb:	75 e3                	jne    404ed0 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x80>
      b->batch[i] = c->batch[i];
      c->batch[i] = c->batch[i + c->max_count / 2];
    }
    b->count = cnt;
    c->count -= cnt;
  404eed:	48 29 c6             	sub    %rax,%rsi
    uptr cnt = Min(c->max_count / 2, c->count);
    for (uptr i = 0; i < cnt; i++) {
      b->batch[i] = c->batch[i];
      c->batch[i] = c->batch[i + c->max_count / 2];
    }
    b->count = cnt;
  404ef0:	48 89 42 08          	mov    %rax,0x8(%rdx)
    c->count -= cnt;
    CHECK_GT(b->count, 0);
    allocator->DeallocateBatch(&stats_, class_id, b);
  404ef4:	4c 89 e7             	mov    %r12,%rdi
    for (uptr i = 0; i < cnt; i++) {
      b->batch[i] = c->batch[i];
      c->batch[i] = c->batch[i + c->max_count / 2];
    }
    b->count = cnt;
    c->count -= cnt;
  404ef7:	48 89 33             	mov    %rsi,(%rbx)
    CHECK_GT(b->count, 0);
    allocator->DeallocateBatch(&stats_, class_id, b);
  }
  404efa:	48 83 c4 08          	add    $0x8,%rsp
      c->batch[i] = c->batch[i + c->max_count / 2];
    }
    b->count = cnt;
    c->count -= cnt;
    CHECK_GT(b->count, 0);
    allocator->DeallocateBatch(&stats_, class_id, b);
  404efe:	48 89 ee             	mov    %rbp,%rsi
  }
  404f01:	5b                   	pop    %rbx
  404f02:	5d                   	pop    %rbp
  404f03:	41 5c                	pop    %r12
  404f05:	41 5d                	pop    %r13
      c->batch[i] = c->batch[i + c->max_count / 2];
    }
    b->count = cnt;
    c->count -= cnt;
    CHECK_GT(b->count, 0);
    allocator->DeallocateBatch(&stats_, class_id, b);
  404f07:	e9 34 e1 ff ff       	jmpq   403040 <_ZN11__sanitizer20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES4_E15DeallocateBatchEPNS_14AllocatorStatsEmPNS2_13TransferBatchE.isra.14>
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
  404f0c:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
    uptr t = kMidSize << (class_id >> S);
  404f10:	b8 00 01 00 00       	mov    $0x100,%eax
  404f15:	48 89 d1             	mov    %rdx,%rcx
    return t + (t >> S) * (class_id & M);
  404f18:	83 e2 03             	and    $0x3,%edx

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  404f1b:	48 c1 e9 02          	shr    $0x2,%rcx
  404f1f:	48 d3 e0             	shl    %cl,%rax
    return t + (t >> S) * (class_id & M);
  404f22:	48 89 c1             	mov    %rax,%rcx
  404f25:	48 c1 e9 02          	shr    $0x2,%rcx
  404f29:	48 0f af ca          	imul   %rdx,%rcx
  404f2d:	48 01 c1             	add    %rax,%rcx
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  404f30:	31 d2                	xor    %edx,%edx
  404f32:	b8 00 40 00 00       	mov    $0x4000,%eax
  404f37:	48 f7 f1             	div    %rcx
  return LeastSignificantSetBitIndex(x);
}

// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
  404f3a:	ba 10 02 00 00       	mov    $0x210,%edx
  404f3f:	48 83 f8 40          	cmp    $0x40,%rax
  404f43:	0f 87 54 ff ff ff    	ja     404e9d <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x4d>
template<class T> T Max(T a, T b) { return a > b ? a : b; }
  404f49:	48 85 c0             	test   %rax,%rax
  404f4c:	0f 85 1d 01 00 00    	jne    40506f <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x21f>
  404f52:	ba 18 00 00 00       	mov    $0x18,%edx

  NOINLINE void Drain(SizeClassAllocator *allocator, uptr class_id) {
    InitCache();
    PerClass *c = &per_class_[class_id];
    Batch *b;
    if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))
  404f57:	48 39 d1             	cmp    %rdx,%rcx
  404f5a:	0f 83 46 ff ff ff    	jae    404ea6 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x56>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  404f60:	49 8b 85 60 d7 00 00 	mov    0xd760(%r13),%rax
    internal_memset(this, 0, sizeof(*this));
  }
  void InitLinkerInitialized() {}

  void Add(AllocatorStat i, uptr v) {
    v += atomic_load(&stats_[i], memory_order_relaxed);
  404f67:	48 05 80 02 00 00    	add    $0x280,%rax
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  404f6d:	49 89 85 60 d7 00 00 	mov    %rax,0xd760(%r13)
  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {
    CHECK_NE(class_id, 0UL);
    CHECK_LT(class_id, kNumClasses);
    stats_.Add(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
    if (UNLIKELY(c->count == 0))
  404f74:	49 8b 85 50 55 00 00 	mov    0x5550(%r13),%rax
  404f7b:	48 85 c0             	test   %rax,%rax
  404f7e:	0f 84 ff 00 00 00    	je     405083 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x233>
      Refill(allocator, class_id);
    void *res = c->batch[--c->count];
  404f84:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  404f88:	49 89 95 50 55 00 00 	mov    %rdx,0x5550(%r13)
  404f8f:	49 8b 94 c5 58 55 00 	mov    0x5558(%r13,%rax,8),%rdx
  404f96:	00 
    PREFETCH(c->batch[c->count - 1]);
  404f97:	49 8b 84 c5 50 55 00 	mov    0x5550(%r13,%rax,8),%rax
  404f9e:	00 
  404f9f:	0f 18 00             	prefetchnta (%rax)
  404fa2:	e9 03 ff ff ff       	jmpq   404eaa <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x5a>
  404fa7:	48 89 fe             	mov    %rdi,%rsi
  };
  PerClass per_class_[kNumClasses];
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
  404faa:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  404fb0:	45 31 c0             	xor    %r8d,%r8d
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  404fb3:	bf 00 40 00 00       	mov    $0x4000,%edi

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  404fb8:	41 ba 00 01 00 00    	mov    $0x100,%r10d
  404fbe:	eb 45                	jmp    405005 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x1b5>
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
  404fc0:	4c 89 c1             	mov    %r8,%rcx
  404fc3:	48 c1 e1 04          	shl    $0x4,%rcx
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);
  404fc7:	31 d2                	xor    %edx,%edx
  404fc9:	48 89 f8             	mov    %rdi,%rax
  404fcc:	48 f7 f1             	div    %rcx
  return LeastSignificantSetBitIndex(x);
}

// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
  404fcf:	ba 80 00 00 00       	mov    $0x80,%edx
  404fd4:	48 83 f8 40          	cmp    $0x40,%rax
  404fd8:	77 0e                	ja     404fe8 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x198>
template<class T> T Max(T a, T b) { return a > b ? a : b; }
  404fda:	48 85 c0             	test   %rax,%rax
  404fdd:	0f 85 83 00 00 00    	jne    405066 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x216>
  404fe3:	ba 02 00 00 00       	mov    $0x2,%edx
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
      return;
    for (uptr i = 0; i < kNumClasses; i++) {
  404fe8:	49 83 f9 35          	cmp    $0x35,%r9
      PerClass *c = &per_class_[i];
      c->max_count = 2 * SizeClassMap::MaxCached(i);
  404fec:	48 89 56 08          	mov    %rdx,0x8(%rsi)
  AllocatorStats stats_;

  void InitCache() {
    if (per_class_[1].max_count)
      return;
    for (uptr i = 0; i < kNumClasses; i++) {
  404ff0:	0f 84 7b fe ff ff    	je     404e71 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x21>
  404ff6:	49 83 c0 01          	add    $0x1,%r8
  404ffa:	49 83 c1 01          	add    $0x1,%r9
  404ffe:	48 81 c6 10 04 00 00 	add    $0x410,%rsi
    uptr l1 = l - kMidSizeLog;
    return kMidClass + (l1 << S) + hbits + (lbits > 0);
  }

  static uptr MaxCached(uptr class_id) {
    if (class_id == 0) return 0;
  405005:	4d 85 c0             	test   %r8,%r8
  405008:	74 52                	je     40505c <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x20c>
      kNumClasses == 32  ? 32 :
      kNumClasses <= 64  ? 64 :
      kNumClasses <= 128 ? 128 : 256;

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
  40500a:	49 83 f8 10          	cmp    $0x10,%r8
  40500e:	76 b0                	jbe    404fc0 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x170>
  405010:	49 8d 50 f0          	lea    -0x10(%r8),%rdx
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  405014:	4c 89 d0             	mov    %r10,%rax
  405017:	48 89 d1             	mov    %rdx,%rcx
    return t + (t >> S) * (class_id & M);
  40501a:	83 e2 03             	and    $0x3,%edx

  static uptr Size(uptr class_id) {
    if (class_id <= kMidClass)
      return kMinSize * class_id;
    class_id -= kMidClass;
    uptr t = kMidSize << (class_id >> S);
  40501d:	48 c1 e9 02          	shr    $0x2,%rcx
  405021:	48 d3 e0             	shl    %cl,%rax
  405024:	48 89 c1             	mov    %rax,%rcx
    return t + (t >> S) * (class_id & M);
  405027:	48 c1 e8 02          	shr    $0x2,%rax
  40502b:	48 0f af c2          	imul   %rdx,%rax
  40502f:	48 01 c1             	add    %rax,%rcx
  405032:	eb 93                	jmp    404fc7 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x177>
    uptr cnt = Min(c->max_count / 2, c->count);
    for (uptr i = 0; i < cnt; i++) {
      b->batch[i] = c->batch[i];
      c->batch[i] = c->batch[i + c->max_count / 2];
    }
    b->count = cnt;
  405034:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
  40503b:	00 
    c->count -= cnt;
    CHECK_GT(b->count, 0);
  40503c:	48 8d 3d 3d 00 01 00 	lea    0x1003d(%rip),%rdi        # 415080 <.LC3>
  405043:	48 8d 15 ba 33 01 00 	lea    0x133ba(%rip),%rdx        # 418404 <.LC6>
    for (uptr i = 0; i < cnt; i++) {
      b->batch[i] = c->batch[i];
      c->batch[i] = c->batch[i + c->max_count / 2];
    }
    b->count = cnt;
    c->count -= cnt;
  40504a:	48 89 33             	mov    %rsi,(%rbx)
    CHECK_GT(b->count, 0);
  40504d:	45 31 c0             	xor    %r8d,%r8d
  405050:	31 c9                	xor    %ecx,%ecx
  405052:	be eb 03 00 00       	mov    $0x3eb,%esi
  405057:	e8 94 03 00 00       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  void InitCache() {
    if (per_class_[1].max_count)
      return;
    for (uptr i = 0; i < kNumClasses; i++) {
      PerClass *c = &per_class_[i];
      c->max_count = 2 * SizeClassMap::MaxCached(i);
  40505c:	48 c7 46 08 00 00 00 	movq   $0x0,0x8(%rsi)
  405063:	00 
  405064:	eb 90                	jmp    404ff6 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x1a6>
  405066:	48 8d 14 00          	lea    (%rax,%rax,1),%rdx
  40506a:	e9 79 ff ff ff       	jmpq   404fe8 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x198>
  40506f:	be 40 00 00 00       	mov    $0x40,%esi
  405074:	48 29 c6             	sub    %rax,%rsi
  405077:	48 c1 e6 03          	shl    $0x3,%rsi
  40507b:	48 29 f2             	sub    %rsi,%rdx
  40507e:	e9 1a fe ff ff       	jmpq   404e9d <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x4d>
    CHECK_NE(class_id, 0UL);
    CHECK_LT(class_id, kNumClasses);
    stats_.Add(AllocatorStatAllocated, SizeClassMap::Size(class_id));
    PerClass *c = &per_class_[class_id];
    if (UNLIKELY(c->count == 0))
      Refill(allocator, class_id);
  405083:	ba 15 00 00 00       	mov    $0x15,%edx
  405088:	4c 89 e6             	mov    %r12,%rsi
  40508b:	4c 89 ef             	mov    %r13,%rdi
  40508e:	e8 bd fa ff ff       	callq  404b50 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE6RefillEPS7_m>
  405093:	49 8b 85 50 55 00 00 	mov    0x5550(%r13),%rax
  40509a:	e9 e5 fe ff ff       	jmpq   404f84 <_ZN11__sanitizer28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEE5DrainEPS7_m+0x134>
  40509f:	90                   	nop

00000000004050a0 <_ZN11__sanitizerL11CompareLessImEEbRKT_S3_>:

typedef bool UptrComparisonFunction(const uptr &a, const uptr &b);

template<class T>
static inline bool CompareLess(const T &a, const T &b) {
  return a < b;
  4050a0:	48 8b 06             	mov    (%rsi),%rax
  4050a3:	48 39 07             	cmp    %rax,(%rdi)
  4050a6:	0f 92 c0             	setb   %al
}
  4050a9:	c3                   	retq   
  4050aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000004050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>:

atomic_uint32_t current_verbosity;

uptr GetPageSizeCached() {
  static uptr PageSize;
  if (!PageSize)
  4050b0:	48 8b 05 69 a6 26 00 	mov    0x26a669(%rip),%rax        # 66f720 <_ZZN11__sanitizer17GetPageSizeCachedEvE8PageSize>
  4050b7:	48 85 c0             	test   %rax,%rax
  4050ba:	74 04                	je     4050c0 <_ZN11__sanitizer17GetPageSizeCachedEv+0x10>
    PageSize = GetPageSize();
  return PageSize;
}
  4050bc:	c3                   	retq   
  4050bd:	0f 1f 00             	nopl   (%rax)

const char *SanitizerToolName = "SanitizerTool";

atomic_uint32_t current_verbosity;

uptr GetPageSizeCached() {
  4050c0:	48 83 ec 08          	sub    $0x8,%rsp
  static uptr PageSize;
  if (!PageSize)
    PageSize = GetPageSize();
  4050c4:	e8 87 6d 00 00       	callq  40be50 <_ZN11__sanitizer11GetPageSizeEv>
  4050c9:	48 89 05 50 a6 26 00 	mov    %rax,0x26a650(%rip)        # 66f720 <_ZZN11__sanitizer17GetPageSizeCachedEvE8PageSize>
  return PageSize;
}
  4050d0:	48 83 c4 08          	add    $0x8,%rsp
  4050d4:	c3                   	retq   
  4050d5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  4050dc:	00 00 00 00 

00000000004050e0 <_ZN11__sanitizer8RawWriteEPKc>:

StaticSpinMutex report_file_mu;
ReportFile report_file = {&report_file_mu, kStderrFd, "", "", 0};

void RawWrite(const char *buffer) {
  4050e0:	53                   	push   %rbx
  4050e1:	48 89 fb             	mov    %rdi,%rbx
  report_file.Write(buffer, internal_strlen(buffer));
  4050e4:	e8 47 58 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  4050e9:	48 89 de             	mov    %rbx,%rsi
  4050ec:	48 8d 3d 4d 93 01 00 	lea    0x1934d(%rip),%rdi        # 41e440 <_ZN11__sanitizer11report_fileE>
  4050f3:	48 89 c2             	mov    %rax,%rdx
}
  4050f6:	5b                   	pop    %rbx

StaticSpinMutex report_file_mu;
ReportFile report_file = {&report_file_mu, kStderrFd, "", "", 0};

void RawWrite(const char *buffer) {
  report_file.Write(buffer, internal_strlen(buffer));
  4050f7:	e9 24 7b 00 00       	jmpq   40cc20 <_ZN11__sanitizer10ReportFile5WriteEPKcm>
  4050fc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000405100 <_ZN11__sanitizer14AddDieCallbackEPFvvE>:
static const int kMaxNumOfInternalDieCallbacks = 5;
static DieCallbackType InternalDieCallbacks[kMaxNumOfInternalDieCallbacks];

bool AddDieCallback(DieCallbackType callback) {
  for (int i = 0; i < kMaxNumOfInternalDieCallbacks; i++) {
    if (InternalDieCallbacks[i] == nullptr) {
  405100:	48 83 3d 78 c6 26 00 	cmpq   $0x0,0x26c678(%rip)        # 671780 <_ZN11__sanitizerL20InternalDieCallbacksE>
  405107:	00 
  405108:	74 56                	je     405160 <_ZN11__sanitizer14AddDieCallbackEPFvvE+0x60>
  40510a:	48 83 3d 76 c6 26 00 	cmpq   $0x0,0x26c676(%rip)        # 671788 <_ZN11__sanitizerL20InternalDieCallbacksE+0x8>
  405111:	00 
  405112:	74 54                	je     405168 <_ZN11__sanitizer14AddDieCallbackEPFvvE+0x68>
  405114:	48 83 3d 74 c6 26 00 	cmpq   $0x0,0x26c674(%rip)        # 671790 <_ZN11__sanitizerL20InternalDieCallbacksE+0x10>
  40511b:	00 
  40511c:	74 52                	je     405170 <_ZN11__sanitizer14AddDieCallbackEPFvvE+0x70>
  40511e:	48 83 3d 72 c6 26 00 	cmpq   $0x0,0x26c672(%rip)        # 671798 <_ZN11__sanitizerL20InternalDieCallbacksE+0x18>
  405125:	00 
  405126:	74 58                	je     405180 <_ZN11__sanitizer14AddDieCallbackEPFvvE+0x80>
      InternalDieCallbacks[i] = callback;
      return true;
    }
  }
  return false;
  405128:	31 c0                	xor    %eax,%eax
static const int kMaxNumOfInternalDieCallbacks = 5;
static DieCallbackType InternalDieCallbacks[kMaxNumOfInternalDieCallbacks];

bool AddDieCallback(DieCallbackType callback) {
  for (int i = 0; i < kMaxNumOfInternalDieCallbacks; i++) {
    if (InternalDieCallbacks[i] == nullptr) {
  40512a:	48 83 3d 6e c6 26 00 	cmpq   $0x0,0x26c66e(%rip)        # 6717a0 <_ZN11__sanitizerL20InternalDieCallbacksE+0x20>
  405131:	00 
  405132:	74 0c                	je     405140 <_ZN11__sanitizer14AddDieCallbackEPFvvE+0x40>
      InternalDieCallbacks[i] = callback;
      return true;
    }
  }
  return false;
}
  405134:	f3 c3                	repz retq 
  405136:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40513d:	00 00 00 

static const int kMaxNumOfInternalDieCallbacks = 5;
static DieCallbackType InternalDieCallbacks[kMaxNumOfInternalDieCallbacks];

bool AddDieCallback(DieCallbackType callback) {
  for (int i = 0; i < kMaxNumOfInternalDieCallbacks; i++) {
  405140:	b8 04 00 00 00       	mov    $0x4,%eax
  405145:	0f 1f 00             	nopl   (%rax)
    if (InternalDieCallbacks[i] == nullptr) {
      InternalDieCallbacks[i] = callback;
  405148:	48 8d 15 31 c6 26 00 	lea    0x26c631(%rip),%rdx        # 671780 <_ZN11__sanitizerL20InternalDieCallbacksE>
  40514f:	48 89 3c c2          	mov    %rdi,(%rdx,%rax,8)
      return true;
  405153:	b8 01 00 00 00       	mov    $0x1,%eax
    }
  }
  return false;
}
  405158:	c3                   	retq   
  405159:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

static const int kMaxNumOfInternalDieCallbacks = 5;
static DieCallbackType InternalDieCallbacks[kMaxNumOfInternalDieCallbacks];

bool AddDieCallback(DieCallbackType callback) {
  for (int i = 0; i < kMaxNumOfInternalDieCallbacks; i++) {
  405160:	31 c0                	xor    %eax,%eax
  405162:	eb e4                	jmp    405148 <_ZN11__sanitizer14AddDieCallbackEPFvvE+0x48>
  405164:	0f 1f 40 00          	nopl   0x0(%rax)
  405168:	b8 01 00 00 00       	mov    $0x1,%eax
  40516d:	eb d9                	jmp    405148 <_ZN11__sanitizer14AddDieCallbackEPFvvE+0x48>
  40516f:	90                   	nop
  405170:	b8 02 00 00 00       	mov    $0x2,%eax
  405175:	eb d1                	jmp    405148 <_ZN11__sanitizer14AddDieCallbackEPFvvE+0x48>
  405177:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40517e:	00 00 
  405180:	b8 03 00 00 00       	mov    $0x3,%eax
  405185:	eb c1                	jmp    405148 <_ZN11__sanitizer14AddDieCallbackEPFvvE+0x48>
  405187:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40518e:	00 00 

0000000000405190 <_ZN11__sanitizer17RemoveDieCallbackEPFvvE>:
    }
  }
  return false;
}

bool RemoveDieCallback(DieCallbackType callback) {
  405190:	48 83 ec 08          	sub    $0x8,%rsp
  for (int i = 0; i < kMaxNumOfInternalDieCallbacks; i++) {
    if (InternalDieCallbacks[i] == callback) {
  405194:	48 39 3d e5 c5 26 00 	cmp    %rdi,0x26c5e5(%rip)        # 671780 <_ZN11__sanitizerL20InternalDieCallbacksE>
  40519b:	74 33                	je     4051d0 <_ZN11__sanitizer17RemoveDieCallbackEPFvvE+0x40>
  40519d:	48 39 3d e4 c5 26 00 	cmp    %rdi,0x26c5e4(%rip)        # 671788 <_ZN11__sanitizerL20InternalDieCallbacksE+0x8>
  4051a4:	74 6a                	je     405210 <_ZN11__sanitizer17RemoveDieCallbackEPFvvE+0x80>
  4051a6:	48 39 3d e3 c5 26 00 	cmp    %rdi,0x26c5e3(%rip)        # 671790 <_ZN11__sanitizerL20InternalDieCallbacksE+0x10>
  4051ad:	74 71                	je     405220 <_ZN11__sanitizer17RemoveDieCallbackEPFvvE+0x90>
  4051af:	48 39 3d e2 c5 26 00 	cmp    %rdi,0x26c5e2(%rip)        # 671798 <_ZN11__sanitizerL20InternalDieCallbacksE+0x18>
  4051b6:	74 78                	je     405230 <_ZN11__sanitizer17RemoveDieCallbackEPFvvE+0xa0>
                           (kMaxNumOfInternalDieCallbacks - i - 1));
      InternalDieCallbacks[kMaxNumOfInternalDieCallbacks - 1] = nullptr;
      return true;
    }
  }
  return false;
  4051b8:	31 c0                	xor    %eax,%eax
  return false;
}

bool RemoveDieCallback(DieCallbackType callback) {
  for (int i = 0; i < kMaxNumOfInternalDieCallbacks; i++) {
    if (InternalDieCallbacks[i] == callback) {
  4051ba:	48 39 3d df c5 26 00 	cmp    %rdi,0x26c5df(%rip)        # 6717a0 <_ZN11__sanitizerL20InternalDieCallbacksE+0x20>
  4051c1:	74 7d                	je     405240 <_ZN11__sanitizer17RemoveDieCallbackEPFvvE+0xb0>
      InternalDieCallbacks[kMaxNumOfInternalDieCallbacks - 1] = nullptr;
      return true;
    }
  }
  return false;
}
  4051c3:	48 83 c4 08          	add    $0x8,%rsp
  4051c7:	c3                   	retq   
  4051c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4051cf:	00 
  }
  return false;
}

bool RemoveDieCallback(DieCallbackType callback) {
  for (int i = 0; i < kMaxNumOfInternalDieCallbacks; i++) {
  4051d0:	31 c0                	xor    %eax,%eax
    if (InternalDieCallbacks[i] == callback) {
      internal_memmove(&InternalDieCallbacks[i], &InternalDieCallbacks[i + 1],
  4051d2:	8d 70 01             	lea    0x1(%rax),%esi
                       sizeof(InternalDieCallbacks[0]) *
                           (kMaxNumOfInternalDieCallbacks - i - 1));
  4051d5:	48 8d 0d a4 c5 26 00 	lea    0x26c5a4(%rip),%rcx        # 671780 <_ZN11__sanitizerL20InternalDieCallbacksE>
  4051dc:	ba 04 00 00 00       	mov    $0x4,%edx
  4051e1:	29 c2                	sub    %eax,%edx
  4051e3:	48 63 f6             	movslq %esi,%rsi
  4051e6:	48 63 d2             	movslq %edx,%rdx
  4051e9:	48 8d 3c c1          	lea    (%rcx,%rax,8),%rdi
  4051ed:	48 8d 34 f1          	lea    (%rcx,%rsi,8),%rsi
  4051f1:	48 c1 e2 03          	shl    $0x3,%rdx
  4051f5:	e8 e6 4e 00 00       	callq  40a0e0 <_ZN11__sanitizer16internal_memmoveEPvPKvm>
      InternalDieCallbacks[kMaxNumOfInternalDieCallbacks - 1] = nullptr;
  4051fa:	48 c7 05 9b c5 26 00 	movq   $0x0,0x26c59b(%rip)        # 6717a0 <_ZN11__sanitizerL20InternalDieCallbacksE+0x20>
  405201:	00 00 00 00 
      return true;
  405205:	b8 01 00 00 00       	mov    $0x1,%eax
    }
  }
  return false;
}
  40520a:	48 83 c4 08          	add    $0x8,%rsp
  40520e:	c3                   	retq   
  40520f:	90                   	nop
  }
  return false;
}

bool RemoveDieCallback(DieCallbackType callback) {
  for (int i = 0; i < kMaxNumOfInternalDieCallbacks; i++) {
  405210:	b8 01 00 00 00       	mov    $0x1,%eax
  405215:	eb bb                	jmp    4051d2 <_ZN11__sanitizer17RemoveDieCallbackEPFvvE+0x42>
  405217:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40521e:	00 00 
  405220:	b8 02 00 00 00       	mov    $0x2,%eax
  405225:	eb ab                	jmp    4051d2 <_ZN11__sanitizer17RemoveDieCallbackEPFvvE+0x42>
  405227:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40522e:	00 00 
  405230:	b8 03 00 00 00       	mov    $0x3,%eax
  405235:	eb 9b                	jmp    4051d2 <_ZN11__sanitizer17RemoveDieCallbackEPFvvE+0x42>
  405237:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40523e:	00 00 
  405240:	b8 04 00 00 00       	mov    $0x4,%eax
  405245:	eb 8b                	jmp    4051d2 <_ZN11__sanitizer17RemoveDieCallbackEPFvvE+0x42>
  405247:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40524e:	00 00 

0000000000405250 <_ZN11__sanitizer18SetUserDieCallbackEPFvvE>:
  return false;
}

static DieCallbackType UserDieCallback;
void SetUserDieCallback(DieCallbackType callback) {
  UserDieCallback = callback;
  405250:	48 89 3d 09 c5 26 00 	mov    %rdi,0x26c509(%rip)        # 671760 <_ZN11__sanitizerL15UserDieCallbackE>
  405257:	c3                   	retq   
  405258:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40525f:	00 

0000000000405260 <_ZN11__sanitizer3DieEv>:
}

void NORETURN Die() {
  405260:	55                   	push   %rbp
  405261:	53                   	push   %rbx
  405262:	48 83 ec 08          	sub    $0x8,%rsp
  if (UserDieCallback)
  405266:	48 8b 05 f3 c4 26 00 	mov    0x26c4f3(%rip),%rax        # 671760 <_ZN11__sanitizerL15UserDieCallbackE>
  40526d:	48 85 c0             	test   %rax,%rax
  405270:	74 02                	je     405274 <_ZN11__sanitizer3DieEv+0x14>
    UserDieCallback();
  405272:	ff d0                	callq  *%rax
  405274:	48 8d 1d 25 c5 26 00 	lea    0x26c525(%rip),%rbx        # 6717a0 <_ZN11__sanitizerL20InternalDieCallbacksE+0x20>
  40527b:	48 8d 2d f6 c4 26 00 	lea    0x26c4f6(%rip),%rbp        # 671778 <_ZN11__sanitizerL15UserDieCallbackE+0x18>
  for (int i = kMaxNumOfInternalDieCallbacks - 1; i >= 0; i--) {
    if (InternalDieCallbacks[i])
  405282:	48 8b 03             	mov    (%rbx),%rax
  405285:	48 85 c0             	test   %rax,%rax
  405288:	74 02                	je     40528c <_ZN11__sanitizer3DieEv+0x2c>
      InternalDieCallbacks[i]();
  40528a:	ff d0                	callq  *%rax
  40528c:	48 83 eb 08          	sub    $0x8,%rbx
}

void NORETURN Die() {
  if (UserDieCallback)
    UserDieCallback();
  for (int i = kMaxNumOfInternalDieCallbacks - 1; i >= 0; i--) {
  405290:	48 39 eb             	cmp    %rbp,%rbx
  405293:	75 ed                	jne    405282 <_ZN11__sanitizer3DieEv+0x22>
    if (InternalDieCallbacks[i])
      InternalDieCallbacks[i]();
  }
  if (common_flags()->abort_on_error)
  405295:	48 8b 05 1c 90 01 00 	mov    0x1901c(%rip),%rax        # 41e2b8 <_DYNAMIC+0x2b8>
  40529c:	80 b8 a4 00 00 00 00 	cmpb   $0x0,0xa4(%rax)
  4052a3:	74 05                	je     4052aa <_ZN11__sanitizer3DieEv+0x4a>
    Abort();
  4052a5:	e8 36 d2 00 00       	callq  4124e0 <_ZN11__sanitizer5AbortEv>
  internal__exit(common_flags()->exitcode);
  4052aa:	8b b8 a0 00 00 00    	mov    0xa0(%rax),%edi
  4052b0:	e8 7b 63 00 00       	callq  40b630 <_ZN11__sanitizer14internal__exitEi>
  4052b5:	90                   	nop
  4052b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4052bd:	00 00 00 

00000000004052c0 <_ZN11__sanitizer10ReportFile13SetReportPathEPKc>:
    Die();
  }
  fd_pid = pid;
}

void ReportFile::SetReportPath(const char *path) {
  4052c0:	41 54                	push   %r12
  4052c2:	55                   	push   %rbp
  4052c3:	48 89 f5             	mov    %rsi,%rbp
  4052c6:	53                   	push   %rbx
  4052c7:	48 83 ec 20          	sub    $0x20,%rsp
  if (!path)
  4052cb:	48 85 f6             	test   %rsi,%rsi
  4052ce:	74 58                	je     405328 <_ZN11__sanitizer10ReportFile13SetReportPathEPKc+0x68>
  4052d0:	48 89 fb             	mov    %rdi,%rbx
    return;
  uptr len = internal_strlen(path);
  4052d3:	48 89 f7             	mov    %rsi,%rdi
  4052d6:	e8 55 56 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  if (len > sizeof(path_prefix) - 100) {
  4052db:	48 3d 9c 0f 00 00    	cmp    $0xf9c,%rax
  4052e1:	0f 87 b5 00 00 00    	ja     40539c <_ZN11__sanitizer10ReportFile13SetReportPathEPKc+0xdc>
           path[0], path[1], path[2], path[3],
           path[4], path[5], path[6], path[7]);
    Die();
  }

  SpinMutexLock l(mu);
  4052e7:	4c 8b 23             	mov    (%rbx),%r12
  4052ea:	b8 01 00 00 00       	mov    $0x1,%eax
  4052ef:	41 86 04 24          	xchg   %al,(%r12)
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  4052f3:	84 c0                	test   %al,%al
  4052f5:	75 41                	jne    405338 <_ZN11__sanitizer10ReportFile13SetReportPathEPKc+0x78>
  if (fd != kStdoutFd && fd != kStderrFd && fd != kInvalidFd)
  4052f7:	8b 7b 08             	mov    0x8(%rbx),%edi
  4052fa:	8d 47 ff             	lea    -0x1(%rdi),%eax
  4052fd:	83 f8 01             	cmp    $0x1,%eax
  405300:	77 49                	ja     40534b <_ZN11__sanitizer10ReportFile13SetReportPathEPKc+0x8b>
    CloseFile(fd);
  fd = kInvalidFd;
  if (internal_strcmp(path, "stdout") == 0) {
  405302:	48 8d 35 fb 31 01 00 	lea    0x131fb(%rip),%rsi        # 418504 <.LC1>
  }

  SpinMutexLock l(mu);
  if (fd != kStdoutFd && fd != kStderrFd && fd != kInvalidFd)
    CloseFile(fd);
  fd = kInvalidFd;
  405309:	c7 43 08 ff ff ff ff 	movl   $0xffffffff,0x8(%rbx)
  if (internal_strcmp(path, "stdout") == 0) {
  405310:	48 89 ef             	mov    %rbp,%rdi
  405313:	e8 c8 54 00 00       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
  405318:	85 c0                	test   %eax,%eax
  40531a:	75 44                	jne    405360 <_ZN11__sanitizer10ReportFile13SetReportPathEPKc+0xa0>
    fd = kStdoutFd;
  40531c:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%rbx)
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  405323:	41 c6 04 24 00       	movb   $0x0,(%r12)
  } else if (internal_strcmp(path, "stderr") == 0) {
    fd = kStderrFd;
  } else {
    internal_snprintf(path_prefix, kMaxPathLength, "%s", path);
  }
}
  405328:	48 83 c4 20          	add    $0x20,%rsp
  40532c:	5b                   	pop    %rbx
  40532d:	5d                   	pop    %rbp
  40532e:	41 5c                	pop    %r12
  405330:	c3                   	retq   
  405331:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      return;
    LockSlow();
  405338:	4c 89 e7             	mov    %r12,%rdi
  40533b:	e8 10 f2 ff ff       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
           path[4], path[5], path[6], path[7]);
    Die();
  }

  SpinMutexLock l(mu);
  if (fd != kStdoutFd && fd != kStderrFd && fd != kInvalidFd)
  405340:	8b 7b 08             	mov    0x8(%rbx),%edi
  405343:	8d 47 ff             	lea    -0x1(%rdi),%eax
  405346:	83 f8 01             	cmp    $0x1,%eax
  405349:	76 b7                	jbe    405302 <_ZN11__sanitizer10ReportFile13SetReportPathEPKc+0x42>
  40534b:	83 ff ff             	cmp    $0xffffffff,%edi
  40534e:	74 b2                	je     405302 <_ZN11__sanitizer10ReportFile13SetReportPathEPKc+0x42>
    CloseFile(fd);
  405350:	e8 5b 73 00 00       	callq  40c6b0 <_ZN11__sanitizer9CloseFileEi>
  405355:	eb ab                	jmp    405302 <_ZN11__sanitizer10ReportFile13SetReportPathEPKc+0x42>
  405357:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40535e:	00 00 
  fd = kInvalidFd;
  if (internal_strcmp(path, "stdout") == 0) {
    fd = kStdoutFd;
  } else if (internal_strcmp(path, "stderr") == 0) {
  405360:	48 8d 35 a4 31 01 00 	lea    0x131a4(%rip),%rsi        # 41850b <.LC13>
  405367:	48 89 ef             	mov    %rbp,%rdi
  40536a:	e8 71 54 00 00       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
  40536f:	85 c0                	test   %eax,%eax
  405371:	75 0d                	jne    405380 <_ZN11__sanitizer10ReportFile13SetReportPathEPKc+0xc0>
    fd = kStderrFd;
  405373:	c7 43 08 02 00 00 00 	movl   $0x2,0x8(%rbx)
  40537a:	eb a7                	jmp    405323 <_ZN11__sanitizer10ReportFile13SetReportPathEPKc+0x63>
  40537c:	0f 1f 40 00          	nopl   0x0(%rax)
  } else {
    internal_snprintf(path_prefix, kMaxPathLength, "%s", path);
  405380:	48 8d 7b 0c          	lea    0xc(%rbx),%rdi
  405384:	48 8d 15 87 31 01 00 	lea    0x13187(%rip),%rdx        # 418512 <.LC18>
  40538b:	48 89 e9             	mov    %rbp,%rcx
  40538e:	be 00 10 00 00       	mov    $0x1000,%esi
  405393:	31 c0                	xor    %eax,%eax
  405395:	e8 26 83 00 00       	callq  40d6c0 <_ZN11__sanitizer17internal_snprintfEPcmPKcz>
  40539a:	eb 87                	jmp    405323 <_ZN11__sanitizer10ReportFile13SetReportPathEPKc+0x63>
    return;
  uptr len = internal_strlen(path);
  if (len > sizeof(path_prefix) - 100) {
    Report("ERROR: Path is too long: %c%c%c%c%c%c%c%c...\n",
           path[0], path[1], path[2], path[3],
           path[4], path[5], path[6], path[7]);
  40539c:	0f be 45 07          	movsbl 0x7(%rbp),%eax
  4053a0:	44 0f be 4d 04       	movsbl 0x4(%rbp),%r9d
  4053a5:	48 8d 3d 9c 00 01 00 	lea    0x1009c(%rip),%rdi        # 415448 <.LC0>
  4053ac:	44 0f be 45 03       	movsbl 0x3(%rbp),%r8d
  4053b1:	0f be 4d 02          	movsbl 0x2(%rbp),%ecx
  4053b5:	0f be 55 01          	movsbl 0x1(%rbp),%edx
  4053b9:	0f be 75 00          	movsbl 0x0(%rbp),%esi
  4053bd:	89 44 24 10          	mov    %eax,0x10(%rsp)
  4053c1:	0f be 45 06          	movsbl 0x6(%rbp),%eax
  4053c5:	89 44 24 08          	mov    %eax,0x8(%rsp)
  4053c9:	0f be 45 05          	movsbl 0x5(%rbp),%eax
  4053cd:	89 04 24             	mov    %eax,(%rsp)
  4053d0:	31 c0                	xor    %eax,%eax
  4053d2:	e8 b9 86 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
    Die();
  4053d7:	e8 84 fe ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  4053dc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000004053e0 <_ZN11__sanitizer22SetCheckFailedCallbackEPFvPKciS1_yyE>:
  internal__exit(common_flags()->exitcode);
}

static CheckFailedCallbackType CheckFailedCallback;
void SetCheckFailedCallback(CheckFailedCallbackType callback) {
  CheckFailedCallback = callback;
  4053e0:	48 89 3d 69 c3 26 00 	mov    %rdi,0x26c369(%rip)        # 671750 <_ZN11__sanitizerL19CheckFailedCallbackE>
  4053e7:	c3                   	retq   
  4053e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4053ef:	00 

00000000004053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>:
}

void NORETURN CheckFailed(const char *file, int line, const char *cond,
                          u64 v1, u64 v2) {
  4053f0:	41 56                	push   %r14
  if (CheckFailedCallback) {
  4053f2:	48 8b 05 57 c3 26 00 	mov    0x26c357(%rip),%rax        # 671750 <_ZN11__sanitizerL19CheckFailedCallbackE>
void SetCheckFailedCallback(CheckFailedCallbackType callback) {
  CheckFailedCallback = callback;
}

void NORETURN CheckFailed(const char *file, int line, const char *cond,
                          u64 v1, u64 v2) {
  4053f9:	4d 89 c6             	mov    %r8,%r14
  4053fc:	41 55                	push   %r13
  4053fe:	49 89 cd             	mov    %rcx,%r13
  if (CheckFailedCallback) {
  405401:	48 85 c0             	test   %rax,%rax
void SetCheckFailedCallback(CheckFailedCallbackType callback) {
  CheckFailedCallback = callback;
}

void NORETURN CheckFailed(const char *file, int line, const char *cond,
                          u64 v1, u64 v2) {
  405404:	41 54                	push   %r12
  405406:	49 89 d4             	mov    %rdx,%r12
  405409:	55                   	push   %rbp
  40540a:	89 f5                	mov    %esi,%ebp
  40540c:	53                   	push   %rbx
  40540d:	48 89 fb             	mov    %rdi,%rbx
  if (CheckFailedCallback) {
  405410:	74 02                	je     405414 <_ZN11__sanitizer11CheckFailedEPKciS1_yy+0x24>
    CheckFailedCallback(file, line, cond, v1, v2);
  405412:	ff d0                	callq  *%rax
  }
  Report("Sanitizer CHECK failed: %s:%d %s (%lld, %lld)\n", file, line, cond,
                                                            v1, v2);
  405414:	48 8d 3d 5d 00 01 00 	lea    0x1005d(%rip),%rdi        # 415478 <.LC4>
  40541b:	4d 89 f1             	mov    %r14,%r9
  40541e:	4d 89 e8             	mov    %r13,%r8
  405421:	4c 89 e1             	mov    %r12,%rcx
  405424:	89 ea                	mov    %ebp,%edx
  405426:	48 89 de             	mov    %rbx,%rsi
  405429:	31 c0                	xor    %eax,%eax
  40542b:	e8 60 86 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
  Die();
  405430:	e8 2b fe ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  405435:	90                   	nop
  405436:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40543d:	00 00 00 

0000000000405440 <_ZN11__sanitizer10ReportFile17ReopenIfNecessaryEv>:

void RawWrite(const char *buffer) {
  report_file.Write(buffer, internal_strlen(buffer));
}

void ReportFile::ReopenIfNecessary() {
  405440:	41 54                	push   %r12
  405442:	55                   	push   %rbp
  405443:	53                   	push   %rbx
  mu->CheckLocked();
  405444:	48 8b 07             	mov    (%rdi),%rax

void RawWrite(const char *buffer) {
  report_file.Write(buffer, internal_strlen(buffer));
}

void ReportFile::ReopenIfNecessary() {
  405447:	48 89 fb             	mov    %rdi,%rbx
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  40544a:	0f b6 08             	movzbl (%rax),%ecx
  void Unlock() {
    atomic_store(&state_, 0, memory_order_release);
  }

  void CheckLocked() {
    CHECK_EQ(atomic_load(&state_, memory_order_relaxed), 1);
  40544d:	48 83 f9 01          	cmp    $0x1,%rcx
  405451:	0f 85 bf 00 00 00    	jne    405516 <_ZN11__sanitizer10ReportFile17ReopenIfNecessaryEv+0xd6>
  mu->CheckLocked();
  if (fd == kStdoutFd || fd == kStderrFd) return;
  405457:	8b 47 08             	mov    0x8(%rdi),%eax
  40545a:	83 e8 01             	sub    $0x1,%eax
  40545d:	83 f8 01             	cmp    $0x1,%eax
  405460:	0f 86 83 00 00 00    	jbe    4054e9 <_ZN11__sanitizer10ReportFile17ReopenIfNecessaryEv+0xa9>

  uptr pid = internal_getpid();
  405466:	e8 75 65 00 00       	callq  40b9e0 <_ZN11__sanitizer15internal_getpidEv>
  // If in tracer, use the parent's file.
  if (pid == stoptheworld_tracer_pid)
    pid = stoptheworld_tracer_ppid;
  if (fd != kInvalidFd) {
  40546b:	8b 7b 08             	mov    0x8(%rbx),%edi
  if (fd == kStdoutFd || fd == kStderrFd) return;

  uptr pid = internal_getpid();
  // If in tracer, use the parent's file.
  if (pid == stoptheworld_tracer_pid)
    pid = stoptheworld_tracer_ppid;
  40546e:	48 3b 05 43 c3 26 00 	cmp    0x26c343(%rip),%rax        # 6717b8 <_ZN11__sanitizer23stoptheworld_tracer_pidE>

void ReportFile::ReopenIfNecessary() {
  mu->CheckLocked();
  if (fd == kStdoutFd || fd == kStderrFd) return;

  uptr pid = internal_getpid();
  405475:	48 89 c5             	mov    %rax,%rbp
  // If in tracer, use the parent's file.
  if (pid == stoptheworld_tracer_pid)
    pid = stoptheworld_tracer_ppid;
  405478:	48 0f 44 2d 30 c3 26 	cmove  0x26c330(%rip),%rbp        # 6717b0 <_ZN11__sanitizer24stoptheworld_tracer_ppidE>
  40547f:	00 
  if (fd != kInvalidFd) {
  405480:	83 ff ff             	cmp    $0xffffffff,%edi
  405483:	74 0e                	je     405493 <_ZN11__sanitizer10ReportFile17ReopenIfNecessaryEv+0x53>
    // If the report file is already opened by the current process,
    // do nothing. Otherwise the report file was opened by the parent
    // process, close it now.
    if (fd_pid == pid)
  405485:	48 39 ab 10 20 00 00 	cmp    %rbp,0x2010(%rbx)
  40548c:	74 5b                	je     4054e9 <_ZN11__sanitizer10ReportFile17ReopenIfNecessaryEv+0xa9>
      return;
    else
      CloseFile(fd);
  40548e:	e8 1d 72 00 00       	callq  40c6b0 <_ZN11__sanitizer9CloseFileEi>
  }

  const char *exe_name = GetProcessName();
  if (common_flags()->log_exe_name && exe_name) {
  405493:	48 8b 05 1e 8e 01 00 	mov    0x18e1e(%rip),%rax        # 41e2b8 <_DYNAMIC+0x2b8>
  40549a:	80 78 30 00          	cmpb   $0x0,0x30(%rax)
  40549e:	74 50                	je     4054f0 <_ZN11__sanitizer10ReportFile17ReopenIfNecessaryEv+0xb0>
    internal_snprintf(full_path, kMaxPathLength, "%s.%s.%zu", path_prefix,
                      exe_name, pid);
  4054a0:	4c 8d a3 0c 10 00 00 	lea    0x100c(%rbx),%r12
  4054a7:	48 8d 4b 0c          	lea    0xc(%rbx),%rcx
  4054ab:	4c 8d 05 8e a2 26 00 	lea    0x26a28e(%rip),%r8        # 66f740 <_ZN11__sanitizerL22process_name_cache_strE>
  4054b2:	48 8d 15 7c 30 01 00 	lea    0x1307c(%rip),%rdx        # 418535 <.LC9>
  4054b9:	49 89 e9             	mov    %rbp,%r9
  4054bc:	be 00 10 00 00       	mov    $0x1000,%esi
  4054c1:	4c 89 e7             	mov    %r12,%rdi
  4054c4:	31 c0                	xor    %eax,%eax
  4054c6:	e8 f5 81 00 00       	callq  40d6c0 <_ZN11__sanitizer17internal_snprintfEPcmPKcz>
  } else {
    internal_snprintf(full_path, kMaxPathLength, "%s.%zu", path_prefix, pid);
  }
  fd = OpenFile(full_path, WrOnly);
  4054cb:	31 d2                	xor    %edx,%edx
  4054cd:	be 01 00 00 00       	mov    $0x1,%esi
  4054d2:	4c 89 e7             	mov    %r12,%rdi
  4054d5:	e8 76 71 00 00       	callq  40c650 <_ZN11__sanitizer8OpenFileEPKcNS_14FileAccessModeEPi>
  if (fd == kInvalidFd) {
  4054da:	83 f8 ff             	cmp    $0xffffffff,%eax
    internal_snprintf(full_path, kMaxPathLength, "%s.%s.%zu", path_prefix,
                      exe_name, pid);
  } else {
    internal_snprintf(full_path, kMaxPathLength, "%s.%zu", path_prefix, pid);
  }
  fd = OpenFile(full_path, WrOnly);
  4054dd:	89 43 08             	mov    %eax,0x8(%rbx)
  if (fd == kInvalidFd) {
  4054e0:	74 52                	je     405534 <_ZN11__sanitizer10ReportFile17ReopenIfNecessaryEv+0xf4>
    const char *ErrorMsgPrefix = "ERROR: Can't open file: ";
    WriteToFile(kStderrFd, ErrorMsgPrefix, internal_strlen(ErrorMsgPrefix));
    WriteToFile(kStderrFd, full_path, internal_strlen(full_path));
    Die();
  }
  fd_pid = pid;
  4054e2:	48 89 ab 10 20 00 00 	mov    %rbp,0x2010(%rbx)
}
  4054e9:	5b                   	pop    %rbx
  4054ea:	5d                   	pop    %rbp
  4054eb:	41 5c                	pop    %r12
  4054ed:	c3                   	retq   
  4054ee:	66 90                	xchg   %ax,%ax
  const char *exe_name = GetProcessName();
  if (common_flags()->log_exe_name && exe_name) {
    internal_snprintf(full_path, kMaxPathLength, "%s.%s.%zu", path_prefix,
                      exe_name, pid);
  } else {
    internal_snprintf(full_path, kMaxPathLength, "%s.%zu", path_prefix, pid);
  4054f0:	4c 8d a3 0c 10 00 00 	lea    0x100c(%rbx),%r12
  4054f7:	48 8d 4b 0c          	lea    0xc(%rbx),%rcx
  4054fb:	48 8d 15 2c 30 01 00 	lea    0x1302c(%rip),%rdx        # 41852e <.LC8>
  405502:	49 89 e8             	mov    %rbp,%r8
  405505:	be 00 10 00 00       	mov    $0x1000,%esi
  40550a:	31 c0                	xor    %eax,%eax
  40550c:	4c 89 e7             	mov    %r12,%rdi
  40550f:	e8 ac 81 00 00       	callq  40d6c0 <_ZN11__sanitizer17internal_snprintfEPcmPKcz>
  405514:	eb b5                	jmp    4054cb <_ZN11__sanitizer10ReportFile17ReopenIfNecessaryEv+0x8b>
  405516:	48 8d 15 8b ff 00 00 	lea    0xff8b(%rip),%rdx        # 4154a8 <.LC5>
  40551d:	48 8d 3d bc ff 00 00 	lea    0xffbc(%rip),%rdi        # 4154e0 <.LC6>
  405524:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  40552a:	be 2c 00 00 00       	mov    $0x2c,%esi
  40552f:	e8 bc fe ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  }
  fd = OpenFile(full_path, WrOnly);
  if (fd == kInvalidFd) {
    const char *ErrorMsgPrefix = "ERROR: Can't open file: ";
    WriteToFile(kStderrFd, ErrorMsgPrefix, internal_strlen(ErrorMsgPrefix));
  405534:	48 8d 3d da 2f 01 00 	lea    0x12fda(%rip),%rdi        # 418515 <.LC7>
  40553b:	e8 f0 53 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  405540:	48 8d 35 ce 2f 01 00 	lea    0x12fce(%rip),%rsi        # 418515 <.LC7>
  405547:	45 31 c0             	xor    %r8d,%r8d
  40554a:	31 c9                	xor    %ecx,%ecx
  40554c:	48 89 c2             	mov    %rax,%rdx
  40554f:	bf 02 00 00 00       	mov    $0x2,%edi
  405554:	e8 b7 71 00 00       	callq  40c710 <_ZN11__sanitizer11WriteToFileEiPKvmPmPi>
    WriteToFile(kStderrFd, full_path, internal_strlen(full_path));
  405559:	4c 89 e7             	mov    %r12,%rdi
  40555c:	e8 cf 53 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  405561:	45 31 c0             	xor    %r8d,%r8d
  405564:	31 c9                	xor    %ecx,%ecx
  405566:	48 89 c2             	mov    %rax,%rdx
  405569:	4c 89 e6             	mov    %r12,%rsi
  40556c:	bf 02 00 00 00       	mov    $0x2,%edi
  405571:	e8 9a 71 00 00       	callq  40c710 <_ZN11__sanitizer11WriteToFileEiPKvmPmPi>
    Die();
  405576:	e8 e5 fc ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  40557b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000405580 <_ZN11__sanitizer23ReportMmapFailureAndDieEmPKci>:
                                                            v1, v2);
  Die();
}

void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,
                                      error_t err) {
  405580:	48 83 ec 08          	sub    $0x8,%rsp
  static int recursion_count;
  if (recursion_count) {
  405584:	8b 05 86 a1 26 00    	mov    0x26a186(%rip),%eax        # 66f710 <_ZZN11__sanitizer23ReportMmapFailureAndDieEmPKciE15recursion_count>
  40558a:	85 c0                	test   %eax,%eax
  40558c:	74 11                	je     40559f <_ZN11__sanitizer23ReportMmapFailureAndDieEmPKci+0x1f>
    // The Report() and CHECK calls below may call mmap recursively and fail.
    // If we went into recursion, just die.
    RawWrite("ERROR: Failed to mmap\n");
  40558e:	48 8d 3d aa 2f 01 00 	lea    0x12faa(%rip),%rdi        # 41853f <.LC10>
  405595:	e8 46 fb ff ff       	callq  4050e0 <_ZN11__sanitizer8RawWriteEPKc>
    Die();
  40559a:	e8 c1 fc ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  }
  recursion_count++;
  Report("ERROR: %s failed to "
         "allocate 0x%zx (%zd) bytes of %s (error code: %d)\n",
         SanitizerToolName, size, size, mem_type, err);
  40559f:	49 89 f0             	mov    %rsi,%r8
  4055a2:	48 8b 35 b7 ae 01 00 	mov    0x1aeb7(%rip),%rsi        # 420460 <_ZN11__sanitizer17SanitizerToolNameE>
  4055a9:	48 89 f9             	mov    %rdi,%rcx
  4055ac:	41 89 d1             	mov    %edx,%r9d
  4055af:	48 89 fa             	mov    %rdi,%rdx
  4055b2:	48 8d 3d 97 ff 00 00 	lea    0xff97(%rip),%rdi        # 415550 <.LC11>
  4055b9:	31 c0                	xor    %eax,%eax
    // The Report() and CHECK calls below may call mmap recursively and fail.
    // If we went into recursion, just die.
    RawWrite("ERROR: Failed to mmap\n");
    Die();
  }
  recursion_count++;
  4055bb:	c7 05 4b a1 26 00 01 	movl   $0x1,0x26a14b(%rip)        # 66f710 <_ZZN11__sanitizer23ReportMmapFailureAndDieEmPKciE15recursion_count>
  4055c2:	00 00 00 
  Report("ERROR: %s failed to "
         "allocate 0x%zx (%zd) bytes of %s (error code: %d)\n",
         SanitizerToolName, size, size, mem_type, err);
  4055c5:	e8 c6 84 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
  DumpProcessMap();
  4055ca:	e8 a1 74 00 00       	callq  40ca70 <_ZN11__sanitizer14DumpProcessMapEv>
  UNREACHABLE("unable to mmap");
  4055cf:	48 8d 15 c2 ff 00 00 	lea    0xffc2(%rip),%rdx        # 415598 <.LC12>
  4055d6:	48 8d 3d e3 ff 00 00 	lea    0xffe3(%rip),%rdi        # 4155c0 <.LC13>
  4055dd:	45 31 c0             	xor    %r8d,%r8d
  4055e0:	31 c9                	xor    %ecx,%ecx
  4055e2:	be b4 00 00 00       	mov    $0xb4,%esi
  4055e7:	e8 04 fe ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  4055ec:	0f 1f 40 00          	nopl   0x0(%rax)

00000000004055f0 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi>:
}

bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,
                      uptr *read_len, uptr max_len, error_t *errno_p) {
  4055f0:	41 57                	push   %r15
  4055f2:	4d 89 cf             	mov    %r9,%r15
  4055f5:	41 56                	push   %r14
  4055f7:	49 89 f6             	mov    %rsi,%r14
  4055fa:	41 55                	push   %r13
  4055fc:	41 54                	push   %r12
  4055fe:	55                   	push   %rbp
  4055ff:	48 89 cd             	mov    %rcx,%rbp
  405602:	53                   	push   %rbx
  405603:	48 83 ec 38          	sub    $0x38,%rsp

atomic_uint32_t current_verbosity;

uptr GetPageSizeCached() {
  static uptr PageSize;
  if (!PageSize)
  405607:	48 8b 1d 12 a1 26 00 	mov    0x26a112(%rip),%rbx        # 66f720 <_ZZN11__sanitizer17GetPageSizeCachedEvE8PageSize>
  DumpProcessMap();
  UNREACHABLE("unable to mmap");
}

bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,
                      uptr *read_len, uptr max_len, error_t *errno_p) {
  40560e:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  405613:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
  405618:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)

atomic_uint32_t current_verbosity;

uptr GetPageSizeCached() {
  static uptr PageSize;
  if (!PageSize)
  40561d:	48 85 db             	test   %rbx,%rbx
  405620:	0f 84 32 01 00 00    	je     405758 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi+0x168>
  uptr kMinFileLen = PageSize;
  *buff = nullptr;
  *buff_size = 0;
  *read_len = 0;
  // The files we usually open are not seekable, so try different buffer sizes.
  for (uptr size = kMinFileLen; size <= max_len; size *= 2) {
  405626:	48 39 5c 24 18       	cmp    %rbx,0x18(%rsp)
bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,
                      uptr *read_len, uptr max_len, error_t *errno_p) {
  uptr PageSize = GetPageSizeCached();
  uptr kMinFileLen = PageSize;
  *buff = nullptr;
  *buff_size = 0;
  40562b:	48 8b 44 24 08       	mov    0x8(%rsp),%rax

bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,
                      uptr *read_len, uptr max_len, error_t *errno_p) {
  uptr PageSize = GetPageSizeCached();
  uptr kMinFileLen = PageSize;
  *buff = nullptr;
  405630:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
  *buff_size = 0;
  405637:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  *read_len = 0;
  40563e:	48 c7 45 00 00 00 00 	movq   $0x0,0x0(%rbp)
  405645:	00 
  // The files we usually open are not seekable, so try different buffer sizes.
  for (uptr size = kMinFileLen; size <= max_len; size *= 2) {
  405646:	0f 82 e2 00 00 00    	jb     40572e <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi+0x13e>
  40564c:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
  405651:	49 89 dc             	mov    %rbx,%r12
  405654:	48 89 04 24          	mov    %rax,(%rsp)
    fd_t fd = OpenFile(file_name, RdOnly, errno_p);
  405658:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  40565d:	31 f6                	xor    %esi,%esi
  40565f:	4c 89 fa             	mov    %r15,%rdx
  405662:	e8 e9 6f 00 00       	callq  40c650 <_ZN11__sanitizer8OpenFileEPKcNS_14FileAccessModeEPi>
    if (fd == kInvalidFd) return false;
  405667:	83 f8 ff             	cmp    $0xffffffff,%eax
  *buff = nullptr;
  *buff_size = 0;
  *read_len = 0;
  // The files we usually open are not seekable, so try different buffer sizes.
  for (uptr size = kMinFileLen; size <= max_len; size *= 2) {
    fd_t fd = OpenFile(file_name, RdOnly, errno_p);
  40566a:	41 89 c5             	mov    %eax,%r13d
    if (fd == kInvalidFd) return false;
  40566d:	0f 84 f9 00 00 00    	je     40576c <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi+0x17c>
    UnmapOrDie(*buff, *buff_size);
  405673:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  405678:	49 8b 3e             	mov    (%r14),%rdi
  40567b:	48 8b 30             	mov    (%rax),%rsi
  40567e:	e8 bd 6d 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
    *buff = (char*)MmapOrDie(size, __func__);
  405683:	48 8d 35 a6 3a 01 00 	lea    0x13aa6(%rip),%rsi        # 419130 <_ZZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPiE8__func__>
  40568a:	4c 89 e7             	mov    %r12,%rdi
  40568d:	e8 0e 6d 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
    *buff_size = size;
  405692:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    *read_len = 0;
    // Read up to one page at a time.
    bool reached_eof = false;
    while (*read_len + PageSize <= size) {
  405697:	49 39 dc             	cmp    %rbx,%r12
  // The files we usually open are not seekable, so try different buffer sizes.
  for (uptr size = kMinFileLen; size <= max_len; size *= 2) {
    fd_t fd = OpenFile(file_name, RdOnly, errno_p);
    if (fd == kInvalidFd) return false;
    UnmapOrDie(*buff, *buff_size);
    *buff = (char*)MmapOrDie(size, __func__);
  40569a:	49 89 06             	mov    %rax,(%r14)
    *buff_size = size;
  40569d:	4c 89 21             	mov    %r12,(%rcx)
    *read_len = 0;
  4056a0:	48 c7 45 00 00 00 00 	movq   $0x0,0x0(%rbp)
  4056a7:	00 
    // Read up to one page at a time.
    bool reached_eof = false;
    while (*read_len + PageSize <= size) {
  4056a8:	72 6e                	jb     405718 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi+0x128>
  4056aa:	48 89 c6             	mov    %rax,%rsi
  4056ad:	31 d2                	xor    %edx,%edx
  4056af:	eb 25                	jmp    4056d6 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi+0xe6>
  4056b1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      uptr just_read;
      if (!ReadFromFile(fd, *buff + *read_len, PageSize, &just_read, errno_p)) {
        UnmapOrDie(*buff, *buff_size);
        return false;
      }
      if (just_read == 0) {
  4056b8:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
  4056bd:	48 85 d2             	test   %rdx,%rdx
  4056c0:	74 76                	je     405738 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi+0x148>
        reached_eof = true;
        break;
      }
      *read_len += just_read;
  4056c2:	48 03 55 00          	add    0x0(%rbp),%rdx
    *buff = (char*)MmapOrDie(size, __func__);
    *buff_size = size;
    *read_len = 0;
    // Read up to one page at a time.
    bool reached_eof = false;
    while (*read_len + PageSize <= size) {
  4056c6:	48 8d 04 13          	lea    (%rbx,%rdx,1),%rax
      }
      if (just_read == 0) {
        reached_eof = true;
        break;
      }
      *read_len += just_read;
  4056ca:	48 89 55 00          	mov    %rdx,0x0(%rbp)
    *buff = (char*)MmapOrDie(size, __func__);
    *buff_size = size;
    *read_len = 0;
    // Read up to one page at a time.
    bool reached_eof = false;
    while (*read_len + PageSize <= size) {
  4056ce:	49 39 c4             	cmp    %rax,%r12
  4056d1:	72 45                	jb     405718 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi+0x128>
  4056d3:	49 8b 36             	mov    (%r14),%rsi
      uptr just_read;
      if (!ReadFromFile(fd, *buff + *read_len, PageSize, &just_read, errno_p)) {
  4056d6:	48 8b 0c 24          	mov    (%rsp),%rcx
  4056da:	48 01 d6             	add    %rdx,%rsi
  4056dd:	4d 89 f8             	mov    %r15,%r8
  4056e0:	48 89 da             	mov    %rbx,%rdx
  4056e3:	44 89 ef             	mov    %r13d,%edi
  4056e6:	e8 d5 6f 00 00       	callq  40c6c0 <_ZN11__sanitizer12ReadFromFileEiPvmPmPi>
  4056eb:	84 c0                	test   %al,%al
  4056ed:	75 c9                	jne    4056b8 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi+0xc8>
  4056ef:	89 04 24             	mov    %eax,(%rsp)
        UnmapOrDie(*buff, *buff_size);
  4056f2:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  4056f7:	49 8b 3e             	mov    (%r14),%rdi
  4056fa:	48 8b 30             	mov    (%rax),%rsi
  4056fd:	e8 3e 6d 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  405702:	8b 04 24             	mov    (%rsp),%eax
    CloseFile(fd);
    if (reached_eof)  // We've read the whole file.
      break;
  }
  return true;
}
  405705:	48 83 c4 38          	add    $0x38,%rsp
  405709:	5b                   	pop    %rbx
  40570a:	5d                   	pop    %rbp
  40570b:	41 5c                	pop    %r12
  40570d:	41 5d                	pop    %r13
  40570f:	41 5e                	pop    %r14
  405711:	41 5f                	pop    %r15
  405713:	c3                   	retq   
  405714:	0f 1f 40 00          	nopl   0x0(%rax)
        reached_eof = true;
        break;
      }
      *read_len += just_read;
    }
    CloseFile(fd);
  405718:	44 89 ef             	mov    %r13d,%edi
  uptr kMinFileLen = PageSize;
  *buff = nullptr;
  *buff_size = 0;
  *read_len = 0;
  // The files we usually open are not seekable, so try different buffer sizes.
  for (uptr size = kMinFileLen; size <= max_len; size *= 2) {
  40571b:	4d 01 e4             	add    %r12,%r12
        reached_eof = true;
        break;
      }
      *read_len += just_read;
    }
    CloseFile(fd);
  40571e:	e8 8d 6f 00 00       	callq  40c6b0 <_ZN11__sanitizer9CloseFileEi>
  uptr kMinFileLen = PageSize;
  *buff = nullptr;
  *buff_size = 0;
  *read_len = 0;
  // The files we usually open are not seekable, so try different buffer sizes.
  for (uptr size = kMinFileLen; size <= max_len; size *= 2) {
  405723:	4c 39 64 24 18       	cmp    %r12,0x18(%rsp)
  405728:	0f 83 2a ff ff ff    	jae    405658 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi+0x68>
    }
    CloseFile(fd);
    if (reached_eof)  // We've read the whole file.
      break;
  }
  return true;
  40572e:	b8 01 00 00 00       	mov    $0x1,%eax
  405733:	eb d0                	jmp    405705 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi+0x115>
  405735:	0f 1f 00             	nopl   (%rax)
        reached_eof = true;
        break;
      }
      *read_len += just_read;
    }
    CloseFile(fd);
  405738:	44 89 ef             	mov    %r13d,%edi
  40573b:	89 04 24             	mov    %eax,(%rsp)
  40573e:	e8 6d 6f 00 00       	callq  40c6b0 <_ZN11__sanitizer9CloseFileEi>
  405743:	8b 04 24             	mov    (%rsp),%eax
    if (reached_eof)  // We've read the whole file.
      break;
  }
  return true;
}
  405746:	48 83 c4 38          	add    $0x38,%rsp
  40574a:	5b                   	pop    %rbx
  40574b:	5d                   	pop    %rbp
  40574c:	41 5c                	pop    %r12
  40574e:	41 5d                	pop    %r13
  405750:	41 5e                	pop    %r14
  405752:	41 5f                	pop    %r15
  405754:	c3                   	retq   
  405755:	0f 1f 00             	nopl   (%rax)
atomic_uint32_t current_verbosity;

uptr GetPageSizeCached() {
  static uptr PageSize;
  if (!PageSize)
    PageSize = GetPageSize();
  405758:	e8 f3 66 00 00       	callq  40be50 <_ZN11__sanitizer11GetPageSizeEv>
  40575d:	48 89 05 bc 9f 26 00 	mov    %rax,0x269fbc(%rip)        # 66f720 <_ZZN11__sanitizer17GetPageSizeCachedEvE8PageSize>
  405764:	48 89 c3             	mov    %rax,%rbx
  405767:	e9 ba fe ff ff       	jmpq   405626 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi+0x36>
  *buff_size = 0;
  *read_len = 0;
  // The files we usually open are not seekable, so try different buffer sizes.
  for (uptr size = kMinFileLen; size <= max_len; size *= 2) {
    fd_t fd = OpenFile(file_name, RdOnly, errno_p);
    if (fd == kInvalidFd) return false;
  40576c:	31 c0                	xor    %eax,%eax
  40576e:	eb 95                	jmp    405705 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi+0x115>

0000000000405770 <_ZN11__sanitizer9SortArrayEPmm>:
};

// HeapSort for arrays and InternalMmapVector.
template<class Container, class Compare>
void InternalSort(Container *v, uptr size, Compare comp) {
  if (size < 2)
  405770:	48 83 fe 01          	cmp    $0x1,%rsi
  405774:	0f 86 ce 00 00 00    	jbe    405848 <_ZN11__sanitizer9SortArrayEPmm+0xd8>
  40577a:	b9 01 00 00 00       	mov    $0x1,%ecx
  40577f:	90                   	nop
  405780:	4c 8b 0c cf          	mov    (%rdi,%rcx,8),%r9
    return;
  // Stage 1: insert elements to the heap.
  for (uptr i = 1; i < size; i++) {
    uptr j, p;
    for (j = i; j > 0; j = p) {
  405784:	48 89 ca             	mov    %rcx,%rdx
  405787:	eb 0a                	jmp    405793 <_ZN11__sanitizer9SortArrayEPmm+0x23>
  405789:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  405790:	48 89 c2             	mov    %rax,%rdx
      p = (j - 1) / 2;
  405793:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
      if (comp((*v)[p], (*v)[j]))
  405797:	4c 8d 14 d7          	lea    (%rdi,%rdx,8),%r10
    return;
  // Stage 1: insert elements to the heap.
  for (uptr i = 1; i < size; i++) {
    uptr j, p;
    for (j = i; j > 0; j = p) {
      p = (j - 1) / 2;
  40579b:	48 d1 e8             	shr    %rax
      if (comp((*v)[p], (*v)[j]))
  40579e:	48 8d 14 c7          	lea    (%rdi,%rax,8),%rdx

typedef bool UptrComparisonFunction(const uptr &a, const uptr &b);

template<class T>
static inline bool CompareLess(const T &a, const T &b) {
  return a < b;
  4057a2:	4c 8b 02             	mov    (%rdx),%r8
  4057a5:	4d 39 c8             	cmp    %r9,%r8
  4057a8:	73 0b                	jae    4057b5 <_ZN11__sanitizer9SortArrayEPmm+0x45>
  if (size < 2)
    return;
  // Stage 1: insert elements to the heap.
  for (uptr i = 1; i < size; i++) {
    uptr j, p;
    for (j = i; j > 0; j = p) {
  4057aa:	48 85 c0             	test   %rax,%rax
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  a = b;
  4057ad:	4d 89 02             	mov    %r8,(%r10)
  b = tmp;
  4057b0:	4c 89 0a             	mov    %r9,(%rdx)
  if (size < 2)
    return;
  // Stage 1: insert elements to the heap.
  for (uptr i = 1; i < size; i++) {
    uptr j, p;
    for (j = i; j > 0; j = p) {
  4057b3:	75 db                	jne    405790 <_ZN11__sanitizer9SortArrayEPmm+0x20>
template<class Container, class Compare>
void InternalSort(Container *v, uptr size, Compare comp) {
  if (size < 2)
    return;
  // Stage 1: insert elements to the heap.
  for (uptr i = 1; i < size; i++) {
  4057b5:	48 83 c1 01          	add    $0x1,%rcx
  4057b9:	48 39 f1             	cmp    %rsi,%rcx
  4057bc:	75 c2                	jne    405780 <_ZN11__sanitizer9SortArrayEPmm+0x10>
        break;
    }
  }
  // Stage 2: swap largest element with the last one,
  // and sink the new top.
  for (uptr i = size - 1; i > 0; i--) {
  4057be:	48 83 e9 01          	sub    $0x1,%rcx
  4057c2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  a = b;
  4057c8:	48 8b 14 cf          	mov    (%rdi,%rcx,8),%rdx
// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  4057cc:	48 8b 07             	mov    (%rdi),%rax
  a = b;
  4057cf:	48 89 17             	mov    %rdx,(%rdi)
  b = tmp;
  4057d2:	48 89 04 cf          	mov    %rax,(%rdi,%rcx,8)
  // Stage 2: swap largest element with the last one,
  // and sink the new top.
  for (uptr i = size - 1; i > 0; i--) {
    Swap((*v)[0], (*v)[i]);
    uptr j, max_ind;
    for (j = 0; j < i; j = max_ind) {
  4057d6:	31 d2                	xor    %edx,%edx
  4057d8:	eb 2f                	jmp    405809 <_ZN11__sanitizer9SortArrayEPmm+0x99>
  4057da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      uptr left = 2 * j + 1;
      uptr right = 2 * j + 2;
      max_ind = j;
      if (left < i && comp((*v)[max_ind], (*v)[left]))
        max_ind = left;
      if (right < i && comp((*v)[max_ind], (*v)[right]))
  4057e0:	48 39 ce             	cmp    %rcx,%rsi
    uptr j, max_ind;
    for (j = 0; j < i; j = max_ind) {
      uptr left = 2 * j + 1;
      uptr right = 2 * j + 2;
      max_ind = j;
      if (left < i && comp((*v)[max_ind], (*v)[left]))
  4057e3:	48 89 d0             	mov    %rdx,%rax
        max_ind = left;
      if (right < i && comp((*v)[max_ind], (*v)[right]))
  4057e6:	72 43                	jb     40582b <_ZN11__sanitizer9SortArrayEPmm+0xbb>
        max_ind = right;
      if (max_ind != j)
  4057e8:	48 39 c2             	cmp    %rax,%rdx
  4057eb:	74 53                	je     405840 <_ZN11__sanitizer9SortArrayEPmm+0xd0>
        Swap((*v)[j], (*v)[max_ind]);
  4057ed:	48 8d 34 c7          	lea    (%rdi,%rax,8),%rsi
  4057f1:	48 8d 14 d7          	lea    (%rdi,%rdx,8),%rdx
  // Stage 2: swap largest element with the last one,
  // and sink the new top.
  for (uptr i = size - 1; i > 0; i--) {
    Swap((*v)[0], (*v)[i]);
    uptr j, max_ind;
    for (j = 0; j < i; j = max_ind) {
  4057f5:	48 39 c1             	cmp    %rax,%rcx
// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  4057f8:	4c 8b 02             	mov    (%rdx),%r8
  a = b;
  4057fb:	4c 8b 0e             	mov    (%rsi),%r9
  4057fe:	4c 89 0a             	mov    %r9,(%rdx)
  b = tmp;
  405801:	4c 89 06             	mov    %r8,(%rsi)
  // Stage 2: swap largest element with the last one,
  // and sink the new top.
  for (uptr i = size - 1; i > 0; i--) {
    Swap((*v)[0], (*v)[i]);
    uptr j, max_ind;
    for (j = 0; j < i; j = max_ind) {
  405804:	76 3a                	jbe    405840 <_ZN11__sanitizer9SortArrayEPmm+0xd0>
  405806:	48 89 c2             	mov    %rax,%rdx
      uptr left = 2 * j + 1;
  405809:	48 8d 34 12          	lea    (%rdx,%rdx,1),%rsi
  40580d:	48 8d 46 01          	lea    0x1(%rsi),%rax
      uptr right = 2 * j + 2;
  405811:	48 83 c6 02          	add    $0x2,%rsi
      max_ind = j;
      if (left < i && comp((*v)[max_ind], (*v)[left]))
  405815:	48 39 c8             	cmp    %rcx,%rax
  405818:	73 c6                	jae    4057e0 <_ZN11__sanitizer9SortArrayEPmm+0x70>
  40581a:	4c 8b 1c c7          	mov    (%rdi,%rax,8),%r11
  40581e:	4c 39 1c d7          	cmp    %r11,(%rdi,%rdx,8)
  405822:	48 0f 43 c2          	cmovae %rdx,%rax
        max_ind = left;
      if (right < i && comp((*v)[max_ind], (*v)[right]))
  405826:	48 39 ce             	cmp    %rcx,%rsi
  405829:	73 bd                	jae    4057e8 <_ZN11__sanitizer9SortArrayEPmm+0x78>
  40582b:	4c 8b 1c f7          	mov    (%rdi,%rsi,8),%r11
  40582f:	4c 39 1c c7          	cmp    %r11,(%rdi,%rax,8)
  405833:	48 0f 42 c6          	cmovb  %rsi,%rax
        max_ind = right;
      if (max_ind != j)
  405837:	48 39 c2             	cmp    %rax,%rdx
  40583a:	75 b1                	jne    4057ed <_ZN11__sanitizer9SortArrayEPmm+0x7d>
  40583c:	0f 1f 40 00          	nopl   0x0(%rax)
        break;
    }
  }
  // Stage 2: swap largest element with the last one,
  // and sink the new top.
  for (uptr i = size - 1; i > 0; i--) {
  405840:	48 83 e9 01          	sub    $0x1,%rcx
  405844:	75 82                	jne    4057c8 <_ZN11__sanitizer9SortArrayEPmm+0x58>
  405846:	f3 c3                	repz retq 
  405848:	f3 c3                	repz retq 
  40584a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000405850 <_ZN11__sanitizer16MmapAlignedOrDieEmmPKc>:
}

// We want to map a chunk of address space aligned to 'alignment'.
// We do it by maping a bit more and then unmaping redundant pieces.
// We probably can do it with fewer syscalls in some OS-dependent way.
void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type) {
  405850:	41 55                	push   %r13
#endif
  return up;
}

INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
  405852:	48 8d 47 ff          	lea    -0x1(%rdi),%rax
  405856:	41 54                	push   %r12
  405858:	55                   	push   %rbp
  405859:	48 89 fd             	mov    %rdi,%rbp
  40585c:	53                   	push   %rbx
  40585d:	48 83 ec 08          	sub    $0x8,%rsp
// uptr PageSize = GetPageSizeCached();
  CHECK(IsPowerOfTwo(size));
  405861:	48 85 f8             	test   %rdi,%rax
  405864:	0f 85 8d 00 00 00    	jne    4058f7 <_ZN11__sanitizer16MmapAlignedOrDieEmmPKc+0xa7>
  40586a:	48 8d 5e ff          	lea    -0x1(%rsi),%rbx
  40586e:	49 89 f4             	mov    %rsi,%r12
  CHECK(IsPowerOfTwo(alignment));
  405871:	48 85 f3             	test   %rsi,%rbx
  405874:	75 64                	jne    4058da <_ZN11__sanitizer16MmapAlignedOrDieEmmPKc+0x8a>
  uptr map_size = size + alignment;
  405876:	4c 8d 2c 37          	lea    (%rdi,%rsi,1),%r13
  uptr map_res = (uptr)MmapOrDie(map_size, mem_type);
  40587a:	48 89 d6             	mov    %rdx,%rsi
  40587d:	4c 89 ef             	mov    %r13,%rdi
  405880:	e8 1b 6b 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  uptr map_end = map_res + map_size;
  405885:	49 01 c5             	add    %rax,%r13
  uptr res = map_res;
  if (res & (alignment - 1))  // Not aligned.
  405888:	48 85 d8             	test   %rbx,%rax
  40588b:	75 2b                	jne    4058b8 <_ZN11__sanitizer16MmapAlignedOrDieEmmPKc+0x68>
    res = (map_res + alignment) & ~(alignment - 1);
  uptr end = res + size;
  40588d:	48 01 c5             	add    %rax,%rbp
void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type) {
// uptr PageSize = GetPageSizeCached();
  CHECK(IsPowerOfTwo(size));
  CHECK(IsPowerOfTwo(alignment));
  uptr map_size = size + alignment;
  uptr map_res = (uptr)MmapOrDie(map_size, mem_type);
  405890:	48 89 c3             	mov    %rax,%rbx
  if (res & (alignment - 1))  // Not aligned.
    res = (map_res + alignment) & ~(alignment - 1);
  uptr end = res + size;
  if (res != map_res)
    UnmapOrDie((void*)map_res, res - map_res);
  if (end != map_end)
  405893:	4c 39 ed             	cmp    %r13,%rbp
  405896:	74 0e                	je     4058a6 <_ZN11__sanitizer16MmapAlignedOrDieEmmPKc+0x56>
    UnmapOrDie((void*)end, map_end - end);
  405898:	4c 89 ee             	mov    %r13,%rsi
  40589b:	48 89 ef             	mov    %rbp,%rdi
  40589e:	48 29 ee             	sub    %rbp,%rsi
  4058a1:	e8 9a 6b 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  return (void*)res;
}
  4058a6:	48 83 c4 08          	add    $0x8,%rsp
  4058aa:	48 89 d8             	mov    %rbx,%rax
  4058ad:	5b                   	pop    %rbx
  4058ae:	5d                   	pop    %rbp
  4058af:	41 5c                	pop    %r12
  4058b1:	41 5d                	pop    %r13
  4058b3:	c3                   	retq   
  4058b4:	0f 1f 40 00          	nopl   0x0(%rax)
  uptr map_size = size + alignment;
  uptr map_res = (uptr)MmapOrDie(map_size, mem_type);
  uptr map_end = map_res + map_size;
  uptr res = map_res;
  if (res & (alignment - 1))  // Not aligned.
    res = (map_res + alignment) & ~(alignment - 1);
  4058b8:	4a 8d 1c 20          	lea    (%rax,%r12,1),%rbx
  4058bc:	49 f7 dc             	neg    %r12
  4058bf:	4c 21 e3             	and    %r12,%rbx
  uptr end = res + size;
  4058c2:	48 01 dd             	add    %rbx,%rbp
  if (res != map_res)
  4058c5:	48 39 d8             	cmp    %rbx,%rax
  4058c8:	74 c9                	je     405893 <_ZN11__sanitizer16MmapAlignedOrDieEmmPKc+0x43>
    UnmapOrDie((void*)map_res, res - map_res);
  4058ca:	48 89 de             	mov    %rbx,%rsi
  4058cd:	48 89 c7             	mov    %rax,%rdi
  4058d0:	48 29 c6             	sub    %rax,%rsi
  4058d3:	e8 68 6b 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  4058d8:	eb b9                	jmp    405893 <_ZN11__sanitizer16MmapAlignedOrDieEmmPKc+0x43>
// We do it by maping a bit more and then unmaping redundant pieces.
// We probably can do it with fewer syscalls in some OS-dependent way.
void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type) {
// uptr PageSize = GetPageSizeCached();
  CHECK(IsPowerOfTwo(size));
  CHECK(IsPowerOfTwo(alignment));
  4058da:	48 8d 15 4f fd 00 00 	lea    0xfd4f(%rip),%rdx        # 415630 <.LC15>
  4058e1:	48 8d 3d d8 fc 00 00 	lea    0xfcd8(%rip),%rdi        # 4155c0 <.LC13>
  4058e8:	45 31 c0             	xor    %r8d,%r8d
  4058eb:	31 c9                	xor    %ecx,%ecx
  4058ed:	be ec 00 00 00       	mov    $0xec,%esi
  4058f2:	e8 f9 fa ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
// We want to map a chunk of address space aligned to 'alignment'.
// We do it by maping a bit more and then unmaping redundant pieces.
// We probably can do it with fewer syscalls in some OS-dependent way.
void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type) {
// uptr PageSize = GetPageSizeCached();
  CHECK(IsPowerOfTwo(size));
  4058f7:	48 8d 15 58 2c 01 00 	lea    0x12c58(%rip),%rdx        # 418556 <.LC14>
  4058fe:	48 8d 3d bb fc 00 00 	lea    0xfcbb(%rip),%rdi        # 4155c0 <.LC13>
  405905:	45 31 c0             	xor    %r8d,%r8d
  405908:	31 c9                	xor    %ecx,%ecx
  40590a:	be eb 00 00 00       	mov    $0xeb,%esi
  40590f:	e8 dc fa ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  405914:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40591b:	00 00 00 00 00 

0000000000405920 <_ZN11__sanitizer15StripPathPrefixEPKcS1_>:
    UnmapOrDie((void*)end, map_end - end);
  return (void*)res;
}

const char *StripPathPrefix(const char *filepath,
                            const char *strip_path_prefix) {
  405920:	41 54                	push   %r12
  if (!filepath) return nullptr;
  405922:	48 85 ff             	test   %rdi,%rdi
    UnmapOrDie((void*)end, map_end - end);
  return (void*)res;
}

const char *StripPathPrefix(const char *filepath,
                            const char *strip_path_prefix) {
  405925:	55                   	push   %rbp
  405926:	53                   	push   %rbx
  405927:	48 89 fb             	mov    %rdi,%rbx
  if (!filepath) return nullptr;
  40592a:	74 4c                	je     405978 <_ZN11__sanitizer15StripPathPrefixEPKcS1_+0x58>
  if (!strip_path_prefix) return filepath;
  40592c:	48 85 f6             	test   %rsi,%rsi
  40592f:	48 89 f5             	mov    %rsi,%rbp
  405932:	48 89 f8             	mov    %rdi,%rax
  405935:	74 21                	je     405958 <_ZN11__sanitizer15StripPathPrefixEPKcS1_+0x38>
  const char *res = filepath;
  if (const char *pos = internal_strstr(filepath, strip_path_prefix))
  405937:	e8 14 51 00 00       	callq  40aa50 <_ZN11__sanitizer15internal_strstrEPKcS1_>
  40593c:	48 85 c0             	test   %rax,%rax
  40593f:	49 89 c4             	mov    %rax,%r12
  405942:	74 0c                	je     405950 <_ZN11__sanitizer15StripPathPrefixEPKcS1_+0x30>
    res = pos + internal_strlen(strip_path_prefix);
  405944:	48 89 ef             	mov    %rbp,%rdi
  405947:	e8 e4 4f 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  40594c:	49 8d 1c 04          	lea    (%r12,%rax,1),%rbx
  if (res[0] == '.' && res[1] == '/')
  405950:	80 3b 2e             	cmpb   $0x2e,(%rbx)
  405953:	48 89 d8             	mov    %rbx,%rax
  405956:	74 08                	je     405960 <_ZN11__sanitizer15StripPathPrefixEPKcS1_+0x40>
    res += 2;
  return res;
}
  405958:	5b                   	pop    %rbx
  405959:	5d                   	pop    %rbp
  40595a:	41 5c                	pop    %r12
  40595c:	c3                   	retq   
  40595d:	0f 1f 00             	nopl   (%rax)
  if (!strip_path_prefix) return filepath;
  const char *res = filepath;
  if (const char *pos = internal_strstr(filepath, strip_path_prefix))
    res = pos + internal_strlen(strip_path_prefix);
  if (res[0] == '.' && res[1] == '/')
    res += 2;
  405960:	80 7b 01 2f          	cmpb   $0x2f,0x1(%rbx)
  405964:	48 8d 53 02          	lea    0x2(%rbx),%rdx
  return res;
}
  405968:	5b                   	pop    %rbx
  405969:	5d                   	pop    %rbp
  40596a:	41 5c                	pop    %r12
  if (!strip_path_prefix) return filepath;
  const char *res = filepath;
  if (const char *pos = internal_strstr(filepath, strip_path_prefix))
    res = pos + internal_strlen(strip_path_prefix);
  if (res[0] == '.' && res[1] == '/')
    res += 2;
  40596c:	48 0f 44 c2          	cmove  %rdx,%rax
  return res;
}
  405970:	c3                   	retq   
  405971:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  return (void*)res;
}

const char *StripPathPrefix(const char *filepath,
                            const char *strip_path_prefix) {
  if (!filepath) return nullptr;
  405978:	31 c0                	xor    %eax,%eax
  40597a:	eb dc                	jmp    405958 <_ZN11__sanitizer15StripPathPrefixEPKcS1_+0x38>
  40597c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000405980 <_ZN11__sanitizer15StripModuleNameEPKc>:
    res += 2;
  return res;
}

const char *StripModuleName(const char *module) {
  if (!module)
  405980:	48 85 ff             	test   %rdi,%rdi
  if (res[0] == '.' && res[1] == '/')
    res += 2;
  return res;
}

const char *StripModuleName(const char *module) {
  405983:	53                   	push   %rbx
  405984:	48 89 fb             	mov    %rdi,%rbx
  if (!module)
  405987:	74 1f                	je     4059a8 <_ZN11__sanitizer15StripModuleNameEPKc+0x28>
    // On Windows, both slash and backslash are possible.
    // Pick the one that goes last.
    if (const char *bslash_pos = internal_strrchr(module, '\\'))
      return StripModuleName(bslash_pos + 1);
  }
  if (const char *slash_pos = internal_strrchr(module, '/')) {
  405989:	be 2f 00 00 00       	mov    $0x2f,%esi
  40598e:	e8 6d 4f 00 00       	callq  40a900 <_ZN11__sanitizer16internal_strrchrEPKci>
    return slash_pos + 1;
  405993:	48 8d 50 01          	lea    0x1(%rax),%rdx
  405997:	48 85 c0             	test   %rax,%rax
  40599a:	48 0f 44 d3          	cmove  %rbx,%rdx
  }
  return module;
}
  40599e:	48 89 d0             	mov    %rdx,%rax
  4059a1:	5b                   	pop    %rbx
  4059a2:	c3                   	retq   
  4059a3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  return res;
}

const char *StripModuleName(const char *module) {
  if (!module)
    return nullptr;
  4059a8:	31 d2                	xor    %edx,%edx
  4059aa:	eb f2                	jmp    40599e <_ZN11__sanitizer15StripModuleNameEPKc+0x1e>
  4059ac:	0f 1f 40 00          	nopl   0x0(%rax)

00000000004059b0 <_ZN11__sanitizer12LoadedModule3setEPKcm>:
              common_flags()->strip_path_prefix);
  ReportErrorSummary(buff.data());
}
#endif

void LoadedModule::set(const char *module_name, uptr base_address) {
  4059b0:	41 54                	push   %r12
  4059b2:	49 89 d4             	mov    %rdx,%r12
  4059b5:	55                   	push   %rbp
  4059b6:	48 89 f5             	mov    %rsi,%rbp
  full_name_ = internal_strdup(module_name);
  base_address_ = base_address;
}

void LoadedModule::clear() {
  InternalFree(full_name_);
  4059b9:	31 f6                	xor    %esi,%esi
              common_flags()->strip_path_prefix);
  ReportErrorSummary(buff.data());
}
#endif

void LoadedModule::set(const char *module_name, uptr base_address) {
  4059bb:	53                   	push   %rbx
  4059bc:	48 89 fb             	mov    %rdi,%rbx
  full_name_ = internal_strdup(module_name);
  base_address_ = base_address;
}

void LoadedModule::clear() {
  InternalFree(full_name_);
  4059bf:	48 8b 3f             	mov    (%rdi),%rdi
  4059c2:	e8 a9 e2 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  full_name_ = nullptr;
  while (!ranges_.empty()) {
    AddressRange *r = ranges_.front();
  4059c7:	48 8b 43 10          	mov    0x10(%rbx),%rax
  base_address_ = base_address;
}

void LoadedModule::clear() {
  InternalFree(full_name_);
  full_name_ = nullptr;
  4059cb:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
  while (!ranges_.empty()) {
  4059d2:	48 85 c0             	test   %rax,%rax
  4059d5:	75 21                	jne    4059f8 <_ZN11__sanitizer12LoadedModule3setEPKcm+0x48>
  4059d7:	eb 3f                	jmp    405a18 <_ZN11__sanitizer12LoadedModule3setEPKcm+0x68>
  4059d9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
    if (!first_)
      last_ = nullptr;
    size_--;
  4059e0:	48 83 e8 01          	sub    $0x1,%rax
    AddressRange *r = ranges_.front();
    ranges_.pop_front();
    InternalFree(r);
  4059e4:	31 f6                	xor    %esi,%esi
  4059e6:	48 89 43 10          	mov    %rax,0x10(%rbx)
  4059ea:	e8 81 e2 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>

void LoadedModule::clear() {
  InternalFree(full_name_);
  full_name_ = nullptr;
  while (!ranges_.empty()) {
    AddressRange *r = ranges_.front();
  4059ef:	48 8b 43 10          	mov    0x10(%rbx),%rax
}

void LoadedModule::clear() {
  InternalFree(full_name_);
  full_name_ = nullptr;
  while (!ranges_.empty()) {
  4059f3:	48 85 c0             	test   %rax,%rax
  4059f6:	74 20                	je     405a18 <_ZN11__sanitizer12LoadedModule3setEPKcm+0x68>
    AddressRange *r = ranges_.front();
  4059f8:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
    }
  }

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
  4059fc:	48 8b 0f             	mov    (%rdi),%rcx
    if (!first_)
  4059ff:	48 85 c9             	test   %rcx,%rcx
    }
  }

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
  405a02:	48 89 4b 18          	mov    %rcx,0x18(%rbx)
    if (!first_)
  405a06:	75 d8                	jne    4059e0 <_ZN11__sanitizer12LoadedModule3setEPKcm+0x30>
      last_ = nullptr;
  405a08:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
  405a0f:	00 
  405a10:	eb ce                	jmp    4059e0 <_ZN11__sanitizer12LoadedModule3setEPKcm+0x30>
  405a12:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
}
#endif

void LoadedModule::set(const char *module_name, uptr base_address) {
  clear();
  full_name_ = internal_strdup(module_name);
  405a18:	48 89 ef             	mov    %rbp,%rdi
  405a1b:	e8 a0 49 00 00       	callq  40a3c0 <_ZN11__sanitizer15internal_strdupEPKc>
  base_address_ = base_address;
  405a20:	4c 89 63 08          	mov    %r12,0x8(%rbx)
}
#endif

void LoadedModule::set(const char *module_name, uptr base_address) {
  clear();
  full_name_ = internal_strdup(module_name);
  405a24:	48 89 03             	mov    %rax,(%rbx)
  base_address_ = base_address;
}
  405a27:	5b                   	pop    %rbx
  405a28:	5d                   	pop    %rbp
  405a29:	41 5c                	pop    %r12
  405a2b:	c3                   	retq   
  405a2c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000405a30 <_ZN11__sanitizer12LoadedModule5clearEv>:

void LoadedModule::clear() {
  405a30:	53                   	push   %rbx
  405a31:	48 89 fb             	mov    %rdi,%rbx
  InternalFree(full_name_);
  405a34:	48 8b 3f             	mov    (%rdi),%rdi
  405a37:	31 f6                	xor    %esi,%esi
  405a39:	e8 32 e2 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  full_name_ = nullptr;
  while (!ranges_.empty()) {
    AddressRange *r = ranges_.front();
  405a3e:	48 8b 43 10          	mov    0x10(%rbx),%rax
  base_address_ = base_address;
}

void LoadedModule::clear() {
  InternalFree(full_name_);
  full_name_ = nullptr;
  405a42:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
  while (!ranges_.empty()) {
  405a49:	48 85 c0             	test   %rax,%rax
  405a4c:	75 1a                	jne    405a68 <_ZN11__sanitizer12LoadedModule5clearEv+0x38>
  405a4e:	eb 38                	jmp    405a88 <_ZN11__sanitizer12LoadedModule5clearEv+0x58>
    size_--;
  405a50:	48 83 e8 01          	sub    $0x1,%rax
    AddressRange *r = ranges_.front();
    ranges_.pop_front();
    InternalFree(r);
  405a54:	31 f6                	xor    %esi,%esi
  405a56:	48 89 43 10          	mov    %rax,0x10(%rbx)
  405a5a:	e8 11 e2 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>

void LoadedModule::clear() {
  InternalFree(full_name_);
  full_name_ = nullptr;
  while (!ranges_.empty()) {
    AddressRange *r = ranges_.front();
  405a5f:	48 8b 43 10          	mov    0x10(%rbx),%rax
}

void LoadedModule::clear() {
  InternalFree(full_name_);
  full_name_ = nullptr;
  while (!ranges_.empty()) {
  405a63:	48 85 c0             	test   %rax,%rax
  405a66:	74 20                	je     405a88 <_ZN11__sanitizer12LoadedModule5clearEv+0x58>
    AddressRange *r = ranges_.front();
  405a68:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
    }
  }

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
  405a6c:	48 8b 17             	mov    (%rdi),%rdx
    if (!first_)
  405a6f:	48 85 d2             	test   %rdx,%rdx
    }
  }

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
  405a72:	48 89 53 18          	mov    %rdx,0x18(%rbx)
    if (!first_)
  405a76:	75 d8                	jne    405a50 <_ZN11__sanitizer12LoadedModule5clearEv+0x20>
      last_ = nullptr;
  405a78:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
  405a7f:	00 
  405a80:	eb ce                	jmp    405a50 <_ZN11__sanitizer12LoadedModule5clearEv+0x20>
  405a82:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    ranges_.pop_front();
    InternalFree(r);
  }
}
  405a88:	5b                   	pop    %rbx
  405a89:	c3                   	retq   
  405a8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000405a90 <_ZN11__sanitizer12LoadedModule15addAddressRangeEmmb>:

void LoadedModule::addAddressRange(uptr beg, uptr end, bool executable) {
  405a90:	41 55                	push   %r13
  405a92:	41 89 cd             	mov    %ecx,%r13d
  405a95:	41 54                	push   %r12
  405a97:	49 89 d4             	mov    %rdx,%r12
  405a9a:	55                   	push   %rbp
  405a9b:	48 89 f5             	mov    %rsi,%rbp
  void *mem = InternalAlloc(sizeof(AddressRange));
  405a9e:	31 f6                	xor    %esi,%esi
    ranges_.pop_front();
    InternalFree(r);
  }
}

void LoadedModule::addAddressRange(uptr beg, uptr end, bool executable) {
  405aa0:	53                   	push   %rbx
  405aa1:	48 89 fb             	mov    %rdi,%rbx
  void *mem = InternalAlloc(sizeof(AddressRange));
  405aa4:	bf 20 00 00 00       	mov    $0x20,%edi
    ranges_.pop_front();
    InternalFree(r);
  }
}

void LoadedModule::addAddressRange(uptr beg, uptr end, bool executable) {
  405aa9:	48 83 ec 08          	sub    $0x8,%rsp
  void *mem = InternalAlloc(sizeof(AddressRange));
  405aad:	e8 7e d8 ff ff       	callq  403330 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE>
  }

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
  405ab2:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    uptr beg;
    uptr end;
    bool executable;

    AddressRange(uptr beg, uptr end, bool executable)
        : next(nullptr), beg(beg), end(end), executable(executable) {}
  405ab6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  405abd:	48 89 68 08          	mov    %rbp,0x8(%rax)
  405ac1:	4c 89 60 10          	mov    %r12,0x10(%rax)
  405ac5:	44 88 68 18          	mov    %r13b,0x18(%rax)
    if (empty()) {
  405ac9:	48 85 d2             	test   %rdx,%rdx
  405acc:	74 22                	je     405af0 <_ZN11__sanitizer12LoadedModule15addAddressRangeEmmb+0x60>
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = nullptr;
      last_->next = x;
  405ace:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
      last_ = x;
      size_++;
  405ad2:	48 83 c2 01          	add    $0x1,%rdx
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = nullptr;
      last_->next = x;
  405ad6:	48 89 01             	mov    %rax,(%rcx)
      last_ = x;
  405ad9:	48 89 43 20          	mov    %rax,0x20(%rbx)
      size_++;
  405add:	48 89 53 10          	mov    %rdx,0x10(%rbx)
  AddressRange *r = new(mem) AddressRange(beg, end, executable);
  ranges_.push_back(r);
}
  405ae1:	48 83 c4 08          	add    $0x8,%rsp
  405ae5:	5b                   	pop    %rbx
  405ae6:	5d                   	pop    %rbp
  405ae7:	41 5c                	pop    %r12
  405ae9:	41 5d                	pop    %r13
  405aeb:	c3                   	retq   
  405aec:	0f 1f 40 00          	nopl   0x0(%rax)
  uptr size() const { return size_; }

  void push_back(Item *x) {
    if (empty()) {
      x->next = nullptr;
      first_ = last_ = x;
  405af0:	48 89 43 20          	mov    %rax,0x20(%rbx)
  405af4:	48 89 43 18          	mov    %rax,0x18(%rbx)
      size_ = 1;
  405af8:	48 c7 43 10 01 00 00 	movq   $0x1,0x10(%rbx)
  405aff:	00 
  405b00:	48 83 c4 08          	add    $0x8,%rsp
  405b04:	5b                   	pop    %rbx
  405b05:	5d                   	pop    %rbp
  405b06:	41 5c                	pop    %r12
  405b08:	41 5d                	pop    %r13
  405b0a:	c3                   	retq   
  405b0b:	90                   	nop
  405b0c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000405b10 <_ZNK11__sanitizer12LoadedModule15containsAddressEm>:

  template<class ListTy, class ItemTy>
  class IteratorBase {
   public:
    explicit IteratorBase(ListTy *list)
        : list_(list), current_(list->first_) { }
  405b10:	48 8b 47 18          	mov    0x18(%rdi),%rax

bool LoadedModule::containsAddress(uptr address) const {
  for (Iterator iter = ranges(); iter.hasNext();) {
  405b14:	48 85 c0             	test   %rax,%rax
  405b17:	75 0a                	jne    405b23 <_ZNK11__sanitizer12LoadedModule15containsAddressEm+0x13>
  405b19:	eb 1c                	jmp    405b37 <_ZNK11__sanitizer12LoadedModule15containsAddressEm+0x27>
  405b1b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  405b20:	48 89 d0             	mov    %rdx,%rax
    const AddressRange *r = iter.next();
    if (r->beg <= address && address < r->end)
  405b23:	48 39 70 08          	cmp    %rsi,0x8(%rax)
    ItemTy *next() {
      ItemTy *ret = current_;
      if (current_) current_ = current_->next;
  405b27:	48 8b 10             	mov    (%rax),%rdx
  405b2a:	77 06                	ja     405b32 <_ZNK11__sanitizer12LoadedModule15containsAddressEm+0x22>
  405b2c:	48 3b 70 10          	cmp    0x10(%rax),%rsi
  405b30:	72 0e                	jb     405b40 <_ZNK11__sanitizer12LoadedModule15containsAddressEm+0x30>
  AddressRange *r = new(mem) AddressRange(beg, end, executable);
  ranges_.push_back(r);
}

bool LoadedModule::containsAddress(uptr address) const {
  for (Iterator iter = ranges(); iter.hasNext();) {
  405b32:	48 85 d2             	test   %rdx,%rdx
  405b35:	75 e9                	jne    405b20 <_ZNK11__sanitizer12LoadedModule15containsAddressEm+0x10>
    const AddressRange *r = iter.next();
    if (r->beg <= address && address < r->end)
      return true;
  }
  return false;
  405b37:	31 c0                	xor    %eax,%eax
}
  405b39:	c3                   	retq   
  405b3a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

bool LoadedModule::containsAddress(uptr address) const {
  for (Iterator iter = ranges(); iter.hasNext();) {
    const AddressRange *r = iter.next();
    if (r->beg <= address && address < r->end)
      return true;
  405b40:	b8 01 00 00 00       	mov    $0x1,%eax
  405b45:	c3                   	retq   
  405b46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  405b4d:	00 00 00 

0000000000405b50 <_ZN11__sanitizer17IncreaseTotalMmapEm>:
}

static atomic_uintptr_t g_total_mmaped;

void IncreaseTotalMmap(uptr size) {
  if (!common_flags()->mmap_limit_mb) return;
  405b50:	48 8b 05 61 87 01 00 	mov    0x18761(%rip),%rax        # 41e2b8 <_DYNAMIC+0x2b8>
  405b57:	48 83 78 60 00       	cmpq   $0x0,0x60(%rax)
  405b5c:	75 02                	jne    405b60 <_ZN11__sanitizer17IncreaseTotalMmapEm+0x10>
  405b5e:	f3 c3                	repz retq 
template<typename T>
INLINE typename T::Type atomic_fetch_add(volatile T *a,
    typename T::Type v, memory_order mo) {
  (void)mo;
  DCHECK(!((uptr)a % sizeof(*a)));
  return __sync_fetch_and_add(&a->val_dont_use, v);
  405b60:	48 89 fa             	mov    %rdi,%rdx
  405b63:	f0 48 0f c1 15 d4 bb 	lock xadd %rdx,0x26bbd4(%rip)        # 671740 <_ZN11__sanitizerL14g_total_mmapedE>
  405b6a:	26 00 
  uptr total_mmaped =
      atomic_fetch_add(&g_total_mmaped, size, memory_order_relaxed) + size;
  405b6c:	48 01 d7             	add    %rdx,%rdi
  // Since for now mmap_limit_mb is not a user-facing flag, just kill
  // a program. Use RAW_CHECK to avoid extra mmaps in reporting.
  RAW_CHECK((total_mmaped >> 20) < common_flags()->mmap_limit_mb);
  405b6f:	48 c1 ef 14          	shr    $0x14,%rdi
  405b73:	48 3b 78 60          	cmp    0x60(%rax),%rdi
  405b77:	72 e5                	jb     405b5e <_ZN11__sanitizer17IncreaseTotalMmapEm+0xe>
  405b79:	48 8d 3d d8 fa 00 00 	lea    0xfad8(%rip),%rdi        # 415658 <.LC16>
  return false;
}

static atomic_uintptr_t g_total_mmaped;

void IncreaseTotalMmap(uptr size) {
  405b80:	50                   	push   %rax
  if (!common_flags()->mmap_limit_mb) return;
  uptr total_mmaped =
      atomic_fetch_add(&g_total_mmaped, size, memory_order_relaxed) + size;
  // Since for now mmap_limit_mb is not a user-facing flag, just kill
  // a program. Use RAW_CHECK to avoid extra mmaps in reporting.
  RAW_CHECK((total_mmaped >> 20) < common_flags()->mmap_limit_mb);
  405b81:	e8 5a f5 ff ff       	callq  4050e0 <_ZN11__sanitizer8RawWriteEPKc>
  405b86:	e8 d5 f6 ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  405b8b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000405b90 <_ZN11__sanitizer17DecreaseTotalMmapEm>:
}

void DecreaseTotalMmap(uptr size) {
  if (!common_flags()->mmap_limit_mb) return;
  405b90:	48 8b 05 21 87 01 00 	mov    0x18721(%rip),%rax        # 41e2b8 <_DYNAMIC+0x2b8>
  405b97:	48 83 78 60 00       	cmpq   $0x0,0x60(%rax)
  405b9c:	75 02                	jne    405ba0 <_ZN11__sanitizer17DecreaseTotalMmapEm+0x10>
  405b9e:	f3 c3                	repz retq 
template<typename T>
INLINE typename T::Type atomic_fetch_sub(volatile T *a,
    typename T::Type v, memory_order mo) {
  (void)mo;
  DCHECK(!((uptr)a % sizeof(*a)));
  return __sync_fetch_and_add(&a->val_dont_use, -v);
  405ba0:	48 f7 df             	neg    %rdi
  405ba3:	f0 48 01 3d 95 bb 26 	lock add %rdi,0x26bb95(%rip)        # 671740 <_ZN11__sanitizerL14g_total_mmapedE>
  405baa:	00 
  405bab:	c3                   	retq   
  405bac:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000405bb0 <_ZN11__sanitizer13TemplateMatchEPKcS1_>:
  atomic_fetch_sub(&g_total_mmaped, size, memory_order_relaxed);
}

bool TemplateMatch(const char *templ, const char *str) {
  405bb0:	41 57                	push   %r15
  405bb2:	41 56                	push   %r14
  405bb4:	41 55                	push   %r13
  405bb6:	41 54                	push   %r12
  405bb8:	49 89 f4             	mov    %rsi,%r12
  405bbb:	55                   	push   %rbp
  405bbc:	53                   	push   %rbx
  405bbd:	48 83 ec 08          	sub    $0x8,%rsp
  if ((!str) || str[0] == 0)
  405bc1:	48 85 f6             	test   %rsi,%rsi
  405bc4:	0f 84 16 01 00 00    	je     405ce0 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x130>
  405bca:	80 3e 00             	cmpb   $0x0,(%rsi)
  405bcd:	0f 84 0d 01 00 00    	je     405ce0 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x130>
    return false;
  bool start = false;
  if (templ && templ[0] == '^') {
  405bd3:	48 85 ff             	test   %rdi,%rdi
  405bd6:	48 89 fb             	mov    %rdi,%rbx
  405bd9:	0f 84 e1 00 00 00    	je     405cc0 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x110>
  405bdf:	0f b6 17             	movzbl (%rdi),%edx
}

bool TemplateMatch(const char *templ, const char *str) {
  if ((!str) || str[0] == 0)
    return false;
  bool start = false;
  405be2:	45 31 f6             	xor    %r14d,%r14d
  if (templ && templ[0] == '^') {
  405be5:	80 fa 5e             	cmp    $0x5e,%dl
  405be8:	0f 84 62 01 00 00    	je     405d50 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x1a0>
    start = true;
    templ++;
  }
  bool asterisk = false;
  while (templ && templ[0]) {
  405bee:	84 d2                	test   %dl,%dl
  405bf0:	0f 84 ca 00 00 00    	je     405cc0 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x110>
  405bf6:	31 c9                	xor    %ecx,%ecx
    if (templ[0] == '*') {
  405bf8:	80 fa 2a             	cmp    $0x2a,%dl
  405bfb:	0f 84 aa 00 00 00    	je     405cab <_ZN11__sanitizer13TemplateMatchEPKcS1_+0xfb>
  405c01:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      templ++;
      start = false;
      asterisk = true;
      continue;
    }
    if (templ[0] == '$')
  405c08:	80 fa 24             	cmp    $0x24,%dl
  405c0b:	0f 84 5f 01 00 00    	je     405d70 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x1c0>
      return str[0] == 0 || asterisk;
    if (str[0] == 0)
  405c11:	41 80 3c 24 00       	cmpb   $0x0,(%r12)
  405c16:	0f 84 c4 00 00 00    	je     405ce0 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x130>
      return false;
    char *tpos = (char*)internal_strchr(templ, '*');
  405c1c:	be 2a 00 00 00       	mov    $0x2a,%esi
  405c21:	48 89 df             	mov    %rbx,%rdi
  405c24:	e8 47 4c 00 00       	callq  40a870 <_ZN11__sanitizer15internal_strchrEPKci>
    char *tpos1 = (char*)internal_strchr(templ, '$');
  405c29:	be 24 00 00 00       	mov    $0x24,%esi
    }
    if (templ[0] == '$')
      return str[0] == 0 || asterisk;
    if (str[0] == 0)
      return false;
    char *tpos = (char*)internal_strchr(templ, '*');
  405c2e:	48 89 c5             	mov    %rax,%rbp
    char *tpos1 = (char*)internal_strchr(templ, '$');
  405c31:	48 89 df             	mov    %rbx,%rdi
  405c34:	e8 37 4c 00 00       	callq  40a870 <_ZN11__sanitizer15internal_strchrEPKci>
    if ((!tpos) || (tpos1 && tpos1 < tpos))
  405c39:	48 85 ed             	test   %rbp,%rbp
    if (templ[0] == '$')
      return str[0] == 0 || asterisk;
    if (str[0] == 0)
      return false;
    char *tpos = (char*)internal_strchr(templ, '*');
    char *tpos1 = (char*)internal_strchr(templ, '$');
  405c3c:	49 89 c7             	mov    %rax,%r15
    if ((!tpos) || (tpos1 && tpos1 < tpos))
  405c3f:	0f 84 b3 00 00 00    	je     405cf8 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x148>
  405c45:	48 39 e8             	cmp    %rbp,%rax
  405c48:	73 09                	jae    405c53 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0xa3>
  405c4a:	48 85 c0             	test   %rax,%rax
  405c4d:	0f 85 a5 00 00 00    	jne    405cf8 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x148>
      tpos = tpos1;
    if (tpos)
      tpos[0] = 0;
    const char *str0 = str;
    const char *spos = internal_strstr(str, templ);
  405c53:	48 89 de             	mov    %rbx,%rsi
  405c56:	4c 89 e7             	mov    %r12,%rdi
    char *tpos = (char*)internal_strchr(templ, '*');
    char *tpos1 = (char*)internal_strchr(templ, '$');
    if ((!tpos) || (tpos1 && tpos1 < tpos))
      tpos = tpos1;
    if (tpos)
      tpos[0] = 0;
  405c59:	c6 45 00 00          	movb   $0x0,0x0(%rbp)
    const char *str0 = str;
    const char *spos = internal_strstr(str, templ);
  405c5d:	e8 ee 4d 00 00       	callq  40aa50 <_ZN11__sanitizer15internal_strstrEPKcS1_>
    str = spos + internal_strlen(templ);
  405c62:	48 89 df             	mov    %rbx,%rdi
    if ((!tpos) || (tpos1 && tpos1 < tpos))
      tpos = tpos1;
    if (tpos)
      tpos[0] = 0;
    const char *str0 = str;
    const char *spos = internal_strstr(str, templ);
  405c65:	49 89 c5             	mov    %rax,%r13
    str = spos + internal_strlen(templ);
  405c68:	e8 c3 4c 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  405c6d:	4c 01 e8             	add    %r13,%rax
    templ = tpos;
    if (tpos)
      tpos[0] = tpos == tpos1 ? '$' : '*';
  405c70:	4c 39 fd             	cmp    %r15,%rbp
  405c73:	0f 84 a1 00 00 00    	je     405d1a <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x16a>
  405c79:	ba 2a 00 00 00       	mov    $0x2a,%edx
  405c7e:	88 55 00             	mov    %dl,0x0(%rbp)
  405c81:	48 89 eb             	mov    %rbp,%rbx
    if (!spos)
  405c84:	4d 85 ed             	test   %r13,%r13
  405c87:	74 57                	je     405ce0 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x130>
      return false;
    if (start && spos != str0)
  405c89:	4d 39 ec             	cmp    %r13,%r12
  405c8c:	75 4a                	jne    405cd8 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x128>
      return false;
    start = false;
    asterisk = false;
  405c8e:	31 c9                	xor    %ecx,%ecx
  if (templ && templ[0] == '^') {
    start = true;
    templ++;
  }
  bool asterisk = false;
  while (templ && templ[0]) {
  405c90:	48 85 db             	test   %rbx,%rbx
  405c93:	74 2b                	je     405cc0 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x110>
  405c95:	0f b6 13             	movzbl (%rbx),%edx
  405c98:	84 d2                	test   %dl,%dl
  405c9a:	74 24                	je     405cc0 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x110>
  405c9c:	45 31 f6             	xor    %r14d,%r14d
    if (templ[0] == '*') {
  405c9f:	80 fa 2a             	cmp    $0x2a,%dl
  if (templ && templ[0] == '^') {
    start = true;
    templ++;
  }
  bool asterisk = false;
  while (templ && templ[0]) {
  405ca2:	49 89 c4             	mov    %rax,%r12
    if (templ[0] == '*') {
  405ca5:	0f 85 5d ff ff ff    	jne    405c08 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x58>
      templ++;
  405cab:	48 83 c3 01          	add    $0x1,%rbx
      start = false;
      asterisk = true;
      continue;
  405caf:	4c 89 e0             	mov    %r12,%rax
  bool asterisk = false;
  while (templ && templ[0]) {
    if (templ[0] == '*') {
      templ++;
      start = false;
      asterisk = true;
  405cb2:	b9 01 00 00 00       	mov    $0x1,%ecx
  if (templ && templ[0] == '^') {
    start = true;
    templ++;
  }
  bool asterisk = false;
  while (templ && templ[0]) {
  405cb7:	48 85 db             	test   %rbx,%rbx
  405cba:	75 d9                	jne    405c95 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0xe5>
  405cbc:	0f 1f 40 00          	nopl   0x0(%rax)
      return false;
    start = false;
    asterisk = false;
  }
  return true;
}
  405cc0:	48 83 c4 08          	add    $0x8,%rsp
    if (start && spos != str0)
      return false;
    start = false;
    asterisk = false;
  }
  return true;
  405cc4:	b8 01 00 00 00       	mov    $0x1,%eax
}
  405cc9:	5b                   	pop    %rbx
  405cca:	5d                   	pop    %rbp
  405ccb:	41 5c                	pop    %r12
  405ccd:	41 5d                	pop    %r13
  405ccf:	41 5e                	pop    %r14
  405cd1:	41 5f                	pop    %r15
  405cd3:	c3                   	retq   
  405cd4:	0f 1f 40 00          	nopl   0x0(%rax)
    templ = tpos;
    if (tpos)
      tpos[0] = tpos == tpos1 ? '$' : '*';
    if (!spos)
      return false;
    if (start && spos != str0)
  405cd8:	45 84 f6             	test   %r14b,%r14b
  405cdb:	74 b1                	je     405c8e <_ZN11__sanitizer13TemplateMatchEPKcS1_+0xde>
  405cdd:	0f 1f 00             	nopl   (%rax)
  atomic_fetch_sub(&g_total_mmaped, size, memory_order_relaxed);
}

bool TemplateMatch(const char *templ, const char *str) {
  if ((!str) || str[0] == 0)
    return false;
  405ce0:	31 c0                	xor    %eax,%eax
      return false;
    start = false;
    asterisk = false;
  }
  return true;
}
  405ce2:	48 83 c4 08          	add    $0x8,%rsp
  405ce6:	5b                   	pop    %rbx
  405ce7:	5d                   	pop    %rbp
  405ce8:	41 5c                	pop    %r12
  405cea:	41 5d                	pop    %r13
  405cec:	41 5e                	pop    %r14
  405cee:	41 5f                	pop    %r15
  405cf0:	c3                   	retq   
  405cf1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      return false;
    char *tpos = (char*)internal_strchr(templ, '*');
    char *tpos1 = (char*)internal_strchr(templ, '$');
    if ((!tpos) || (tpos1 && tpos1 < tpos))
      tpos = tpos1;
    if (tpos)
  405cf8:	4d 85 ff             	test   %r15,%r15
  405cfb:	74 33                	je     405d30 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x180>
      tpos[0] = 0;
    const char *str0 = str;
    const char *spos = internal_strstr(str, templ);
  405cfd:	48 89 de             	mov    %rbx,%rsi
  405d00:	4c 89 e7             	mov    %r12,%rdi
    char *tpos = (char*)internal_strchr(templ, '*');
    char *tpos1 = (char*)internal_strchr(templ, '$');
    if ((!tpos) || (tpos1 && tpos1 < tpos))
      tpos = tpos1;
    if (tpos)
      tpos[0] = 0;
  405d03:	41 c6 07 00          	movb   $0x0,(%r15)
    const char *str0 = str;
    const char *spos = internal_strstr(str, templ);
  405d07:	e8 44 4d 00 00       	callq  40aa50 <_ZN11__sanitizer15internal_strstrEPKcS1_>
    str = spos + internal_strlen(templ);
  405d0c:	48 89 df             	mov    %rbx,%rdi
    if ((!tpos) || (tpos1 && tpos1 < tpos))
      tpos = tpos1;
    if (tpos)
      tpos[0] = 0;
    const char *str0 = str;
    const char *spos = internal_strstr(str, templ);
  405d0f:	49 89 c5             	mov    %rax,%r13
    str = spos + internal_strlen(templ);
  405d12:	e8 19 4c 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  405d17:	4c 01 e8             	add    %r13,%rax
  405d1a:	4c 89 fd             	mov    %r15,%rbp
    templ = tpos;
    if (tpos)
      tpos[0] = tpos == tpos1 ? '$' : '*';
  405d1d:	ba 24 00 00 00       	mov    $0x24,%edx
  405d22:	e9 57 ff ff ff       	jmpq   405c7e <_ZN11__sanitizer13TemplateMatchEPKcS1_+0xce>
  405d27:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  405d2e:	00 00 
    if ((!tpos) || (tpos1 && tpos1 < tpos))
      tpos = tpos1;
    if (tpos)
      tpos[0] = 0;
    const char *str0 = str;
    const char *spos = internal_strstr(str, templ);
  405d30:	48 89 de             	mov    %rbx,%rsi
  405d33:	4c 89 e7             	mov    %r12,%rdi
  405d36:	e8 15 4d 00 00       	callq  40aa50 <_ZN11__sanitizer15internal_strstrEPKcS1_>
    str = spos + internal_strlen(templ);
  405d3b:	48 89 df             	mov    %rbx,%rdi
    if ((!tpos) || (tpos1 && tpos1 < tpos))
      tpos = tpos1;
    if (tpos)
      tpos[0] = 0;
    const char *str0 = str;
    const char *spos = internal_strstr(str, templ);
  405d3e:	49 89 c5             	mov    %rax,%r13
    str = spos + internal_strlen(templ);
  405d41:	31 db                	xor    %ebx,%ebx
  405d43:	e8 e8 4b 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  405d48:	4c 01 e8             	add    %r13,%rax
  405d4b:	e9 34 ff ff ff       	jmpq   405c84 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0xd4>
  if (templ && templ[0] == '^') {
    start = true;
    templ++;
  }
  bool asterisk = false;
  while (templ && templ[0]) {
  405d50:	48 89 f8             	mov    %rdi,%rax
  405d53:	48 83 c0 01          	add    $0x1,%rax
  405d57:	0f 84 63 ff ff ff    	je     405cc0 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x110>
  405d5d:	0f b6 57 01          	movzbl 0x1(%rdi),%edx
  405d61:	48 89 c3             	mov    %rax,%rbx
bool TemplateMatch(const char *templ, const char *str) {
  if ((!str) || str[0] == 0)
    return false;
  bool start = false;
  if (templ && templ[0] == '^') {
    start = true;
  405d64:	41 be 01 00 00 00    	mov    $0x1,%r14d
  405d6a:	e9 7f fe ff ff       	jmpq   405bee <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x3e>
  405d6f:	90                   	nop
      start = false;
      asterisk = true;
      continue;
    }
    if (templ[0] == '$')
      return str[0] == 0 || asterisk;
  405d70:	41 80 3c 24 00       	cmpb   $0x0,(%r12)
  405d75:	89 c8                	mov    %ecx,%eax
  405d77:	0f 85 65 ff ff ff    	jne    405ce2 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x132>
  405d7d:	e9 3e ff ff ff       	jmpq   405cc0 <_ZN11__sanitizer13TemplateMatchEPKcS1_+0x110>
  405d82:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  405d89:	1f 84 00 00 00 00 00 

0000000000405d90 <_ZN11__sanitizer16FindPathToBinaryEPKc>:
  return true;
}

static const char kPathSeparator = SANITIZER_WINDOWS ? ';' : ':';

char *FindPathToBinary(const char *name) {
  405d90:	41 57                	push   %r15
  405d92:	41 56                	push   %r14
  405d94:	41 55                	push   %r13
  405d96:	41 54                	push   %r12
  405d98:	55                   	push   %rbp
  405d99:	53                   	push   %rbx
  405d9a:	48 89 fb             	mov    %rdi,%rbx
  405d9d:	48 83 ec 18          	sub    $0x18,%rsp
  405da1:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  const char *path = GetEnv("PATH");
  405da6:	48 8d 3d c7 27 01 00 	lea    0x127c7(%rip),%rdi        # 418574 <.LC17>
  405dad:	e8 2e 59 00 00       	callq  40b6e0 <_ZN11__sanitizer6GetEnvEPKc>
  if (!path)
  405db2:	48 85 c0             	test   %rax,%rax
}

static const char kPathSeparator = SANITIZER_WINDOWS ? ';' : ':';

char *FindPathToBinary(const char *name) {
  const char *path = GetEnv("PATH");
  405db5:	48 89 c5             	mov    %rax,%rbp
  if (!path)
  405db8:	0f 84 bb 00 00 00    	je     405e79 <_ZN11__sanitizer16FindPathToBinaryEPKc+0xe9>
    return nullptr;
  uptr name_len = internal_strlen(name);
  405dbe:	48 89 df             	mov    %rbx,%rdi
  405dc1:	e8 6a 4b 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  405dc6:	48 8d 35 ac 27 01 00 	lea    0x127ac(%rip),%rsi        # 418579 <.LC1>
  405dcd:	bf 00 10 00 00       	mov    $0x1000,%edi
  405dd2:	49 89 c6             	mov    %rax,%r14
  405dd5:	e8 c6 65 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  405dda:	49 89 c5             	mov    %rax,%r13
  405ddd:	eb 0a                	jmp    405de9 <_ZN11__sanitizer16FindPathToBinaryEPKc+0x59>
  405ddf:	90                   	nop
      internal_memcpy(&buffer[prefix_len + 1], name, name_len);
      buffer[prefix_len + 1 + name_len] = '\0';
      if (FileExists(buffer.data()))
        return internal_strdup(buffer.data());
    }
    if (*end == '\0') break;
  405de0:	80 3b 00             	cmpb   $0x0,(%rbx)
  405de3:	74 73                	je     405e58 <_ZN11__sanitizer16FindPathToBinaryEPKc+0xc8>
    beg = end + 1;
  405de5:	48 8d 6b 01          	lea    0x1(%rbx),%rbp
    return nullptr;
  uptr name_len = internal_strlen(name);
  InternalScopedBuffer<char> buffer(kMaxPathLength);
  const char *beg = path;
  while (true) {
    const char *end = internal_strchrnul(beg, kPathSeparator);
  405de9:	be 3a 00 00 00       	mov    $0x3a,%esi
  405dee:	48 89 ef             	mov    %rbp,%rdi
  405df1:	e8 aa 4a 00 00       	callq  40a8a0 <_ZN11__sanitizer18internal_strchrnulEPKci>
    uptr prefix_len = end - beg;
  405df6:	49 89 c4             	mov    %rax,%r12
    return nullptr;
  uptr name_len = internal_strlen(name);
  InternalScopedBuffer<char> buffer(kMaxPathLength);
  const char *beg = path;
  while (true) {
    const char *end = internal_strchrnul(beg, kPathSeparator);
  405df9:	48 89 c3             	mov    %rax,%rbx
    uptr prefix_len = end - beg;
  405dfc:	49 29 ec             	sub    %rbp,%r12
    if (prefix_len + name_len + 2 <= kMaxPathLength) {
  405dff:	4f 8d 3c 34          	lea    (%r12,%r14,1),%r15
  405e03:	49 8d 47 02          	lea    0x2(%r15),%rax
  405e07:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  405e0d:	77 d1                	ja     405de0 <_ZN11__sanitizer16FindPathToBinaryEPKc+0x50>
      internal_memcpy(buffer.data(), beg, prefix_len);
  405e0f:	4c 89 e2             	mov    %r12,%rdx
  405e12:	48 89 ee             	mov    %rbp,%rsi
  405e15:	4c 89 ef             	mov    %r13,%rdi
  405e18:	e8 f3 40 00 00       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
      buffer[prefix_len] = '/';
      internal_memcpy(&buffer[prefix_len + 1], name, name_len);
  405e1d:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  }
  ~InternalScopedBuffer() {
    UnmapOrDie(ptr_, cnt_ * sizeof(T));
  }
  T &operator[](uptr i) { return ptr_[i]; }
  405e22:	4b 8d 7c 25 01       	lea    0x1(%r13,%r12,1),%rdi
  405e27:	4c 89 f2             	mov    %r14,%rdx
  while (true) {
    const char *end = internal_strchrnul(beg, kPathSeparator);
    uptr prefix_len = end - beg;
    if (prefix_len + name_len + 2 <= kMaxPathLength) {
      internal_memcpy(buffer.data(), beg, prefix_len);
      buffer[prefix_len] = '/';
  405e2a:	43 c6 44 25 00 2f    	movb   $0x2f,0x0(%r13,%r12,1)
      internal_memcpy(&buffer[prefix_len + 1], name, name_len);
  405e30:	e8 db 40 00 00       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
      buffer[prefix_len + 1 + name_len] = '\0';
  405e35:	43 c6 44 3d 01 00    	movb   $0x0,0x1(%r13,%r15,1)
      if (FileExists(buffer.data()))
  405e3b:	4c 89 ef             	mov    %r13,%rdi
  405e3e:	e8 1d 58 00 00       	callq  40b660 <_ZN11__sanitizer10FileExistsEPKc>
  405e43:	84 c0                	test   %al,%al
  405e45:	74 99                	je     405de0 <_ZN11__sanitizer16FindPathToBinaryEPKc+0x50>
        return internal_strdup(buffer.data());
  405e47:	4c 89 ef             	mov    %r13,%rdi
  405e4a:	e8 71 45 00 00       	callq  40a3c0 <_ZN11__sanitizer15internal_strdupEPKc>
  405e4f:	48 89 c3             	mov    %rax,%rbx
  405e52:	eb 06                	jmp    405e5a <_ZN11__sanitizer16FindPathToBinaryEPKc+0xca>
  405e54:	0f 1f 40 00          	nopl   0x0(%rax)
    }
    if (*end == '\0') break;
    beg = end + 1;
  }
  return nullptr;
  405e58:	31 db                	xor    %ebx,%ebx
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  }
  ~InternalScopedBuffer() {
    UnmapOrDie(ptr_, cnt_ * sizeof(T));
  405e5a:	be 00 10 00 00       	mov    $0x1000,%esi
  405e5f:	4c 89 ef             	mov    %r13,%rdi
  405e62:	e8 d9 65 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
}
  405e67:	48 83 c4 18          	add    $0x18,%rsp
  405e6b:	48 89 d8             	mov    %rbx,%rax
  405e6e:	5b                   	pop    %rbx
  405e6f:	5d                   	pop    %rbp
  405e70:	41 5c                	pop    %r12
  405e72:	41 5d                	pop    %r13
  405e74:	41 5e                	pop    %r14
  405e76:	41 5f                	pop    %r15
  405e78:	c3                   	retq   
static const char kPathSeparator = SANITIZER_WINDOWS ? ';' : ':';

char *FindPathToBinary(const char *name) {
  const char *path = GetEnv("PATH");
  if (!path)
    return nullptr;
  405e79:	31 db                	xor    %ebx,%ebx
  405e7b:	eb ea                	jmp    405e67 <_ZN11__sanitizer16FindPathToBinaryEPKc+0xd7>
  405e7d:	0f 1f 00             	nopl   (%rax)

0000000000405e80 <_ZN11__sanitizer14GetProcessNameEv>:
static char binary_name_cache_str[kMaxPathLength];
static char process_name_cache_str[kMaxPathLength];

const char *GetProcessName() {
  return process_name_cache_str;
}
  405e80:	48 8d 05 b9 98 26 00 	lea    0x2698b9(%rip),%rax        # 66f740 <_ZN11__sanitizerL22process_name_cache_strE>
  405e87:	c3                   	retq   
  405e88:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  405e8f:	00 

0000000000405e90 <_ZN11__sanitizer17UpdateProcessNameEv>:
    buf[len] = '\0';
  }
  return len;
}

void UpdateProcessName() {
  405e90:	41 54                	push   %r12
const char *GetProcessName() {
  return process_name_cache_str;
}

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  405e92:	48 8d 3d a7 98 26 00 	lea    0x2698a7(%rip),%rdi        # 66f740 <_ZN11__sanitizerL22process_name_cache_strE>
  405e99:	be 00 10 00 00       	mov    $0x1000,%esi
    buf[len] = '\0';
  }
  return len;
}

void UpdateProcessName() {
  405e9e:	55                   	push   %rbp
  405e9f:	53                   	push   %rbx
const char *GetProcessName() {
  return process_name_cache_str;
}

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  405ea0:	e8 4b 60 00 00       	callq  40bef0 <_ZN11__sanitizer19ReadLongProcessNameEPcm>
    // On Windows, both slash and backslash are possible.
    // Pick the one that goes last.
    if (const char *bslash_pos = internal_strrchr(module, '\\'))
      return StripModuleName(bslash_pos + 1);
  }
  if (const char *slash_pos = internal_strrchr(module, '/')) {
  405ea5:	48 8d 3d 94 98 26 00 	lea    0x269894(%rip),%rdi        # 66f740 <_ZN11__sanitizerL22process_name_cache_strE>
  405eac:	be 2f 00 00 00       	mov    $0x2f,%esi
  405eb1:	e8 4a 4a 00 00       	callq  40a900 <_ZN11__sanitizer16internal_strrchrEPKci>
  405eb6:	48 85 c0             	test   %rax,%rax
  405eb9:	74 35                	je     405ef0 <_ZN11__sanitizer17UpdateProcessNameEv+0x60>
    return slash_pos + 1;
  405ebb:	48 8d 58 01          	lea    0x1(%rax),%rbx

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  char *s = const_cast<char *>(StripModuleName(buf));
  uptr len = internal_strlen(s);
  if (s != buf) {
  405ebf:	48 8d 2d 7a 98 26 00 	lea    0x26987a(%rip),%rbp        # 66f740 <_ZN11__sanitizerL22process_name_cache_strE>
}

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  char *s = const_cast<char *>(StripModuleName(buf));
  uptr len = internal_strlen(s);
  405ec6:	48 89 df             	mov    %rbx,%rdi
  405ec9:	e8 62 4a 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  if (s != buf) {
  405ece:	48 39 eb             	cmp    %rbp,%rbx
}

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  char *s = const_cast<char *>(StripModuleName(buf));
  uptr len = internal_strlen(s);
  405ed1:	49 89 c4             	mov    %rax,%r12
  if (s != buf) {
  405ed4:	74 14                	je     405eea <_ZN11__sanitizer17UpdateProcessNameEv+0x5a>
    internal_memmove(buf, s, len);
  405ed6:	48 89 c2             	mov    %rax,%rdx
  405ed9:	48 89 de             	mov    %rbx,%rsi
  405edc:	48 89 ef             	mov    %rbp,%rdi
  405edf:	e8 fc 41 00 00       	callq  40a0e0 <_ZN11__sanitizer16internal_memmoveEPvPKvm>
    buf[len] = '\0';
  405ee4:	42 c6 44 25 00 00    	movb   $0x0,0x0(%rbp,%r12,1)
  return len;
}

void UpdateProcessName() {
  ReadProcessName(process_name_cache_str, sizeof(process_name_cache_str));
}
  405eea:	5b                   	pop    %rbx
  405eeb:	5d                   	pop    %rbp
  405eec:	41 5c                	pop    %r12
  405eee:	c3                   	retq   
  405eef:	90                   	nop
  405ef0:	5b                   	pop    %rbx
  405ef1:	5d                   	pop    %rbp
  405ef2:	41 5c                	pop    %r12
}

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  char *s = const_cast<char *>(StripModuleName(buf));
  uptr len = internal_strlen(s);
  405ef4:	48 8d 3d 45 98 26 00 	lea    0x269845(%rip),%rdi        # 66f740 <_ZN11__sanitizerL22process_name_cache_strE>
  405efb:	e9 30 4a 00 00       	jmpq   40a930 <_ZN11__sanitizer15internal_strlenEPKc>

0000000000405f00 <_ZN11__sanitizer15CacheBinaryNameEv>:
  ReadProcessName(process_name_cache_str, sizeof(process_name_cache_str));
}

// Call once to make sure that binary_name_cache_str is initialized
void CacheBinaryName() {
  if (binary_name_cache_str[0] != '\0')
  405f00:	80 3d 39 a8 26 00 00 	cmpb   $0x0,0x26a839(%rip)        # 670740 <_ZN11__sanitizerL21binary_name_cache_strE>
  405f07:	74 07                	je     405f10 <_ZN11__sanitizer15CacheBinaryNameEv+0x10>
    return;
  ReadBinaryName(binary_name_cache_str, sizeof(binary_name_cache_str));
  ReadProcessName(process_name_cache_str, sizeof(process_name_cache_str));
}
  405f09:	c3                   	retq   
  405f0a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
void UpdateProcessName() {
  ReadProcessName(process_name_cache_str, sizeof(process_name_cache_str));
}

// Call once to make sure that binary_name_cache_str is initialized
void CacheBinaryName() {
  405f10:	41 54                	push   %r12
  if (binary_name_cache_str[0] != '\0')
    return;
  ReadBinaryName(binary_name_cache_str, sizeof(binary_name_cache_str));
  405f12:	48 8d 3d 27 a8 26 00 	lea    0x26a827(%rip),%rdi        # 670740 <_ZN11__sanitizerL21binary_name_cache_strE>
  405f19:	be 00 10 00 00       	mov    $0x1000,%esi
void UpdateProcessName() {
  ReadProcessName(process_name_cache_str, sizeof(process_name_cache_str));
}

// Call once to make sure that binary_name_cache_str is initialized
void CacheBinaryName() {
  405f1e:	55                   	push   %rbp
  405f1f:	53                   	push   %rbx
  if (binary_name_cache_str[0] != '\0')
    return;
  ReadBinaryName(binary_name_cache_str, sizeof(binary_name_cache_str));
  405f20:	e8 3b 5f 00 00       	callq  40be60 <_ZN11__sanitizer14ReadBinaryNameEPcm>
const char *GetProcessName() {
  return process_name_cache_str;
}

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  405f25:	48 8d 3d 14 98 26 00 	lea    0x269814(%rip),%rdi        # 66f740 <_ZN11__sanitizerL22process_name_cache_strE>
  405f2c:	be 00 10 00 00       	mov    $0x1000,%esi
  405f31:	e8 ba 5f 00 00       	callq  40bef0 <_ZN11__sanitizer19ReadLongProcessNameEPcm>
    // On Windows, both slash and backslash are possible.
    // Pick the one that goes last.
    if (const char *bslash_pos = internal_strrchr(module, '\\'))
      return StripModuleName(bslash_pos + 1);
  }
  if (const char *slash_pos = internal_strrchr(module, '/')) {
  405f36:	48 8d 3d 03 98 26 00 	lea    0x269803(%rip),%rdi        # 66f740 <_ZN11__sanitizerL22process_name_cache_strE>
  405f3d:	be 2f 00 00 00       	mov    $0x2f,%esi
  405f42:	e8 b9 49 00 00       	callq  40a900 <_ZN11__sanitizer16internal_strrchrEPKci>
  405f47:	48 85 c0             	test   %rax,%rax
  405f4a:	74 34                	je     405f80 <_ZN11__sanitizer15CacheBinaryNameEv+0x80>
    return slash_pos + 1;
  405f4c:	48 8d 58 01          	lea    0x1(%rax),%rbx

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  char *s = const_cast<char *>(StripModuleName(buf));
  uptr len = internal_strlen(s);
  if (s != buf) {
  405f50:	48 8d 2d e9 97 26 00 	lea    0x2697e9(%rip),%rbp        # 66f740 <_ZN11__sanitizerL22process_name_cache_strE>
}

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  char *s = const_cast<char *>(StripModuleName(buf));
  uptr len = internal_strlen(s);
  405f57:	48 89 df             	mov    %rbx,%rdi
  405f5a:	e8 d1 49 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  if (s != buf) {
  405f5f:	48 39 eb             	cmp    %rbp,%rbx
}

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  char *s = const_cast<char *>(StripModuleName(buf));
  uptr len = internal_strlen(s);
  405f62:	49 89 c4             	mov    %rax,%r12
  if (s != buf) {
  405f65:	74 14                	je     405f7b <_ZN11__sanitizer15CacheBinaryNameEv+0x7b>
    internal_memmove(buf, s, len);
  405f67:	48 89 c2             	mov    %rax,%rdx
  405f6a:	48 89 de             	mov    %rbx,%rsi
  405f6d:	48 89 ef             	mov    %rbp,%rdi
  405f70:	e8 6b 41 00 00       	callq  40a0e0 <_ZN11__sanitizer16internal_memmoveEPvPKvm>
    buf[len] = '\0';
  405f75:	42 c6 44 25 00 00    	movb   $0x0,0x0(%rbp,%r12,1)
void CacheBinaryName() {
  if (binary_name_cache_str[0] != '\0')
    return;
  ReadBinaryName(binary_name_cache_str, sizeof(binary_name_cache_str));
  ReadProcessName(process_name_cache_str, sizeof(process_name_cache_str));
}
  405f7b:	5b                   	pop    %rbx
  405f7c:	5d                   	pop    %rbp
  405f7d:	41 5c                	pop    %r12
  405f7f:	c3                   	retq   
  405f80:	5b                   	pop    %rbx
  405f81:	5d                   	pop    %rbp
  405f82:	41 5c                	pop    %r12
}

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  char *s = const_cast<char *>(StripModuleName(buf));
  uptr len = internal_strlen(s);
  405f84:	48 8d 3d b5 97 26 00 	lea    0x2697b5(%rip),%rdi        # 66f740 <_ZN11__sanitizerL22process_name_cache_strE>
  405f8b:	e9 a0 49 00 00       	jmpq   40a930 <_ZN11__sanitizer15internal_strlenEPKc>

0000000000405f90 <_ZN11__sanitizer20ReadBinaryNameCachedEPcm>:
    return;
  ReadBinaryName(binary_name_cache_str, sizeof(binary_name_cache_str));
  ReadProcessName(process_name_cache_str, sizeof(process_name_cache_str));
}

uptr ReadBinaryNameCached(/*out*/char *buf, uptr buf_len) {
  405f90:	41 56                	push   %r14
  ReadProcessName(process_name_cache_str, sizeof(process_name_cache_str));
}

// Call once to make sure that binary_name_cache_str is initialized
void CacheBinaryName() {
  if (binary_name_cache_str[0] != '\0')
  405f92:	80 3d a7 a7 26 00 00 	cmpb   $0x0,0x26a7a7(%rip)        # 670740 <_ZN11__sanitizerL21binary_name_cache_strE>
    return;
  ReadBinaryName(binary_name_cache_str, sizeof(binary_name_cache_str));
  ReadProcessName(process_name_cache_str, sizeof(process_name_cache_str));
}

uptr ReadBinaryNameCached(/*out*/char *buf, uptr buf_len) {
  405f99:	41 55                	push   %r13
  405f9b:	41 54                	push   %r12
  405f9d:	55                   	push   %rbp
  405f9e:	48 89 fd             	mov    %rdi,%rbp
  405fa1:	53                   	push   %rbx
  405fa2:	48 89 f3             	mov    %rsi,%rbx
  ReadProcessName(process_name_cache_str, sizeof(process_name_cache_str));
}

// Call once to make sure that binary_name_cache_str is initialized
void CacheBinaryName() {
  if (binary_name_cache_str[0] != '\0')
  405fa5:	74 49                	je     405ff0 <_ZN11__sanitizer20ReadBinaryNameCachedEPcm+0x60>
  ReadProcessName(process_name_cache_str, sizeof(process_name_cache_str));
}

uptr ReadBinaryNameCached(/*out*/char *buf, uptr buf_len) {
  CacheBinaryName();
  uptr name_len = internal_strlen(binary_name_cache_str);
  405fa7:	48 8d 3d 92 a7 26 00 	lea    0x26a792(%rip),%rdi        # 670740 <_ZN11__sanitizerL21binary_name_cache_strE>
  405fae:	e8 7d 49 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  405fb3:	48 89 c2             	mov    %rax,%rdx
  name_len = (name_len < buf_len - 1) ? name_len : buf_len - 1;
  if (buf_len == 0)
    return 0;
  405fb6:	31 c0                	xor    %eax,%eax

uptr ReadBinaryNameCached(/*out*/char *buf, uptr buf_len) {
  CacheBinaryName();
  uptr name_len = internal_strlen(binary_name_cache_str);
  name_len = (name_len < buf_len - 1) ? name_len : buf_len - 1;
  if (buf_len == 0)
  405fb8:	48 85 db             	test   %rbx,%rbx
  405fbb:	74 25                	je     405fe2 <_ZN11__sanitizer20ReadBinaryNameCachedEPcm+0x52>
}

uptr ReadBinaryNameCached(/*out*/char *buf, uptr buf_len) {
  CacheBinaryName();
  uptr name_len = internal_strlen(binary_name_cache_str);
  name_len = (name_len < buf_len - 1) ? name_len : buf_len - 1;
  405fbd:	48 83 eb 01          	sub    $0x1,%rbx
  if (buf_len == 0)
    return 0;
  internal_memcpy(buf, binary_name_cache_str, name_len);
  405fc1:	48 8d 35 78 a7 26 00 	lea    0x26a778(%rip),%rsi        # 670740 <_ZN11__sanitizerL21binary_name_cache_strE>
  405fc8:	48 89 ef             	mov    %rbp,%rdi
}

uptr ReadBinaryNameCached(/*out*/char *buf, uptr buf_len) {
  CacheBinaryName();
  uptr name_len = internal_strlen(binary_name_cache_str);
  name_len = (name_len < buf_len - 1) ? name_len : buf_len - 1;
  405fcb:	48 39 da             	cmp    %rbx,%rdx
  405fce:	48 0f 46 da          	cmovbe %rdx,%rbx
  if (buf_len == 0)
    return 0;
  internal_memcpy(buf, binary_name_cache_str, name_len);
  405fd2:	48 89 da             	mov    %rbx,%rdx
  405fd5:	e8 36 3f 00 00       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
  buf[name_len] = '\0';
  405fda:	c6 44 1d 00 00       	movb   $0x0,0x0(%rbp,%rbx,1)
  return name_len;
  405fdf:	48 89 d8             	mov    %rbx,%rax
}
  405fe2:	5b                   	pop    %rbx
  405fe3:	5d                   	pop    %rbp
  405fe4:	41 5c                	pop    %r12
  405fe6:	41 5d                	pop    %r13
  405fe8:	41 5e                	pop    %r14
  405fea:	c3                   	retq   
  405feb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

// Call once to make sure that binary_name_cache_str is initialized
void CacheBinaryName() {
  if (binary_name_cache_str[0] != '\0')
    return;
  ReadBinaryName(binary_name_cache_str, sizeof(binary_name_cache_str));
  405ff0:	48 8d 3d 49 a7 26 00 	lea    0x26a749(%rip),%rdi        # 670740 <_ZN11__sanitizerL21binary_name_cache_strE>
  405ff7:	be 00 10 00 00       	mov    $0x1000,%esi
  405ffc:	e8 5f 5e 00 00       	callq  40be60 <_ZN11__sanitizer14ReadBinaryNameEPcm>
const char *GetProcessName() {
  return process_name_cache_str;
}

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  406001:	48 8d 3d 38 97 26 00 	lea    0x269738(%rip),%rdi        # 66f740 <_ZN11__sanitizerL22process_name_cache_strE>
  406008:	be 00 10 00 00       	mov    $0x1000,%esi
  40600d:	e8 de 5e 00 00       	callq  40bef0 <_ZN11__sanitizer19ReadLongProcessNameEPcm>
    // On Windows, both slash and backslash are possible.
    // Pick the one that goes last.
    if (const char *bslash_pos = internal_strrchr(module, '\\'))
      return StripModuleName(bslash_pos + 1);
  }
  if (const char *slash_pos = internal_strrchr(module, '/')) {
  406012:	48 8d 3d 27 97 26 00 	lea    0x269727(%rip),%rdi        # 66f740 <_ZN11__sanitizerL22process_name_cache_strE>
  406019:	be 2f 00 00 00       	mov    $0x2f,%esi
  40601e:	e8 dd 48 00 00       	callq  40a900 <_ZN11__sanitizer16internal_strrchrEPKci>
  406023:	48 85 c0             	test   %rax,%rax
  406026:	74 38                	je     406060 <_ZN11__sanitizer20ReadBinaryNameCachedEPcm+0xd0>
    return slash_pos + 1;
  406028:	4c 8d 60 01          	lea    0x1(%rax),%r12

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  char *s = const_cast<char *>(StripModuleName(buf));
  uptr len = internal_strlen(s);
  if (s != buf) {
  40602c:	4c 8d 2d 0d 97 26 00 	lea    0x26970d(%rip),%r13        # 66f740 <_ZN11__sanitizerL22process_name_cache_strE>
}

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  char *s = const_cast<char *>(StripModuleName(buf));
  uptr len = internal_strlen(s);
  406033:	4c 89 e7             	mov    %r12,%rdi
  406036:	e8 f5 48 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  if (s != buf) {
  40603b:	4d 39 ec             	cmp    %r13,%r12
}

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  char *s = const_cast<char *>(StripModuleName(buf));
  uptr len = internal_strlen(s);
  40603e:	49 89 c6             	mov    %rax,%r14
  if (s != buf) {
  406041:	0f 84 60 ff ff ff    	je     405fa7 <_ZN11__sanitizer20ReadBinaryNameCachedEPcm+0x17>
    internal_memmove(buf, s, len);
  406047:	48 89 c2             	mov    %rax,%rdx
  40604a:	4c 89 e6             	mov    %r12,%rsi
  40604d:	4c 89 ef             	mov    %r13,%rdi
  406050:	e8 8b 40 00 00       	callq  40a0e0 <_ZN11__sanitizer16internal_memmoveEPvPKvm>
    buf[len] = '\0';
  406055:	43 c6 44 35 00 00    	movb   $0x0,0x0(%r13,%r14,1)
  40605b:	e9 47 ff ff ff       	jmpq   405fa7 <_ZN11__sanitizer20ReadBinaryNameCachedEPcm+0x17>
}

static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {
  ReadLongProcessName(buf, buf_len);
  char *s = const_cast<char *>(StripModuleName(buf));
  uptr len = internal_strlen(s);
  406060:	48 8d 3d d9 96 26 00 	lea    0x2696d9(%rip),%rdi        # 66f740 <_ZN11__sanitizerL22process_name_cache_strE>
  406067:	e8 c4 48 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  40606c:	e9 36 ff ff ff       	jmpq   405fa7 <_ZN11__sanitizer20ReadBinaryNameCachedEPcm+0x17>
  406071:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  406078:	0f 1f 84 00 00 00 00 
  40607f:	00 

0000000000406080 <__sanitizer_set_report_path>:
} // namespace __sanitizer

using namespace __sanitizer;  // NOLINT

extern "C" {
void __sanitizer_set_report_path(const char *path) {
  406080:	55                   	push   %rbp
  406081:	53                   	push   %rbx
  406082:	48 89 fb             	mov    %rdi,%rbx
  406085:	48 83 ec 28          	sub    $0x28,%rsp
  }
  fd_pid = pid;
}

void ReportFile::SetReportPath(const char *path) {
  if (!path)
  406089:	48 85 ff             	test   %rdi,%rdi
  40608c:	74 5d                	je     4060eb <__sanitizer_set_report_path+0x6b>
    return;
  uptr len = internal_strlen(path);
  40608e:	e8 9d 48 00 00       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  if (len > sizeof(path_prefix) - 100) {
  406093:	48 3d 9c 0f 00 00    	cmp    $0xf9c,%rax
  406099:	0f 87 c0 00 00 00    	ja     40615f <__sanitizer_set_report_path+0xdf>
           path[0], path[1], path[2], path[3],
           path[4], path[5], path[6], path[7]);
    Die();
  }

  SpinMutexLock l(mu);
  40609f:	48 8b 2d 9a 83 01 00 	mov    0x1839a(%rip),%rbp        # 41e440 <_ZN11__sanitizer11report_fileE>
INLINE typename T::Type atomic_exchange(volatile T *a,
    typename T::Type v, memory_order mo) {
  DCHECK(!((uptr)a % sizeof(*a)));
  if (mo & (memory_order_release | memory_order_acq_rel | memory_order_seq_cst))
    __sync_synchronize();
  v = __sync_lock_test_and_set(&a->val_dont_use, v);
  4060a6:	b8 01 00 00 00       	mov    $0x1,%eax
  4060ab:	86 45 00             	xchg   %al,0x0(%rbp)
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  4060ae:	84 c0                	test   %al,%al
  4060b0:	75 46                	jne    4060f8 <__sanitizer_set_report_path+0x78>
  if (fd != kStdoutFd && fd != kStderrFd && fd != kInvalidFd)
  4060b2:	8b 3d 90 83 01 00    	mov    0x18390(%rip),%edi        # 41e448 <_ZN11__sanitizer11report_fileE+0x8>
  4060b8:	8d 47 ff             	lea    -0x1(%rdi),%eax
  4060bb:	83 f8 01             	cmp    $0x1,%eax
  4060be:	77 4e                	ja     40610e <__sanitizer_set_report_path+0x8e>
    CloseFile(fd);
  fd = kInvalidFd;
  if (internal_strcmp(path, "stdout") == 0) {
  4060c0:	48 8d 35 3d 24 01 00 	lea    0x1243d(%rip),%rsi        # 418504 <.LC1>
  4060c7:	48 89 df             	mov    %rbx,%rdi
  }

  SpinMutexLock l(mu);
  if (fd != kStdoutFd && fd != kStderrFd && fd != kInvalidFd)
    CloseFile(fd);
  fd = kInvalidFd;
  4060ca:	c7 05 74 83 01 00 ff 	movl   $0xffffffff,0x18374(%rip)        # 41e448 <_ZN11__sanitizer11report_fileE+0x8>
  4060d1:	ff ff ff 
  if (internal_strcmp(path, "stdout") == 0) {
  4060d4:	e8 07 47 00 00       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
  4060d9:	85 c0                	test   %eax,%eax
  4060db:	75 43                	jne    406120 <__sanitizer_set_report_path+0xa0>
    fd = kStdoutFd;
  4060dd:	c7 05 61 83 01 00 01 	movl   $0x1,0x18361(%rip)        # 41e448 <_ZN11__sanitizer11report_fileE+0x8>
  4060e4:	00 00 00 
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  4060e7:	c6 45 00 00          	movb   $0x0,0x0(%rbp)
using namespace __sanitizer;  // NOLINT

extern "C" {
void __sanitizer_set_report_path(const char *path) {
  report_file.SetReportPath(path);
}
  4060eb:	48 83 c4 28          	add    $0x28,%rsp
  4060ef:	5b                   	pop    %rbx
  4060f0:	5d                   	pop    %rbp
  4060f1:	c3                   	retq   
  4060f2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      return;
    LockSlow();
  4060f8:	48 89 ef             	mov    %rbp,%rdi
  4060fb:	e8 50 e4 ff ff       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
           path[4], path[5], path[6], path[7]);
    Die();
  }

  SpinMutexLock l(mu);
  if (fd != kStdoutFd && fd != kStderrFd && fd != kInvalidFd)
  406100:	8b 3d 42 83 01 00    	mov    0x18342(%rip),%edi        # 41e448 <_ZN11__sanitizer11report_fileE+0x8>
  406106:	8d 47 ff             	lea    -0x1(%rdi),%eax
  406109:	83 f8 01             	cmp    $0x1,%eax
  40610c:	76 b2                	jbe    4060c0 <__sanitizer_set_report_path+0x40>
  40610e:	83 ff ff             	cmp    $0xffffffff,%edi
  406111:	74 ad                	je     4060c0 <__sanitizer_set_report_path+0x40>
    CloseFile(fd);
  406113:	e8 98 65 00 00       	callq  40c6b0 <_ZN11__sanitizer9CloseFileEi>
  406118:	eb a6                	jmp    4060c0 <__sanitizer_set_report_path+0x40>
  40611a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  fd = kInvalidFd;
  if (internal_strcmp(path, "stdout") == 0) {
    fd = kStdoutFd;
  } else if (internal_strcmp(path, "stderr") == 0) {
  406120:	48 8d 35 e4 23 01 00 	lea    0x123e4(%rip),%rsi        # 41850b <.LC13>
  406127:	48 89 df             	mov    %rbx,%rdi
  40612a:	e8 b1 46 00 00       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
  40612f:	85 c0                	test   %eax,%eax
  406131:	75 0d                	jne    406140 <__sanitizer_set_report_path+0xc0>
    fd = kStderrFd;
  406133:	c7 05 0b 83 01 00 02 	movl   $0x2,0x1830b(%rip)        # 41e448 <_ZN11__sanitizer11report_fileE+0x8>
  40613a:	00 00 00 
  40613d:	eb a8                	jmp    4060e7 <__sanitizer_set_report_path+0x67>
  40613f:	90                   	nop
  } else {
    internal_snprintf(path_prefix, kMaxPathLength, "%s", path);
  406140:	48 8d 15 cb 23 01 00 	lea    0x123cb(%rip),%rdx        # 418512 <.LC18>
  406147:	48 8d 3d fe 82 01 00 	lea    0x182fe(%rip),%rdi        # 41e44c <_ZN11__sanitizer11report_fileE+0xc>
  40614e:	48 89 d9             	mov    %rbx,%rcx
  406151:	be 00 10 00 00       	mov    $0x1000,%esi
  406156:	31 c0                	xor    %eax,%eax
  406158:	e8 63 75 00 00       	callq  40d6c0 <_ZN11__sanitizer17internal_snprintfEPcmPKcz>
  40615d:	eb 88                	jmp    4060e7 <__sanitizer_set_report_path+0x67>
    return;
  uptr len = internal_strlen(path);
  if (len > sizeof(path_prefix) - 100) {
    Report("ERROR: Path is too long: %c%c%c%c%c%c%c%c...\n",
           path[0], path[1], path[2], path[3],
           path[4], path[5], path[6], path[7]);
  40615f:	0f be 43 07          	movsbl 0x7(%rbx),%eax
  406163:	44 0f be 4b 04       	movsbl 0x4(%rbx),%r9d
  406168:	48 8d 3d d9 f2 00 00 	lea    0xf2d9(%rip),%rdi        # 415448 <.LC0>
  40616f:	44 0f be 43 03       	movsbl 0x3(%rbx),%r8d
  406174:	0f be 4b 02          	movsbl 0x2(%rbx),%ecx
  406178:	0f be 53 01          	movsbl 0x1(%rbx),%edx
  40617c:	0f be 33             	movsbl (%rbx),%esi
  40617f:	89 44 24 10          	mov    %eax,0x10(%rsp)
  406183:	0f be 43 06          	movsbl 0x6(%rbx),%eax
  406187:	89 44 24 08          	mov    %eax,0x8(%rsp)
  40618b:	0f be 43 05          	movsbl 0x5(%rbx),%eax
  40618f:	89 04 24             	mov    %eax,(%rsp)
  406192:	31 c0                	xor    %eax,%eax
  406194:	e8 f7 78 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
    Die();
  406199:	e8 c2 f0 ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  40619e:	66 90                	xchg   %ax,%ax

00000000004061a0 <__sanitizer_report_error_summary>:
extern "C" {
void __sanitizer_set_report_path(const char *path) {
  report_file.SetReportPath(path);
}

void __sanitizer_report_error_summary(const char *error_summary) {
  4061a0:	48 89 fe             	mov    %rdi,%rsi
  Printf("%s\n", error_summary);
  4061a3:	48 8d 3d e4 23 01 00 	lea    0x123e4(%rip),%rdi        # 41858e <.LC19>
  4061aa:	31 c0                	xor    %eax,%eax
  4061ac:	e9 3f 78 00 00       	jmpq   40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  4061b1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4061b8:	0f 1f 84 00 00 00 00 
  4061bf:	00 

00000000004061c0 <_ZN11__sanitizer18ReportErrorSummaryEPKc>:
  }
  return module;
}

void ReportErrorSummary(const char *error_message) {
  if (!common_flags()->print_summary)
  4061c0:	48 8b 05 f1 80 01 00 	mov    0x180f1(%rip),%rax        # 41e2b8 <_DYNAMIC+0x2b8>
  4061c7:	80 78 3b 00          	cmpb   $0x0,0x3b(%rax)
  4061cb:	75 03                	jne    4061d0 <_ZN11__sanitizer18ReportErrorSummaryEPKc+0x10>
    return;
  InternalScopedString buff(kMaxSummaryLength);
  buff.append("SUMMARY: %s: %s", SanitizerToolName, error_message);
  __sanitizer_report_error_summary(buff.data());
}
  4061cd:	c3                   	retq   
  4061ce:	66 90                	xchg   %ax,%ax
    return slash_pos + 1;
  }
  return module;
}

void ReportErrorSummary(const char *error_message) {
  4061d0:	53                   	push   %rbx
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  4061d1:	48 8d 35 a1 23 01 00 	lea    0x123a1(%rip),%rsi        # 418579 <.LC1>
  4061d8:	48 89 fb             	mov    %rdi,%rbx
  4061db:	bf 00 04 00 00       	mov    $0x400,%edi
  4061e0:	48 83 ec 20          	sub    $0x20,%rsp
// InternalAlloc is made libc-free.
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
  4061e4:	48 c7 44 24 08 00 04 	movq   $0x400,0x8(%rsp)
  4061eb:	00 00 
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  4061ed:	e8 ae 61 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
};

class InternalScopedString : public InternalScopedBuffer<char> {
 public:
  explicit InternalScopedString(uptr max_length)
      : InternalScopedBuffer<char>(max_length), length_(0) {
  4061f2:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
  4061f9:	00 00 
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  4061fb:	48 89 04 24          	mov    %rax,(%rsp)
  if (!common_flags()->print_summary)
    return;
  InternalScopedString buff(kMaxSummaryLength);
  buff.append("SUMMARY: %s: %s", SanitizerToolName, error_message);
  4061ff:	48 8d 35 8c 23 01 00 	lea    0x1238c(%rip),%rsi        # 418592 <.LC20>

class InternalScopedString : public InternalScopedBuffer<char> {
 public:
  explicit InternalScopedString(uptr max_length)
      : InternalScopedBuffer<char>(max_length), length_(0) {
    (*this)[0] = '\0';
  406206:	c6 00 00             	movb   $0x0,(%rax)
  406209:	48 8b 15 50 a2 01 00 	mov    0x1a250(%rip),%rdx        # 420460 <_ZN11__sanitizer17SanitizerToolNameE>
  406210:	48 89 d9             	mov    %rbx,%rcx
  406213:	48 89 e7             	mov    %rsp,%rdi
  406216:	31 c0                	xor    %eax,%eax
  406218:	e8 13 79 00 00       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  __sanitizer_report_error_summary(buff.data());
  40621d:	48 8b 3c 24          	mov    (%rsp),%rdi
  406221:	e8 7a ff ff ff       	callq  4061a0 <__sanitizer_report_error_summary>
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  }
  ~InternalScopedBuffer() {
    UnmapOrDie(ptr_, cnt_ * sizeof(T));
  406226:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  40622b:	48 8b 3c 24          	mov    (%rsp),%rdi
  40622f:	e8 0c 62 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
}
  406234:	48 83 c4 20          	add    $0x20,%rsp
  406238:	5b                   	pop    %rbx
  406239:	c3                   	retq   
  40623a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000406240 <_ZN11__sanitizer18ReportErrorSummaryEPKcRKNS_11AddressInfoE>:

#ifndef SANITIZER_GO
void ReportErrorSummary(const char *error_type, const AddressInfo &info) {
  406240:	41 55                	push   %r13
  406242:	41 54                	push   %r12
  406244:	55                   	push   %rbp
  406245:	53                   	push   %rbx
  406246:	48 83 ec 58          	sub    $0x58,%rsp
  if (!common_flags()->print_summary)
  40624a:	48 8b 1d 67 80 01 00 	mov    0x18067(%rip),%rbx        # 41e2b8 <_DYNAMIC+0x2b8>
  406251:	80 7b 3b 00          	cmpb   $0x0,0x3b(%rbx)
  406255:	75 11                	jne    406268 <_ZN11__sanitizer18ReportErrorSummaryEPKcRKNS_11AddressInfoE+0x28>
  InternalScopedString buff(kMaxSummaryLength);
  buff.append("%s ", error_type);
  RenderFrame(&buff, "%L %F", 0, info, common_flags()->symbolize_vs_style,
              common_flags()->strip_path_prefix);
  ReportErrorSummary(buff.data());
}
  406257:	48 83 c4 58          	add    $0x58,%rsp
  40625b:	5b                   	pop    %rbx
  40625c:	5d                   	pop    %rbp
  40625d:	41 5c                	pop    %r12
  40625f:	41 5d                	pop    %r13
  406261:	c3                   	retq   
  406262:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  406268:	48 89 f5             	mov    %rsi,%rbp
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  40626b:	48 8d 35 07 23 01 00 	lea    0x12307(%rip),%rsi        # 418579 <.LC1>
  406272:	49 89 fc             	mov    %rdi,%r12
#ifndef SANITIZER_GO
void ReportErrorSummary(const char *error_type, const AddressInfo &info) {
  if (!common_flags()->print_summary)
    return;
  InternalScopedString buff(kMaxSummaryLength);
  buff.append("%s ", error_type);
  406275:	4c 8d 6c 24 10       	lea    0x10(%rsp),%r13
  40627a:	bf 00 04 00 00       	mov    $0x400,%edi
// InternalAlloc is made libc-free.
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
  40627f:	48 c7 44 24 18 00 04 	movq   $0x400,0x18(%rsp)
  406286:	00 00 
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  406288:	e8 13 61 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  40628d:	48 8d 35 0e 23 01 00 	lea    0x1230e(%rip),%rsi        # 4185a2 <.LC21>
  406294:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
};

class InternalScopedString : public InternalScopedBuffer<char> {
 public:
  explicit InternalScopedString(uptr max_length)
      : InternalScopedBuffer<char>(max_length), length_(0) {
  406299:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
  4062a0:	00 00 
  4062a2:	4c 89 e2             	mov    %r12,%rdx
    (*this)[0] = '\0';
  4062a5:	c6 00 00             	movb   $0x0,(%rax)
  4062a8:	4c 89 ef             	mov    %r13,%rdi
  4062ab:	31 c0                	xor    %eax,%eax
  4062ad:	e8 7e 78 00 00       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  RenderFrame(&buff, "%L %F", 0, info, common_flags()->symbolize_vs_style,
              common_flags()->strip_path_prefix);
  4062b2:	44 0f b6 83 8d 00 00 	movzbl 0x8d(%rbx),%r8d
  4062b9:	00 
  4062ba:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
  4062be:	48 8d 05 e7 22 01 00 	lea    0x122e7(%rip),%rax        # 4185ac <.LC12>
  4062c5:	48 8d 35 da 22 01 00 	lea    0x122da(%rip),%rsi        # 4185a6 <.LC22>
  4062cc:	48 89 e9             	mov    %rbp,%rcx
  4062cf:	31 d2                	xor    %edx,%edx
  4062d1:	48 89 04 24          	mov    %rax,(%rsp)
  4062d5:	4c 89 ef             	mov    %r13,%rdi
  4062d8:	e8 d3 94 00 00       	callq  40f7b0 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_>
  }
  return module;
}

void ReportErrorSummary(const char *error_message) {
  if (!common_flags()->print_summary)
  4062dd:	80 7b 3b 00          	cmpb   $0x0,0x3b(%rbx)
    return;
  InternalScopedString buff(kMaxSummaryLength);
  buff.append("%s ", error_type);
  RenderFrame(&buff, "%L %F", 0, info, common_flags()->symbolize_vs_style,
              common_flags()->strip_path_prefix);
  ReportErrorSummary(buff.data());
  4062e1:	48 8b 6c 24 10       	mov    0x10(%rsp),%rbp
  }
  return module;
}

void ReportErrorSummary(const char *error_message) {
  if (!common_flags()->print_summary)
  4062e6:	75 18                	jne    406300 <_ZN11__sanitizer18ReportErrorSummaryEPKcRKNS_11AddressInfoE+0xc0>
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  }
  ~InternalScopedBuffer() {
    UnmapOrDie(ptr_, cnt_ * sizeof(T));
  4062e8:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
  4062ed:	48 89 ef             	mov    %rbp,%rdi
  4062f0:	e8 4b 61 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  InternalScopedString buff(kMaxSummaryLength);
  buff.append("%s ", error_type);
  RenderFrame(&buff, "%L %F", 0, info, common_flags()->symbolize_vs_style,
              common_flags()->strip_path_prefix);
  ReportErrorSummary(buff.data());
}
  4062f5:	48 83 c4 58          	add    $0x58,%rsp
  4062f9:	5b                   	pop    %rbx
  4062fa:	5d                   	pop    %rbp
  4062fb:	41 5c                	pop    %r12
  4062fd:	41 5d                	pop    %r13
  4062ff:	c3                   	retq   
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  406300:	48 8d 35 72 22 01 00 	lea    0x12272(%rip),%rsi        # 418579 <.LC1>
  406307:	bf 00 04 00 00       	mov    $0x400,%edi
// InternalAlloc is made libc-free.
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
  40630c:	48 c7 44 24 38 00 04 	movq   $0x400,0x38(%rsp)
  406313:	00 00 
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  406315:	e8 86 60 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
};

class InternalScopedString : public InternalScopedBuffer<char> {
 public:
  explicit InternalScopedString(uptr max_length)
      : InternalScopedBuffer<char>(max_length), length_(0) {
  40631a:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
  406321:	00 00 
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  406323:	48 89 44 24 30       	mov    %rax,0x30(%rsp)

void ReportErrorSummary(const char *error_message) {
  if (!common_flags()->print_summary)
    return;
  InternalScopedString buff(kMaxSummaryLength);
  buff.append("SUMMARY: %s: %s", SanitizerToolName, error_message);
  406328:	48 8d 35 63 22 01 00 	lea    0x12263(%rip),%rsi        # 418592 <.LC20>

class InternalScopedString : public InternalScopedBuffer<char> {
 public:
  explicit InternalScopedString(uptr max_length)
      : InternalScopedBuffer<char>(max_length), length_(0) {
    (*this)[0] = '\0';
  40632f:	c6 00 00             	movb   $0x0,(%rax)
  406332:	48 8b 15 27 a1 01 00 	mov    0x1a127(%rip),%rdx        # 420460 <_ZN11__sanitizer17SanitizerToolNameE>
  406339:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  40633e:	48 89 e9             	mov    %rbp,%rcx
  406341:	31 c0                	xor    %eax,%eax
  406343:	e8 e8 77 00 00       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  __sanitizer_report_error_summary(buff.data());
  406348:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
  40634d:	e8 4e fe ff ff       	callq  4061a0 <__sanitizer_report_error_summary>
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  }
  ~InternalScopedBuffer() {
    UnmapOrDie(ptr_, cnt_ * sizeof(T));
  406352:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  406357:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
  40635c:	e8 df 60 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  406361:	48 8b 6c 24 10       	mov    0x10(%rsp),%rbp
  406366:	eb 80                	jmp    4062e8 <_ZN11__sanitizer18ReportErrorSummaryEPKcRKNS_11AddressInfoE+0xa8>
  406368:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40636f:	00 

0000000000406370 <__sanitizer_set_death_callback>:
  return false;
}

static DieCallbackType UserDieCallback;
void SetUserDieCallback(DieCallbackType callback) {
  UserDieCallback = callback;
  406370:	48 89 3d e9 b3 26 00 	mov    %rdi,0x26b3e9(%rip)        # 671760 <_ZN11__sanitizerL15UserDieCallbackE>
  406377:	c3                   	retq   
  406378:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40637f:	00 

0000000000406380 <_ZN11__sanitizer2DD20CreatePhysicalThreadEv>:
  dd.clear();
}

DDPhysicalThread* DD::CreatePhysicalThread() {
  return nullptr;
}
  406380:	31 c0                	xor    %eax,%eax
  406382:	c3                   	retq   
  406383:	90                   	nop
  406384:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40638b:	00 00 00 00 00 

0000000000406390 <_ZN11__sanitizer2DD21DestroyPhysicalThreadEPNS_16DDPhysicalThreadE>:

void DD::DestroyPhysicalThread(DDPhysicalThread *pt) {
  406390:	f3 c3                	repz retq 
  406392:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  406399:	1f 84 00 00 00 00 00 

00000000004063a0 <_ZN11__sanitizer2DD9MutexInitEPNS_10DDCallbackEPNS_7DDMutexE>:
  InternalFree(lt);
}

void DD::MutexInit(DDCallback *cb, DDMutex *m) {
  m->id = 0;
  m->stk = cb->Unwind();
  4063a0:	48 8b 06             	mov    (%rsi),%rax
void DD::DestroyLogicalThread(DDLogicalThread *lt) {
  lt->~DDLogicalThread();
  InternalFree(lt);
}

void DD::MutexInit(DDCallback *cb, DDMutex *m) {
  4063a3:	53                   	push   %rbx
  4063a4:	48 89 d3             	mov    %rdx,%rbx
  m->id = 0;
  4063a7:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
  m->stk = cb->Unwind();
  4063ae:	48 89 f7             	mov    %rsi,%rdi
  4063b1:	ff 10                	callq  *(%rax)
  4063b3:	89 43 08             	mov    %eax,0x8(%rbx)
}
  4063b6:	5b                   	pop    %rbx
  4063b7:	c3                   	retq   
  4063b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4063bf:	00 

00000000004063c0 <_ZN11__sanitizer2DD9GetReportEPNS_10DDCallbackE>:
    dd.removeNode(m->id);
  m->id = 0;
}

DDReport *DD::GetReport(DDCallback *cb) {
  if (!cb->lt->report_pending)
  4063c0:	48 8b 46 10          	mov    0x10(%rsi),%rax
  4063c4:	80 b8 30 07 00 00 00 	cmpb   $0x0,0x730(%rax)
  4063cb:	74 13                	je     4063e0 <_ZN11__sanitizer2DD9GetReportEPNS_10DDCallbackE+0x20>
    return nullptr;
  cb->lt->report_pending = false;
  4063cd:	c6 80 30 07 00 00 00 	movb   $0x0,0x730(%rax)
  return &cb->lt->rep;
  4063d4:	48 05 28 06 00 00    	add    $0x628,%rax
  4063da:	c3                   	retq   
  4063db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  m->id = 0;
}

DDReport *DD::GetReport(DDCallback *cb) {
  if (!cb->lt->report_pending)
    return nullptr;
  4063e0:	31 c0                	xor    %eax,%eax
  cb->lt->report_pending = false;
  return &cb->lt->rep;
}
  4063e2:	c3                   	retq   
  4063e3:	90                   	nop
  4063e4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4063eb:	00 00 00 00 00 

00000000004063f0 <_ZN11__sanitizer2DD19CreateLogicalThreadEy>:
}

void DD::DestroyPhysicalThread(DDPhysicalThread *pt) {
}

DDLogicalThread* DD::CreateLogicalThread(u64 ctx) {
  4063f0:	53                   	push   %rbx
  DDLogicalThread *lt = (DDLogicalThread*)InternalAlloc(sizeof(*lt));
  4063f1:	bf 38 07 00 00       	mov    $0x738,%edi
}

void DD::DestroyPhysicalThread(DDPhysicalThread *pt) {
}

DDLogicalThread* DD::CreateLogicalThread(u64 ctx) {
  4063f6:	48 89 f3             	mov    %rsi,%rbx
  DDLogicalThread *lt = (DDLogicalThread*)InternalAlloc(sizeof(*lt));
  4063f9:	31 f6                	xor    %esi,%esi
  4063fb:	e8 30 cf ff ff       	callq  403330 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE>
  lt->ctx = ctx;
  406400:	48 89 18             	mov    %rbx,(%rax)
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  406403:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  40640a:	00 
class DeadlockDetectorTLS {
 public:
  // No CTOR.
  void clear() {
    bv_.clear();
    epoch_ = 0;
  40640b:	48 c7 80 10 02 00 00 	movq   $0x0,0x210(%rax)
  406412:	00 00 00 00 
    n_recursive_locks = 0;
  406416:	48 c7 80 18 04 00 00 	movq   $0x0,0x418(%rax)
  40641d:	00 00 00 00 
    n_all_locks_ = 0;
  406421:	48 c7 80 20 06 00 00 	movq   $0x0,0x620(%rax)
  406428:	00 00 00 00 
  lt->dd.clear();
  lt->report_pending = false;
  40642c:	c6 80 30 07 00 00 00 	movb   $0x0,0x730(%rax)
  return lt;
}
  406433:	5b                   	pop    %rbx
  406434:	c3                   	retq   
  406435:	90                   	nop
  406436:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40643d:	00 00 00 

0000000000406440 <_ZN11__sanitizer2DD20DestroyLogicalThreadEPNS_15DDLogicalThreadE>:

void DD::DestroyLogicalThread(DDLogicalThread *lt) {
  406440:	48 89 f7             	mov    %rsi,%rdi
  lt->~DDLogicalThread();
  InternalFree(lt);
  406443:	31 f6                	xor    %esi,%esi
  406445:	e9 26 d8 ff ff       	jmpq   403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  40644a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000406450 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb>:
  dd.onLockAfter(&lt->dd, m->id, stk);
}

void DD::MutexBeforeUnlock(DDCallback *cb, DDMutex *m, bool wlock) {
  // Printf("T%p MutexUnLock: %zx\n", cb->lt, m->id);
  dd.onUnlock(&cb->lt->dd, m->id);
  406450:	48 8b 3a             	mov    (%rdx),%rdi
  406453:	48 8b 56 10          	mov    0x10(%rsi),%rdx
  uptr nodeToIndex(uptr node) const {
    check_node(node);
    return nodeToIndexUnchecked(node);
  }

  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }
  406457:	48 89 f8             	mov    %rdi,%rax
  40645a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  }

  // Handle the unlock event.
  // This operation is thread-safe as it only touches the dtls.
  void onUnlock(DeadlockDetectorTLS<BV> *dtls, uptr node) {
    if (dtls->getEpoch() == nodeToEpoch(node))
  406460:	48 39 82 10 02 00 00 	cmp    %rax,0x210(%rdx)
  406467:	74 07                	je     406470 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0x20>
  406469:	f3 c3                	repz retq 
  40646b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    all_locks_with_contexts_[n_all_locks_++] = l;
    return true;
  }

  void removeLock(uptr lock_id) {
    if (n_recursive_locks) {
  406470:	48 8b 8a 18 04 00 00 	mov    0x418(%rdx),%rcx
  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  }

  uptr nodeToIndexUnchecked(uptr node) const { return node % size(); }
  406477:	49 89 f8             	mov    %rdi,%r8
  40647a:	41 81 e0 ff 0f 00 00 	and    $0xfff,%r8d
    all_locks_with_contexts_[n_all_locks_++] = l;
    return true;
  }

  void removeLock(uptr lock_id) {
    if (n_recursive_locks) {
  406481:	48 85 c9             	test   %rcx,%rcx
  406484:	74 3d                	je     4064c3 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0x73>
      for (sptr i = n_recursive_locks - 1; i >= 0; i--) {
  406486:	4c 8d 49 ff          	lea    -0x1(%rcx),%r9
  40648a:	4d 85 c9             	test   %r9,%r9
  40648d:	4c 89 c8             	mov    %r9,%rax
  406490:	78 31                	js     4064c3 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0x73>
        if (recursive_locks[i] == lock_id) {
  406492:	48 8b b4 ca 10 02 00 	mov    0x210(%rdx,%rcx,8),%rsi
  406499:	00 
  40649a:	49 39 f0             	cmp    %rsi,%r8
  40649d:	75 1a                	jne    4064b9 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0x69>
  40649f:	e9 b4 00 00 00       	jmpq   406558 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0x108>
  4064a4:	0f 1f 40 00          	nopl   0x0(%rax)
  4064a8:	48 8b b4 c2 18 02 00 	mov    0x218(%rdx,%rax,8),%rsi
  4064af:	00 
  4064b0:	49 39 f0             	cmp    %rsi,%r8
  4064b3:	0f 84 9f 00 00 00    	je     406558 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0x108>
    return true;
  }

  void removeLock(uptr lock_id) {
    if (n_recursive_locks) {
      for (sptr i = n_recursive_locks - 1; i >= 0; i--) {
  4064b9:	48 83 e8 01          	sub    $0x1,%rax
  4064bd:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  4064c1:	75 e5                	jne    4064a8 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0x58>
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  4064c3:	4c 89 c1             	mov    %r8,%rcx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  4064c6:	b8 01 00 00 00       	mov    $0x1,%eax
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  4064cb:	48 c1 e9 06          	shr    $0x6,%rcx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  4064cf:	49 89 c1             	mov    %rax,%r9
  4064d2:	49 d3 e1             	shl    %cl,%r9
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    bool res = false;
    if (l1_[i0].getBit(i1)) {
  4064d5:	4c 85 4a 08          	test   %r9,0x8(%rdx)
  4064d9:	74 8e                	je     406469 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0x19>
      res = l2_[i0][i1].clearBit(i2);
  4064db:	48 8d 72 08          	lea    0x8(%rdx),%rsi
  4064df:	4c 8d 1c ce          	lea    (%rsi,%rcx,8),%r11
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  4064e3:	48 89 f9             	mov    %rdi,%rcx
  4064e6:	83 e1 3f             	and    $0x3f,%ecx
    return bits_ != old;
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
  4064e9:	4d 8b 53 08          	mov    0x8(%r11),%r10
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  4064ed:	48 d3 e0             	shl    %cl,%rax
  4064f0:	48 89 c1             	mov    %rax,%rcx
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  4064f3:	48 f7 d1             	not    %rcx
  4064f6:	4c 21 d1             	and    %r10,%rcx
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    bool res = false;
    if (l1_[i0].getBit(i1)) {
      res = l2_[i0][i1].clearBit(i2);
      if (l2_[i0][i1].empty())
  4064f9:	48 85 c9             	test   %rcx,%rcx
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  4064fc:	49 89 4b 08          	mov    %rcx,0x8(%r11)
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    bool res = false;
    if (l1_[i0].getBit(i1)) {
      res = l2_[i0][i1].clearBit(i2);
      if (l2_[i0][i1].empty())
  406500:	74 7e                	je     406580 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0x130>
          return;
        }
      }
    }
    // Printf("remLock: %zx %zx\n", lock_id, epoch_);
    if (!bv_.clearBit(lock_id))
  406502:	49 39 ca             	cmp    %rcx,%r10
  406505:	0f 84 5e ff ff ff    	je     406469 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0x19>
      return;  // probably addLock happened before flush
    if (n_all_locks_) {
  40650b:	48 8b ba 20 06 00 00 	mov    0x620(%rdx),%rdi
  406512:	48 85 ff             	test   %rdi,%rdi
  406515:	0f 84 4e ff ff ff    	je     406469 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0x19>
      for (sptr i = n_all_locks_ - 1; i >= 0; i--) {
  40651b:	4c 8d 4f ff          	lea    -0x1(%rdi),%r9
  40651f:	4d 85 c9             	test   %r9,%r9
  406522:	4c 89 c8             	mov    %r9,%rax
  406525:	0f 88 3e ff ff ff    	js     406469 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0x19>
        if (all_locks_with_contexts_[i].lock == static_cast<u32>(lock_id)) {
  40652b:	44 39 84 fa 18 04 00 	cmp    %r8d,0x418(%rdx,%rdi,8)
  406532:	00 
  406533:	44 89 c1             	mov    %r8d,%ecx
  406536:	75 11                	jne    406549 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0xf9>
  406538:	eb 56                	jmp    406590 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0x140>
  40653a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  406540:	39 8c c6 18 04 00 00 	cmp    %ecx,0x418(%rsi,%rax,8)
  406547:	74 47                	je     406590 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0x140>
    }
    // Printf("remLock: %zx %zx\n", lock_id, epoch_);
    if (!bv_.clearBit(lock_id))
      return;  // probably addLock happened before flush
    if (n_all_locks_) {
      for (sptr i = n_all_locks_ - 1; i >= 0; i--) {
  406549:	48 83 e8 01          	sub    $0x1,%rax
  40654d:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  406551:	75 ed                	jne    406540 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0xf0>
  406553:	f3 c3                	repz retq 
  406555:	0f 1f 00             	nopl   (%rax)
  406558:	4a 8d 0c ca          	lea    (%rdx,%r9,8),%rcx

  void removeLock(uptr lock_id) {
    if (n_recursive_locks) {
      for (sptr i = n_recursive_locks - 1; i >= 0; i--) {
        if (recursive_locks[i] == lock_id) {
          n_recursive_locks--;
  40655c:	4c 89 8a 18 04 00 00 	mov    %r9,0x418(%rdx)
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  a = b;
  406563:	48 8b b9 18 02 00 00 	mov    0x218(%rcx),%rdi
  40656a:	48 89 bc c2 18 02 00 	mov    %rdi,0x218(%rdx,%rax,8)
  406571:	00 
  b = tmp;
  406572:	48 89 b1 18 02 00 00 	mov    %rsi,0x218(%rcx)
  406579:	c3                   	retq   
  40657a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  406580:	49 f7 d1             	not    %r9
  406583:	4c 21 4a 08          	and    %r9,0x8(%rdx)
  406587:	e9 76 ff ff ff       	jmpq   406502 <_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb+0xb2>
  40658c:	0f 1f 40 00          	nopl   0x0(%rax)
      return;  // probably addLock happened before flush
    if (n_all_locks_) {
      for (sptr i = n_all_locks_ - 1; i >= 0; i--) {
        if (all_locks_with_contexts_[i].lock == static_cast<u32>(lock_id)) {
          Swap(all_locks_with_contexts_[i],
               all_locks_with_contexts_[n_all_locks_ - 1]);
  406590:	49 8d b9 82 00 00 00 	lea    0x82(%r9),%rdi
  406597:	48 05 82 00 00 00    	add    $0x82,%rax
  40659d:	48 8d 0c fe          	lea    (%rsi,%rdi,8),%rcx
  4065a1:	48 8d 34 c6          	lea    (%rsi,%rax,8),%rsi
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  a = b;
  4065a5:	48 8b 7c fa 10       	mov    0x10(%rdx,%rdi,8),%rdi
// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  4065aa:	44 8b 46 08          	mov    0x8(%rsi),%r8d
  4065ae:	8b 76 0c             	mov    0xc(%rsi),%esi
  a = b;
  4065b1:	48 89 7c c2 10       	mov    %rdi,0x10(%rdx,%rax,8)
  b = tmp;
  4065b6:	44 89 41 08          	mov    %r8d,0x8(%rcx)
  4065ba:	89 71 0c             	mov    %esi,0xc(%rcx)
          n_all_locks_--;
  4065bd:	4c 89 8a 20 06 00 00 	mov    %r9,0x620(%rdx)
  4065c4:	c3                   	retq   
  4065c5:	90                   	nop
  4065c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4065cd:	00 00 00 

00000000004065d0 <_ZN11__sanitizer2DD12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE>:
}

void DD::MutexDestroy(DDCallback *cb,
    DDMutex *m) {
  if (!m->id) return;
  4065d0:	48 83 3a 00          	cmpq   $0x0,(%rdx)
  4065d4:	75 0a                	jne    4065e0 <_ZN11__sanitizer2DD12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE+0x10>
  SpinMutexLock lk(&mtx);
  if (dd.nodeBelongsToCurrentEpoch(m->id))
    dd.removeNode(m->id);
  m->id = 0;
}
  4065d6:	c3                   	retq   
  4065d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4065de:	00 00 
  // Printf("T%p MutexUnLock: %zx\n", cb->lt, m->id);
  dd.onUnlock(&cb->lt->dd, m->id);
}

void DD::MutexDestroy(DDCallback *cb,
    DDMutex *m) {
  4065e0:	53                   	push   %rbx
  4065e1:	48 89 fb             	mov    %rdi,%rbx
  if (!m->id) return;
  SpinMutexLock lk(&mtx);
  4065e4:	48 8d 7f 08          	lea    0x8(%rdi),%rdi
  4065e8:	b8 01 00 00 00       	mov    $0x1,%eax
  // Printf("T%p MutexUnLock: %zx\n", cb->lt, m->id);
  dd.onUnlock(&cb->lt->dd, m->id);
}

void DD::MutexDestroy(DDCallback *cb,
    DDMutex *m) {
  4065ed:	48 83 ec 10          	sub    $0x10,%rsp
  4065f1:	86 07                	xchg   %al,(%rdi)
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  4065f3:	84 c0                	test   %al,%al
  4065f5:	74 0f                	je     406606 <_ZN11__sanitizer2DD12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE+0x36>
  4065f7:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
      return;
    LockSlow();
  4065fc:	e8 4f df ff ff       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  406601:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  if (!m->id) return;
  SpinMutexLock lk(&mtx);
  if (dd.nodeBelongsToCurrentEpoch(m->id))
  406606:	48 8b 02             	mov    (%rdx),%rax

  // Get data associated with the node created by newNode().
  uptr getData(uptr node) const { return data_[nodeToIndex(node)]; }

  bool nodeBelongsToCurrentEpoch(uptr node) {
    return node && (node / size() * size()) == current_epoch_;
  406609:	48 85 c0             	test   %rax,%rax
  40660c:	0f 84 8e 00 00 00    	je     4066a0 <_ZN11__sanitizer2DD12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE+0xd0>
  406612:	48 89 c1             	mov    %rax,%rcx
  406615:	48 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%rcx
  40661c:	48 3b 4b 10          	cmp    0x10(%rbx),%rcx
  406620:	75 7e                	jne    4066a0 <_ZN11__sanitizer2DD12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE+0xd0>

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  406622:	48 3d ff 0f 00 00    	cmp    $0xfff,%rax
  406628:	0f 86 be 00 00 00    	jbe    4066ec <_ZN11__sanitizer2DD12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE+0x11c>
  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  }

  uptr nodeToIndexUnchecked(uptr node) const { return node % size(); }
  40662e:	48 89 c6             	mov    %rax,%rsi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406631:	41 b9 01 00 00 00    	mov    $0x1,%r9d
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  406637:	83 e0 3f             	and    $0x3f,%eax
  40663a:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406640:	4d 89 c8             	mov    %r9,%r8
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  406643:	48 89 f7             	mov    %rsi,%rdi
  406646:	48 c1 ef 06          	shr    $0x6,%rdi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  40664a:	89 f9                	mov    %edi,%ecx
  40664c:	49 d3 e0             	shl    %cl,%r8
  40664f:	89 c1                	mov    %eax,%ecx
  406651:	49 d3 e1             	shl    %cl,%r9
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  406654:	4c 85 43 18          	test   %r8,0x18(%rbx)
  406658:	74 07                	je     406661 <_ZN11__sanitizer2DD12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE+0x91>
  40665a:	4c 85 4c fb 20       	test   %r9,0x20(%rbx,%rdi,8)
  40665f:	75 57                	jne    4066b8 <_ZN11__sanitizer2DD12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE+0xe8>
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
    return bits_ != old;
  }

  bool getBit(uptr idx) const { return (bits_ & mask(idx)) != 0; }
  406661:	48 8b 83 20 02 00 00 	mov    0x220(%rbx),%rax
  bool setBit(uptr idx) {
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    if (!l1_[i0].getBit(i1)) {
  406668:	49 85 c0             	test   %rax,%r8
  40666b:	74 6b                	je     4066d8 <_ZN11__sanitizer2DD12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE+0x108>
  40666d:	48 8d 8c fb 20 02 00 	lea    0x220(%rbx,%rdi,8),%rcx
  406674:	00 
  406675:	48 8b 41 08          	mov    0x8(%rcx),%rax
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  406679:	49 09 c1             	or     %rax,%r9
  }

  void removeNode(uptr node) {
    uptr idx = nodeToIndex(node);
    CHECK(!available_nodes_.getBit(idx));
    CHECK(recycled_nodes_.setBit(idx));
  40667c:	4c 39 c8             	cmp    %r9,%rax
  40667f:	4c 89 49 08          	mov    %r9,0x8(%rcx)
  406683:	0f 84 84 00 00 00    	je     40670d <_ZN11__sanitizer2DD12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE+0x13d>
    }
    return res;
  }

  void removeEdgesFrom(uptr from) {
    return v[from].clear();
  406689:	48 89 f0             	mov    %rsi,%rax
  40668c:	48 c1 e0 09          	shl    $0x9,%rax
  406690:	48 8d 04 f0          	lea    (%rax,%rsi,8),%rax
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  406694:	48 c7 84 03 30 06 00 	movq   $0x0,0x630(%rbx,%rax,1)
  40669b:	00 00 00 00 00 
    dd.removeNode(m->id);
  m->id = 0;
  4066a0:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
  4066a7:	c6 43 08 00          	movb   $0x0,0x8(%rbx)
}
  4066ab:	48 83 c4 10          	add    $0x10,%rsp
  4066af:	5b                   	pop    %rbx
  4066b0:	c3                   	retq   
  4066b1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    return node && (node / size() * size()) == current_epoch_;
  }

  void removeNode(uptr node) {
    uptr idx = nodeToIndex(node);
    CHECK(!available_nodes_.getBit(idx));
  4066b8:	48 8d 15 f1 f0 00 00 	lea    0xf0f1(%rip),%rdx        # 4157b0 <.LC6>
  4066bf:	48 8d 3d 42 f0 00 00 	lea    0xf042(%rip),%rdi        # 415708 <.LC4>
  4066c6:	45 31 c0             	xor    %r8d,%r8d
  4066c9:	31 c9                	xor    %ecx,%ecx
  4066cb:	be c2 00 00 00       	mov    $0xc2,%esi
  4066d0:	e8 1b ed ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  4066d5:	0f 1f 00             	nopl   (%rax)
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  4066d8:	49 09 c0             	or     %rax,%r8
  4066db:	4c 89 83 20 02 00 00 	mov    %r8,0x220(%rbx)
  4066e2:	4c 89 8c fb 28 02 00 	mov    %r9,0x228(%rbx,%rdi,8)
  4066e9:	00 
  4066ea:	eb 9d                	jmp    406689 <_ZN11__sanitizer2DD12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE+0xb9>

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  4066ec:	48 8d 15 f3 1e 01 00 	lea    0x11ef3(%rip),%rdx        # 4185e6 <.LC3>
  4066f3:	48 8d 3d 0e f0 00 00 	lea    0xf00e(%rip),%rdi        # 415708 <.LC4>
  4066fa:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  406700:	48 89 c1             	mov    %rax,%rcx
  406703:	be 74 01 00 00       	mov    $0x174,%esi
  406708:	e8 e3 ec ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  }

  void removeNode(uptr node) {
    uptr idx = nodeToIndex(node);
    CHECK(!available_nodes_.getBit(idx));
    CHECK(recycled_nodes_.setBit(idx));
  40670d:	48 8d 15 74 f0 00 00 	lea    0xf074(%rip),%rdx        # 415788 <.LC5>
  406714:	48 8d 3d ed ef 00 00 	lea    0xefed(%rip),%rdi        # 415708 <.LC4>
  40671b:	45 31 c0             	xor    %r8d,%r8d
  40671e:	31 c9                	xor    %ecx,%ecx
  406720:	be c3 00 00 00       	mov    $0xc3,%esi
  406725:	e8 c6 ec ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40672a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000406730 <_ZN11__sanitizer9DDetector6CreateEPKNS_7DDFlagsE>:

  void MutexEnsureID(DDLogicalThread *lt, DDMutex *m);
  void ReportDeadlock(DDCallback *cb, DDMutex *m);
};

DDetector *DDetector::Create(const DDFlags *flags) {
  406730:	53                   	push   %rbx
  (void)flags;
  void *mem = MmapOrDie(sizeof(DD), "deadlock detector");
  406731:	48 8d 35 c5 1e 01 00 	lea    0x11ec5(%rip),%rsi        # 4185fd <.LC7>

  void MutexEnsureID(DDLogicalThread *lt, DDMutex *m);
  void ReportDeadlock(DDCallback *cb, DDMutex *m);
};

DDetector *DDetector::Create(const DDFlags *flags) {
  406738:	48 89 fb             	mov    %rdi,%rbx
  (void)flags;
  void *mem = MmapOrDie(sizeof(DD), "deadlock detector");
  40673b:	bf 50 0a 41 00       	mov    $0x410a50,%edi
  406740:	e8 5b 5c 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  406745:	c6 40 08 00          	movb   $0x0,0x8(%rax)
  return new(mem) DD(flags);
}

DD::DD(const DDFlags *flags)
    : flags(*flags) {
  406749:	0f b6 13             	movzbl (%rbx),%edx
  40674c:	48 8d 0d 7d a6 01 00 	lea    0x1a67d(%rip),%rcx        # 420dd0 <_ZTVN11__sanitizer2DDE+0x10>

  uptr size() const { return g_.size(); }

  // No CTOR.
  void clear() {
    current_epoch_ = 0;
  406753:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  40675a:	00 
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  40675b:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  406762:	00 
  406763:	48 89 08             	mov    %rcx,(%rax)
  406766:	48 c7 80 20 02 00 00 	movq   $0x0,0x220(%rax)
  40676d:	00 00 00 00 
  406771:	88 90 48 0a 41 00    	mov    %dl,0x410a48(%rax)
  406777:	31 d2                	xor    %edx,%edx
  406779:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  406780:	48 c7 84 10 30 06 00 	movq   $0x0,0x630(%rax,%rdx,1)
  406787:	00 00 00 00 00 
  40678c:	48 81 c2 08 02 00 00 	add    $0x208,%rdx
 public:
  enum SizeEnum { kSize = BV::kSize };
  uptr size() const { return kSize; }
  // No CTOR.
  void clear() {
    for (uptr i = 0; i < size(); i++)
  406793:	48 81 fa 00 80 20 00 	cmp    $0x208000,%rdx
  40679a:	75 e4                	jne    406780 <_ZN11__sanitizer9DDetector6CreateEPKNS_7DDFlagsE+0x50>
    available_nodes_.clear();
    recycled_nodes_.clear();
    g_.clear();
    n_edges_ = 0;
  40679c:	48 c7 80 40 0a 41 00 	movq   $0x0,0x410a40(%rax)
  4067a3:	00 00 00 00 

DDetector *DDetector::Create(const DDFlags *flags) {
  (void)flags;
  void *mem = MmapOrDie(sizeof(DD), "deadlock detector");
  return new(mem) DD(flags);
}
  4067a7:	5b                   	pop    %rbx
  4067a8:	c3                   	retq   
  4067a9:	90                   	nop
  4067aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000004067b0 <_ZN11__sanitizer2DDC1EPKNS_7DDFlagsE>:

DD::DD(const DDFlags *flags)
    : flags(*flags) {
  4067b0:	48 8d 05 19 a6 01 00 	lea    0x1a619(%rip),%rax        # 420dd0 <_ZTVN11__sanitizer2DDE+0x10>
  4067b7:	c6 47 08 00          	movb   $0x0,0x8(%rdi)
  4067bb:	48 89 07             	mov    %rax,(%rdi)
  4067be:	0f b6 06             	movzbl (%rsi),%eax

  uptr size() const { return g_.size(); }

  // No CTOR.
  void clear() {
    current_epoch_ = 0;
  4067c1:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  4067c8:	00 
  4067c9:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
  4067d0:	00 
  4067d1:	48 c7 87 20 02 00 00 	movq   $0x0,0x220(%rdi)
  4067d8:	00 00 00 00 
  4067dc:	88 87 48 0a 41 00    	mov    %al,0x410a48(%rdi)
  4067e2:	31 c0                	xor    %eax,%eax
  4067e4:	0f 1f 40 00          	nopl   0x0(%rax)
  4067e8:	48 c7 84 07 30 06 00 	movq   $0x0,0x630(%rdi,%rax,1)
  4067ef:	00 00 00 00 00 
  4067f4:	48 05 08 02 00 00    	add    $0x208,%rax
  4067fa:	48 3d 00 80 20 00    	cmp    $0x208000,%rax
  406800:	75 e6                	jne    4067e8 <_ZN11__sanitizer2DDC1EPKNS_7DDFlagsE+0x38>
    available_nodes_.clear();
    recycled_nodes_.clear();
    g_.clear();
    n_edges_ = 0;
  406802:	48 c7 87 40 0a 41 00 	movq   $0x0,0x410a40(%rdi)
  406809:	00 00 00 00 
  40680d:	c3                   	retq   
  40680e:	66 90                	xchg   %ax,%ax

0000000000406810 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE>:
void DD::MutexInit(DDCallback *cb, DDMutex *m) {
  m->id = 0;
  m->stk = cb->Unwind();
}

void DD::MutexEnsureID(DDLogicalThread *lt, DDMutex *m) {
  406810:	41 57                	push   %r15
  406812:	41 56                	push   %r14
  406814:	41 55                	push   %r13
  406816:	41 54                	push   %r12
  406818:	55                   	push   %rbp
  406819:	48 89 f5             	mov    %rsi,%rbp
  40681c:	53                   	push   %rbx
  40681d:	48 89 fb             	mov    %rdi,%rbx
  406820:	48 83 ec 28          	sub    $0x28,%rsp
  if (!dd.nodeBelongsToCurrentEpoch(m->id))
  406824:	48 8b 02             	mov    (%rdx),%rax
void DD::MutexInit(DDCallback *cb, DDMutex *m) {
  m->id = 0;
  m->stk = cb->Unwind();
}

void DD::MutexEnsureID(DDLogicalThread *lt, DDMutex *m) {
  406827:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)

  // Get data associated with the node created by newNode().
  uptr getData(uptr node) const { return data_[nodeToIndex(node)]; }

  bool nodeBelongsToCurrentEpoch(uptr node) {
    return node && (node / size() * size()) == current_epoch_;
  40682c:	48 85 c0             	test   %rax,%rax
  40682f:	74 10                	je     406841 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x31>
  406831:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  406837:	48 3b 47 10          	cmp    0x10(%rdi),%rax
  40683b:	0f 84 90 01 00 00    	je     4069d1 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x1c1>
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  406841:	48 8b 43 18          	mov    0x18(%rbx),%rax
    }
  }

  bool empty() const {
    for (uptr i = 0; i < kLevel1Size; i++)
      if (!l1_[i].empty())
  406845:	48 85 c0             	test   %rax,%rax
  406848:	0f 85 43 04 00 00    	jne    406c91 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x481>

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  40684e:	48 8b 83 20 02 00 00 	mov    0x220(%rbx),%rax
    }
  }

  bool empty() const {
    for (uptr i = 0; i < kLevel1Size; i++)
      if (!l1_[i].empty())
  406855:	48 85 c0             	test   %rax,%rax

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  406858:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    }
  }

  bool empty() const {
    for (uptr i = 0; i < kLevel1Size; i++)
      if (!l1_[i].empty())
  40685d:	0f 85 ab 01 00 00    	jne    406a0e <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x1fe>
  406863:	48 89 d8             	mov    %rbx,%rax
      available_nodes_.setUnion(recycled_nodes_);
      recycled_nodes_.clear();
      return getAvailableNode(data);
    }
    // We are out of vacant nodes. Flush and increment the current_epoch_.
    current_epoch_ += size();
  406866:	48 81 43 10 00 10 00 	addq   $0x1000,0x10(%rbx)
  40686d:	00 
  }

  void setAll() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      l1_[i0].setAll();
      for (uptr i1 = 0; i1 < BV::kSize; i1++)
  40686e:	31 ff                	xor    %edi,%edi
  406870:	48 c1 e0 3c          	shl    $0x3c,%rax
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  406874:	48 c7 83 20 02 00 00 	movq   $0x0,0x220(%rbx)
  40687b:	00 00 00 00 
  void setAll() { bits_ = ~(basic_int_t)0; }
  40687f:	48 c7 43 18 ff ff ff 	movq   $0xffffffffffffffff,0x18(%rbx)
  406886:	ff 
  406887:	48 c1 e8 3f          	shr    $0x3f,%rax
  40688b:	48 85 c0             	test   %rax,%rax
  40688e:	74 0b                	je     40689b <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x8b>
  406890:	48 c7 43 20 ff ff ff 	movq   $0xffffffffffffffff,0x20(%rbx)
  406897:	ff 
  }

  void setAll() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      l1_[i0].setAll();
      for (uptr i1 = 0; i1 < BV::kSize; i1++)
  406898:	40 b7 01             	mov    $0x1,%dil
  40689b:	be 40 00 00 00       	mov    $0x40,%esi
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  4068a0:	66 0f 76 c0          	pcmpeqd %xmm0,%xmm0
  4068a4:	48 29 c6             	sub    %rax,%rsi
  4068a7:	48 83 c0 04          	add    $0x4,%rax
  4068ab:	48 89 f1             	mov    %rsi,%rcx
  4068ae:	48 8d 14 c3          	lea    (%rbx,%rax,8),%rdx
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  4068b2:	31 c0                	xor    %eax,%eax
  4068b4:	48 d1 e9             	shr    %rcx
  4068b7:	4c 8d 04 09          	lea    (%rcx,%rcx,1),%r8
  4068bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  4068c0:	48 83 c0 01          	add    $0x1,%rax
  4068c4:	48 83 c2 10          	add    $0x10,%rdx
  void setAll() { bits_ = ~(basic_int_t)0; }
  4068c8:	66 0f 7f 42 f0       	movdqa %xmm0,-0x10(%rdx)
  4068cd:	48 39 c8             	cmp    %rcx,%rax
  4068d0:	72 ee                	jb     4068c0 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0xb0>
  4068d2:	4c 01 c7             	add    %r8,%rdi
  4068d5:	49 39 f0             	cmp    %rsi,%r8
  4068d8:	74 09                	je     4068e3 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0xd3>
  4068da:	48 c7 44 fb 20 ff ff 	movq   $0xffffffffffffffff,0x20(%rbx,%rdi,8)
  4068e1:	ff ff 
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  4068e3:	31 c0                	xor    %eax,%eax
  4068e5:	0f 1f 00             	nopl   (%rax)
  4068e8:	48 c7 84 03 30 06 00 	movq   $0x0,0x630(%rbx,%rax,1)
  4068ef:	00 00 00 00 00 
  4068f4:	48 05 08 02 00 00    	add    $0x208,%rax
  4068fa:	48 3d 00 80 20 00    	cmp    $0x208000,%rax
  406900:	75 e6                	jne    4068e8 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0xd8>
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  406902:	48 8b 73 18          	mov    0x18(%rbx),%rsi
    recycled_nodes_.clear();
    available_nodes_.setAll();
    g_.clear();
    n_edges_ = 0;
  406906:	48 c7 83 40 0a 41 00 	movq   $0x0,0x410a40(%rbx)
  40690d:	00 00 00 00 
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  }

  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
  406911:	48 85 f6             	test   %rsi,%rsi
  406914:	75 31                	jne    406947 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x137>
        l1_[i0].setBit(i1);
      uptr res = i0 * BV::kSize * BV::kSize + i1 * BV::kSize + i2;
      // Printf("getAndClearFirstOne: %zd %zd %zd => %zd\n", i0, i1, i2, res);
      return res;
    }
    CHECK(0);
  406916:	48 8d 15 fc 1a 01 00 	lea    0x11afc(%rip),%rdx        # 418419 <.LC0>
  40691d:	48 8d 3d 6c ed 00 00 	lea    0xed6c(%rip),%rdi        # 415690 <.LC1>
  406924:	45 31 c0             	xor    %r8d,%r8d
  406927:	31 c9                	xor    %ecx,%ecx
  406929:	be c1 00 00 00       	mov    $0xc1,%esi
  40692e:	e8 bd ea ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  406933:	48 8b 73 18          	mov    0x18(%rbx),%rsi
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  406937:	48 c7 83 20 02 00 00 	movq   $0x0,0x220(%rbx)
  40693e:	00 00 00 00 
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  }

  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
  406942:	48 85 f6             	test   %rsi,%rsi
  406945:	74 cf                	je     406916 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x106>
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = __builtin_ctzll(x);
# else
  up = __builtin_ctzl(x);
  406947:	f3 48 0f bc ce       	tzcnt  %rsi,%rcx
  40694c:	4c 63 e1             	movslq %ecx,%r12
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  40694f:	49 83 fc 3f          	cmp    $0x3f,%r12
  406953:	0f 87 ad 03 00 00    	ja     406d06 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x4f6>
    return (basic_int_t)1UL << idx;
  406959:	b8 01 00 00 00       	mov    $0x1,%eax

  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
  40695e:	48 8d 7b 18          	lea    0x18(%rbx),%rdi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406962:	48 89 c2             	mov    %rax,%rdx
  406965:	48 d3 e2             	shl    %cl,%rdx
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  406968:	48 f7 d2             	not    %rdx
  40696b:	48 21 f2             	and    %rsi,%rdx

  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
  40696e:	4a 8d 34 e7          	lea    (%rdi,%r12,8),%rsi
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  406972:	48 89 53 18          	mov    %rdx,0x18(%rbx)

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  406976:	48 8b 56 08          	mov    0x8(%rsi),%rdx
  }

  bool getBit(uptr idx) const { return (bits_ & mask(idx)) != 0; }

  uptr getAndClearFirstOne() {
    CHECK(!empty());
  40697a:	48 85 d2             	test   %rdx,%rdx
  40697d:	0f 84 66 03 00 00    	je     406ce9 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x4d9>
  406983:	f3 48 0f bc ca       	tzcnt  %rdx,%rcx
  406988:	4c 63 e9             	movslq %ecx,%r13
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  40698b:	49 83 fd 3f          	cmp    $0x3f,%r13
  40698f:	0f 87 ef 02 00 00    	ja     406c84 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x474>
    return (basic_int_t)1UL << idx;
  406995:	48 d3 e0             	shl    %cl,%rax
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  406998:	48 f7 d0             	not    %rax
  40699b:	48 21 d0             	and    %rdx,%rax
  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
      if (!l2_[i0][i1].empty())
  40699e:	48 85 c0             	test   %rax,%rax
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  4069a1:	48 89 46 08          	mov    %rax,0x8(%rsi)
  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
      if (!l2_[i0][i1].empty())
  4069a5:	0f 85 31 03 00 00    	jne    406cdc <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x4cc>

  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }

  uptr getAvailableNode(uptr data) {
    uptr idx = available_nodes_.getAndClearFirstOne();
    data_[idx] = data;
  4069ab:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
        l1_[i0].setBit(i1);
      uptr res = i0 * BV::kSize * BV::kSize + i1 * BV::kSize + i2;
  4069b0:	4c 89 e2             	mov    %r12,%rdx
  4069b3:	48 c1 e2 06          	shl    $0x6,%rdx
  4069b7:	4c 01 ea             	add    %r13,%rdx
  4069ba:	48 89 84 d3 40 8a 20 	mov    %rax,0x208a40(%rbx,%rdx,8)
  4069c1:	00 
    return nodeToIndexUnchecked(node);
  }

  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }

  uptr getAvailableNode(uptr data) {
  4069c2:	48 8b 43 10          	mov    0x10(%rbx),%rax
  if (!dd.nodeBelongsToCurrentEpoch(m->id))
    m->id = dd.newNode(reinterpret_cast<uptr>(m));
  4069c6:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  }

  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  4069cb:	48 01 c2             	add    %rax,%rdx
  4069ce:	48 89 13             	mov    %rdx,(%rbx)
  }

  bool empty() const { return bv_.empty(); }

  void ensureCurrentEpoch(uptr current_epoch) {
    if (epoch_ == current_epoch) return;
  4069d1:	48 39 85 10 02 00 00 	cmp    %rax,0x210(%rbp)
  4069d8:	74 25                	je     4069ff <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x1ef>
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  4069da:	48 c7 45 08 00 00 00 	movq   $0x0,0x8(%rbp)
  4069e1:	00 
    bv_.clear();
    epoch_ = current_epoch;
  4069e2:	48 89 85 10 02 00 00 	mov    %rax,0x210(%rbp)
    n_recursive_locks = 0;
  4069e9:	48 c7 85 18 04 00 00 	movq   $0x0,0x418(%rbp)
  4069f0:	00 00 00 00 
    n_all_locks_ = 0;
  4069f4:	48 c7 85 20 06 00 00 	movq   $0x0,0x620(%rbp)
  4069fb:	00 00 00 00 
  dd.ensureCurrentEpoch(&lt->dd);
}
  4069ff:	48 83 c4 28          	add    $0x28,%rsp
  406a03:	5b                   	pop    %rbx
  406a04:	5d                   	pop    %rbp
  406a05:	41 5c                	pop    %r12
  406a07:	41 5d                	pop    %r13
  406a09:	41 5e                	pop    %r14
  406a0b:	41 5f                	pop    %r15
  406a0d:	c3                   	retq   
  uptr newNode(uptr data) {
    if (!available_nodes_.empty())
      return getAvailableNode(data);
    if (!recycled_nodes_.empty()) {
      // Printf("recycling: n_edges_ %zd\n", n_edges_);
      for (sptr i = n_edges_ - 1; i >= 0; i--) {
  406a0e:	4c 8b bb 40 0a 41 00 	mov    0x410a40(%rbx),%r15
  406a15:	4c 89 fa             	mov    %r15,%rdx
  406a18:	48 83 ea 01          	sub    $0x1,%rdx
  406a1c:	0f 88 68 01 00 00    	js     406b8a <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x37a>
        if (recycled_nodes_.getBit(edges_[i].from) ||
  406a22:	49 8d 87 a2 10 02 00 	lea    0x210a2(%r15),%rax
  406a29:	48 c1 e0 04          	shl    $0x4,%rax
  406a2d:	44 0f b7 54 03 10    	movzwl 0x10(%rbx,%rax,1),%r10d
  406a33:	41 0f b7 fa          	movzwl %r10w,%edi
    uptr i0_, i1_;
    typename BV::Iterator it1_, it2_;
  };

 private:
  void check(uptr idx) const { CHECK_LE(idx, size()); }
  406a37:	48 81 ff 00 10 00 00 	cmp    $0x1000,%rdi
  406a3e:	0f 87 48 02 00 00    	ja     406c8c <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x47c>
  406a44:	49 8d 87 a3 10 02 00 	lea    0x210a3(%r15),%rax
  406a4b:	48 8d 73 10          	lea    0x10(%rbx),%rsi
  406a4f:	4c 8d 8b 20 02 00 00 	lea    0x220(%rbx),%r9
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406a56:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  406a5c:	48 89 6c 24 18       	mov    %rbp,0x18(%rsp)
  406a61:	48 c1 e0 04          	shl    $0x4,%rax
  406a65:	48 01 d8             	add    %rbx,%rax
  406a68:	e9 7e 00 00 00       	jmpq   406aeb <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x2db>
  406a6d:	0f 1f 00             	nopl   (%rax)
  406a70:	48 89 c1             	mov    %rax,%rcx
  406a73:	48 29 d9             	sub    %rbx,%rcx
  406a76:	44 0f b7 54 0e f2    	movzwl -0xe(%rsi,%rcx,1),%r10d
  406a7c:	41 0f b7 fa          	movzwl %r10w,%edi
    uptr i0_, i1_;
    typename BV::Iterator it1_, it2_;
  };

 private:
  void check(uptr idx) const { CHECK_LE(idx, size()); }
  406a80:	48 81 ff 00 10 00 00 	cmp    $0x1000,%rdi
  406a87:	0f 87 ff 01 00 00    	ja     406c8c <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x47c>

  uptr idx0(uptr idx) const {
    uptr res = idx / (BV::kSize * BV::kSize);
  406a8d:	49 89 fb             	mov    %rdi,%r11
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  406a90:	48 c1 ef 06          	shr    $0x6,%rdi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406a94:	4d 89 c6             	mov    %r8,%r14
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  406a97:	83 e7 3f             	and    $0x3f,%edi

 private:
  void check(uptr idx) const { CHECK_LE(idx, size()); }

  uptr idx0(uptr idx) const {
    uptr res = idx / (BV::kSize * BV::kSize);
  406a9a:	49 c1 eb 0c          	shr    $0xc,%r11
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406a9e:	89 f9                	mov    %edi,%ecx
  406aa0:	49 d3 e6             	shl    %cl,%r14
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  406aa3:	4f 85 34 d9          	test   %r14,(%r9,%r11,8)
  406aa7:	74 17                	je     406ac0 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x2b0>
  406aa9:	49 c1 e3 06          	shl    $0x6,%r11
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406aad:	4d 89 c6             	mov    %r8,%r14
  406ab0:	44 89 d1             	mov    %r10d,%ecx
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  406ab3:	4c 01 df             	add    %r11,%rdi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406ab6:	49 d3 e6             	shl    %cl,%r14
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  406ab9:	4d 85 74 f9 08       	test   %r14,0x8(%r9,%rdi,8)
  406abe:	75 66                	jne    406b26 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x316>
  uptr newNode(uptr data) {
    if (!available_nodes_.empty())
      return getAvailableNode(data);
    if (!recycled_nodes_.empty()) {
      // Printf("recycling: n_edges_ %zd\n", n_edges_);
      for (sptr i = n_edges_ - 1; i >= 0; i--) {
  406ac0:	48 83 ea 01          	sub    $0x1,%rdx
  406ac4:	0f 88 bb 00 00 00    	js     406b85 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x375>
  406aca:	48 89 c1             	mov    %rax,%rcx
  406acd:	48 83 e8 10          	sub    $0x10,%rax
  406ad1:	48 29 d9             	sub    %rbx,%rcx
        if (recycled_nodes_.getBit(edges_[i].from) ||
  406ad4:	44 0f b7 54 0e e0    	movzwl -0x20(%rsi,%rcx,1),%r10d
  406ada:	41 0f b7 fa          	movzwl %r10w,%edi
    uptr i0_, i1_;
    typename BV::Iterator it1_, it2_;
  };

 private:
  void check(uptr idx) const { CHECK_LE(idx, size()); }
  406ade:	48 81 ff 00 10 00 00 	cmp    $0x1000,%rdi
  406ae5:	0f 87 a1 01 00 00    	ja     406c8c <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x47c>

  uptr idx0(uptr idx) const {
    uptr res = idx / (BV::kSize * BV::kSize);
  406aeb:	49 89 fb             	mov    %rdi,%r11
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  406aee:	48 c1 ef 06          	shr    $0x6,%rdi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406af2:	4d 89 c6             	mov    %r8,%r14
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  406af5:	83 e7 3f             	and    $0x3f,%edi

 private:
  void check(uptr idx) const { CHECK_LE(idx, size()); }

  uptr idx0(uptr idx) const {
    uptr res = idx / (BV::kSize * BV::kSize);
  406af8:	49 c1 eb 0c          	shr    $0xc,%r11
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406afc:	89 f9                	mov    %edi,%ecx
  406afe:	49 d3 e6             	shl    %cl,%r14
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  406b01:	4f 85 34 d9          	test   %r14,(%r9,%r11,8)
  406b05:	0f 84 65 ff ff ff    	je     406a70 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x260>
  406b0b:	49 c1 e3 06          	shl    $0x6,%r11
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406b0f:	4d 89 c6             	mov    %r8,%r14
  406b12:	44 89 d1             	mov    %r10d,%ecx
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  406b15:	4c 01 df             	add    %r11,%rdi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406b18:	49 d3 e6             	shl    %cl,%r14
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  406b1b:	4d 85 74 f9 08       	test   %r14,0x8(%r9,%rdi,8)
  406b20:	0f 84 4a ff ff ff    	je     406a70 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x260>
            recycled_nodes_.getBit(edges_[i].to)) {
          Swap(edges_[i], edges_[n_edges_ - 1]);
  406b26:	49 8d bf a2 10 02 00 	lea    0x210a2(%r15),%rdi
// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  406b2d:	44 0f b7 28          	movzwl (%rax),%r13d
  406b31:	44 0f b7 60 02       	movzwl 0x2(%rax),%r12d
  406b36:	8b 68 04             	mov    0x4(%rax),%ebp
  406b39:	44 8b 58 08          	mov    0x8(%rax),%r11d
  406b3d:	49 89 c6             	mov    %rax,%r14
  406b40:	44 8b 50 0c          	mov    0xc(%rax),%r10d
  406b44:	48 c1 e7 04          	shl    $0x4,%rdi
  406b48:	49 29 de             	sub    %rbx,%r14
  a = b;
  406b4b:	f3 0f 6f 4c 3b 10    	movdqu 0x10(%rbx,%rdi,1),%xmm1
  406b51:	48 8d 0c 3e          	lea    (%rsi,%rdi,1),%rcx
          n_edges_--;
  406b55:	49 83 ef 01          	sub    $0x1,%r15
  uptr newNode(uptr data) {
    if (!available_nodes_.empty())
      return getAvailableNode(data);
    if (!recycled_nodes_.empty()) {
      // Printf("recycling: n_edges_ %zd\n", n_edges_);
      for (sptr i = n_edges_ - 1; i >= 0; i--) {
  406b59:	48 83 ea 01          	sub    $0x1,%rdx
  406b5d:	f3 42 0f 7f 4c 36 f0 	movdqu %xmm1,-0x10(%rsi,%r14,1)
  b = tmp;
  406b64:	66 44 89 29          	mov    %r13w,(%rcx)
  406b68:	66 44 89 61 02       	mov    %r12w,0x2(%rcx)
  406b6d:	89 69 04             	mov    %ebp,0x4(%rcx)
  406b70:	44 89 59 08          	mov    %r11d,0x8(%rcx)
  406b74:	44 89 51 0c          	mov    %r10d,0xc(%rcx)
        if (recycled_nodes_.getBit(edges_[i].from) ||
            recycled_nodes_.getBit(edges_[i].to)) {
          Swap(edges_[i], edges_[n_edges_ - 1]);
          n_edges_--;
  406b78:	4c 89 bb 40 0a 41 00 	mov    %r15,0x410a40(%rbx)
  uptr newNode(uptr data) {
    if (!available_nodes_.empty())
      return getAvailableNode(data);
    if (!recycled_nodes_.empty()) {
      // Printf("recycling: n_edges_ %zd\n", n_edges_);
      for (sptr i = n_edges_ - 1; i >= 0; i--) {
  406b7f:	0f 89 45 ff ff ff    	jns    406aca <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x2ba>
  406b85:	48 8b 6c 24 18       	mov    0x18(%rsp),%rbp
  }

  void setAll() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      l1_[i0].setAll();
      for (uptr i1 = 0; i1 < BV::kSize; i1++)
  406b8a:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  406b8f:	4c 8d 83 30 06 00 00 	lea    0x630(%rbx),%r8
  406b96:	4c 8d 93 30 86 20 00 	lea    0x208630(%rbx),%r10
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406b9d:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  406ba3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  }

  // Do "this &= v" and return whether any bits have been removed.
  bool setIntersection(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ &= v.bits_;
  406ba8:	49 23 10             	and    (%r8),%rdx
  406bab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  bool setDifference(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = l1_[i0];
      t.setIntersection(v.l1_[i0]);
      while (!t.empty()) {
  406bb0:	48 85 d2             	test   %rdx,%rdx
  406bb3:	74 42                	je     406bf7 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x3e7>
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = __builtin_ctzll(x);
# else
  up = __builtin_ctzl(x);
  406bb5:	f3 48 0f bc ca       	tzcnt  %rdx,%rcx
  406bba:	48 63 f9             	movslq %ecx,%rdi
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  406bbd:	48 83 ff 3f          	cmp    $0x3f,%rdi
  406bc1:	0f 87 c0 00 00 00    	ja     406c87 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x477>
    return (basic_int_t)1UL << idx;
  406bc7:	4c 89 c8             	mov    %r9,%rax
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = l1_[i0];
      t.setIntersection(v.l1_[i0]);
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l2_[i0][i1].setDifference(v.l2_[i0][i1]))
  406bca:	48 c1 e7 03          	shl    $0x3,%rdi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406bce:	48 d3 e0             	shl    %cl,%rax
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = l1_[i0];
      t.setIntersection(v.l1_[i0]);
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l2_[i0][i1].setDifference(v.l2_[i0][i1]))
  406bd1:	49 8d 34 38          	lea    (%r8,%rdi,1),%rsi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406bd5:	48 89 c1             	mov    %rax,%rcx
  }

  // Do "this &= ~v" and return whether any bits have been removed.
  bool setDifference(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ &= ~v.bits_;
  406bd8:	48 8b 84 3b 28 02 00 	mov    0x228(%rbx,%rdi,1),%rax
  406bdf:	00 
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  406be0:	48 f7 d1             	not    %rcx
  406be3:	48 21 ca             	and    %rcx,%rdx
  }

  // Do "this &= ~v" and return whether any bits have been removed.
  bool setDifference(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ &= ~v.bits_;
  406be6:	48 f7 d0             	not    %rax
      t.setIntersection(v.l1_[i0]);
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l2_[i0][i1].setDifference(v.l2_[i0][i1]))
          res = true;
        if (l2_[i0][i1].empty())
  406be9:	48 21 46 08          	and    %rax,0x8(%rsi)
  406bed:	75 c1                	jne    406bb0 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x3a0>
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  406bef:	49 21 08             	and    %rcx,(%r8)
  bool setDifference(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = l1_[i0];
      t.setIntersection(v.l1_[i0]);
      while (!t.empty()) {
  406bf2:	48 85 d2             	test   %rdx,%rdx
  406bf5:	75 be                	jne    406bb5 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x3a5>
  406bf7:	49 81 c0 08 02 00 00 	add    $0x208,%r8
  406bfe:	48 8b 93 20 02 00 00 	mov    0x220(%rbx),%rdx
  }

  // Returns true if at least one edge *=>to was removed.
  bool removeEdgesTo(const BV &to) {
    bool res = 0;
    for (uptr from = 0; from < size(); from++) {
  406c05:	4d 39 d0             	cmp    %r10,%r8
  406c08:	75 9e                	jne    406ba8 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x398>
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  406c0a:	48 85 d2             	test   %rdx,%rdx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406c0d:	41 b9 01 00 00 00    	mov    $0x1,%r9d
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
          l2_[i0][i1].clear();
  406c13:	4c 8d 43 18          	lea    0x18(%rbx),%r8
  406c17:	48 89 d6             	mov    %rdx,%rsi
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  406c1a:	75 2d                	jne    406c49 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x439>
  406c1c:	e9 12 fd ff ff       	jmpq   406933 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x123>
  406c21:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  406c28:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
  406c2f:	00 
  406c30:	31 d2                	xor    %edx,%edx
  }

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ |= v.bits_;
  406c32:	48 0b 94 fb 28 02 00 	or     0x228(%rbx,%rdi,8),%rdx
  406c39:	00 
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  406c3a:	48 85 c0             	test   %rax,%rax
  }

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ |= v.bits_;
  406c3d:	48 89 11             	mov    %rdx,(%rcx)
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  406c40:	0f 84 ed fc ff ff    	je     406933 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x123>

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  406c46:	48 89 c6             	mov    %rax,%rsi
  406c49:	f3 48 0f bc ce       	tzcnt  %rsi,%rcx
  406c4e:	48 63 f9             	movslq %ecx,%rdi
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  406c51:	48 83 ff 3f          	cmp    $0x3f,%rdi
  406c55:	77 30                	ja     406c87 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x477>
    return (basic_int_t)1UL << idx;
  406c57:	4c 89 ca             	mov    %r9,%rdx
  406c5a:	48 d3 e2             	shl    %cl,%rdx
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
  406c5d:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  406c61:	48 89 d0             	mov    %rdx,%rax
  406c64:	48 f7 d0             	not    %rax
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  406c67:	48 09 ca             	or     %rcx,%rdx
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  406c6a:	48 21 f0             	and    %rsi,%rax
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  406c6d:	48 89 53 18          	mov    %rdx,0x18(%rbx)
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
  406c71:	48 39 d1             	cmp    %rdx,%rcx
          l2_[i0][i1].clear();
  406c74:	49 8d 14 f8          	lea    (%r8,%rdi,8),%rdx
  406c78:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
  406c7c:	75 aa                	jne    406c28 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x418>
  406c7e:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  406c82:	eb ae                	jmp    406c32 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x422>
  406c84:	4c 89 ef             	mov    %r13,%rdi
  406c87:	e8 18 b8 ff ff       	callq  4024a4 <_ZNK11__sanitizer14BasicBitVectorImE4maskEm.isra.19.part.20>
  406c8c:	e8 f1 b7 ff ff       	callq  402482 <_ZNK11__sanitizer17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEE5checkEm.isra.16.part.17>
  406c91:	f3 48 0f bc c8       	tzcnt  %rax,%rcx
  406c96:	4c 63 e1             	movslq %ecx,%r12
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  406c99:	49 83 fc 3f          	cmp    $0x3f,%r12
  406c9d:	77 67                	ja     406d06 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x4f6>
    return (basic_int_t)1UL << idx;
  406c9f:	41 b8 01 00 00 00    	mov    $0x1,%r8d

  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
  406ca5:	48 8d 7b 18          	lea    0x18(%rbx),%rdi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406ca9:	4c 89 c2             	mov    %r8,%rdx
  406cac:	48 d3 e2             	shl    %cl,%rdx

  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
  406caf:	4a 8d 34 e7          	lea    (%rdi,%r12,8),%rsi
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  406cb3:	48 f7 d2             	not    %rdx
  406cb6:	48 21 c2             	and    %rax,%rdx
  406cb9:	48 89 53 18          	mov    %rdx,0x18(%rbx)

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  406cbd:	48 8b 56 08          	mov    0x8(%rsi),%rdx
  }

  bool getBit(uptr idx) const { return (bits_ & mask(idx)) != 0; }

  uptr getAndClearFirstOne() {
    CHECK(!empty());
  406cc1:	48 85 d2             	test   %rdx,%rdx
  406cc4:	74 23                	je     406ce9 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x4d9>
  406cc6:	f3 48 0f bc ca       	tzcnt  %rdx,%rcx
  406ccb:	4c 63 e9             	movslq %ecx,%r13
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  406cce:	49 83 fd 3f          	cmp    $0x3f,%r13
  406cd2:	77 b0                	ja     406c84 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x474>
    return (basic_int_t)1UL << idx;
  406cd4:	4c 89 c0             	mov    %r8,%rax
  406cd7:	e9 b9 fc ff ff       	jmpq   406995 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x185>
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
      if (!l2_[i0][i1].empty())
        l1_[i0].setBit(i1);
  406cdc:	4c 89 e6             	mov    %r12,%rsi
  406cdf:	e8 5c 15 00 00       	callq  408240 <_ZN11__sanitizer14BasicBitVectorImE6setBitEm>
  406ce4:	e9 c2 fc ff ff       	jmpq   4069ab <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE+0x19b>
  }

  bool getBit(uptr idx) const { return (bits_ & mask(idx)) != 0; }

  uptr getAndClearFirstOne() {
    CHECK(!empty());
  406ce9:	48 8d 15 1f 19 01 00 	lea    0x1191f(%rip),%rdx        # 41860f <.LC10>
  406cf0:	48 8d 3d 99 e9 00 00 	lea    0xe999(%rip),%rdi        # 415690 <.LC1>
  406cf7:	45 31 c0             	xor    %r8d,%r8d
  406cfa:	31 c9                	xor    %ecx,%ecx
  406cfc:	be 32 00 00 00       	mov    $0x32,%esi
  406d01:	e8 ea e6 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  406d06:	4c 89 e7             	mov    %r12,%rdi
  406d09:	e8 96 b7 ff ff       	callq  4024a4 <_ZNK11__sanitizer14BasicBitVectorImE4maskEm.isra.19.part.20>
  406d0e:	66 90                	xchg   %ax,%ax

0000000000406d10 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb>:
    rep->loop[i].stk[0] = stk_to;
    rep->loop[i].stk[1] = stk_from;
  }
}

void DD::MutexAfterLock(DDCallback *cb, DDMutex *m, bool wlock, bool trylock) {
  406d10:	41 57                	push   %r15
  406d12:	41 56                	push   %r14
  DDLogicalThread *lt = cb->lt;
  u32 stk = 0;
  406d14:	45 31 f6             	xor    %r14d,%r14d
    rep->loop[i].stk[0] = stk_to;
    rep->loop[i].stk[1] = stk_from;
  }
}

void DD::MutexAfterLock(DDCallback *cb, DDMutex *m, bool wlock, bool trylock) {
  406d17:	41 55                	push   %r13
  406d19:	49 89 d5             	mov    %rdx,%r13
  406d1c:	41 54                	push   %r12
  406d1e:	49 89 f4             	mov    %rsi,%r12
  406d21:	55                   	push   %rbp
  406d22:	48 89 fd             	mov    %rdi,%rbp
  406d25:	53                   	push   %rbx
  406d26:	48 83 ec 38          	sub    $0x38,%rsp
  DDLogicalThread *lt = cb->lt;
  u32 stk = 0;
  if (flags.second_deadlock_stack)
  406d2a:	80 bf 48 0a 41 00 00 	cmpb   $0x0,0x410a48(%rdi)
    rep->loop[i].stk[1] = stk_from;
  }
}

void DD::MutexAfterLock(DDCallback *cb, DDMutex *m, bool wlock, bool trylock) {
  DDLogicalThread *lt = cb->lt;
  406d31:	48 8b 5e 10          	mov    0x10(%rsi),%rbx
    rep->loop[i].stk[0] = stk_to;
    rep->loop[i].stk[1] = stk_from;
  }
}

void DD::MutexAfterLock(DDCallback *cb, DDMutex *m, bool wlock, bool trylock) {
  406d35:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
  DDLogicalThread *lt = cb->lt;
  u32 stk = 0;
  if (flags.second_deadlock_stack)
  406d39:	0f 85 91 01 00 00    	jne    406ed0 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x1c0>

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  406d3f:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    stk = cb->Unwind();
  // Printf("T%p MutexLock:   %zx stk %u\n", lt, m->id, stk);
  if (dd.onFirstLock(&lt->dd, m->id, stk))
  406d43:	4d 8b 4d 00          	mov    0x0(%r13),%r9
  406d47:	48 8b 83 10 02 00 00 	mov    0x210(%rbx),%rax
    }
  }

  bool empty() const {
    for (uptr i = 0; i < kLevel1Size; i++)
      if (!l1_[i].empty())
  406d4e:	48 85 f6             	test   %rsi,%rsi
  406d51:	75 1c                	jne    406d6f <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x5f>
  // Returns true iff dtls is empty (no locks are currently held) and we can
  // add the node to the currently held locks w/o chanding the global state.
  // This operation is thread-safe as it only touches the dtls.
  bool onFirstLock(DeadlockDetectorTLS<BV> *dtls, uptr node, u32 stk = 0) {
    if (!dtls->empty()) return false;
    if (dtls->getEpoch() && dtls->getEpoch() == nodeToEpoch(node)) {
  406d53:	48 85 c0             	test   %rax,%rax
  406d56:	0f 84 64 01 00 00    	je     406ec0 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x1b0>
  uptr nodeToIndex(uptr node) const {
    check_node(node);
    return nodeToIndexUnchecked(node);
  }

  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }
  406d5c:	4c 89 ca             	mov    %r9,%rdx
  406d5f:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  // Returns true iff dtls is empty (no locks are currently held) and we can
  // add the node to the currently held locks w/o chanding the global state.
  // This operation is thread-safe as it only touches the dtls.
  bool onFirstLock(DeadlockDetectorTLS<BV> *dtls, uptr node, u32 stk = 0) {
    if (!dtls->empty()) return false;
    if (dtls->getEpoch() && dtls->getEpoch() == nodeToEpoch(node)) {
  406d66:	48 39 d0             	cmp    %rdx,%rax
  406d69:	0f 84 81 01 00 00    	je     406ef0 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x1e0>
  // Experimental *racy* fast path function.
  // Returns true if all edges from the currently held locks to cur_node exist.
  bool hasAllEdges(DeadlockDetectorTLS<BV> *dtls, uptr cur_node) {
    uptr local_epoch = dtls->getEpoch();
    // Read from current_epoch_ is racy.
    if (cur_node && local_epoch == current_epoch_ &&
  406d6f:	4d 85 c9             	test   %r9,%r9
  406d72:	74 24                	je     406d98 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x88>
  406d74:	0f 1f 40 00          	nopl   0x0(%rax)
  406d78:	48 39 45 10          	cmp    %rax,0x10(%rbp)
  406d7c:	75 1a                	jne    406d98 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x88>
  uptr nodeToIndex(uptr node) const {
    check_node(node);
    return nodeToIndexUnchecked(node);
  }

  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }
  406d7e:	4c 89 ca             	mov    %r9,%rdx
  406d81:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  // Experimental *racy* fast path function.
  // Returns true if all edges from the currently held locks to cur_node exist.
  bool hasAllEdges(DeadlockDetectorTLS<BV> *dtls, uptr cur_node) {
    uptr local_epoch = dtls->getEpoch();
    // Read from current_epoch_ is racy.
    if (cur_node && local_epoch == current_epoch_ &&
  406d88:	48 39 d0             	cmp    %rdx,%rax
  406d8b:	0f 84 be 02 00 00    	je     40704f <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x33f>
  406d91:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    return;
  if (dd.onLockFast(&lt->dd, m->id, stk))
    return;

  SpinMutexLock lk(&mtx);
  406d98:	48 8d 7d 08          	lea    0x8(%rbp),%rdi
  406d9c:	b8 01 00 00 00       	mov    $0x1,%eax
  406da1:	86 07                	xchg   %al,(%rdi)
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  406da3:	84 c0                	test   %al,%al
  406da5:	0f 85 fd 01 00 00    	jne    406fa8 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x298>
  MutexEnsureID(lt, m);
  406dab:	4c 89 ea             	mov    %r13,%rdx
  406dae:	48 89 de             	mov    %rbx,%rsi
  406db1:	48 89 ef             	mov    %rbp,%rdi
  406db4:	44 89 44 24 10       	mov    %r8d,0x10(%rsp)
  406db9:	e8 52 fa ff ff       	callq  406810 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE>
  if (wlock)  // Only a recursive rlock may be held.
  406dbe:	80 7c 24 0c 00       	cmpb   $0x0,0xc(%rsp)
  406dc3:	44 8b 44 24 10       	mov    0x10(%rsp),%r8d
  406dc8:	0f 85 f2 01 00 00    	jne    406fc0 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x2b0>
    CHECK(!dd.isHeld(&lt->dd, m->id));
  if (!trylock)
  406dce:	45 84 c0             	test   %r8b,%r8b
  406dd1:	0f 84 49 03 00 00    	je     407120 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x410>
  u32 findLockContext(DeadlockDetectorTLS<BV> *dtls, uptr node) {
    return dtls->findLockContext(nodeToIndex(node));
  }

  // Add cur_node to the set of locks held currently by dtls.
  void onLockAfter(DeadlockDetectorTLS<BV> *dtls, uptr cur_node, u32 stk = 0) {
  406dd7:	48 8b 45 10          	mov    0x10(%rbp),%rax
  }

  bool empty() const { return bv_.empty(); }

  void ensureCurrentEpoch(uptr current_epoch) {
    if (epoch_ == current_epoch) return;
  406ddb:	48 3b 83 10 02 00 00 	cmp    0x210(%rbx),%rax
    dd.addEdges(&lt->dd, m->id, stk ? stk : cb->Unwind(), cb->UniqueTid());
  dd.onLockAfter(&lt->dd, m->id, stk);
  406de2:	49 8b 55 00          	mov    0x0(%r13),%rdx
  406de6:	74 25                	je     406e0d <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0xfd>
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  406de8:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
  406def:	00 
    bv_.clear();
    epoch_ = current_epoch;
  406df0:	48 89 83 10 02 00 00 	mov    %rax,0x210(%rbx)
    n_recursive_locks = 0;
  406df7:	48 c7 83 18 04 00 00 	movq   $0x0,0x418(%rbx)
  406dfe:	00 00 00 00 
    n_all_locks_ = 0;
  406e02:	48 c7 83 20 06 00 00 	movq   $0x0,0x620(%rbx)
  406e09:	00 00 00 00 

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  406e0d:	48 81 fa ff 0f 00 00 	cmp    $0xfff,%rdx
  406e14:	0f 86 63 04 00 00    	jbe    40727d <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x56d>
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  406e1a:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  uptr nodeToIndex(uptr node) const {
    check_node(node);
    return nodeToIndexUnchecked(node);
  }

  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }
  406e1e:	49 89 d0             	mov    %rdx,%r8
  406e21:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8
 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  406e28:	4c 39 c1             	cmp    %r8,%rcx
  406e2b:	0f 85 34 04 00 00    	jne    407265 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x555>
  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  }

  uptr nodeToIndexUnchecked(uptr node) const { return node % size(); }
  406e31:	48 89 d0             	mov    %rdx,%rax
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
    return bits_ != old;
  }

  bool getBit(uptr idx) const { return (bits_ & mask(idx)) != 0; }
  406e34:	4c 8b 43 08          	mov    0x8(%rbx),%r8
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406e38:	bf 01 00 00 00       	mov    $0x1,%edi
  406e3d:	25 ff 0f 00 00       	and    $0xfff,%eax
  406e42:	49 89 f9             	mov    %rdi,%r9
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  406e45:	83 e2 3f             	and    $0x3f,%edx
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  406e48:	48 89 c6             	mov    %rax,%rsi
  406e4b:	48 c1 ee 06          	shr    $0x6,%rsi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406e4f:	89 f1                	mov    %esi,%ecx
  406e51:	49 d3 e1             	shl    %cl,%r9
  bool setBit(uptr idx) {
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    if (!l1_[i0].getBit(i1)) {
  406e54:	4d 85 c1             	test   %r8,%r9
  406e57:	0f 84 03 01 00 00    	je     406f60 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x250>
  406e5d:	4c 8d 5b 08          	lea    0x8(%rbx),%r11
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406e61:	89 d1                	mov    %edx,%ecx
  406e63:	48 d3 e7             	shl    %cl,%rdi
  406e66:	4d 8d 04 f3          	lea    (%r11,%rsi,8),%r8
  406e6a:	48 89 fa             	mov    %rdi,%rdx
  406e6d:	49 8b 70 08          	mov    0x8(%r8),%rsi
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  406e71:	48 09 f2             	or     %rsi,%rdx

  // Returns true if this is the first (non-recursive) acquisition of this lock.
  bool addLock(uptr lock_id, uptr current_epoch, u32 stk) {
    // Printf("addLock: %zx %zx stk %u\n", lock_id, current_epoch, stk);
    CHECK_EQ(epoch_, current_epoch);
    if (!bv_.setBit(lock_id)) {
  406e74:	48 39 d6             	cmp    %rdx,%rsi
  406e77:	49 89 50 08          	mov    %rdx,0x8(%r8)
  406e7b:	0f 85 f4 00 00 00    	jne    406f75 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x265>
      // The lock is already held by this thread, it must be recursive.
      CHECK_LT(n_recursive_locks, ARRAY_SIZE(recursive_locks));
  406e81:	48 8b 8b 18 04 00 00 	mov    0x418(%rbx),%rcx
  406e88:	48 83 f9 3f          	cmp    $0x3f,%rcx
  406e8c:	0f 87 92 03 00 00    	ja     407224 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x514>
      recursive_locks[n_recursive_locks++] = lock_id;
  406e92:	48 8d 51 01          	lea    0x1(%rcx),%rdx
  406e96:	48 89 93 18 04 00 00 	mov    %rdx,0x418(%rbx)
  406e9d:	48 89 84 cb 18 02 00 	mov    %rax,0x218(%rbx,%rcx,8)
  406ea4:	00 
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  406ea5:	c6 45 08 00          	movb   $0x0,0x8(%rbp)
}
  406ea9:	48 83 c4 38          	add    $0x38,%rsp
  406ead:	5b                   	pop    %rbx
  406eae:	5d                   	pop    %rbp
  406eaf:	41 5c                	pop    %r12
  406eb1:	41 5d                	pop    %r13
  406eb3:	41 5e                	pop    %r14
  406eb5:	41 5f                	pop    %r15
  406eb7:	c3                   	retq   
  406eb8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  406ebf:	00 
  // Returns true iff dtls is empty (no locks are currently held) and we can
  // add the node to the currently held locks w/o chanding the global state.
  // This operation is thread-safe as it only touches the dtls.
  bool onFirstLock(DeadlockDetectorTLS<BV> *dtls, uptr node, u32 stk = 0) {
    if (!dtls->empty()) return false;
    if (dtls->getEpoch() && dtls->getEpoch() == nodeToEpoch(node)) {
  406ec0:	31 c0                	xor    %eax,%eax
  // Experimental *racy* fast path function.
  // Returns true if all edges from the currently held locks to cur_node exist.
  bool hasAllEdges(DeadlockDetectorTLS<BV> *dtls, uptr cur_node) {
    uptr local_epoch = dtls->getEpoch();
    // Read from current_epoch_ is racy.
    if (cur_node && local_epoch == current_epoch_ &&
  406ec2:	4d 85 c9             	test   %r9,%r9
  406ec5:	0f 85 ad fe ff ff    	jne    406d78 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x68>
  406ecb:	e9 c8 fe ff ff       	jmpq   406d98 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x88>

void DD::MutexAfterLock(DDCallback *cb, DDMutex *m, bool wlock, bool trylock) {
  DDLogicalThread *lt = cb->lt;
  u32 stk = 0;
  if (flags.second_deadlock_stack)
    stk = cb->Unwind();
  406ed0:	48 8b 06             	mov    (%rsi),%rax
  406ed3:	44 89 44 24 10       	mov    %r8d,0x10(%rsp)
  406ed8:	48 89 f7             	mov    %rsi,%rdi
  406edb:	ff 10                	callq  *(%rax)
  406edd:	44 8b 44 24 10       	mov    0x10(%rsp),%r8d
  406ee2:	41 89 c6             	mov    %eax,%r14d
  406ee5:	e9 55 fe ff ff       	jmpq   406d3f <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x2f>
  406eea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  }

  uptr nodeToIndexUnchecked(uptr node) const { return node % size(); }
  406ef0:	4c 89 ca             	mov    %r9,%rdx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406ef3:	bf 01 00 00 00       	mov    $0x1,%edi
  406ef8:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  406efe:	48 89 f8             	mov    %rdi,%rax
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  406f01:	48 89 d6             	mov    %rdx,%rsi
  406f04:	48 c1 ee 06          	shr    $0x6,%rsi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406f08:	89 f1                	mov    %esi,%ecx
  406f0a:	48 d3 e0             	shl    %cl,%rax
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  406f0d:	4c 89 c9             	mov    %r9,%rcx
  406f10:	83 e1 3f             	and    $0x3f,%ecx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406f13:	48 89 43 08          	mov    %rax,0x8(%rbx)
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    if (!l1_[i0].getBit(i1)) {
      l1_[i0].setBit(i1);
      l2_[i0][i1].clear();
  406f17:	48 8d 43 08          	lea    0x8(%rbx),%rax
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406f1b:	48 d3 e7             	shl    %cl,%rdi
      // The lock is already held by this thread, it must be recursive.
      CHECK_LT(n_recursive_locks, ARRAY_SIZE(recursive_locks));
      recursive_locks[n_recursive_locks++] = lock_id;
      return false;
    }
    CHECK_LT(n_all_locks_, ARRAY_SIZE(all_locks_with_contexts_));
  406f1e:	48 8b 8b 20 06 00 00 	mov    0x620(%rbx),%rcx
  406f25:	48 89 7c f0 08       	mov    %rdi,0x8(%rax,%rsi,8)
  406f2a:	48 83 f9 3f          	cmp    $0x3f,%rcx
  406f2e:	0f 87 6a 03 00 00    	ja     40729e <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x58e>
    // lock_id < BV::kSize, can cast to a smaller int.
    u32 lock_id_short = static_cast<u32>(lock_id);
    LockWithContext l = {lock_id_short, stk};
    all_locks_with_contexts_[n_all_locks_++] = l;
  406f34:	48 8d 84 c8 10 04 00 	lea    0x410(%rax,%rcx,8),%rax
  406f3b:	00 
  406f3c:	48 8d 71 01          	lea    0x1(%rcx),%rsi
  406f40:	48 89 b3 20 06 00 00 	mov    %rsi,0x620(%rbx)
      recursive_locks[n_recursive_locks++] = lock_id;
      return false;
    }
    CHECK_LT(n_all_locks_, ARRAY_SIZE(all_locks_with_contexts_));
    // lock_id < BV::kSize, can cast to a smaller int.
    u32 lock_id_short = static_cast<u32>(lock_id);
  406f47:	89 50 08             	mov    %edx,0x8(%rax)
    LockWithContext l = {lock_id_short, stk};
    all_locks_with_contexts_[n_all_locks_++] = l;
  406f4a:	44 89 70 0c          	mov    %r14d,0xc(%rax)
  if (wlock)  // Only a recursive rlock may be held.
    CHECK(!dd.isHeld(&lt->dd, m->id));
  if (!trylock)
    dd.addEdges(&lt->dd, m->id, stk ? stk : cb->Unwind(), cb->UniqueTid());
  dd.onLockAfter(&lt->dd, m->id, stk);
}
  406f4e:	48 83 c4 38          	add    $0x38,%rsp
  406f52:	5b                   	pop    %rbx
  406f53:	5d                   	pop    %rbp
  406f54:	41 5c                	pop    %r12
  406f56:	41 5d                	pop    %r13
  406f58:	41 5e                	pop    %r14
  406f5a:	41 5f                	pop    %r15
  406f5c:	c3                   	retq   
  406f5d:	0f 1f 00             	nopl   (%rax)
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    if (!l1_[i0].getBit(i1)) {
      l1_[i0].setBit(i1);
      l2_[i0][i1].clear();
  406f60:	4c 8d 5b 08          	lea    0x8(%rbx),%r11
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406f64:	89 d1                	mov    %edx,%ecx
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  406f66:	4d 09 c1             	or     %r8,%r9
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406f69:	48 d3 e7             	shl    %cl,%rdi
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  406f6c:	4c 89 4b 08          	mov    %r9,0x8(%rbx)
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  406f70:	49 89 7c f3 08       	mov    %rdi,0x8(%r11,%rsi,8)
      // The lock is already held by this thread, it must be recursive.
      CHECK_LT(n_recursive_locks, ARRAY_SIZE(recursive_locks));
      recursive_locks[n_recursive_locks++] = lock_id;
      return false;
    }
    CHECK_LT(n_all_locks_, ARRAY_SIZE(all_locks_with_contexts_));
  406f75:	48 8b 8b 20 06 00 00 	mov    0x620(%rbx),%rcx
  406f7c:	48 83 f9 3f          	cmp    $0x3f,%rcx
  406f80:	0f 87 18 03 00 00    	ja     40729e <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x58e>
    // lock_id < BV::kSize, can cast to a smaller int.
    u32 lock_id_short = static_cast<u32>(lock_id);
    LockWithContext l = {lock_id_short, stk};
    all_locks_with_contexts_[n_all_locks_++] = l;
  406f86:	48 8d 51 01          	lea    0x1(%rcx),%rdx
  406f8a:	48 89 93 20 06 00 00 	mov    %rdx,0x620(%rbx)
  406f91:	49 8d 94 cb 10 04 00 	lea    0x410(%r11,%rcx,8),%rdx
  406f98:	00 
      recursive_locks[n_recursive_locks++] = lock_id;
      return false;
    }
    CHECK_LT(n_all_locks_, ARRAY_SIZE(all_locks_with_contexts_));
    // lock_id < BV::kSize, can cast to a smaller int.
    u32 lock_id_short = static_cast<u32>(lock_id);
  406f99:	89 42 08             	mov    %eax,0x8(%rdx)
    LockWithContext l = {lock_id_short, stk};
    all_locks_with_contexts_[n_all_locks_++] = l;
  406f9c:	44 89 72 0c          	mov    %r14d,0xc(%rdx)
  406fa0:	e9 00 ff ff ff       	jmpq   406ea5 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x195>
  406fa5:	0f 1f 00             	nopl   (%rax)
  406fa8:	44 89 44 24 10       	mov    %r8d,0x10(%rsp)
      return;
    LockSlow();
  406fad:	e8 9e d5 ff ff       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  406fb2:	44 8b 44 24 10       	mov    0x10(%rsp),%r8d
  406fb7:	e9 ef fd ff ff       	jmpq   406dab <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x9b>
  406fbc:	0f 1f 40 00          	nopl   0x0(%rax)
    return;

  SpinMutexLock lk(&mtx);
  MutexEnsureID(lt, m);
  if (wlock)  // Only a recursive rlock may be held.
    CHECK(!dd.isHeld(&lt->dd, m->id));
  406fc0:	49 8b 45 00          	mov    0x0(%r13),%rax

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  406fc4:	48 3d ff 0f 00 00    	cmp    $0xfff,%rax
  406fca:	0f 86 25 03 00 00    	jbe    4072f5 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x5e5>
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  406fd0:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  uptr nodeToIndex(uptr node) const {
    check_node(node);
    return nodeToIndexUnchecked(node);
  }

  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }
  406fd4:	48 89 c1             	mov    %rax,%rcx
  406fd7:	48 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%rcx
 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  406fde:	48 39 ca             	cmp    %rcx,%rdx
  406fe1:	0f 85 f0 02 00 00    	jne    4072d7 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x5c7>
        return all_locks_with_contexts_[i].stk;
    return 0;
  }

  const BV &getLocks(uptr current_epoch) const {
    CHECK_EQ(epoch_, current_epoch);
  406fe7:	48 8b 8b 10 02 00 00 	mov    0x210(%rbx),%rcx
  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  }

  uptr nodeToIndexUnchecked(uptr node) const { return node % size(); }
  406fee:	48 89 c6             	mov    %rax,%rsi
  406ff1:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
        return all_locks_with_contexts_[i].stk;
    return 0;
  }

  const BV &getLocks(uptr current_epoch) const {
    CHECK_EQ(epoch_, current_epoch);
  406ff7:	48 39 ca             	cmp    %rcx,%rdx
  406ffa:	0f 85 bc 02 00 00    	jne    4072bc <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x5ac>
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  407000:	48 89 f2             	mov    %rsi,%rdx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407003:	be 01 00 00 00       	mov    $0x1,%esi
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  407008:	48 c1 ea 06          	shr    $0x6,%rdx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  40700c:	48 89 f7             	mov    %rsi,%rdi
  40700f:	89 d1                	mov    %edx,%ecx
  407011:	48 d3 e7             	shl    %cl,%rdi
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  407014:	48 85 7b 08          	test   %rdi,0x8(%rbx)
  407018:	0f 84 b0 fd ff ff    	je     406dce <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0xbe>
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  40701e:	83 e0 3f             	and    $0x3f,%eax
  407021:	48 89 c1             	mov    %rax,%rcx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407024:	48 d3 e6             	shl    %cl,%rsi
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  407027:	48 85 74 d3 10       	test   %rsi,0x10(%rbx,%rdx,8)
  40702c:	0f 84 9c fd ff ff    	je     406dce <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0xbe>
  407032:	48 8d 15 af e8 00 00 	lea    0xe8af(%rip),%rdx        # 4158e8 <.LC14>
  407039:	48 8d 3d d0 e8 00 00 	lea    0xe8d0(%rip),%rdi        # 415910 <.LC15>
  407040:	45 31 c0             	xor    %r8d,%r8d
  407043:	31 c9                	xor    %ecx,%ecx
  407045:	be a2 00 00 00       	mov    $0xa2,%esi
  40704a:	e8 a1 e3 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  }

  uptr nodeToIndexUnchecked(uptr node) const { return node % size(); }
  40704f:	4c 89 c8             	mov    %r9,%rax
  407052:	25 ff 0f 00 00       	and    $0xfff,%eax
  407057:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    dtls->addLock(cur_idx, current_epoch_, stk);
  }

  // Experimental *racy* fast path function.
  // Returns true if all edges from the currently held locks to cur_node exist.
  bool hasAllEdges(DeadlockDetectorTLS<BV> *dtls, uptr cur_node) {
  40705c:	48 8b 83 20 06 00 00 	mov    0x620(%rbx),%rax
    uptr local_epoch = dtls->getEpoch();
    // Read from current_epoch_ is racy.
    if (cur_node && local_epoch == current_epoch_ &&
        local_epoch == nodeToEpoch(cur_node)) {
      uptr cur_idx = nodeToIndexUnchecked(cur_node);
      for (uptr i = 0, n = dtls->getNumLocks(); i < n; i++) {
  407063:	48 85 c0             	test   %rax,%rax
    dtls->addLock(cur_idx, current_epoch_, stk);
  }

  // Experimental *racy* fast path function.
  // Returns true if all edges from the currently held locks to cur_node exist.
  bool hasAllEdges(DeadlockDetectorTLS<BV> *dtls, uptr cur_node) {
  407066:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    uptr local_epoch = dtls->getEpoch();
    // Read from current_epoch_ is racy.
    if (cur_node && local_epoch == current_epoch_ &&
        local_epoch == nodeToEpoch(cur_node)) {
      uptr cur_idx = nodeToIndexUnchecked(cur_node);
      for (uptr i = 0, n = dtls->getNumLocks(); i < n; i++) {
  40706b:	0f 84 8b 01 00 00    	je     4071fc <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x4ec>
    CHECK_EQ(epoch_, current_epoch);
    return bv_;
  }

  uptr getNumLocks() const { return n_all_locks_; }
  uptr getLock(uptr idx) const { return all_locks_with_contexts_[idx].lock; }
  407071:	8b 83 20 04 00 00    	mov    0x420(%rbx),%eax
  // Returns true if an edge from=>to exist.
  // This function does not use any global state except for 'this' itself,
  // and thus can be called from different threads w/o locking.
  // This would be racy.
  // FIXME: investigate how much we can prove about this race being "benign".
  bool hasEdge(uptr from, uptr to) { return v[from].getBit(to); }
  407077:	48 8d 95 30 06 00 00 	lea    0x630(%rbp),%rdx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  40707e:	bf 01 00 00 00       	mov    $0x1,%edi
  407083:	49 89 ff             	mov    %rdi,%r15
  407086:	48 89 c1             	mov    %rax,%rcx
  407089:	48 c1 e1 09          	shl    $0x9,%rcx
  40708d:	4c 8d 14 c1          	lea    (%rcx,%rax,8),%r10
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  407091:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  407096:	49 01 d2             	add    %rdx,%r10
  407099:	48 c1 e8 06          	shr    $0x6,%rax
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  40709d:	89 c1                	mov    %eax,%ecx
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  40709f:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  4070a4:	49 d3 e7             	shl    %cl,%r15
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  4070a7:	4d 85 3a             	test   %r15,(%r10)
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  4070aa:	4c 89 f8             	mov    %r15,%rax
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  4070ad:	0f 84 e5 fc ff ff    	je     406d98 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x88>
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  4070b3:	4c 89 c9             	mov    %r9,%rcx
  4070b6:	83 e1 3f             	and    $0x3f,%ecx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  4070b9:	48 d3 e7             	shl    %cl,%rdi
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  4070bc:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
  4070c1:	4c 8d 3c cd 00 00 00 	lea    0x0(,%rcx,8),%r15
  4070c8:	00 
  4070c9:	4b 85 7c 3a 08       	test   %rdi,0x8(%r10,%r15,1)
  4070ce:	0f 84 c4 fc ff ff    	je     406d98 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x88>
    uptr local_epoch = dtls->getEpoch();
    // Read from current_epoch_ is racy.
    if (cur_node && local_epoch == current_epoch_ &&
        local_epoch == nodeToEpoch(cur_node)) {
      uptr cur_idx = nodeToIndexUnchecked(cur_node);
      for (uptr i = 0, n = dtls->getNumLocks(); i < n; i++) {
  4070d4:	45 31 d2             	xor    %r10d,%r10d
  4070d7:	4c 8d 5b 08          	lea    0x8(%rbx),%r11
  4070db:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  4070e0:	4c 8b 4c 24 18       	mov    0x18(%rsp),%r9
  4070e5:	eb 0b                	jmp    4070f2 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x3e2>
  4070e7:	4a 85 7c 39 08       	test   %rdi,0x8(%rcx,%r15,1)
  4070ec:	0f 84 a6 fc ff ff    	je     406d98 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x88>
  4070f2:	49 83 c2 01          	add    $0x1,%r10
  4070f6:	4d 39 ca             	cmp    %r9,%r10
  4070f9:	74 54                	je     40714f <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x43f>
    CHECK_EQ(epoch_, current_epoch);
    return bv_;
  }

  uptr getNumLocks() const { return n_all_locks_; }
  uptr getLock(uptr idx) const { return all_locks_with_contexts_[idx].lock; }
  4070fb:	43 8b 8c d3 18 04 00 	mov    0x418(%r11,%r10,8),%ecx
  407102:	00 
  407103:	48 89 ce             	mov    %rcx,%rsi
  407106:	48 c1 e6 09          	shl    $0x9,%rsi
  40710a:	48 8d 0c ce          	lea    (%rsi,%rcx,8),%rcx
  40710e:	48 01 d1             	add    %rdx,%rcx
  407111:	48 85 01             	test   %rax,(%rcx)
  407114:	0f 84 7e fc ff ff    	je     406d98 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x88>
  40711a:	eb cb                	jmp    4070e7 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x3d7>
  40711c:	0f 1f 40 00          	nopl   0x0(%rax)
  if (!trylock)
    dd.addEdges(&lt->dd, m->id, stk ? stk : cb->Unwind(), cb->UniqueTid());
  407120:	49 8b 04 24          	mov    (%r12),%rax
  407124:	4c 89 e7             	mov    %r12,%rdi
  407127:	ff 50 08             	callq  *0x8(%rax)
  40712a:	45 85 f6             	test   %r14d,%r14d
  40712d:	41 89 c0             	mov    %eax,%r8d
  407130:	44 89 f1             	mov    %r14d,%ecx
  407133:	0f 84 aa 00 00 00    	je     4071e3 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x4d3>
  407139:	49 8b 55 00          	mov    0x0(%r13),%rdx
  DDLogicalThread *lt = cb->lt;
  u32 stk = 0;
  if (flags.second_deadlock_stack)
    stk = cb->Unwind();
  // Printf("T%p MutexLock:   %zx stk %u\n", lt, m->id, stk);
  if (dd.onFirstLock(&lt->dd, m->id, stk))
  40713d:	48 8d 73 08          	lea    0x8(%rbx),%rsi
    return;
  if (dd.onLockFast(&lt->dd, m->id, stk))
  407141:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
  SpinMutexLock lk(&mtx);
  MutexEnsureID(lt, m);
  if (wlock)  // Only a recursive rlock may be held.
    CHECK(!dd.isHeld(&lt->dd, m->id));
  if (!trylock)
    dd.addEdges(&lt->dd, m->id, stk ? stk : cb->Unwind(), cb->UniqueTid());
  407145:	e8 86 0d 00 00       	callq  407ed0 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji>
  40714a:	e9 88 fc ff ff       	jmpq   406dd7 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0xc7>
  40714f:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
    uptr local_epoch = dtls->getEpoch();
    // Read from current_epoch_ is racy.
    if (cur_node && local_epoch == current_epoch_ &&
        local_epoch == nodeToEpoch(cur_node)) {
      uptr cur_idx = nodeToIndexUnchecked(cur_node);
      for (uptr i = 0, n = dtls->getNumLocks(); i < n; i++) {
  407154:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
  bool setBit(uptr idx) {
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    if (!l1_[i0].getBit(i1)) {
  407159:	48 85 f0             	test   %rsi,%rax
  40715c:	74 42                	je     4071a0 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x490>
  40715e:	49 8d 14 d3          	lea    (%r11,%rdx,8),%rdx
  407162:	48 8b 42 08          	mov    0x8(%rdx),%rax
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  407166:	48 09 c7             	or     %rax,%rdi

  // Returns true if this is the first (non-recursive) acquisition of this lock.
  bool addLock(uptr lock_id, uptr current_epoch, u32 stk) {
    // Printf("addLock: %zx %zx stk %u\n", lock_id, current_epoch, stk);
    CHECK_EQ(epoch_, current_epoch);
    if (!bv_.setBit(lock_id)) {
  407169:	48 39 f8             	cmp    %rdi,%rax
  40716c:	48 89 7a 08          	mov    %rdi,0x8(%rdx)
  407170:	75 3a                	jne    4071ac <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x49c>
      // The lock is already held by this thread, it must be recursive.
      CHECK_LT(n_recursive_locks, ARRAY_SIZE(recursive_locks));
  407172:	48 8b 8b 18 04 00 00 	mov    0x418(%rbx),%rcx
  407179:	48 83 f9 3f          	cmp    $0x3f,%rcx
  40717d:	0f 87 a1 00 00 00    	ja     407224 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x514>
      recursive_locks[n_recursive_locks++] = lock_id;
  407183:	48 8d 41 01          	lea    0x1(%rcx),%rax
  407187:	48 89 83 18 04 00 00 	mov    %rax,0x418(%rbx)
  40718e:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  407193:	48 89 84 cb 18 02 00 	mov    %rax,0x218(%rbx,%rcx,8)
  40719a:	00 
  40719b:	e9 09 fd ff ff       	jmpq   406ea9 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x199>
  4071a0:	48 09 f0             	or     %rsi,%rax
  4071a3:	48 89 43 08          	mov    %rax,0x8(%rbx)
  4071a7:	49 89 7c d3 08       	mov    %rdi,0x8(%r11,%rdx,8)
      return false;
    }
    CHECK_LT(n_all_locks_, ARRAY_SIZE(all_locks_with_contexts_));
  4071ac:	48 83 7c 24 18 3f    	cmpq   $0x3f,0x18(%rsp)
  4071b2:	0f 87 8a 00 00 00    	ja     407242 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x532>
    // lock_id < BV::kSize, can cast to a smaller int.
    u32 lock_id_short = static_cast<u32>(lock_id);
    LockWithContext l = {lock_id_short, stk};
    all_locks_with_contexts_[n_all_locks_++] = l;
  4071b8:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  4071bd:	48 89 f8             	mov    %rdi,%rax
  4071c0:	48 83 c0 01          	add    $0x1,%rax
  4071c4:	48 89 83 20 06 00 00 	mov    %rax,0x620(%rbx)
  4071cb:	49 8d 84 fb 10 04 00 	lea    0x410(%r11,%rdi,8),%rax
  4071d2:	00 
      recursive_locks[n_recursive_locks++] = lock_id;
      return false;
    }
    CHECK_LT(n_all_locks_, ARRAY_SIZE(all_locks_with_contexts_));
    // lock_id < BV::kSize, can cast to a smaller int.
    u32 lock_id_short = static_cast<u32>(lock_id);
  4071d3:	8b 7c 24 10          	mov    0x10(%rsp),%edi
    LockWithContext l = {lock_id_short, stk};
    all_locks_with_contexts_[n_all_locks_++] = l;
  4071d7:	44 89 70 0c          	mov    %r14d,0xc(%rax)
      recursive_locks[n_recursive_locks++] = lock_id;
      return false;
    }
    CHECK_LT(n_all_locks_, ARRAY_SIZE(all_locks_with_contexts_));
    // lock_id < BV::kSize, can cast to a smaller int.
    u32 lock_id_short = static_cast<u32>(lock_id);
  4071db:	89 78 08             	mov    %edi,0x8(%rax)
  4071de:	e9 c6 fc ff ff       	jmpq   406ea9 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x199>
  4071e3:	89 44 24 0c          	mov    %eax,0xc(%rsp)
  4071e7:	49 8b 04 24          	mov    (%r12),%rax
  4071eb:	4c 89 e7             	mov    %r12,%rdi
  4071ee:	ff 10                	callq  *(%rax)
  4071f0:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
  4071f5:	89 c1                	mov    %eax,%ecx
  4071f7:	e9 3d ff ff ff       	jmpq   407139 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x429>
  4071fc:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  407201:	bf 01 00 00 00       	mov    $0x1,%edi
  407206:	4c 8d 5b 08          	lea    0x8(%rbx),%r11
  40720a:	48 89 f8             	mov    %rdi,%rax
  40720d:	48 c1 ea 06          	shr    $0x6,%rdx
  407211:	89 d1                	mov    %edx,%ecx
  407213:	48 d3 e0             	shl    %cl,%rax
  407216:	4c 89 c9             	mov    %r9,%rcx
  407219:	83 e1 3f             	and    $0x3f,%ecx
  40721c:	48 d3 e7             	shl    %cl,%rdi
  40721f:	e9 35 ff ff ff       	jmpq   407159 <_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb+0x449>
  bool addLock(uptr lock_id, uptr current_epoch, u32 stk) {
    // Printf("addLock: %zx %zx stk %u\n", lock_id, current_epoch, stk);
    CHECK_EQ(epoch_, current_epoch);
    if (!bv_.setBit(lock_id)) {
      // The lock is already held by this thread, it must be recursive.
      CHECK_LT(n_recursive_locks, ARRAY_SIZE(recursive_locks));
  407224:	48 8d 15 65 e6 00 00 	lea    0xe665(%rip),%rdx        # 415890 <.LC13>
  40722b:	48 8d 3d d6 e4 00 00 	lea    0xe4d6(%rip),%rdi        # 415708 <.LC4>
  407232:	41 b8 40 00 00 00    	mov    $0x40,%r8d
  407238:	be 41 00 00 00       	mov    $0x41,%esi
  40723d:	e8 ae e1 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
      recursive_locks[n_recursive_locks++] = lock_id;
      return false;
    }
    CHECK_LT(n_all_locks_, ARRAY_SIZE(all_locks_with_contexts_));
  407242:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  407247:	48 8d 15 e2 e5 00 00 	lea    0xe5e2(%rip),%rdx        # 415830 <.LC12>
  40724e:	48 8d 3d b3 e4 00 00 	lea    0xe4b3(%rip),%rdi        # 415708 <.LC4>
  407255:	41 b8 40 00 00 00    	mov    $0x40,%r8d
  40725b:	be 45 00 00 00       	mov    $0x45,%esi
  407260:	e8 8b e1 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  407265:	48 8d 15 74 e5 00 00 	lea    0xe574(%rip),%rdx        # 4157e0 <.LC8>
  40726c:	48 8d 3d 95 e4 00 00 	lea    0xe495(%rip),%rdi        # 415708 <.LC4>
  407273:	be 75 01 00 00       	mov    $0x175,%esi
  407278:	e8 73 e1 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  40727d:	48 89 d1             	mov    %rdx,%rcx
  407280:	48 8d 3d 81 e4 00 00 	lea    0xe481(%rip),%rdi        # 415708 <.LC4>
  407287:	48 8d 15 58 13 01 00 	lea    0x11358(%rip),%rdx        # 4185e6 <.LC3>
  40728e:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  407294:	be 74 01 00 00       	mov    $0x174,%esi
  407299:	e8 52 e1 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
      // The lock is already held by this thread, it must be recursive.
      CHECK_LT(n_recursive_locks, ARRAY_SIZE(recursive_locks));
      recursive_locks[n_recursive_locks++] = lock_id;
      return false;
    }
    CHECK_LT(n_all_locks_, ARRAY_SIZE(all_locks_with_contexts_));
  40729e:	48 8d 15 8b e5 00 00 	lea    0xe58b(%rip),%rdx        # 415830 <.LC12>
  4072a5:	48 8d 3d 5c e4 00 00 	lea    0xe45c(%rip),%rdi        # 415708 <.LC4>
  4072ac:	41 b8 40 00 00 00    	mov    $0x40,%r8d
  4072b2:	be 45 00 00 00       	mov    $0x45,%esi
  4072b7:	e8 34 e1 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
        return all_locks_with_contexts_[i].stk;
    return 0;
  }

  const BV &getLocks(uptr current_epoch) const {
    CHECK_EQ(epoch_, current_epoch);
  4072bc:	49 89 d0             	mov    %rdx,%r8
  4072bf:	48 8d 3d 42 e4 00 00 	lea    0xe442(%rip),%rdi        # 415708 <.LC4>
  4072c6:	48 8d 15 43 e5 00 00 	lea    0xe543(%rip),%rdx        # 415810 <.LC9>
  4072cd:	be 6e 00 00 00       	mov    $0x6e,%esi
  4072d2:	e8 19 e1 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  4072d7:	49 89 c8             	mov    %rcx,%r8
  4072da:	48 8d 3d 27 e4 00 00 	lea    0xe427(%rip),%rdi        # 415708 <.LC4>
  4072e1:	48 89 d1             	mov    %rdx,%rcx
  4072e4:	48 8d 15 f5 e4 00 00 	lea    0xe4f5(%rip),%rdx        # 4157e0 <.LC8>
  4072eb:	be 75 01 00 00       	mov    $0x175,%esi
  4072f0:	e8 fb e0 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  4072f5:	48 8d 15 ea 12 01 00 	lea    0x112ea(%rip),%rdx        # 4185e6 <.LC3>
  4072fc:	48 8d 3d 05 e4 00 00 	lea    0xe405(%rip),%rdi        # 415708 <.LC4>
  407303:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  407309:	48 89 c1             	mov    %rax,%rcx
  40730c:	be 74 01 00 00       	mov    $0x174,%esi
  407311:	e8 da e0 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  407316:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40731d:	00 00 00 

0000000000407320 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE>:
    dd.addEdges(&lt->dd, m->id, cb->Unwind(), cb->UniqueTid());
    ReportDeadlock(cb, m);
  }
}

void DD::ReportDeadlock(DDCallback *cb, DDMutex *m) {
  407320:	41 57                	push   %r15
  407322:	49 89 ff             	mov    %rdi,%r15
  407325:	41 56                	push   %r14
  407327:	41 55                	push   %r13
  407329:	41 54                	push   %r12
  40732b:	55                   	push   %rbp
  40732c:	53                   	push   %rbx
  40732d:	48 81 ec c8 00 00 00 	sub    $0xc8,%rsp
  DDLogicalThread *lt = cb->lt;
  407334:	48 8b 46 10          	mov    0x10(%rsi),%rax
  // Finds a path between the lock 'cur_node' (currently not held in dtls)
  // and some currently held lock, returns the length of the path
  // or 0 on failure.
  uptr findPathToLock(DeadlockDetectorTLS<BV> *dtls, uptr cur_node, uptr *path,
                      uptr path_size) {
    tmp_bv_.copyFrom(dtls->getLocks(current_epoch_));
  407338:	4c 8b 47 10          	mov    0x10(%rdi),%r8
  uptr path[10];
  uptr len = dd.findPathToLock(&lt->dd, m->id, path, ARRAY_SIZE(path));
  40733c:	48 8b 1a             	mov    (%rdx),%rbx
    dd.addEdges(&lt->dd, m->id, cb->Unwind(), cb->UniqueTid());
    ReportDeadlock(cb, m);
  }
}

void DD::ReportDeadlock(DDCallback *cb, DDMutex *m) {
  40733f:	48 89 54 24 68       	mov    %rdx,0x68(%rsp)
        return all_locks_with_contexts_[i].stk;
    return 0;
  }

  const BV &getLocks(uptr current_epoch) const {
    CHECK_EQ(epoch_, current_epoch);
  407344:	48 8b 88 10 02 00 00 	mov    0x210(%rax),%rcx
  DDLogicalThread *lt = cb->lt;
  40734b:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
  uptr path[10];
  uptr len = dd.findPathToLock(&lt->dd, m->id, path, ARRAY_SIZE(path));
  407350:	48 89 5c 24 40       	mov    %rbx,0x40(%rsp)
  407355:	49 39 c8             	cmp    %rcx,%r8
  407358:	0f 85 36 03 00 00    	jne    407694 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x374>
  // Finds a path between the lock 'cur_node' (currently not held in dtls)
  // and some currently held lock, returns the length of the path
  // or 0 on failure.
  uptr findPathToLock(DeadlockDetectorTLS<BV> *dtls, uptr cur_node, uptr *path,
                      uptr path_size) {
    tmp_bv_.copyFrom(dtls->getLocks(current_epoch_));
  40735e:	48 8d 87 28 04 00 00 	lea    0x428(%rdi),%rax
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  407365:	48 c7 87 28 04 00 00 	movq   $0x0,0x428(%rdi)
  40736c:	00 00 00 00 
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407370:	be 01 00 00 00       	mov    $0x1,%esi
  407375:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
  40737a:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
  40737f:	4c 8b 4c 24 08       	mov    0x8(%rsp),%r9
  407384:	48 8b 50 08          	mov    0x8(%rax),%rdx
  407388:	49 89 c0             	mov    %rax,%r8
      while (!t.empty()) {
  40738b:	48 85 d2             	test   %rdx,%rdx
  40738e:	75 22                	jne    4073b2 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x92>
  407390:	eb 70                	jmp    407402 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0xe2>
  407392:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  407398:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
  40739f:	00 
  4073a0:	31 d2                	xor    %edx,%edx
  }

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ |= v.bits_;
  4073a2:	49 0b 54 f8 10       	or     0x10(%r8,%rdi,8),%rdx
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  4073a7:	48 85 c0             	test   %rax,%rax
  }

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ |= v.bits_;
  4073aa:	48 89 11             	mov    %rdx,(%rcx)
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  4073ad:	74 53                	je     407402 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0xe2>

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  4073af:	48 89 c2             	mov    %rax,%rdx
  4073b2:	f3 48 0f bc ca       	tzcnt  %rdx,%rcx
  4073b7:	48 63 f9             	movslq %ecx,%rdi
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  4073ba:	48 83 ff 3f          	cmp    $0x3f,%rdi
  4073be:	0f 87 cb 02 00 00    	ja     40768f <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x36f>
    return (basic_int_t)1UL << idx;
  4073c4:	48 89 f0             	mov    %rsi,%rax
  4073c7:	48 d3 e0             	shl    %cl,%rax
  4073ca:	48 89 c1             	mov    %rax,%rcx
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  4073cd:	48 f7 d0             	not    %rax
  4073d0:	48 21 d0             	and    %rdx,%rax
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
  4073d3:	49 8b 97 28 04 00 00 	mov    0x428(%r15),%rdx
    bits_ |= mask(idx);
  4073da:	48 09 d1             	or     %rdx,%rcx
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
  4073dd:	48 39 ca             	cmp    %rcx,%rdx
          l2_[i0][i1].clear();
  4073e0:	49 8d 14 f9          	lea    (%r9,%rdi,8),%rdx
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  4073e4:	49 89 8f 28 04 00 00 	mov    %rcx,0x428(%r15)
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
          l2_[i0][i1].clear();
  4073eb:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
  4073ef:	75 a7                	jne    407398 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x78>
  4073f1:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  }

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ |= v.bits_;
  4073f5:	49 0b 54 f8 10       	or     0x10(%r8,%rdi,8),%rdx
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  4073fa:	48 85 c0             	test   %rax,%rax
  }

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ |= v.bits_;
  4073fd:	48 89 11             	mov    %rdx,(%rcx)
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  407400:	75 ad                	jne    4073af <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x8f>

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  407402:	48 81 7c 24 40 ff 0f 	cmpq   $0xfff,0x40(%rsp)
  407409:	00 00 
  40740b:	0f 86 0f 05 00 00    	jbe    407920 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x600>
  uptr nodeToIndex(uptr node) const {
    check_node(node);
    return nodeToIndexUnchecked(node);
  }

  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }
  407411:	4c 8b 44 24 40       	mov    0x40(%rsp),%r8
 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  407416:	49 8b 4f 10          	mov    0x10(%r15),%rcx
  uptr nodeToIndex(uptr node) const {
    check_node(node);
    return nodeToIndexUnchecked(node);
  }

  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }
  40741a:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8
 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  407421:	4c 39 c1             	cmp    %r8,%rcx
  407424:	0f 85 5d 04 00 00    	jne    407887 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x567>
  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  }

  uptr nodeToIndexUnchecked(uptr node) const { return node % size(); }
  40742a:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  40742f:	ba 01 00 00 00       	mov    $0x1,%edx
  407434:	48 89 d7             	mov    %rdx,%rdi
  407437:	48 89 f0             	mov    %rsi,%rax
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  40743a:	83 e6 3f             	and    $0x3f,%esi
  40743d:	25 ff 0f 00 00       	and    $0xfff,%eax
  407442:	48 89 c3             	mov    %rax,%rbx
  407445:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
    return bits_ != old;
  }

  bool getBit(uptr idx) const { return (bits_ & mask(idx)) != 0; }
  40744a:	49 8b 87 28 04 00 00 	mov    0x428(%r15),%rax
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  407451:	48 c1 eb 06          	shr    $0x6,%rbx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407455:	89 d9                	mov    %ebx,%ecx
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  407457:	48 89 5c 24 60       	mov    %rbx,0x60(%rsp)
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  40745c:	48 d3 e7             	shl    %cl,%rdi
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  40745f:	48 85 c7             	test   %rax,%rdi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407462:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  407467:	0f 85 c5 01 00 00    	jne    407632 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x312>
  uptr findPathToLock(DeadlockDetectorTLS<BV> *dtls, uptr cur_node, uptr *path,
                      uptr path_size) {
    tmp_bv_.copyFrom(dtls->getLocks(current_epoch_));
    uptr idx = nodeToIndex(cur_node);
    CHECK(!tmp_bv_.getBit(idx));
    uptr res = g_.findShortestPath(idx, tmp_bv_, path, path_size);
  40746d:	49 8d 9f 30 06 00 00 	lea    0x630(%r15),%rbx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407474:	48 c7 44 24 58 01 00 	movq   $0x1,0x58(%rsp)
  40747b:	00 00 
  40747d:	89 f1                	mov    %esi,%ecx
  40747f:	48 d3 64 24 58       	shlq   %cl,0x58(%rsp)
  }

  // Same as findPath, but finds a shortest path.
  uptr findShortestPath(uptr from, const BV &targets, uptr *path,
                        uptr path_size) {
    for (uptr p = 1; p <= path_size; p++)
  407484:	41 bc 01 00 00 00    	mov    $0x1,%r12d
  40748a:	4c 89 7c 24 30       	mov    %r15,0x30(%rsp)
  40748f:	48 89 df             	mov    %rbx,%rdi
  407492:	48 89 5c 24 20       	mov    %rbx,0x20(%rsp)
    path[0] = from;
    if (targets.getBit(from))
      return 1;
    // The function is recursive, so we don't want to create BV on stack.
    // Instead of a getAndClearFirstOne loop we use the slower iterator.
    for (typename BV::Iterator it(v[from]); it.hasNext(); ) {
  407497:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
  40749c:	48 89 da             	mov    %rbx,%rdx
  40749f:	48 c1 e2 09          	shl    $0x9,%rdx
  4074a3:	48 8d 14 da          	lea    (%rdx,%rbx,8),%rdx
  4074a7:	48 01 fa             	add    %rdi,%rdx
  4074aa:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
  4074af:	90                   	nop
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  4074b0:	48 85 44 24 48       	test   %rax,0x48(%rsp)
  // stores up to 'path_size' items of the path into 'path',
  // returns the path length, or 0 if there is no path of size 'path_size'.
  uptr findPath(uptr from, const BV &targets, uptr *path, uptr path_size) {
    if (path_size == 0)
      return 0;
    path[0] = from;
  4074b5:	48 89 5c 24 70       	mov    %rbx,0x70(%rsp)
  4074ba:	74 1a                	je     4074d6 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x1b6>
  4074bc:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  4074c1:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
  4074c6:	48 8b 7c 24 58       	mov    0x58(%rsp),%rdi
  4074cb:	48 85 7c d8 08       	test   %rdi,0x8(%rax,%rbx,8)
  4074d0:	0f 85 52 01 00 00    	jne    407628 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x308>
  4074d6:	49 8d 44 24 ff       	lea    -0x1(%r12),%rax
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  4074db:	31 db                	xor    %ebx,%ebx
  4074dd:	45 31 ed             	xor    %r13d,%r13d
  //   use(idx);
  // }
  class Iterator {
   public:
    Iterator() = default;
    explicit Iterator(const TwoLevelBitVector &bv) : bv_(bv), i0_(0), i1_(0) {
  4074e0:	45 31 f6             	xor    %r14d,%r14d
  4074e3:	45 31 ff             	xor    %r15d,%r15d
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  4074e6:	bd 01 00 00 00       	mov    $0x1,%ebp
  4074eb:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
      return 1;
    // The function is recursive, so we don't want to create BV on stack.
    // Instead of a getAndClearFirstOne loop we use the slower iterator.
    for (typename BV::Iterator it(v[from]); it.hasNext(); ) {
      uptr idx = it.next();
      if (uptr res = findPath(idx, targets, path + 1, path_size - 1))
  4074f0:	48 8d 44 24 78       	lea    0x78(%rsp),%rax
  4074f5:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  4074fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      it1_.clear();
      it2_.clear();
    }

    bool hasNext() const {
      if (it1_.hasNext()) return true;
  407500:	4d 85 ed             	test   %r13,%r13
  407503:	0f 84 a7 00 00 00    	je     4075b0 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x290>
          // Printf("+i0: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
          //   it2_.hasNext(), kSize);
          break;
        }
      }
      if (!it2_.hasNext()) {
  407509:	48 85 db             	test   %rbx,%rbx
  40750c:	0f 84 ab 03 00 00    	je     4078bd <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x59d>
  407512:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  407518:	f3 48 0f bc cb       	tzcnt  %rbx,%rcx
  40751d:	48 63 f1             	movslq %ecx,%rsi
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  407520:	48 83 fe 3f          	cmp    $0x3f,%rsi
  407524:	0f 87 5a 01 00 00    	ja     407684 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x364>
    return (basic_int_t)1UL << idx;
  40752a:	48 89 e8             	mov    %rbp,%rax
  40752d:	48 d3 e0             	shl    %cl,%rax
  407530:	48 89 c1             	mov    %rax,%rcx
        // Printf("++i1: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
        //       it2_.hasNext(), kSize);
      }
      CHECK(it2_.hasNext());
      uptr i2 = it2_.next();
      uptr res = i0_ * BV::kSize * BV::kSize + i1_ * BV::kSize + i2;
  407533:	4c 89 f0             	mov    %r14,%rax
  407536:	48 c1 e0 06          	shl    $0x6,%rax
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  40753a:	48 f7 d1             	not    %rcx
        // Printf("++i1: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
        //       it2_.hasNext(), kSize);
      }
      CHECK(it2_.hasNext());
      uptr i2 = it2_.next();
      uptr res = i0_ * BV::kSize * BV::kSize + i1_ * BV::kSize + i2;
  40753d:	4c 01 f8             	add    %r15,%rax
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  407540:	48 21 cb             	and    %rcx,%rbx
        // Printf("++i1: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
        //       it2_.hasNext(), kSize);
      }
      CHECK(it2_.hasNext());
      uptr i2 = it2_.next();
      uptr res = i0_ * BV::kSize * BV::kSize + i1_ * BV::kSize + i2;
  407543:	48 c1 e0 06          	shl    $0x6,%rax
  407547:	48 01 c6             	add    %rax,%rsi
      // Printf("+ret: %zd %zd; %d %d; size %zd; res: %zd\n", i0_, i1_,
      //       it1_.hasNext(), it2_.hasNext(), kSize, res);
      if (!it1_.hasNext() && !it2_.hasNext())
  40754a:	4d 85 ed             	test   %r13,%r13
  40754d:	75 08                	jne    407557 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x237>
        i0_++;
  40754f:	48 83 fb 01          	cmp    $0x1,%rbx
  407553:	49 83 d6 00          	adc    $0x0,%r14
  407557:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
  40755c:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  407561:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  407566:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  40756b:	e8 00 0d 00 00       	callq  408270 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm>
  407570:	48 85 c0             	test   %rax,%rax
  407573:	74 8b                	je     407500 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x1e0>
        return res + 1;
  407575:	48 83 c0 01          	add    $0x1,%rax

  // Same as findPath, but finds a shortest path.
  uptr findShortestPath(uptr from, const BV &targets, uptr *path,
                        uptr path_size) {
    for (uptr p = 1; p <= path_size; p++)
      if (findPath(from, targets, path, p) == p)
  407579:	49 39 c4             	cmp    %rax,%r12
  40757c:	0f 84 2a 01 00 00    	je     4076ac <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x38c>
  407582:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  }

  // Same as findPath, but finds a shortest path.
  uptr findShortestPath(uptr from, const BV &targets, uptr *path,
                        uptr path_size) {
    for (uptr p = 1; p <= path_size; p++)
  407588:	49 83 c4 01          	add    $0x1,%r12
  40758c:	49 83 fc 0b          	cmp    $0xb,%r12
  407590:	0f 84 d1 00 00 00    	je     407667 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x347>
  407596:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  40759b:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
  4075a0:	48 8b 80 28 04 00 00 	mov    0x428(%rax),%rax
  4075a7:	e9 04 ff ff ff       	jmpq   4074b0 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x190>
  4075ac:	0f 1f 40 00          	nopl   0x0(%rax)
      it2_.clear();
    }

    bool hasNext() const {
      if (it1_.hasNext()) return true;
      for (uptr i = i0_; i < kLevel1Size; i++)
  4075b0:	4d 85 f6             	test   %r14,%r14
  4075b3:	75 d3                	jne    407588 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x268>

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  4075b5:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  4075ba:	48 8b 00             	mov    (%rax),%rax
    }

    bool hasNext() const {
      if (it1_.hasNext()) return true;
      for (uptr i = i0_; i < kLevel1Size; i++)
        if (!bv_.l1_[i].empty()) return true;
  4075bd:	48 85 c0             	test   %rax,%rax
  4075c0:	74 c6                	je     407588 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x268>
    }

    uptr next() {
      // Printf("++++: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
      //       it2_.hasNext(), kSize);
      if (!it1_.hasNext() && !it2_.hasNext()) {
  4075c2:	48 85 db             	test   %rbx,%rbx
  4075c5:	0f 85 4d ff ff ff    	jne    407518 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x1f8>
  4075cb:	f3 48 0f bc c8       	tzcnt  %rax,%rcx
  4075d0:	4c 63 f9             	movslq %ecx,%r15
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  4075d3:	49 83 ff 3f          	cmp    $0x3f,%r15
  4075d7:	0f 87 af 00 00 00    	ja     40768c <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x36c>
    return (basic_int_t)1UL << idx;
  4075dd:	49 89 ed             	mov    %rbp,%r13
  //   use(idx);
  // }
  class Iterator {
   public:
    Iterator() = default;
    explicit Iterator(const BasicBitVector &bv) : bv_(bv) {}
  4075e0:	48 8b 5c 24 28       	mov    0x28(%rsp),%rbx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  4075e5:	49 d3 e5             	shl    %cl,%r13
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  4075e8:	49 f7 d5             	not    %r13
  4075eb:	49 21 c5             	and    %rax,%r13
  //   use(idx);
  // }
  class Iterator {
   public:
    Iterator() = default;
    explicit Iterator(const BasicBitVector &bv) : bv_(bv) {}
  4075ee:	4c 89 f0             	mov    %r14,%rax
  4075f1:	48 c1 e0 06          	shl    $0x6,%rax
  4075f5:	4c 01 f8             	add    %r15,%rax
  4075f8:	48 8b 5c c3 08       	mov    0x8(%rbx,%rax,8),%rbx
        i1_ = it1_.next();
        it2_ = typename BV::Iterator(bv_.l2_[i0_][i1_]);
        // Printf("++i1: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
        //       it2_.hasNext(), kSize);
      }
      CHECK(it2_.hasNext());
  4075fd:	48 85 db             	test   %rbx,%rbx
  407600:	0f 85 12 ff ff ff    	jne    407518 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x1f8>
  407606:	48 8d 15 16 10 01 00 	lea    0x11016(%rip),%rdx        # 418623 <.LC16>
  40760d:	48 8d 3d 7c e0 00 00 	lea    0xe07c(%rip),%rdi        # 415690 <.LC1>
  407614:	45 31 c0             	xor    %r8d,%r8d
  407617:	31 c9                	xor    %ecx,%ecx
  407619:	be 34 01 00 00       	mov    $0x134,%esi
  40761e:	e8 cd dd ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  407623:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  uptr findPath(uptr from, const BV &targets, uptr *path, uptr path_size) {
    if (path_size == 0)
      return 0;
    path[0] = from;
    if (targets.getBit(from))
      return 1;
  407628:	b8 01 00 00 00       	mov    $0x1,%eax
  40762d:	e9 47 ff ff ff       	jmpq   407579 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x259>
  407632:	48 89 df             	mov    %rbx,%rdi
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  407635:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  40763a:	89 f1                	mov    %esi,%ecx
  40763c:	48 d3 e2             	shl    %cl,%rdx
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  40763f:	48 85 54 fb 08       	test   %rdx,0x8(%rbx,%rdi,8)
  407644:	0f 84 23 fe ff ff    	je     40746d <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x14d>
  // or 0 on failure.
  uptr findPathToLock(DeadlockDetectorTLS<BV> *dtls, uptr cur_node, uptr *path,
                      uptr path_size) {
    tmp_bv_.copyFrom(dtls->getLocks(current_epoch_));
    uptr idx = nodeToIndex(cur_node);
    CHECK(!tmp_bv_.getBit(idx));
  40764a:	48 8d 15 3f e3 00 00 	lea    0xe33f(%rip),%rdx        # 415990 <.LC19>
  407651:	48 8d 3d b0 e0 00 00 	lea    0xe0b0(%rip),%rdi        # 415708 <.LC4>
  407658:	45 31 c0             	xor    %r8d,%r8d
  40765b:	31 c9                	xor    %ecx,%ecx
  40765d:	be 40 01 00 00       	mov    $0x140,%esi
  407662:	e8 89 dd ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  CHECK_GT(len, 0U);  // Hm.. cycle of 10 locks? I'd like to see that.
  407667:	48 8d 15 04 10 01 00 	lea    0x11004(%rip),%rdx        # 418672 <.LC20>
  40766e:	48 8d 3d 9b e2 00 00 	lea    0xe29b(%rip),%rdi        # 415910 <.LC15>
  407675:	45 31 c0             	xor    %r8d,%r8d
  407678:	31 c9                	xor    %ecx,%ecx
  40767a:	be 7c 00 00 00       	mov    $0x7c,%esi
  40767f:	e8 6c dd ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  407684:	48 89 f7             	mov    %rsi,%rdi
  407687:	e8 18 ae ff ff       	callq  4024a4 <_ZNK11__sanitizer14BasicBitVectorImE4maskEm.isra.19.part.20>
  40768c:	4c 89 ff             	mov    %r15,%rdi
  40768f:	e8 10 ae ff ff       	callq  4024a4 <_ZNK11__sanitizer14BasicBitVectorImE4maskEm.isra.19.part.20>
        return all_locks_with_contexts_[i].stk;
    return 0;
  }

  const BV &getLocks(uptr current_epoch) const {
    CHECK_EQ(epoch_, current_epoch);
  407694:	48 8d 15 75 e1 00 00 	lea    0xe175(%rip),%rdx        # 415810 <.LC9>
  40769b:	48 8d 3d 66 e0 00 00 	lea    0xe066(%rip),%rdi        # 415708 <.LC4>
  4076a2:	be 6e 00 00 00       	mov    $0x6e,%esi
  4076a7:	e8 44 dd ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    tmp_bv_.copyFrom(dtls->getLocks(current_epoch_));
    uptr idx = nodeToIndex(cur_node);
    CHECK(!tmp_bv_.getBit(idx));
    uptr res = g_.findShortestPath(idx, tmp_bv_, path, path_size);
    for (uptr i = 0; i < res; i++)
      path[i] = indexToNode(path[i]);
  4076ac:	48 8b 4c 24 70       	mov    0x70(%rsp),%rcx
  4076b1:	4c 8b 7c 24 30       	mov    0x30(%rsp),%r15
        if (g_.hasEdge(from, to))
          Printf("  %zx => %zx\n", from, to);
  }

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }
  4076b6:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx

  // Finds a path between the lock 'cur_node' (currently not held in dtls)
  // and some currently held lock, returns the length of the path
  // or 0 on failure.
  uptr findPathToLock(DeadlockDetectorTLS<BV> *dtls, uptr cur_node, uptr *path,
                      uptr path_size) {
  4076bd:	4d 8b 5f 10          	mov    0x10(%r15),%r11
        if (g_.hasEdge(from, to))
          Printf("  %zx => %zx\n", from, to);
  }

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }
  4076c1:	0f 87 d8 01 00 00    	ja     40789f <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x57f>
  4076c7:	48 8d 5c 24 70       	lea    0x70(%rsp),%rbx
                      uptr path_size) {
    tmp_bv_.copyFrom(dtls->getLocks(current_epoch_));
    uptr idx = nodeToIndex(cur_node);
    CHECK(!tmp_bv_.getBit(idx));
    uptr res = g_.findShortestPath(idx, tmp_bv_, path, path_size);
    for (uptr i = 0; i < res; i++)
  4076cc:	31 d2                	xor    %edx,%edx
  4076ce:	48 8d 43 08          	lea    0x8(%rbx),%rax
      path[i] = indexToNode(path[i]);
  4076d2:	48 89 de             	mov    %rbx,%rsi
  4076d5:	eb 21                	jmp    4076f8 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x3d8>
  4076d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4076de:	00 00 
  4076e0:	48 89 c6             	mov    %rax,%rsi
  4076e3:	48 83 c0 08          	add    $0x8,%rax
  4076e7:	48 8b 48 f8          	mov    -0x8(%rax),%rcx
        if (g_.hasEdge(from, to))
          Printf("  %zx => %zx\n", from, to);
  }

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }
  4076eb:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx
  4076f2:	0f 87 a7 01 00 00    	ja     40789f <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x57f>
                      uptr path_size) {
    tmp_bv_.copyFrom(dtls->getLocks(current_epoch_));
    uptr idx = nodeToIndex(cur_node);
    CHECK(!tmp_bv_.getBit(idx));
    uptr res = g_.findShortestPath(idx, tmp_bv_, path, path_size);
    for (uptr i = 0; i < res; i++)
  4076f8:	48 83 c2 01          	add    $0x1,%rdx
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  }

  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  4076fc:	4c 01 d9             	add    %r11,%rcx
                      uptr path_size) {
    tmp_bv_.copyFrom(dtls->getLocks(current_epoch_));
    uptr idx = nodeToIndex(cur_node);
    CHECK(!tmp_bv_.getBit(idx));
    uptr res = g_.findShortestPath(idx, tmp_bv_, path, path_size);
    for (uptr i = 0; i < res; i++)
  4076ff:	4c 39 e2             	cmp    %r12,%rdx
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  }

  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  407702:	48 89 0e             	mov    %rcx,(%rsi)
                      uptr path_size) {
    tmp_bv_.copyFrom(dtls->getLocks(current_epoch_));
    uptr idx = nodeToIndex(cur_node);
    CHECK(!tmp_bv_.getBit(idx));
    uptr res = g_.findShortestPath(idx, tmp_bv_, path, path_size);
    for (uptr i = 0; i < res; i++)
  407705:	75 d9                	jne    4076e0 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x3c0>
      path[i] = indexToNode(path[i]);
    if (res)
      CHECK_EQ(path[0], cur_node);
  407707:	48 8b 4c 24 70       	mov    0x70(%rsp),%rcx
  40770c:	48 39 4c 24 40       	cmp    %rcx,0x40(%rsp)
  407711:	0f 85 cb 01 00 00    	jne    4078e2 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x5c2>
  CHECK_EQ(m->id, path[0]);
  407717:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
  40771c:	48 8b 08             	mov    (%rax),%rcx
  40771f:	48 39 4c 24 40       	cmp    %rcx,0x40(%rsp)
  407724:	0f 85 9b 01 00 00    	jne    4078c5 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x5a5>
  lt->report_pending = true;
  40772a:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
  DDReport *rep = &lt->rep;
  rep->n = len;
  for (uptr i = 0; i < len; i++) {
  40772f:	45 31 ed             	xor    %r13d,%r13d
  407732:	48 8d a8 30 06 00 00 	lea    0x630(%rax),%rbp
  DDLogicalThread *lt = cb->lt;
  uptr path[10];
  uptr len = dd.findPathToLock(&lt->dd, m->id, path, ARRAY_SIZE(path));
  CHECK_GT(len, 0U);  // Hm.. cycle of 10 locks? I'd like to see that.
  CHECK_EQ(m->id, path[0]);
  lt->report_pending = true;
  407739:	c6 80 30 07 00 00 01 	movb   $0x1,0x730(%rax)
  DDReport *rep = &lt->rep;
  rep->n = len;
  407740:	44 89 a0 28 06 00 00 	mov    %r12d,0x628(%rax)
  407747:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40774e:	00 00 
  for (uptr i = 0; i < len; i++) {
    uptr from = path[i];
  407750:	4a 8b 3c eb          	mov    (%rbx,%r13,8),%rdi
    uptr to = path[(i + 1) % len];
  407754:	49 83 c5 01          	add    $0x1,%r13
  407758:	31 d2                	xor    %edx,%edx
  40775a:	4c 89 e8             	mov    %r13,%rax
  40775d:	49 f7 f4             	div    %r12

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  407760:	48 81 ff ff 0f 00 00 	cmp    $0xfff,%rdi
  407767:	4c 8b 4c d4 70       	mov    0x70(%rsp,%rdx,8),%r9
  40776c:	0f 86 8d 01 00 00    	jbe    4078ff <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x5df>
  uptr nodeToIndex(uptr node) const {
    check_node(node);
    return nodeToIndexUnchecked(node);
  }

  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }
  407772:	49 89 f8             	mov    %rdi,%r8
  407775:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8
 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  40777c:	4d 39 d8             	cmp    %r11,%r8
  40777f:	0f 85 ff 00 00 00    	jne    407884 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x564>
  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  }

  uptr nodeToIndexUnchecked(uptr node) const { return node % size(); }
  407785:	81 e7 ff 0f 00 00    	and    $0xfff,%edi

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  40778b:	49 81 f9 ff 0f 00 00 	cmp    $0xfff,%r9
    DDMutex *m0 = (DDMutex*)dd.getData(from);
  407792:	49 8b 84 ff 40 8a 20 	mov    0x208a40(%r15,%rdi,8),%rax
  407799:	00 
  40779a:	0f 86 c3 00 00 00    	jbe    407863 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x543>
  uptr nodeToIndex(uptr node) const {
    check_node(node);
    return nodeToIndexUnchecked(node);
  }

  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }
  4077a0:	4d 89 c8             	mov    %r9,%r8
  4077a3:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8
 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  4077aa:	4d 39 c3             	cmp    %r8,%r11
  4077ad:	0f 85 d1 00 00 00    	jne    407884 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x564>

  bool findEdge(uptr from_node, uptr to_node, u32 *stk_from, u32 *stk_to,
                int *unique_tid) {
    uptr from_idx = nodeToIndex(from_node);
    uptr to_idx = nodeToIndex(to_node);
    for (uptr i = 0; i < n_edges_; i++) {
  4077b3:	4d 8b 87 40 0a 41 00 	mov    0x410a40(%r15),%r8
  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  }

  uptr nodeToIndexUnchecked(uptr node) const { return node % size(); }
  4077ba:	41 81 e1 ff 0f 00 00 	and    $0xfff,%r9d
    DDMutex *m1 = (DDMutex*)dd.getData(to);
  4077c1:	4f 8b 94 cf 40 8a 20 	mov    0x208a40(%r15,%r9,8),%r10
  4077c8:	00 

  bool findEdge(uptr from_node, uptr to_node, u32 *stk_from, u32 *stk_to,
                int *unique_tid) {
    uptr from_idx = nodeToIndex(from_node);
    uptr to_idx = nodeToIndex(to_node);
    for (uptr i = 0; i < n_edges_; i++) {
  4077c9:	4d 85 c0             	test   %r8,%r8
  4077cc:	0f 84 86 00 00 00    	je     407858 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x538>
  4077d2:	49 8d 97 40 0a 21 00 	lea    0x210a40(%r15),%rdx
  4077d9:	31 c9                	xor    %ecx,%ecx
  4077db:	eb 10                	jmp    4077ed <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x4cd>
  4077dd:	0f 1f 00             	nopl   (%rax)
  4077e0:	48 83 c1 01          	add    $0x1,%rcx
  4077e4:	48 83 c2 10          	add    $0x10,%rdx
  4077e8:	4c 39 c1             	cmp    %r8,%rcx
  4077eb:	74 6b                	je     407858 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x538>
      if (edges_[i].from == from_idx && edges_[i].to == to_idx) {
  4077ed:	0f b7 32             	movzwl (%rdx),%esi
  4077f0:	48 39 f7             	cmp    %rsi,%rdi
  4077f3:	75 eb                	jne    4077e0 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x4c0>
  4077f5:	0f b7 72 02          	movzwl 0x2(%rdx),%esi
  4077f9:	49 39 f1             	cmp    %rsi,%r9
  4077fc:	75 e2                	jne    4077e0 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x4c0>
  4077fe:	48 c1 e1 04          	shl    $0x4,%rcx
  407802:	49 8d 34 0f          	lea    (%r15,%rcx,1),%rsi
        *stk_from = edges_[i].stk_from;
  407806:	8b 8e 44 0a 21 00    	mov    0x210a44(%rsi),%ecx
        *stk_to = edges_[i].stk_to;
  40780c:	8b 96 48 0a 21 00    	mov    0x210a48(%rsi),%edx
  407812:	48 63 b6 4c 0a 21 00 	movslq 0x210a4c(%rsi),%rsi
    int unique_tid = 0;
    dd.findEdge(from, to, &stk_from, &stk_to, &unique_tid);
    // Printf("Edge: %zd=>%zd: %u/%u T%d\n", from, to, stk_from, stk_to,
    //    unique_tid);
    rep->loop[i].thr_ctx = unique_tid;
    rep->loop[i].mtx_ctx0 = m0->ctx;
  407819:	48 8b 40 10          	mov    0x10(%rax),%rax
    u32 stk_from = -1U, stk_to = -1U;
    int unique_tid = 0;
    dd.findEdge(from, to, &stk_from, &stk_to, &unique_tid);
    // Printf("Edge: %zd=>%zd: %u/%u T%d\n", from, to, stk_from, stk_to,
    //    unique_tid);
    rep->loop[i].thr_ctx = unique_tid;
  40781d:	48 89 75 00          	mov    %rsi,0x0(%rbp)
  407821:	48 83 c5 20          	add    $0x20,%rbp
    rep->loop[i].mtx_ctx0 = m0->ctx;
  407825:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    rep->loop[i].mtx_ctx1 = m1->ctx;
  407829:	49 8b 42 10          	mov    0x10(%r10),%rax
    rep->loop[i].stk[0] = stk_to;
  40782d:	89 55 f8             	mov    %edx,-0x8(%rbp)
    rep->loop[i].stk[1] = stk_from;
  407830:	89 4d fc             	mov    %ecx,-0x4(%rbp)
    dd.findEdge(from, to, &stk_from, &stk_to, &unique_tid);
    // Printf("Edge: %zd=>%zd: %u/%u T%d\n", from, to, stk_from, stk_to,
    //    unique_tid);
    rep->loop[i].thr_ctx = unique_tid;
    rep->loop[i].mtx_ctx0 = m0->ctx;
    rep->loop[i].mtx_ctx1 = m1->ctx;
  407833:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  CHECK_GT(len, 0U);  // Hm.. cycle of 10 locks? I'd like to see that.
  CHECK_EQ(m->id, path[0]);
  lt->report_pending = true;
  DDReport *rep = &lt->rep;
  rep->n = len;
  for (uptr i = 0; i < len; i++) {
  407837:	4d 39 e5             	cmp    %r12,%r13
  40783a:	0f 85 10 ff ff ff    	jne    407750 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x430>
    rep->loop[i].mtx_ctx0 = m0->ctx;
    rep->loop[i].mtx_ctx1 = m1->ctx;
    rep->loop[i].stk[0] = stk_to;
    rep->loop[i].stk[1] = stk_from;
  }
}
  407840:	48 81 c4 c8 00 00 00 	add    $0xc8,%rsp
  407847:	5b                   	pop    %rbx
  407848:	5d                   	pop    %rbp
  407849:	41 5c                	pop    %r12
  40784b:	41 5d                	pop    %r13
  40784d:	41 5e                	pop    %r14
  40784f:	41 5f                	pop    %r15
  407851:	c3                   	retq   
  407852:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    uptr from = path[i];
    uptr to = path[(i + 1) % len];
    DDMutex *m0 = (DDMutex*)dd.getData(from);
    DDMutex *m1 = (DDMutex*)dd.getData(to);

    u32 stk_from = -1U, stk_to = -1U;
  407858:	ba ff ff ff ff       	mov    $0xffffffff,%edx

  bool findEdge(uptr from_node, uptr to_node, u32 *stk_from, u32 *stk_to,
                int *unique_tid) {
    uptr from_idx = nodeToIndex(from_node);
    uptr to_idx = nodeToIndex(to_node);
    for (uptr i = 0; i < n_edges_; i++) {
  40785d:	31 f6                	xor    %esi,%esi
  40785f:	89 d1                	mov    %edx,%ecx
  407861:	eb b6                	jmp    407819 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x4f9>

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  407863:	48 8d 15 7c 0d 01 00 	lea    0x10d7c(%rip),%rdx        # 4185e6 <.LC3>
  40786a:	48 8d 3d 97 de 00 00 	lea    0xde97(%rip),%rdi        # 415708 <.LC4>
  407871:	4c 89 c9             	mov    %r9,%rcx
  407874:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  40787a:	be 74 01 00 00       	mov    $0x174,%esi
  40787f:	e8 6c db ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  407884:	4c 89 d9             	mov    %r11,%rcx
  407887:	48 8d 15 52 df 00 00 	lea    0xdf52(%rip),%rdx        # 4157e0 <.LC8>
  40788e:	48 8d 3d 73 de 00 00 	lea    0xde73(%rip),%rdi        # 415708 <.LC4>
  407895:	be 75 01 00 00       	mov    $0x175,%esi
  40789a:	e8 51 db ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
        if (g_.hasEdge(from, to))
          Printf("  %zx => %zx\n", from, to);
  }

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }
  40789f:	48 8d 15 2b 0d 01 00 	lea    0x10d2b(%rip),%rdx        # 4185d1 <.LC2>
  4078a6:	48 8d 3d 5b de 00 00 	lea    0xde5b(%rip),%rdi        # 415708 <.LC4>
  4078ad:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  4078b3:	be 71 01 00 00       	mov    $0x171,%esi
  4078b8:	e8 33 db ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
          // Printf("+i0: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
          //   it2_.hasNext(), kSize);
          break;
        }
      }
      if (!it2_.hasNext()) {
  4078bd:	4c 89 e8             	mov    %r13,%rax
  4078c0:	e9 06 fd ff ff       	jmpq   4075cb <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE+0x2ab>
void DD::ReportDeadlock(DDCallback *cb, DDMutex *m) {
  DDLogicalThread *lt = cb->lt;
  uptr path[10];
  uptr len = dd.findPathToLock(&lt->dd, m->id, path, ARRAY_SIZE(path));
  CHECK_GT(len, 0U);  // Hm.. cycle of 10 locks? I'd like to see that.
  CHECK_EQ(m->id, path[0]);
  4078c5:	4c 8b 44 24 40       	mov    0x40(%rsp),%r8
  4078ca:	48 8d 15 88 0d 01 00 	lea    0x10d88(%rip),%rdx        # 418659 <.LC18>
  4078d1:	48 8d 3d 38 e0 00 00 	lea    0xe038(%rip),%rdi        # 415910 <.LC15>
  4078d8:	be 7d 00 00 00       	mov    $0x7d,%esi
  4078dd:	e8 0e db ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    CHECK(!tmp_bv_.getBit(idx));
    uptr res = g_.findShortestPath(idx, tmp_bv_, path, path_size);
    for (uptr i = 0; i < res; i++)
      path[i] = indexToNode(path[i]);
    if (res)
      CHECK_EQ(path[0], cur_node);
  4078e2:	4c 8b 44 24 40       	mov    0x40(%rsp),%r8
  4078e7:	48 8d 15 4f 0d 01 00 	lea    0x10d4f(%rip),%rdx        # 41863d <.LC17>
  4078ee:	48 8d 3d 13 de 00 00 	lea    0xde13(%rip),%rdi        # 415708 <.LC4>
  4078f5:	be 45 01 00 00       	mov    $0x145,%esi
  4078fa:	e8 f1 da ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  4078ff:	48 89 f9             	mov    %rdi,%rcx
  407902:	48 8d 15 dd 0c 01 00 	lea    0x10cdd(%rip),%rdx        # 4185e6 <.LC3>
  407909:	48 8d 3d f8 dd 00 00 	lea    0xddf8(%rip),%rdi        # 415708 <.LC4>
  407910:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  407916:	be 74 01 00 00       	mov    $0x174,%esi
  40791b:	e8 d0 da ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  407920:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
  407925:	48 8d 15 ba 0c 01 00 	lea    0x10cba(%rip),%rdx        # 4185e6 <.LC3>
  40792c:	48 8d 3d d5 dd 00 00 	lea    0xddd5(%rip),%rdi        # 415708 <.LC4>
  407933:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  407939:	be 74 01 00 00       	mov    $0x174,%esi
  40793e:	e8 ad da ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  407943:	90                   	nop
  407944:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40794b:	00 00 00 00 00 

0000000000407950 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb>:
    m->id = dd.newNode(reinterpret_cast<uptr>(m));
  dd.ensureCurrentEpoch(&lt->dd);
}

void DD::MutexBeforeLock(DDCallback *cb,
    DDMutex *m, bool wlock) {
  407950:	41 57                	push   %r15
  407952:	41 56                	push   %r14
  407954:	41 55                	push   %r13
  407956:	41 54                	push   %r12
  407958:	49 89 f4             	mov    %rsi,%r12
  40795b:	55                   	push   %rbp
  40795c:	53                   	push   %rbx
  40795d:	48 83 ec 08          	sub    $0x8,%rsp
  DDLogicalThread *lt = cb->lt;
  407961:	48 8b 5e 10          	mov    0x10(%rsi),%rbx
    }
  }

  bool empty() const {
    for (uptr i = 0; i < kLevel1Size; i++)
      if (!l1_[i].empty())
  407965:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
  40796a:	75 14                	jne    407980 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x30>
  if (dd.onLockBefore(&lt->dd, m->id)) {
    // Actually add this edge now so that we have all the stack traces.
    dd.addEdges(&lt->dd, m->id, cb->Unwind(), cb->UniqueTid());
    ReportDeadlock(cb, m);
  }
}
  40796c:	48 83 c4 08          	add    $0x8,%rsp
  407970:	5b                   	pop    %rbx
  407971:	5d                   	pop    %rbp
  407972:	41 5c                	pop    %r12
  407974:	41 5d                	pop    %r13
  407976:	41 5e                	pop    %r14
  407978:	41 5f                	pop    %r15
  40797a:	c3                   	retq   
  40797b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  407980:	49 89 d5             	mov    %rdx,%r13

void DD::MutexBeforeLock(DDCallback *cb,
    DDMutex *m, bool wlock) {
  DDLogicalThread *lt = cb->lt;
  if (lt->dd.empty()) return;  // This will be the first lock held by lt.
  if (dd.hasAllEdges(&lt->dd, m->id)) return;  // We already have all edges.
  407983:	48 8b 12             	mov    (%rdx),%rdx
  407986:	48 89 fd             	mov    %rdi,%rbp
    dtls->addLock(cur_idx, current_epoch_, stk);
  }

  // Experimental *racy* fast path function.
  // Returns true if all edges from the currently held locks to cur_node exist.
  bool hasAllEdges(DeadlockDetectorTLS<BV> *dtls, uptr cur_node) {
  407989:	48 8b 83 10 02 00 00 	mov    0x210(%rbx),%rax
    uptr local_epoch = dtls->getEpoch();
    // Read from current_epoch_ is racy.
    if (cur_node && local_epoch == current_epoch_ &&
  407990:	48 85 d2             	test   %rdx,%rdx
  407993:	0f 85 3a 01 00 00    	jne    407ad3 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x183>
  407999:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  SpinMutexLock lk(&mtx);
  4079a0:	48 8d 7d 08          	lea    0x8(%rbp),%rdi
  4079a4:	b8 01 00 00 00       	mov    $0x1,%eax
  4079a9:	86 07                	xchg   %al,(%rdi)
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  4079ab:	84 c0                	test   %al,%al
  4079ad:	74 05                	je     4079b4 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x64>
      return;
    LockSlow();
  4079af:	e8 9c cb ff ff       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  MutexEnsureID(lt, m);
  4079b4:	4c 89 ea             	mov    %r13,%rdx
  4079b7:	48 89 de             	mov    %rbx,%rsi
  4079ba:	48 89 ef             	mov    %rbp,%rdi
  4079bd:	e8 4e ee ff ff       	callq  406810 <_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE>
  if (dd.isHeld(&lt->dd, m->id))
  4079c2:	4d 8b 7d 00          	mov    0x0(%r13),%r15

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  4079c6:	49 81 ff ff 0f 00 00 	cmp    $0xfff,%r15
  4079cd:	0f 86 3b 04 00 00    	jbe    407e0e <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x4be>
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  4079d3:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  uptr nodeToIndex(uptr node) const {
    check_node(node);
    return nodeToIndexUnchecked(node);
  }

  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }
  4079d7:	4d 89 f8             	mov    %r15,%r8
  4079da:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8
 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  4079e1:	4c 39 c2             	cmp    %r8,%rdx
  4079e4:	0f 85 09 04 00 00    	jne    407df3 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x4a3>
        return all_locks_with_contexts_[i].stk;
    return 0;
  }

  const BV &getLocks(uptr current_epoch) const {
    CHECK_EQ(epoch_, current_epoch);
  4079ea:	48 8b 8b 10 02 00 00 	mov    0x210(%rbx),%rcx
  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  }

  uptr nodeToIndexUnchecked(uptr node) const { return node % size(); }
  4079f1:	4c 89 f8             	mov    %r15,%rax
  4079f4:	25 ff 0f 00 00       	and    $0xfff,%eax
        return all_locks_with_contexts_[i].stk;
    return 0;
  }

  const BV &getLocks(uptr current_epoch) const {
    CHECK_EQ(epoch_, current_epoch);
  4079f9:	48 39 ca             	cmp    %rcx,%rdx
  4079fc:	0f 85 b9 03 00 00    	jne    407dbb <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x46b>
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  407a02:	49 89 c3             	mov    %rax,%r11
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407a05:	ba 01 00 00 00       	mov    $0x1,%edx
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  407a0a:	41 83 e7 3f          	and    $0x3f,%r15d
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  407a0e:	49 c1 eb 06          	shr    $0x6,%r11
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407a12:	49 89 d6             	mov    %rdx,%r14
  407a15:	44 89 d9             	mov    %r11d,%ecx
  407a18:	49 d3 e6             	shl    %cl,%r14
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  407a1b:	4c 85 73 08          	test   %r14,0x8(%rbx)
  407a1f:	74 11                	je     407a32 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0xe2>
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407a21:	44 89 f9             	mov    %r15d,%ecx
  407a24:	48 d3 e2             	shl    %cl,%rdx
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  407a27:	4a 85 54 db 10       	test   %rdx,0x10(%rbx,%r11,8)
  407a2c:	0f 85 2e 02 00 00    	jne    407c60 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x310>
  // Returns true if there is a path from the node 'from'
  // to any of the nodes in 'targets'.
  bool isReachable(uptr from, const BV &targets) {
    BV &to_visit = t1,
       &visited = t2;
    to_visit.copyFrom(v[from]);
  407a32:	48 89 c2             	mov    %rax,%rdx
  407a35:	48 8d b5 30 06 00 00 	lea    0x630(%rbp),%rsi
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  407a3c:	48 c7 85 30 86 20 00 	movq   $0x0,0x208630(%rbp)
  407a43:	00 00 00 00 
  407a47:	48 c1 e2 09          	shl    $0x9,%rdx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407a4b:	41 b9 01 00 00 00    	mov    $0x1,%r9d
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
          l2_[i0][i1].clear();
  407a51:	4c 8d 95 30 86 20 00 	lea    0x208630(%rbp),%r10
  407a58:	4c 8d 04 c2          	lea    (%rdx,%rax,8),%r8
  407a5c:	49 01 f0             	add    %rsi,%r8

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
  407a5f:	49 8b 10             	mov    (%r8),%rdx
      while (!t.empty()) {
  407a62:	48 85 d2             	test   %rdx,%rdx
  407a65:	75 27                	jne    407a8e <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x13e>
  407a67:	e9 2c 01 00 00       	jmpq   407b98 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x248>
  407a6c:	0f 1f 40 00          	nopl   0x0(%rax)
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  407a70:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
  407a77:	00 
  407a78:	31 d2                	xor    %edx,%edx
  }

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ |= v.bits_;
  407a7a:	49 0b 54 f8 08       	or     0x8(%r8,%rdi,8),%rdx
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  407a7f:	48 85 c0             	test   %rax,%rax
  }

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ |= v.bits_;
  407a82:	48 89 11             	mov    %rdx,(%rcx)
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  407a85:	0f 84 0d 01 00 00    	je     407b98 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x248>

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  407a8b:	48 89 c2             	mov    %rax,%rdx
  407a8e:	f3 48 0f bc ca       	tzcnt  %rdx,%rcx
  407a93:	48 63 f9             	movslq %ecx,%rdi
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  407a96:	48 83 ff 3f          	cmp    $0x3f,%rdi
  407a9a:	0f 87 16 03 00 00    	ja     407db6 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x466>
    return (basic_int_t)1UL << idx;
  407aa0:	4c 89 c8             	mov    %r9,%rax
  407aa3:	48 d3 e0             	shl    %cl,%rax
  407aa6:	48 89 c1             	mov    %rax,%rcx
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  407aa9:	48 f7 d0             	not    %rax
  407aac:	48 21 d0             	and    %rdx,%rax
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
  407aaf:	48 8b 95 30 86 20 00 	mov    0x208630(%rbp),%rdx
    bits_ |= mask(idx);
  407ab6:	48 09 d1             	or     %rdx,%rcx
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
  407ab9:	48 39 ca             	cmp    %rcx,%rdx
          l2_[i0][i1].clear();
  407abc:	49 8d 14 fa          	lea    (%r10,%rdi,8),%rdx
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  407ac0:	48 89 8d 30 86 20 00 	mov    %rcx,0x208630(%rbp)
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
          l2_[i0][i1].clear();
  407ac7:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
  407acb:	75 a3                	jne    407a70 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x120>
  407acd:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  407ad1:	eb a7                	jmp    407a7a <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x12a>
  // Experimental *racy* fast path function.
  // Returns true if all edges from the currently held locks to cur_node exist.
  bool hasAllEdges(DeadlockDetectorTLS<BV> *dtls, uptr cur_node) {
    uptr local_epoch = dtls->getEpoch();
    // Read from current_epoch_ is racy.
    if (cur_node && local_epoch == current_epoch_ &&
  407ad3:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  407ad7:	0f 85 c3 fe ff ff    	jne    4079a0 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x50>
  uptr nodeToIndex(uptr node) const {
    check_node(node);
    return nodeToIndexUnchecked(node);
  }

  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }
  407add:	48 89 d1             	mov    %rdx,%rcx
  407ae0:	48 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%rcx
  // Experimental *racy* fast path function.
  // Returns true if all edges from the currently held locks to cur_node exist.
  bool hasAllEdges(DeadlockDetectorTLS<BV> *dtls, uptr cur_node) {
    uptr local_epoch = dtls->getEpoch();
    // Read from current_epoch_ is racy.
    if (cur_node && local_epoch == current_epoch_ &&
  407ae7:	48 39 c8             	cmp    %rcx,%rax
  407aea:	0f 85 b0 fe ff ff    	jne    4079a0 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x50>
    dtls->addLock(cur_idx, current_epoch_, stk);
  }

  // Experimental *racy* fast path function.
  // Returns true if all edges from the currently held locks to cur_node exist.
  bool hasAllEdges(DeadlockDetectorTLS<BV> *dtls, uptr cur_node) {
  407af0:	4c 8b 93 20 06 00 00 	mov    0x620(%rbx),%r10
  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  }

  uptr nodeToIndexUnchecked(uptr node) const { return node % size(); }
  407af7:	49 89 d1             	mov    %rdx,%r9
  407afa:	41 81 e1 ff 0f 00 00 	and    $0xfff,%r9d
    uptr local_epoch = dtls->getEpoch();
    // Read from current_epoch_ is racy.
    if (cur_node && local_epoch == current_epoch_ &&
        local_epoch == nodeToEpoch(cur_node)) {
      uptr cur_idx = nodeToIndexUnchecked(cur_node);
      for (uptr i = 0, n = dtls->getNumLocks(); i < n; i++) {
  407b01:	4d 85 d2             	test   %r10,%r10
  407b04:	0f 84 62 fe ff ff    	je     40796c <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x1c>
    CHECK_EQ(epoch_, current_epoch);
    return bv_;
  }

  uptr getNumLocks() const { return n_all_locks_; }
  uptr getLock(uptr idx) const { return all_locks_with_contexts_[idx].lock; }
  407b0a:	8b 83 20 04 00 00    	mov    0x420(%rbx),%eax
  // Returns true if an edge from=>to exist.
  // This function does not use any global state except for 'this' itself,
  // and thus can be called from different threads w/o locking.
  // This would be racy.
  // FIXME: investigate how much we can prove about this race being "benign".
  bool hasEdge(uptr from, uptr to) { return v[from].getBit(to); }
  407b10:	48 8d b5 30 06 00 00 	lea    0x630(%rbp),%rsi
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  407b17:	49 c1 e9 06          	shr    $0x6,%r9
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407b1b:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  407b21:	4c 89 c7             	mov    %r8,%rdi
  407b24:	48 89 c1             	mov    %rax,%rcx
  407b27:	48 c1 e1 09          	shl    $0x9,%rcx
  407b2b:	48 8d 04 c1          	lea    (%rcx,%rax,8),%rax
  407b2f:	44 89 c9             	mov    %r9d,%ecx
  407b32:	48 d3 e7             	shl    %cl,%rdi
  407b35:	48 01 f0             	add    %rsi,%rax
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  407b38:	48 85 38             	test   %rdi,(%rax)
  407b3b:	0f 84 5f fe ff ff    	je     4079a0 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x50>
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  407b41:	83 e2 3f             	and    $0x3f,%edx
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  407b44:	49 c1 e1 03          	shl    $0x3,%r9
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  407b48:	48 89 d1             	mov    %rdx,%rcx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407b4b:	49 d3 e0             	shl    %cl,%r8
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  407b4e:	4e 85 44 08 08       	test   %r8,0x8(%rax,%r9,1)
  407b53:	0f 84 47 fe ff ff    	je     4079a0 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x50>
  407b59:	31 d2                	xor    %edx,%edx
  407b5b:	eb 0b                	jmp    407b68 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x218>
  407b5d:	4e 85 44 08 08       	test   %r8,0x8(%rax,%r9,1)
  407b62:	0f 84 38 fe ff ff    	je     4079a0 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x50>
    uptr local_epoch = dtls->getEpoch();
    // Read from current_epoch_ is racy.
    if (cur_node && local_epoch == current_epoch_ &&
        local_epoch == nodeToEpoch(cur_node)) {
      uptr cur_idx = nodeToIndexUnchecked(cur_node);
      for (uptr i = 0, n = dtls->getNumLocks(); i < n; i++) {
  407b68:	48 83 c2 01          	add    $0x1,%rdx
  407b6c:	4c 39 d2             	cmp    %r10,%rdx
  407b6f:	0f 84 f7 fd ff ff    	je     40796c <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x1c>
    CHECK_EQ(epoch_, current_epoch);
    return bv_;
  }

  uptr getNumLocks() const { return n_all_locks_; }
  uptr getLock(uptr idx) const { return all_locks_with_contexts_[idx].lock; }
  407b75:	8b 84 d3 20 04 00 00 	mov    0x420(%rbx,%rdx,8),%eax
  407b7c:	48 89 c1             	mov    %rax,%rcx
  407b7f:	48 c1 e1 09          	shl    $0x9,%rcx
  407b83:	48 8d 04 c1          	lea    (%rcx,%rax,8),%rax
  407b87:	48 01 f0             	add    %rsi,%rax
  407b8a:	48 85 38             	test   %rdi,(%rax)
  407b8d:	0f 84 0d fe ff ff    	je     4079a0 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x50>
  407b93:	eb c8                	jmp    407b5d <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x20d>
  407b95:	0f 1f 00             	nopl   (%rax)
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    if (!l1_[i0].getBit(i1)) {
      l1_[i0].setBit(i1);
      l2_[i0][i1].clear();
  407b98:	4c 8d 85 38 88 20 00 	lea    0x208838(%rbp),%r8
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407b9f:	b8 01 00 00 00       	mov    $0x1,%eax
  407ba4:	44 89 f9             	mov    %r15d,%ecx
  407ba7:	48 d3 e0             	shl    %cl,%rax

  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
  407baa:	4c 8d 8d 30 86 20 00 	lea    0x208630(%rbp),%r9
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  407bb1:	4c 89 b5 38 88 20 00 	mov    %r14,0x208838(%rbp)
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407bb8:	ba 01 00 00 00       	mov    $0x1,%edx
  407bbd:	4b 89 44 d8 08       	mov    %rax,0x8(%r8,%r11,8)

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  407bc2:	48 8b 85 30 86 20 00 	mov    0x208630(%rbp),%rax
    }
  }

  bool empty() const {
    for (uptr i = 0; i < kLevel1Size; i++)
      if (!l1_[i].empty())
  407bc9:	48 85 c0             	test   %rax,%rax
  407bcc:	0f 85 97 00 00 00    	jne    407c69 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x319>
  }

  // Do "this &= v" and return whether any bits have been removed.
  bool setIntersection(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ &= v.bits_;
  407bd2:	48 8b 95 38 88 20 00 	mov    0x208838(%rbp),%rdx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407bd9:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  }

  // Do "this &= v" and return whether any bits have been removed.
  bool setIntersection(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ &= v.bits_;
  407bdf:	48 89 d0             	mov    %rdx,%rax
  407be2:	48 23 43 08          	and    0x8(%rbx),%rax
  // Returns true if 'this' intersects with 'v'.
  bool intersectsWith(const TwoLevelBitVector &v) const {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = l1_[i0];
      t.setIntersection(v.l1_[i0]);
      while (!t.empty()) {
  407be6:	48 85 c0             	test   %rax,%rax
  407be9:	74 75                	je     407c60 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x310>
  407beb:	f3 48 0f bc c8       	tzcnt  %rax,%rcx
  407bf0:	48 63 f9             	movslq %ecx,%rdi
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  407bf3:	48 83 ff 3f          	cmp    $0x3f,%rdi
  407bf7:	0f 87 b9 01 00 00    	ja     407db6 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x466>
    return (basic_int_t)1UL << idx;
  407bfd:	4c 89 ce             	mov    %r9,%rsi
  407c00:	48 d3 e6             	shl    %cl,%rsi
  407c03:	48 89 f1             	mov    %rsi,%rcx
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  407c06:	48 f7 d6             	not    %rsi
  407c09:	48 21 f0             	and    %rsi,%rax
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = l1_[i0];
      t.setIntersection(v.l1_[i0]);
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (!v.l1_[i0].getBit(i1)) continue;
  407c0c:	48 85 d1             	test   %rdx,%rcx
  407c0f:	74 d5                	je     407be6 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x296>

  void copyFrom(const BasicBitVector &v) { bits_ = v.bits_; }

  // Returns true if 'this' intersects with 'v'.
  bool intersectsWith(const BasicBitVector &v) const {
    return (bits_ & v.bits_) != 0;
  407c11:	49 8b 4c f8 08       	mov    0x8(%r8,%rdi,8),%rcx
      BV t = l1_[i0];
      t.setIntersection(v.l1_[i0]);
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (!v.l1_[i0].getBit(i1)) continue;
        if (l2_[i0][i1].intersectsWith(v.l2_[i0][i1]))
  407c16:	48 85 4c fb 10       	test   %rcx,0x10(%rbx,%rdi,8)
  407c1b:	4c 8d 73 08          	lea    0x8(%rbx),%r14
  407c1f:	74 c5                	je     407be6 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x296>
    return;  // FIXME: allow this only for recursive locks.
  if (dd.onLockBefore(&lt->dd, m->id)) {
    // Actually add this edge now so that we have all the stack traces.
    dd.addEdges(&lt->dd, m->id, cb->Unwind(), cb->UniqueTid());
  407c21:	49 8b 04 24          	mov    (%r12),%rax
  407c25:	4c 89 e7             	mov    %r12,%rdi
  407c28:	ff 50 08             	callq  *0x8(%rax)
  407c2b:	89 c3                	mov    %eax,%ebx
  407c2d:	49 8b 04 24          	mov    (%r12),%rax
  407c31:	4c 89 e7             	mov    %r12,%rdi
  407c34:	ff 10                	callq  *(%rax)
  407c36:	49 8b 55 00          	mov    0x0(%r13),%rdx

void DD::MutexBeforeLock(DDCallback *cb,
    DDMutex *m, bool wlock) {
  DDLogicalThread *lt = cb->lt;
  if (lt->dd.empty()) return;  // This will be the first lock held by lt.
  if (dd.hasAllEdges(&lt->dd, m->id)) return;  // We already have all edges.
  407c3a:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
  MutexEnsureID(lt, m);
  if (dd.isHeld(&lt->dd, m->id))
    return;  // FIXME: allow this only for recursive locks.
  if (dd.onLockBefore(&lt->dd, m->id)) {
    // Actually add this edge now so that we have all the stack traces.
    dd.addEdges(&lt->dd, m->id, cb->Unwind(), cb->UniqueTid());
  407c3e:	4c 89 f6             	mov    %r14,%rsi
  407c41:	41 89 d8             	mov    %ebx,%r8d
  407c44:	89 c1                	mov    %eax,%ecx
  407c46:	e8 85 02 00 00       	callq  407ed0 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji>
    ReportDeadlock(cb, m);
  407c4b:	4c 89 ea             	mov    %r13,%rdx
  407c4e:	4c 89 e6             	mov    %r12,%rsi
  407c51:	48 89 ef             	mov    %rbp,%rdi
  407c54:	e8 c7 f6 ff ff       	callq  407320 <_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE>
  407c59:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  407c60:	c6 45 08 00          	movb   $0x0,0x8(%rbp)
      __asm__ __volatile__("" ::: "memory");
  407c64:	e9 03 fd ff ff       	jmpq   40796c <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x1c>
  407c69:	f3 48 0f bc c8       	tzcnt  %rax,%rcx
  407c6e:	4c 63 d1             	movslq %ecx,%r10
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  407c71:	49 83 fa 3f          	cmp    $0x3f,%r10
  407c75:	0f 87 38 01 00 00    	ja     407db3 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x463>
    return (basic_int_t)1UL << idx;
  407c7b:	49 89 d6             	mov    %rdx,%r14

  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
  407c7e:	4f 8d 3c d1          	lea    (%r9,%r10,8),%r15
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407c82:	49 d3 e6             	shl    %cl,%r14
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  407c85:	4c 89 f1             	mov    %r14,%rcx
  407c88:	48 f7 d1             	not    %rcx
  407c8b:	48 21 c1             	and    %rax,%rcx
  407c8e:	48 89 8d 30 86 20 00 	mov    %rcx,0x208630(%rbp)

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  407c95:	4d 8b 5f 08          	mov    0x8(%r15),%r11
  }

  bool getBit(uptr idx) const { return (bits_ & mask(idx)) != 0; }

  uptr getAndClearFirstOne() {
    CHECK(!empty());
  407c99:	4d 85 db             	test   %r11,%r11
  407c9c:	0f 84 34 01 00 00    	je     407dd6 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x486>
  407ca2:	f3 49 0f bc cb       	tzcnt  %r11,%rcx
  407ca7:	48 63 f9             	movslq %ecx,%rdi
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  407caa:	48 83 ff 3f          	cmp    $0x3f,%rdi
  407cae:	0f 87 02 01 00 00    	ja     407db6 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x466>
    return (basic_int_t)1UL << idx;
  407cb4:	48 89 d0             	mov    %rdx,%rax
  407cb7:	48 d3 e0             	shl    %cl,%rax
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  407cba:	48 f7 d0             	not    %rax
  407cbd:	4c 21 d8             	and    %r11,%rax
  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
      if (!l2_[i0][i1].empty())
  407cc0:	48 85 c0             	test   %rax,%rax
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  407cc3:	49 89 47 08          	mov    %rax,0x8(%r15)
  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
      if (!l2_[i0][i1].empty())
  407cc7:	74 07                	je     407cd0 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x380>
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  407cc9:	4c 09 b5 30 86 20 00 	or     %r14,0x208630(%rbp)
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
      if (!l2_[i0][i1].empty())
        l1_[i0].setBit(i1);
      uptr res = i0 * BV::kSize * BV::kSize + i1 * BV::kSize + i2;
  407cd0:	49 c1 e2 06          	shl    $0x6,%r10
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
    return bits_ != old;
  }

  bool getBit(uptr idx) const { return (bits_ & mask(idx)) != 0; }
  407cd4:	4c 8b b5 38 88 20 00 	mov    0x208838(%rbp),%r14
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407cdb:	49 89 d3             	mov    %rdx,%r11
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
      if (!l2_[i0][i1].empty())
        l1_[i0].setBit(i1);
      uptr res = i0 * BV::kSize * BV::kSize + i1 * BV::kSize + i2;
  407cde:	4c 01 d7             	add    %r10,%rdi
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  407ce1:	48 89 f9             	mov    %rdi,%rcx
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  407ce4:	48 89 f8             	mov    %rdi,%rax
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  407ce7:	48 c1 e9 06          	shr    $0x6,%rcx
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  407ceb:	83 e0 3f             	and    $0x3f,%eax
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407cee:	49 d3 e3             	shl    %cl,%r11
  bool setBit(uptr idx) {
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    if (!l1_[i0].getBit(i1)) {
  407cf1:	4d 85 f3             	test   %r14,%r11
  407cf4:	0f 84 a1 00 00 00    	je     407d9b <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x44b>
      l1_[i0].setBit(i1);
      l2_[i0][i1].clear();
    }
    bool res = l2_[i0][i1].setBit(i2);
  407cfa:	4d 8d 1c c8          	lea    (%r8,%rcx,8),%r11
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407cfe:	49 89 d6             	mov    %rdx,%r14
  407d01:	89 c1                	mov    %eax,%ecx
  407d03:	49 d3 e6             	shl    %cl,%r14
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
  407d06:	4d 8b 53 08          	mov    0x8(%r11),%r10
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407d0a:	4c 89 f0             	mov    %r14,%rax
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  407d0d:	4c 09 d0             	or     %r10,%rax
    to_visit.copyFrom(v[from]);
    visited.clear();
    visited.setBit(from);
    while (!to_visit.empty()) {
      uptr idx = to_visit.getAndClearFirstOne();
      if (visited.setBit(idx))
  407d10:	49 39 c2             	cmp    %rax,%r10
  407d13:	49 89 43 08          	mov    %rax,0x8(%r11)
  407d17:	0f 84 a5 fe ff ff    	je     407bc2 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x272>
        to_visit.setUnion(v[idx]);
  407d1d:	48 69 ff 08 02 00 00 	imul   $0x208,%rdi,%rdi
  407d24:	4c 8d 14 3e          	lea    (%rsi,%rdi,1),%r10

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
  407d28:	49 8b 02             	mov    (%r10),%rax
      while (!t.empty()) {
  407d2b:	48 85 c0             	test   %rax,%rax
  407d2e:	75 27                	jne    407d57 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x407>
  407d30:	e9 8d fe ff ff       	jmpq   407bc2 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x272>
  407d35:	0f 1f 00             	nopl   (%rax)
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  407d38:	49 c7 43 08 00 00 00 	movq   $0x0,0x8(%r11)
  407d3f:	00 
  407d40:	45 31 db             	xor    %r11d,%r11d
  }

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ |= v.bits_;
  407d43:	4d 0b 5c fa 08       	or     0x8(%r10,%rdi,8),%r11
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  407d48:	48 85 c9             	test   %rcx,%rcx
  }

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ |= v.bits_;
  407d4b:	4c 89 18             	mov    %r11,(%rax)
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  407d4e:	0f 84 6e fe ff ff    	je     407bc2 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x272>

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  407d54:	48 89 c8             	mov    %rcx,%rax
  407d57:	f3 48 0f bc c8       	tzcnt  %rax,%rcx
  407d5c:	48 63 f9             	movslq %ecx,%rdi
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  407d5f:	48 83 ff 3f          	cmp    $0x3f,%rdi
  407d63:	77 51                	ja     407db6 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x466>
    return (basic_int_t)1UL << idx;
  407d65:	49 89 d6             	mov    %rdx,%r14
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
  407d68:	4c 8b 9d 30 86 20 00 	mov    0x208630(%rbp),%r11
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407d6f:	49 d3 e6             	shl    %cl,%r14
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  407d72:	4c 89 f1             	mov    %r14,%rcx
  407d75:	48 f7 d1             	not    %rcx
  407d78:	48 21 c1             	and    %rax,%rcx
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  407d7b:	4c 89 f0             	mov    %r14,%rax
  407d7e:	4c 09 d8             	or     %r11,%rax
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
  407d81:	49 39 c3             	cmp    %rax,%r11
          l2_[i0][i1].clear();
  407d84:	4d 8d 1c f9          	lea    (%r9,%rdi,8),%r11
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  407d88:	48 89 85 30 86 20 00 	mov    %rax,0x208630(%rbp)
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
          l2_[i0][i1].clear();
  407d8f:	49 8d 43 08          	lea    0x8(%r11),%rax
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
  407d93:	75 a3                	jne    407d38 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x3e8>
  407d95:	4d 8b 5b 08          	mov    0x8(%r11),%r11
  407d99:	eb a8                	jmp    407d43 <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x3f3>
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  407d9b:	4d 09 f3             	or     %r14,%r11
  407d9e:	4c 89 9d 38 88 20 00 	mov    %r11,0x208838(%rbp)
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  407da5:	49 c7 44 c8 08 00 00 	movq   $0x0,0x8(%r8,%rcx,8)
  407dac:	00 00 
  407dae:	e9 47 ff ff ff       	jmpq   407cfa <_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb+0x3aa>
  407db3:	4c 89 d7             	mov    %r10,%rdi
  407db6:	e8 e9 a6 ff ff       	callq  4024a4 <_ZNK11__sanitizer14BasicBitVectorImE4maskEm.isra.19.part.20>
        return all_locks_with_contexts_[i].stk;
    return 0;
  }

  const BV &getLocks(uptr current_epoch) const {
    CHECK_EQ(epoch_, current_epoch);
  407dbb:	49 89 d0             	mov    %rdx,%r8
  407dbe:	48 8d 3d 43 d9 00 00 	lea    0xd943(%rip),%rdi        # 415708 <.LC4>
  407dc5:	48 8d 15 44 da 00 00 	lea    0xda44(%rip),%rdx        # 415810 <.LC9>
  407dcc:	be 6e 00 00 00       	mov    $0x6e,%esi
  407dd1:	e8 1a d6 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  }

  bool getBit(uptr idx) const { return (bits_ & mask(idx)) != 0; }

  uptr getAndClearFirstOne() {
    CHECK(!empty());
  407dd6:	48 8d 15 32 08 01 00 	lea    0x10832(%rip),%rdx        # 41860f <.LC10>
  407ddd:	48 8d 3d ac d8 00 00 	lea    0xd8ac(%rip),%rdi        # 415690 <.LC1>
  407de4:	45 31 c0             	xor    %r8d,%r8d
  407de7:	31 c9                	xor    %ecx,%ecx
  407de9:	be 32 00 00 00       	mov    $0x32,%esi
  407dee:	e8 fd d5 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  407df3:	48 89 d1             	mov    %rdx,%rcx
  407df6:	48 8d 3d 0b d9 00 00 	lea    0xd90b(%rip),%rdi        # 415708 <.LC4>
  407dfd:	48 8d 15 dc d9 00 00 	lea    0xd9dc(%rip),%rdx        # 4157e0 <.LC8>
  407e04:	be 75 01 00 00       	mov    $0x175,%esi
  407e09:	e8 e2 d5 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  407e0e:	48 8d 15 d1 07 01 00 	lea    0x107d1(%rip),%rdx        # 4185e6 <.LC3>
  407e15:	48 8d 3d ec d8 00 00 	lea    0xd8ec(%rip),%rdi        # 415708 <.LC4>
  407e1c:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  407e22:	4c 89 f9             	mov    %r15,%rcx
  407e25:	be 74 01 00 00       	mov    $0x174,%esi
  407e2a:	e8 c1 d5 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  407e2f:	90                   	nop

0000000000407e30 <_ZN11__sanitizer9DDetector20CreatePhysicalThreadEv>:
};

struct DDetector {
  static DDetector *Create(const DDFlags *flags);

  virtual DDPhysicalThread* CreatePhysicalThread() { return nullptr; }
  407e30:	31 c0                	xor    %eax,%eax
  407e32:	c3                   	retq   
  407e33:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  407e3a:	84 00 00 00 00 00 

0000000000407e40 <_ZN11__sanitizer9DDetector21DestroyPhysicalThreadEPNS_16DDPhysicalThreadE>:
  virtual void DestroyPhysicalThread(DDPhysicalThread *pt) {}
  407e40:	f3 c3                	repz retq 
  407e42:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  407e49:	1f 84 00 00 00 00 00 

0000000000407e50 <_ZN11__sanitizer9DDetector19CreateLogicalThreadEy>:

  virtual DDLogicalThread* CreateLogicalThread(u64 ctx) { return nullptr; }
  407e50:	31 c0                	xor    %eax,%eax
  407e52:	c3                   	retq   
  407e53:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  407e5a:	84 00 00 00 00 00 

0000000000407e60 <_ZN11__sanitizer9DDetector20DestroyLogicalThreadEPNS_15DDLogicalThreadE>:
  virtual void DestroyLogicalThread(DDLogicalThread *lt) {}
  407e60:	f3 c3                	repz retq 
  407e62:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  407e69:	1f 84 00 00 00 00 00 

0000000000407e70 <_ZN11__sanitizer9DDetector9MutexInitEPNS_10DDCallbackEPNS_7DDMutexE>:

  virtual void MutexInit(DDCallback *cb, DDMutex *m) {}
  407e70:	f3 c3                	repz retq 
  407e72:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  407e79:	1f 84 00 00 00 00 00 

0000000000407e80 <_ZN11__sanitizer9DDetector15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb>:
  virtual void MutexBeforeLock(DDCallback *cb, DDMutex *m, bool wlock) {}
  407e80:	f3 c3                	repz retq 
  407e82:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  407e89:	1f 84 00 00 00 00 00 

0000000000407e90 <_ZN11__sanitizer9DDetector14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb>:
  virtual void MutexAfterLock(DDCallback *cb, DDMutex *m, bool wlock,
  407e90:	f3 c3                	repz retq 
  407e92:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  407e99:	1f 84 00 00 00 00 00 

0000000000407ea0 <_ZN11__sanitizer9DDetector17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb>:
      bool trylock) {}
  virtual void MutexBeforeUnlock(DDCallback *cb, DDMutex *m, bool wlock) {}
  407ea0:	f3 c3                	repz retq 
  407ea2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  407ea9:	1f 84 00 00 00 00 00 

0000000000407eb0 <_ZN11__sanitizer9DDetector12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE>:
  virtual void MutexDestroy(DDCallback *cb, DDMutex *m) {}
  407eb0:	f3 c3                	repz retq 
  407eb2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  407eb9:	1f 84 00 00 00 00 00 

0000000000407ec0 <_ZN11__sanitizer9DDetector9GetReportEPNS_10DDCallbackE>:

  virtual DDReport *GetReport(DDCallback *cb) { return nullptr; }
  407ec0:	31 c0                	xor    %eax,%eax
  407ec2:	c3                   	retq   
  407ec3:	90                   	nop
  407ec4:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  407ecb:	00 
  407ecc:	00 00                	add    %al,(%rax)
	...

0000000000407ed0 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji>:

  // Adds edges from currently held locks to cur_node,
  // returns the number of added edges, and puts the sources of added edges
  // into added_edges[].
  // Should be called before onLockAfter.
  uptr addEdges(DeadlockDetectorTLS<BV> *dtls, uptr cur_node, u32 stk,
  407ed0:	41 57                	push   %r15
  407ed2:	41 89 ca             	mov    %ecx,%r10d
  407ed5:	41 56                	push   %r14
  407ed7:	41 55                	push   %r13
  407ed9:	41 54                	push   %r12
  407edb:	55                   	push   %rbp
  407edc:	53                   	push   %rbx
  407edd:	48 81 ec 68 01 00 00 	sub    $0x168,%rsp
                int unique_tid) {
  407ee4:	48 8b 07             	mov    (%rdi),%rax
  }

  bool empty() const { return bv_.empty(); }

  void ensureCurrentEpoch(uptr current_epoch) {
    if (epoch_ == current_epoch) return;
  407ee7:	48 3b 86 08 02 00 00 	cmp    0x208(%rsi),%rax
  407eee:	74 24                	je     407f14 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x44>
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  407ef0:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
    bv_.clear();
    epoch_ = current_epoch;
  407ef7:	48 89 86 08 02 00 00 	mov    %rax,0x208(%rsi)
    n_recursive_locks = 0;
  407efe:	48 c7 86 10 04 00 00 	movq   $0x0,0x410(%rsi)
  407f05:	00 00 00 00 
    n_all_locks_ = 0;
  407f09:	48 c7 86 18 06 00 00 	movq   $0x0,0x618(%rsi)
  407f10:	00 00 00 00 

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  407f14:	48 81 fa ff 0f 00 00 	cmp    $0xfff,%rdx
  407f1b:	0f 86 ca 02 00 00    	jbe    4081eb <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x31b>
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  407f21:	48 8b 0f             	mov    (%rdi),%rcx
  uptr nodeToIndex(uptr node) const {
    check_node(node);
    return nodeToIndexUnchecked(node);
  }

  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }
  407f24:	48 89 d0             	mov    %rdx,%rax
  407f27:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  407f2d:	48 39 c1             	cmp    %rax,%rcx
  407f30:	0f 85 9a 02 00 00    	jne    4081d0 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x300>
  407f36:	48 c7 87 20 86 20 00 	movq   $0x0,0x208620(%rdi)
  407f3d:	00 00 00 00 

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
  407f41:	48 8b 2e             	mov    (%rsi),%rbp
  uptr indexToNode(uptr idx) const {
    check_idx(idx);
    return idx + current_epoch_;
  }

  uptr nodeToIndexUnchecked(uptr node) const { return node % size(); }
  407f44:	49 89 d1             	mov    %rdx,%r9
  407f47:	41 81 e1 ff 0f 00 00 	and    $0xfff,%r9d
      while (!t.empty()) {
  407f4e:	48 85 ed             	test   %rbp,%rbp
  407f51:	0f 84 7a 01 00 00    	je     4080d1 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x201>
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407f57:	41 bd 01 00 00 00    	mov    $0x1,%r13d
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
          l2_[i0][i1].clear();
  407f5d:	4c 8d a7 20 86 20 00 	lea    0x208620(%rdi),%r12
  407f64:	eb 24                	jmp    407f8a <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0xba>
  407f66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  407f6d:	00 00 00 
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  407f70:	48 c7 41 08 00 00 00 	movq   $0x0,0x8(%rcx)
  407f77:	00 
  407f78:	31 c9                	xor    %ecx,%ecx
  }

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ |= v.bits_;
  407f7a:	4a 0b 4c de 08       	or     0x8(%rsi,%r11,8),%rcx
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  407f7f:	48 85 c0             	test   %rax,%rax
  }

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ |= v.bits_;
  407f82:	48 89 0b             	mov    %rcx,(%rbx)
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  407f85:	74 53                	je     407fda <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x10a>

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  407f87:	48 89 c5             	mov    %rax,%rbp
  407f8a:	f3 48 0f bc cd       	tzcnt  %rbp,%rcx
  407f8f:	4c 63 d9             	movslq %ecx,%r11
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  407f92:	49 83 fb 3f          	cmp    $0x3f,%r11
  407f96:	0f 87 2c 02 00 00    	ja     4081c8 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x2f8>
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
  407f9c:	48 8b 9f 20 86 20 00 	mov    0x208620(%rdi),%rbx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407fa3:	4c 89 e8             	mov    %r13,%rax
  407fa6:	48 d3 e0             	shl    %cl,%rax
  407fa9:	48 89 c1             	mov    %rax,%rcx
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  407fac:	48 f7 d0             	not    %rax
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  407faf:	48 09 d9             	or     %rbx,%rcx
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  407fb2:	48 21 e8             	and    %rbp,%rax
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  407fb5:	48 89 8f 20 86 20 00 	mov    %rcx,0x208620(%rdi)
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
  407fbc:	48 39 cb             	cmp    %rcx,%rbx
          l2_[i0][i1].clear();
  407fbf:	4b 8d 0c dc          	lea    (%r12,%r11,8),%rcx
  407fc3:	48 8d 59 08          	lea    0x8(%rcx),%rbx
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
        uptr i1 = t.getAndClearFirstOne();
        if (l1_[i0].setBit(i1))
  407fc7:	75 a7                	jne    407f70 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0xa0>
  407fc9:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  }

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ |= v.bits_;
  407fcd:	4a 0b 4c de 08       	or     0x8(%rsi,%r11,8),%rcx
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  407fd2:	48 85 c0             	test   %rax,%rax
  }

  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const BasicBitVector &v) {
    basic_int_t old = bits_;
    bits_ |= v.bits_;
  407fd5:	48 89 0b             	mov    %rcx,(%rbx)
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  407fd8:	75 ad                	jne    407f87 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0xb7>
  407fda:	4c 8b af 20 86 20 00 	mov    0x208620(%rdi),%r13
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  407fe1:	4d 89 ce             	mov    %r9,%r14
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407fe4:	b8 01 00 00 00       	mov    $0x1,%eax
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  407fe9:	83 e2 3f             	and    $0x3f,%edx
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  407fec:	49 c1 ee 06          	shr    $0x6,%r14
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407ff0:	49 89 c7             	mov    %rax,%r15

  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
  407ff3:	4c 8d a7 20 86 20 00 	lea    0x208620(%rdi),%r12
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  407ffa:	44 89 f1             	mov    %r14d,%ecx
                uptr max_added_edges) {
    uptr res = 0;
    t1.copyFrom(from);
    while (!t1.empty()) {
      uptr node = t1.getAndClearFirstOne();
      if (v[node].setBit(to))
  407ffd:	48 8d af 20 06 00 00 	lea    0x620(%rdi),%rbp
  408004:	49 d3 e7             	shl    %cl,%r15
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  408007:	48 89 d1             	mov    %rdx,%rcx
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    if (!l1_[i0].getBit(i1)) {
      l1_[i0].setBit(i1);
      l2_[i0][i1].clear();
  40800a:	4a 8d 14 f5 00 00 00 	lea    0x0(,%r14,8),%rdx
  408011:	00 
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  408012:	48 d3 e0             	shl    %cl,%rax
  408015:	48 89 c3             	mov    %rax,%rbx
  408018:	31 c0                	xor    %eax,%eax
    }
  }

  bool empty() const {
    for (uptr i = 0; i < kLevel1Size; i++)
      if (!l1_[i].empty())
  40801a:	4d 85 ed             	test   %r13,%r13
  40801d:	0f 85 b6 00 00 00    	jne    4080d9 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x209>
    ensureCurrentEpoch(dtls);
    uptr cur_idx = nodeToIndex(cur_node);
    uptr added_edges[40];
    uptr n_added_edges = g_.addEdges(dtls->getLocks(current_epoch_), cur_idx,
                                     added_edges, ARRAY_SIZE(added_edges));
    for (uptr i = 0; i < n_added_edges; i++) {
  408023:	31 db                	xor    %ebx,%ebx
  408025:	48 85 c0             	test   %rax,%rax
  408028:	0f 84 81 00 00 00    	je     4080af <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x1df>
      if (n_edges_ < ARRAY_SIZE(edges_)) {
  40802e:	48 8b af 30 0a 41 00 	mov    0x410a30(%rdi),%rbp
  408035:	48 81 fd ff ff 01 00 	cmp    $0x1ffff,%rbp
  40803c:	77 64                	ja     4080a2 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x1d2>
      }
    }
  }

  u32 findLockContext(uptr lock_id) {
    for (uptr i = 0; i < n_all_locks_; i++)
  40803e:	48 8b 8e 18 06 00 00 	mov    0x618(%rsi),%rcx
                                     added_edges, ARRAY_SIZE(added_edges));
    for (uptr i = 0; i < n_added_edges; i++) {
      if (n_edges_ < ARRAY_SIZE(edges_)) {
        Edge e = {(u16)added_edges[i], (u16)cur_idx,
                  dtls->findLockContext(added_edges[i]), stk,
                  unique_tid};
  408045:	4c 8b 64 dc 20       	mov    0x20(%rsp,%rbx,8),%r12
      }
    }
  }

  u32 findLockContext(uptr lock_id) {
    for (uptr i = 0; i < n_all_locks_; i++)
  40804a:	48 85 c9             	test   %rcx,%rcx
  40804d:	74 24                	je     408073 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x1a3>
  40804f:	31 d2                	xor    %edx,%edx
      if (all_locks_with_contexts_[i].lock == static_cast<u32>(lock_id))
  408051:	44 39 a6 18 04 00 00 	cmp    %r12d,0x418(%rsi)
  408058:	45 89 e3             	mov    %r12d,%r11d
  40805b:	75 0d                	jne    40806a <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x19a>
  40805d:	eb 62                	jmp    4080c1 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x1f1>
  40805f:	90                   	nop
  408060:	44 39 9c d6 18 04 00 	cmp    %r11d,0x418(%rsi,%rdx,8)
  408067:	00 
  408068:	74 5e                	je     4080c8 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x1f8>
      }
    }
  }

  u32 findLockContext(uptr lock_id) {
    for (uptr i = 0; i < n_all_locks_; i++)
  40806a:	48 83 c2 01          	add    $0x1,%rdx
  40806e:	48 39 ca             	cmp    %rcx,%rdx
  408071:	75 ed                	jne    408060 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x190>
      if (all_locks_with_contexts_[i].lock == static_cast<u32>(lock_id))
        return all_locks_with_contexts_[i].stk;
    return 0;
  408073:	31 c9                	xor    %ecx,%ecx
    for (uptr i = 0; i < n_added_edges; i++) {
      if (n_edges_ < ARRAY_SIZE(edges_)) {
        Edge e = {(u16)added_edges[i], (u16)cur_idx,
                  dtls->findLockContext(added_edges[i]), stk,
                  unique_tid};
        edges_[n_edges_++] = e;
  408075:	48 8d 55 01          	lea    0x1(%rbp),%rdx
  408079:	48 89 97 30 0a 41 00 	mov    %rdx,0x410a30(%rdi)
  408080:	48 8d 95 a3 10 02 00 	lea    0x210a3(%rbp),%rdx
  408087:	48 c1 e2 04          	shl    $0x4,%rdx
  40808b:	48 01 fa             	add    %rdi,%rdx
  40808e:	66 44 89 22          	mov    %r12w,(%rdx)
  408092:	66 44 89 4a 02       	mov    %r9w,0x2(%rdx)
  408097:	89 4a 04             	mov    %ecx,0x4(%rdx)
  40809a:	44 89 52 08          	mov    %r10d,0x8(%rdx)
  40809e:	44 89 42 0c          	mov    %r8d,0xc(%rdx)
    ensureCurrentEpoch(dtls);
    uptr cur_idx = nodeToIndex(cur_node);
    uptr added_edges[40];
    uptr n_added_edges = g_.addEdges(dtls->getLocks(current_epoch_), cur_idx,
                                     added_edges, ARRAY_SIZE(added_edges));
    for (uptr i = 0; i < n_added_edges; i++) {
  4080a2:	48 83 c3 01          	add    $0x1,%rbx
  4080a6:	48 39 c3             	cmp    %rax,%rbx
  4080a9:	0f 85 7f ff ff ff    	jne    40802e <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x15e>
      }
      // Printf("Edge%zd: %u %zd=>%zd in T%d\n",
      //        n_edges_, stk, added_edges[i], cur_idx, unique_tid);
    }
    return n_added_edges;
  }
  4080af:	48 81 c4 68 01 00 00 	add    $0x168,%rsp
  4080b6:	5b                   	pop    %rbx
  4080b7:	5d                   	pop    %rbp
  4080b8:	41 5c                	pop    %r12
  4080ba:	41 5d                	pop    %r13
  4080bc:	41 5e                	pop    %r14
  4080be:	41 5f                	pop    %r15
  4080c0:	c3                   	retq   
      }
    }
  }

  u32 findLockContext(uptr lock_id) {
    for (uptr i = 0; i < n_all_locks_; i++)
  4080c1:	31 d2                	xor    %edx,%edx
  4080c3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
      if (all_locks_with_contexts_[i].lock == static_cast<u32>(lock_id))
        return all_locks_with_contexts_[i].stk;
  4080c8:	8b 8c d6 1c 04 00 00 	mov    0x41c(%rsi,%rdx,8),%ecx
  4080cf:	eb a4                	jmp    408075 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x1a5>
  // Do "this |= v" and return whether new bits have been added.
  bool setUnion(const TwoLevelBitVector &v) {
    bool res = false;
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      BV t = v.l1_[i0];
      while (!t.empty()) {
  4080d1:	45 31 ed             	xor    %r13d,%r13d
  4080d4:	e9 08 ff ff ff       	jmpq   407fe1 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x111>
  4080d9:	f3 49 0f bc cd       	tzcnt  %r13,%rcx
  4080de:	4c 63 f1             	movslq %ecx,%r14
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  4080e1:	49 83 fe 3f          	cmp    $0x3f,%r14
  4080e5:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  4080ea:	0f 87 39 01 00 00    	ja     408229 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x359>
    return (basic_int_t)1UL << idx;
  4080f0:	41 be 01 00 00 00    	mov    $0x1,%r14d
  4080f6:	49 d3 e6             	shl    %cl,%r14
  4080f9:	4c 89 f1             	mov    %r14,%rcx
  4080fc:	4c 89 74 24 10       	mov    %r14,0x10(%rsp)
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  408101:	48 f7 d1             	not    %rcx
  408104:	4c 21 e9             	and    %r13,%rcx
  408107:	48 89 8f 20 86 20 00 	mov    %rcx,0x208620(%rdi)

  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
  40810e:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
  408113:	49 8d 0c cc          	lea    (%r12,%rcx,8),%rcx

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  408117:	4c 8b 69 08          	mov    0x8(%rcx),%r13

  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
  40811b:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  }

  bool getBit(uptr idx) const { return (bits_ & mask(idx)) != 0; }

  uptr getAndClearFirstOne() {
    CHECK(!empty());
  408120:	4d 85 ed             	test   %r13,%r13
  408123:	0f 84 e3 00 00 00    	je     40820c <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x33c>
  408129:	f3 49 0f bc cd       	tzcnt  %r13,%rcx
  40812e:	4c 63 f1             	movslq %ecx,%r14
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  408131:	49 83 fe 3f          	cmp    $0x3f,%r14
  408135:	0f 87 ee 00 00 00    	ja     408229 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x359>
    return (basic_int_t)1UL << idx;
  40813b:	41 bb 01 00 00 00    	mov    $0x1,%r11d
  408141:	49 d3 e3             	shl    %cl,%r11
  408144:	4c 89 d9             	mov    %r11,%rcx
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  408147:	4c 8b 5c 24 18       	mov    0x18(%rsp),%r11
  40814c:	48 f7 d1             	not    %rcx
  40814f:	4c 21 e9             	and    %r13,%rcx
  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
      if (!l2_[i0][i1].empty())
  408152:	48 85 c9             	test   %rcx,%rcx
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  408155:	49 89 4b 08          	mov    %rcx,0x8(%r11)
  uptr getAndClearFirstOne() {
    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
      if (!l2_[i0][i1].empty())
  408159:	74 0c                	je     408167 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x297>
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  40815b:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
  408160:	48 09 8f 20 86 20 00 	or     %rcx,0x208620(%rdi)
      if (l1_[i0].empty()) continue;
      uptr i1 = l1_[i0].getAndClearFirstOne();
      uptr i2 = l2_[i0][i1].getAndClearFirstOne();
      if (!l2_[i0][i1].empty())
        l1_[i0].setBit(i1);
      uptr res = i0 * BV::kSize * BV::kSize + i1 * BV::kSize + i2;
  408167:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
  40816c:	48 c1 e1 06          	shl    $0x6,%rcx
  408170:	4c 01 f1             	add    %r14,%rcx
  408173:	49 89 cd             	mov    %rcx,%r13
  408176:	49 c1 e5 09          	shl    $0x9,%r13
  40817a:	4d 8d 74 cd 00       	lea    0x0(%r13,%rcx,8),%r14
  40817f:	49 01 ee             	add    %rbp,%r14
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
    return bits_ != old;
  }

  bool getBit(uptr idx) const { return (bits_ & mask(idx)) != 0; }
  408182:	4d 8b 2e             	mov    (%r14),%r13
  bool setBit(uptr idx) {
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    if (!l1_[i0].getBit(i1)) {
  408185:	4d 85 ef             	test   %r13,%r15
  408188:	74 22                	je     4081ac <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x2dc>
  40818a:	49 01 d6             	add    %rdx,%r14
  40818d:	4d 8b 6e 08          	mov    0x8(%r14),%r13
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  408191:	4d 89 eb             	mov    %r13,%r11
  408194:	49 09 db             	or     %rbx,%r11
  408197:	4d 39 dd             	cmp    %r11,%r13
  40819a:	4d 89 5e 08          	mov    %r11,0x8(%r14)
  40819e:	75 17                	jne    4081b7 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x2e7>
  4081a0:	4c 8b af 20 86 20 00 	mov    0x208620(%rdi),%r13
  4081a7:	e9 6e fe ff ff       	jmpq   40801a <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x14a>
  4081ac:	4d 09 fd             	or     %r15,%r13
  4081af:	4d 89 2e             	mov    %r13,(%r14)
  4081b2:	49 89 5c 16 08       	mov    %rbx,0x8(%r14,%rdx,1)
        if (res < max_added_edges)
  4081b7:	48 83 f8 27          	cmp    $0x27,%rax
  4081bb:	77 e3                	ja     4081a0 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x2d0>
          added_edges[res++] = node;
  4081bd:	48 89 4c c4 20       	mov    %rcx,0x20(%rsp,%rax,8)
  4081c2:	48 83 c0 01          	add    $0x1,%rax
  4081c6:	eb d8                	jmp    4081a0 <_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji+0x2d0>
  4081c8:	4c 89 df             	mov    %r11,%rdi
  4081cb:	e8 d4 a2 ff ff       	callq  4024a4 <_ZNK11__sanitizer14BasicBitVectorImE4maskEm.isra.19.part.20>
 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
    CHECK_EQ(current_epoch_, nodeToEpoch(node));
  4081d0:	48 8d 15 09 d6 00 00 	lea    0xd609(%rip),%rdx        # 4157e0 <.LC8>
  4081d7:	48 8d 3d 2a d5 00 00 	lea    0xd52a(%rip),%rdi        # 415708 <.LC4>
  4081de:	49 89 c0             	mov    %rax,%r8
  4081e1:	be 75 01 00 00       	mov    $0x175,%esi
  4081e6:	e8 05 d2 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

 private:
  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }

  void check_node(uptr node) const {
    CHECK_GE(node, size());
  4081eb:	48 89 d1             	mov    %rdx,%rcx
  4081ee:	48 8d 3d 13 d5 00 00 	lea    0xd513(%rip),%rdi        # 415708 <.LC4>
  4081f5:	48 8d 15 ea 03 01 00 	lea    0x103ea(%rip),%rdx        # 4185e6 <.LC3>
  4081fc:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  408202:	be 74 01 00 00       	mov    $0x174,%esi
  408207:	e8 e4 d1 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  }

  bool getBit(uptr idx) const { return (bits_ & mask(idx)) != 0; }

  uptr getAndClearFirstOne() {
    CHECK(!empty());
  40820c:	48 8d 15 fc 03 01 00 	lea    0x103fc(%rip),%rdx        # 41860f <.LC10>
  408213:	48 8d 3d 76 d4 00 00 	lea    0xd476(%rip),%rdi        # 415690 <.LC1>
  40821a:	45 31 c0             	xor    %r8d,%r8d
  40821d:	31 c9                	xor    %ecx,%ecx
  40821f:	be 32 00 00 00       	mov    $0x32,%esi
  408224:	e8 c7 d1 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  408229:	4c 89 f7             	mov    %r14,%rdi
  40822c:	e8 73 a2 ff ff       	callq  4024a4 <_ZNK11__sanitizer14BasicBitVectorImE4maskEm.isra.19.part.20>
  408231:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  408238:	0f 1f 84 00 00 00 00 
  40823f:	00 

0000000000408240 <_ZN11__sanitizer14BasicBitVectorImE6setBitEm>:
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  408240:	48 83 fe 3f          	cmp    $0x3f,%rsi
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
  408244:	48 8b 17             	mov    (%rdi),%rdx
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  408247:	77 17                	ja     408260 <_ZN11__sanitizer14BasicBitVectorImE6setBitEm+0x20>
    return (basic_int_t)1UL << idx;
  408249:	89 f1                	mov    %esi,%ecx
  40824b:	b8 01 00 00 00       	mov    $0x1,%eax
  408250:	48 d3 e0             	shl    %cl,%rax
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  408253:	48 09 d0             	or     %rdx,%rax
    return bits_ != old;
  408256:	48 39 c2             	cmp    %rax,%rdx
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ |= mask(idx);
  408259:	48 89 07             	mov    %rax,(%rdi)
    return bits_ != old;
  40825c:	0f 95 c0             	setne  %al
  }
  40825f:	c3                   	retq   
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }

  // Returns true if the bit has changed from 0 to 1.
  bool setBit(uptr idx) {
  408260:	50                   	push   %rax
  408261:	48 89 f7             	mov    %rsi,%rdi
  408264:	e8 3b a2 ff ff       	callq  4024a4 <_ZNK11__sanitizer14BasicBitVectorImE4maskEm.isra.19.part.20>
  408269:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000408270 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm>:
  }

  // Finds a path from 'from' to one of the nodes in 'target',
  // stores up to 'path_size' items of the path into 'path',
  // returns the path length, or 0 if there is no path of size 'path_size'.
  uptr findPath(uptr from, const BV &targets, uptr *path, uptr path_size) {
  408270:	41 57                	push   %r15
    if (path_size == 0)
      return 0;
  408272:	31 c0                	xor    %eax,%eax
  }

  // Finds a path from 'from' to one of the nodes in 'target',
  // stores up to 'path_size' items of the path into 'path',
  // returns the path length, or 0 if there is no path of size 'path_size'.
  uptr findPath(uptr from, const BV &targets, uptr *path, uptr path_size) {
  408274:	41 56                	push   %r14
  408276:	41 55                	push   %r13
  408278:	41 54                	push   %r12
  40827a:	55                   	push   %rbp
  40827b:	53                   	push   %rbx
  40827c:	48 83 ec 68          	sub    $0x68,%rsp
    if (path_size == 0)
  408280:	4d 85 c0             	test   %r8,%r8
  }

  // Finds a path from 'from' to one of the nodes in 'target',
  // stores up to 'path_size' items of the path into 'path',
  // returns the path length, or 0 if there is no path of size 'path_size'.
  uptr findPath(uptr from, const BV &targets, uptr *path, uptr path_size) {
  408283:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  408288:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
  40828d:	48 89 4c 24 58       	mov    %rcx,0x58(%rsp)
  408292:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    if (path_size == 0)
  408297:	75 17                	jne    4082b0 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x40>
      uptr idx = it.next();
      if (uptr res = findPath(idx, targets, path + 1, path_size - 1))
        return res + 1;
    }
    return 0;
  }
  408299:	48 83 c4 68          	add    $0x68,%rsp
  40829d:	5b                   	pop    %rbx
  40829e:	5d                   	pop    %rbp
  40829f:	41 5c                	pop    %r12
  4082a1:	41 5d                	pop    %r13
  4082a3:	41 5e                	pop    %r14
  4082a5:	41 5f                	pop    %r15
  4082a7:	c3                   	retq   
  4082a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4082af:	00 
    uptr i0_, i1_;
    typename BV::Iterator it1_, it2_;
  };

 private:
  void check(uptr idx) const { CHECK_LE(idx, size()); }
  4082b0:	48 81 fe 00 10 00 00 	cmp    $0x1000,%rsi
  // stores up to 'path_size' items of the path into 'path',
  // returns the path length, or 0 if there is no path of size 'path_size'.
  uptr findPath(uptr from, const BV &targets, uptr *path, uptr path_size) {
    if (path_size == 0)
      return 0;
    path[0] = from;
  4082b7:	48 89 31             	mov    %rsi,(%rcx)
  4082ba:	0f 87 68 03 00 00    	ja     408628 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x3b8>
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  4082c0:	48 89 f0             	mov    %rsi,%rax
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  4082c3:	bf 01 00 00 00       	mov    $0x1,%edi

 private:
  void check(uptr idx) const { CHECK_LE(idx, size()); }

  uptr idx0(uptr idx) const {
    uptr res = idx / (BV::kSize * BV::kSize);
  4082c8:	48 89 f2             	mov    %rsi,%rdx
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  4082cb:	48 c1 e8 06          	shr    $0x6,%rax
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  4082cf:	48 89 fb             	mov    %rdi,%rbx

 private:
  void check(uptr idx) const { CHECK_LE(idx, size()); }

  uptr idx0(uptr idx) const {
    uptr res = idx / (BV::kSize * BV::kSize);
  4082d2:	48 c1 ea 0c          	shr    $0xc,%rdx
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  4082d6:	83 e0 3f             	and    $0x3f,%eax
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  4082d9:	89 c1                	mov    %eax,%ecx
  4082db:	48 d3 e3             	shl    %cl,%rbx
  4082de:	48 89 d9             	mov    %rbx,%rcx
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  4082e1:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
  4082e6:	48 85 0c d3          	test   %rcx,(%rbx,%rdx,8)
  4082ea:	74 1b                	je     408307 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x97>
  4082ec:	48 c1 e2 06          	shl    $0x6,%rdx
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  4082f0:	48 89 f1             	mov    %rsi,%rcx
  4082f3:	83 e1 3f             	and    $0x3f,%ecx
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  4082f6:	48 01 d0             	add    %rdx,%rax
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  4082f9:	48 d3 e7             	shl    %cl,%rdi
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  4082fc:	48 85 7c c3 08       	test   %rdi,0x8(%rbx,%rax,8)
  408301:	0f 85 d9 02 00 00    	jne    4085e0 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x370>
    if (targets.getBit(from))
      return 1;
    // The function is recursive, so we don't want to create BV on stack.
    // Instead of a getAndClearFirstOne loop we use the slower iterator.
    for (typename BV::Iterator it(v[from]); it.hasNext(); ) {
  408307:	48 89 f0             	mov    %rsi,%rax
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  40830a:	45 31 e4             	xor    %r12d,%r12d
  40830d:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
  408314:	00 00 
  408316:	48 c1 e0 09          	shl    $0x9,%rax
  //   use(idx);
  // }
  class Iterator {
   public:
    Iterator() = default;
    explicit Iterator(const TwoLevelBitVector &bv) : bv_(bv), i0_(0), i1_(0) {
  40831a:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
  408321:	00 00 
  408323:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
  40832a:	00 00 
  40832c:	48 8d 04 f0          	lea    (%rax,%rsi,8),%rax
  408330:	48 03 44 24 18       	add    0x18(%rsp),%rax
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  408335:	bd 01 00 00 00       	mov    $0x1,%ebp
  40833a:	4d 89 e7             	mov    %r12,%r15
  40833d:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
      uptr idx = it.next();
      if (uptr res = findPath(idx, targets, path + 1, path_size - 1))
  408342:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  408347:	48 83 e8 02          	sub    $0x2,%rax
  40834b:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  408350:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
  408355:	48 83 c0 10          	add    $0x10,%rax
  408359:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  40835e:	66 90                	xchg   %ax,%ax
      it1_.clear();
      it2_.clear();
    }

    bool hasNext() const {
      if (it1_.hasNext()) return true;
  408360:	48 83 7c 24 10 00    	cmpq   $0x0,0x10(%rsp)
  408366:	74 18                	je     408380 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x110>
          // Printf("+i0: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
          //   it2_.hasNext(), kSize);
          break;
        }
      }
      if (!it2_.hasNext()) {
  408368:	4d 85 ff             	test   %r15,%r15
  40836b:	0f 84 9b 02 00 00    	je     40860c <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x39c>
  408371:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    }

    uptr next() {
      // Printf("++++: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
      //       it2_.hasNext(), kSize);
      if (!it1_.hasNext() && !it2_.hasNext()) {
  408378:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  40837d:	eb 79                	jmp    4083f8 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x188>
  40837f:	90                   	nop
      it2_.clear();
    }

    bool hasNext() const {
      if (it1_.hasNext()) return true;
      for (uptr i = i0_; i < kLevel1Size; i++)
  408380:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
  408386:	75 0d                	jne    408395 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x125>

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  408388:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
  40838d:	48 8b 10             	mov    (%rax),%rdx
    }

    bool hasNext() const {
      if (it1_.hasNext()) return true;
      for (uptr i = i0_; i < kLevel1Size; i++)
        if (!bv_.l1_[i].empty()) return true;
  408390:	48 85 d2             	test   %rdx,%rdx
  408393:	75 11                	jne    4083a6 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x136>
        return res + 1;
    }
    return 0;
  }
  408395:	48 83 c4 68          	add    $0x68,%rsp
    for (typename BV::Iterator it(v[from]); it.hasNext(); ) {
      uptr idx = it.next();
      if (uptr res = findPath(idx, targets, path + 1, path_size - 1))
        return res + 1;
    }
    return 0;
  408399:	31 c0                	xor    %eax,%eax
  }
  40839b:	5b                   	pop    %rbx
  40839c:	5d                   	pop    %rbp
  40839d:	41 5c                	pop    %r12
  40839f:	41 5d                	pop    %r13
  4083a1:	41 5e                	pop    %r14
  4083a3:	41 5f                	pop    %r15
  4083a5:	c3                   	retq   
    }

    uptr next() {
      // Printf("++++: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
      //       it2_.hasNext(), kSize);
      if (!it1_.hasNext() && !it2_.hasNext()) {
  4083a6:	4d 85 ff             	test   %r15,%r15
  4083a9:	75 cd                	jne    408378 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x108>
  4083ab:	31 c0                	xor    %eax,%eax
  4083ad:	f3 48 0f bc ca       	tzcnt  %rdx,%rcx
  4083b2:	48 63 f9             	movslq %ecx,%rdi
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  4083b5:	48 83 ff 3f          	cmp    $0x3f,%rdi
  4083b9:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  4083be:	0f 87 43 02 00 00    	ja     408607 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x397>
    return (basic_int_t)1UL << idx;
  4083c4:	48 89 eb             	mov    %rbp,%rbx
  //   use(idx);
  // }
  class Iterator {
   public:
    Iterator() = default;
    explicit Iterator(const BasicBitVector &bv) : bv_(bv) {}
  4083c7:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  4083cc:	48 d3 e3             	shl    %cl,%rbx
  4083cf:	48 89 5c 24 10       	mov    %rbx,0x10(%rsp)
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  4083d4:	48 f7 54 24 10       	notq   0x10(%rsp)
  4083d9:	48 21 54 24 10       	and    %rdx,0x10(%rsp)
  //   use(idx);
  // }
  class Iterator {
   public:
    Iterator() = default;
    explicit Iterator(const BasicBitVector &bv) : bv_(bv) {}
  4083de:	48 89 c2             	mov    %rax,%rdx
  4083e1:	48 c1 e2 06          	shl    $0x6,%rdx
  4083e5:	48 03 54 24 48       	add    0x48(%rsp),%rdx
  4083ea:	4c 8b 7c d7 08       	mov    0x8(%rdi,%rdx,8),%r15
        i1_ = it1_.next();
        it2_ = typename BV::Iterator(bv_.l2_[i0_][i1_]);
        // Printf("++i1: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
        //       it2_.hasNext(), kSize);
      }
      CHECK(it2_.hasNext());
  4083ef:	4d 85 ff             	test   %r15,%r15
  4083f2:	0f 84 c7 01 00 00    	je     4085bf <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x34f>
  4083f8:	f3 49 0f bc cf       	tzcnt  %r15,%rcx
  4083fd:	48 63 f9             	movslq %ecx,%rdi
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  408400:	48 83 ff 3f          	cmp    $0x3f,%rdi
  408404:	0f 87 fd 01 00 00    	ja     408607 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x397>
    return (basic_int_t)1UL << idx;
  40840a:	48 89 ea             	mov    %rbp,%rdx
      CHECK(it2_.hasNext());
      uptr i2 = it2_.next();
      uptr res = i0_ * BV::kSize * BV::kSize + i1_ * BV::kSize + i2;
      // Printf("+ret: %zd %zd; %d %d; size %zd; res: %zd\n", i0_, i1_,
      //       it1_.hasNext(), it2_.hasNext(), kSize, res);
      if (!it1_.hasNext() && !it2_.hasNext())
  40840d:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  408412:	48 d3 e2             	shl    %cl,%rdx
  408415:	48 89 d1             	mov    %rdx,%rcx
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  408418:	48 f7 d1             	not    %rcx
  40841b:	49 21 cf             	and    %rcx,%r15
      CHECK(it2_.hasNext());
      uptr i2 = it2_.next();
      uptr res = i0_ * BV::kSize * BV::kSize + i1_ * BV::kSize + i2;
      // Printf("+ret: %zd %zd; %d %d; size %zd; res: %zd\n", i0_, i1_,
      //       it1_.hasNext(), it2_.hasNext(), kSize, res);
      if (!it1_.hasNext() && !it2_.hasNext())
  40841e:	48 83 7c 24 10 00    	cmpq   $0x0,0x10(%rsp)
  408424:	75 10                	jne    408436 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x1c6>
  408426:	48 8d 50 01          	lea    0x1(%rax),%rdx
  40842a:	4d 85 ff             	test   %r15,%r15
  40842d:	48 0f 45 d0          	cmovne %rax,%rdx
  408431:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)

  // Finds a path from 'from' to one of the nodes in 'target',
  // stores up to 'path_size' items of the path into 'path',
  // returns the path length, or 0 if there is no path of size 'path_size'.
  uptr findPath(uptr from, const BV &targets, uptr *path, uptr path_size) {
    if (path_size == 0)
  408436:	48 83 7c 24 40 01    	cmpq   $0x1,0x40(%rsp)
  40843c:	0f 84 1e ff ff ff    	je     408360 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0xf0>
        // Printf("++i1: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
        //       it2_.hasNext(), kSize);
      }
      CHECK(it2_.hasNext());
      uptr i2 = it2_.next();
      uptr res = i0_ * BV::kSize * BV::kSize + i1_ * BV::kSize + i2;
  408442:	48 c1 e0 06          	shl    $0x6,%rax
  408446:	48 03 44 24 48       	add    0x48(%rsp),%rax
  40844b:	48 c1 e0 06          	shl    $0x6,%rax
  40844f:	48 01 c7             	add    %rax,%rdi
      return 0;
    path[0] = from;
  408452:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
    uptr i0_, i1_;
    typename BV::Iterator it1_, it2_;
  };

 private:
  void check(uptr idx) const { CHECK_LE(idx, size()); }
  408457:	48 81 ff 00 10 00 00 	cmp    $0x1000,%rdi
  40845e:	48 89 78 08          	mov    %rdi,0x8(%rax)
  408462:	0f 87 b3 01 00 00    	ja     40861b <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x3ab>
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  408468:	48 89 f8             	mov    %rdi,%rax
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  40846b:	48 89 eb             	mov    %rbp,%rbx

 private:
  void check(uptr idx) const { CHECK_LE(idx, size()); }

  uptr idx0(uptr idx) const {
    uptr res = idx / (BV::kSize * BV::kSize);
  40846e:	48 89 fa             	mov    %rdi,%rdx
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  408471:	48 c1 e8 06          	shr    $0x6,%rax

 private:
  void check(uptr idx) const { CHECK_LE(idx, size()); }

  uptr idx0(uptr idx) const {
    uptr res = idx / (BV::kSize * BV::kSize);
  408475:	48 c1 ea 0c          	shr    $0xc,%rdx
    CHECK_LE(res, kLevel1Size);
    return res;
  }

  uptr idx1(uptr idx) const {
    uptr res = (idx / BV::kSize) % BV::kSize;
  408479:	83 e0 3f             	and    $0x3f,%eax
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  40847c:	89 c1                	mov    %eax,%ecx
  40847e:	48 d3 e3             	shl    %cl,%rbx
  408481:	48 89 d9             	mov    %rbx,%rcx
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  408484:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
  408489:	48 85 0c d3          	test   %rcx,(%rbx,%rdx,8)
  40848d:	74 26                	je     4084b5 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x245>
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  40848f:	48 89 f9             	mov    %rdi,%rcx
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  408492:	48 89 eb             	mov    %rbp,%rbx
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  408495:	48 c1 e2 06          	shl    $0x6,%rdx
    CHECK_LE(res, BV::kSize);
    return res;
  }

  uptr idx2(uptr idx) const {
    uptr res = idx % BV::kSize;
  408499:	83 e1 3f             	and    $0x3f,%ecx
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  40849c:	48 01 d0             	add    %rdx,%rax
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
    return (basic_int_t)1UL << idx;
  40849f:	48 d3 e3             	shl    %cl,%rbx
  4084a2:	48 89 d9             	mov    %rbx,%rcx
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  4084a5:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
  4084aa:	48 85 4c c3 08       	test   %rcx,0x8(%rbx,%rax,8)
  4084af:	0f 85 3b 01 00 00    	jne    4085f0 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x380>
    if (targets.getBit(from))
      return 1;
    // The function is recursive, so we don't want to create BV on stack.
    // Instead of a getAndClearFirstOne loop we use the slower iterator.
    for (typename BV::Iterator it(v[from]); it.hasNext(); ) {
  4084b5:	48 89 f8             	mov    %rdi,%rax
 public:
  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  4084b8:	45 31 ed             	xor    %r13d,%r13d
  4084bb:	4c 89 7c 24 38       	mov    %r15,0x38(%rsp)
  4084c0:	48 c1 e0 09          	shl    $0x9,%rax
  4084c4:	31 db                	xor    %ebx,%ebx
  //   use(idx);
  // }
  class Iterator {
   public:
    Iterator() = default;
    explicit Iterator(const TwoLevelBitVector &bv) : bv_(bv), i0_(0), i1_(0) {
  4084c6:	45 31 f6             	xor    %r14d,%r14d
  4084c9:	4c 8d 24 f8          	lea    (%rax,%rdi,8),%r12
  4084cd:	4c 03 64 24 18       	add    0x18(%rsp),%r12
  4084d2:	4d 89 ef             	mov    %r13,%r15
  4084d5:	0f 1f 00             	nopl   (%rax)
      it1_.clear();
      it2_.clear();
    }

    bool hasNext() const {
      if (it1_.hasNext()) return true;
  4084d8:	4d 85 ff             	test   %r15,%r15
  4084db:	0f 84 87 00 00 00    	je     408568 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x2f8>
          // Printf("+i0: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
          //   it2_.hasNext(), kSize);
          break;
        }
      }
      if (!it2_.hasNext()) {
  4084e1:	48 85 db             	test   %rbx,%rbx
  4084e4:	0f 84 46 01 00 00    	je     408630 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x3c0>
  4084ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  4084f0:	f3 48 0f bc cb       	tzcnt  %rbx,%rcx
  4084f5:	48 63 f1             	movslq %ecx,%rsi
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  4084f8:	48 83 fe 3f          	cmp    $0x3f,%rsi
  4084fc:	0f 87 02 01 00 00    	ja     408604 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x394>
    return (basic_int_t)1UL << idx;
  408502:	48 89 e8             	mov    %rbp,%rax
  408505:	48 d3 e0             	shl    %cl,%rax
  408508:	48 89 c1             	mov    %rax,%rcx
        // Printf("++i1: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
        //       it2_.hasNext(), kSize);
      }
      CHECK(it2_.hasNext());
      uptr i2 = it2_.next();
      uptr res = i0_ * BV::kSize * BV::kSize + i1_ * BV::kSize + i2;
  40850b:	4c 89 e8             	mov    %r13,%rax
  40850e:	48 c1 e0 06          	shl    $0x6,%rax
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  408512:	48 f7 d1             	not    %rcx
        // Printf("++i1: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
        //       it2_.hasNext(), kSize);
      }
      CHECK(it2_.hasNext());
      uptr i2 = it2_.next();
      uptr res = i0_ * BV::kSize * BV::kSize + i1_ * BV::kSize + i2;
  408515:	4c 01 f0             	add    %r14,%rax
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  408518:	48 21 cb             	and    %rcx,%rbx
        // Printf("++i1: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
        //       it2_.hasNext(), kSize);
      }
      CHECK(it2_.hasNext());
      uptr i2 = it2_.next();
      uptr res = i0_ * BV::kSize * BV::kSize + i1_ * BV::kSize + i2;
  40851b:	48 c1 e0 06          	shl    $0x6,%rax
  40851f:	48 01 c6             	add    %rax,%rsi
      // Printf("+ret: %zd %zd; %d %d; size %zd; res: %zd\n", i0_, i1_,
      //       it1_.hasNext(), it2_.hasNext(), kSize, res);
      if (!it1_.hasNext() && !it2_.hasNext())
  408522:	4d 85 ff             	test   %r15,%r15
  408525:	75 08                	jne    40852f <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x2bf>
        i0_++;
  408527:	48 83 fb 01          	cmp    $0x1,%rbx
  40852b:	49 83 d5 00          	adc    $0x0,%r13
      uptr idx = it.next();
      if (uptr res = findPath(idx, targets, path + 1, path_size - 1))
  40852f:	4c 8b 44 24 20       	mov    0x20(%rsp),%r8
  408534:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
  408539:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  40853e:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  408543:	e8 28 fd ff ff       	callq  408270 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm>
  408548:	48 85 c0             	test   %rax,%rax
  40854b:	74 8b                	je     4084d8 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x268>
  40854d:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  408551:	4c 8b 7c 24 38       	mov    0x38(%rsp),%r15
  408556:	0f 84 04 fe ff ff    	je     408360 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0xf0>
  40855c:	48 83 c0 02          	add    $0x2,%rax
  408560:	e9 34 fd ff ff       	jmpq   408299 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x29>
  408565:	0f 1f 00             	nopl   (%rax)
      it2_.clear();
    }

    bool hasNext() const {
      if (it1_.hasNext()) return true;
      for (uptr i = i0_; i < kLevel1Size; i++)
  408568:	4d 85 ed             	test   %r13,%r13
  40856b:	75 09                	jne    408576 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x306>

  uptr size() const { return kSize; }
  // No CTOR.
  void clear() { bits_ = 0; }
  void setAll() { bits_ = ~(basic_int_t)0; }
  bool empty() const { return bits_ == 0; }
  40856d:	49 8b 04 24          	mov    (%r12),%rax
    }

    bool hasNext() const {
      if (it1_.hasNext()) return true;
      for (uptr i = i0_; i < kLevel1Size; i++)
        if (!bv_.l1_[i].empty()) return true;
  408571:	48 85 c0             	test   %rax,%rax
  408574:	75 0a                	jne    408580 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x310>
  408576:	4c 8b 7c 24 38       	mov    0x38(%rsp),%r15
  40857b:	e9 e0 fd ff ff       	jmpq   408360 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0xf0>
    }

    uptr next() {
      // Printf("++++: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
      //       it2_.hasNext(), kSize);
      if (!it1_.hasNext() && !it2_.hasNext()) {
  408580:	48 85 db             	test   %rbx,%rbx
  408583:	0f 85 67 ff ff ff    	jne    4084f0 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x280>
  408589:	f3 48 0f bc c8       	tzcnt  %rax,%rcx
  40858e:	4c 63 f1             	movslq %ecx,%r14
    BasicBitVector bv_;
  };

 private:
  basic_int_t mask(uptr idx) const {
    CHECK_LT(idx, size());
  408591:	49 83 fe 3f          	cmp    $0x3f,%r14
  408595:	0f 87 85 00 00 00    	ja     408620 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x3b0>
    return (basic_int_t)1UL << idx;
  40859b:	49 89 ef             	mov    %rbp,%r15
  40859e:	49 d3 e7             	shl    %cl,%r15
  }

  // Returns true if the bit has changed from 1 to 0.
  bool clearBit(uptr idx) {
    basic_int_t old = bits_;
    bits_ &= ~mask(idx);
  4085a1:	49 f7 d7             	not    %r15
  4085a4:	49 21 c7             	and    %rax,%r15
  //   use(idx);
  // }
  class Iterator {
   public:
    Iterator() = default;
    explicit Iterator(const BasicBitVector &bv) : bv_(bv) {}
  4085a7:	4c 89 e8             	mov    %r13,%rax
  4085aa:	48 c1 e0 06          	shl    $0x6,%rax
  4085ae:	4c 01 f0             	add    %r14,%rax
  4085b1:	49 8b 5c c4 08       	mov    0x8(%r12,%rax,8),%rbx
        i1_ = it1_.next();
        it2_ = typename BV::Iterator(bv_.l2_[i0_][i1_]);
        // Printf("++i1: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
        //       it2_.hasNext(), kSize);
      }
      CHECK(it2_.hasNext());
  4085b6:	48 85 db             	test   %rbx,%rbx
  4085b9:	0f 85 31 ff ff ff    	jne    4084f0 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x280>
  4085bf:	48 8d 15 5d 00 01 00 	lea    0x1005d(%rip),%rdx        # 418623 <.LC16>
  4085c6:	48 8d 3d c3 d0 00 00 	lea    0xd0c3(%rip),%rdi        # 415690 <.LC1>
  4085cd:	45 31 c0             	xor    %r8d,%r8d
  4085d0:	31 c9                	xor    %ecx,%ecx
  4085d2:	be 34 01 00 00       	mov    $0x134,%esi
  4085d7:	e8 14 ce ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  4085dc:	0f 1f 40 00          	nopl   0x0(%rax)
  uptr findPath(uptr from, const BV &targets, uptr *path, uptr path_size) {
    if (path_size == 0)
      return 0;
    path[0] = from;
    if (targets.getBit(from))
      return 1;
  4085e0:	b8 01 00 00 00       	mov    $0x1,%eax
  4085e5:	e9 af fc ff ff       	jmpq   408299 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x29>
  4085ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      uptr idx = it.next();
      if (uptr res = findPath(idx, targets, path + 1, path_size - 1))
        return res + 1;
    }
    return 0;
  }
  4085f0:	48 83 c4 68          	add    $0x68,%rsp
    check(idx);
    uptr i0 = idx0(idx);
    uptr i1 = idx1(idx);
    uptr i2 = idx2(idx);
    // Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);
  4085f4:	b8 02 00 00 00       	mov    $0x2,%eax
  4085f9:	5b                   	pop    %rbx
  4085fa:	5d                   	pop    %rbp
  4085fb:	41 5c                	pop    %r12
  4085fd:	41 5d                	pop    %r13
  4085ff:	41 5e                	pop    %r14
  408601:	41 5f                	pop    %r15
  408603:	c3                   	retq   
  408604:	48 89 f7             	mov    %rsi,%rdi
  408607:	e8 98 9e ff ff       	callq  4024a4 <_ZNK11__sanitizer14BasicBitVectorImE4maskEm.isra.19.part.20>
          // Printf("+i0: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
          //   it2_.hasNext(), kSize);
          break;
        }
      }
      if (!it2_.hasNext()) {
  40860c:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  408611:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  408616:	e9 92 fd ff ff       	jmpq   4083ad <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x13d>
  40861b:	e8 62 9e ff ff       	callq  402482 <_ZNK11__sanitizer17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEE5checkEm.isra.16.part.17>
  408620:	4c 89 f7             	mov    %r14,%rdi
  408623:	e8 7c 9e ff ff       	callq  4024a4 <_ZNK11__sanitizer14BasicBitVectorImE4maskEm.isra.19.part.20>
  408628:	48 89 f7             	mov    %rsi,%rdi
  40862b:	e8 52 9e ff ff       	callq  402482 <_ZNK11__sanitizer17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEE5checkEm.isra.16.part.17>
  408630:	4c 89 f8             	mov    %r15,%rax
  408633:	e9 51 ff ff ff       	jmpq   408589 <_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm+0x319>
  408638:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40863f:	00 

0000000000408640 <_ZN11__sanitizer11CommonFlags11SetDefaultsEv>:
COMMON_FLAG(
    bool, allow_addr2line, false,
    "If set, allows online symbolizer to run addr2line binary to symbolize "
    "stack traces (addr2line will only be used if llvm-symbolizer binary is "
    "unavailable.")
COMMON_FLAG(const char *, strip_path_prefix, "",
  408640:	48 8d 05 65 ff 00 00 	lea    0xff65(%rip),%rax        # 4185ac <.LC12>
// COMMON_FLAG(Type, Name, DefaultValue, Description)
// Supported types: bool, const char *, int, uptr.
// Default value must be a compile-time constant.
// Description must be a string literal.

COMMON_FLAG(
  408647:	c6 07 01             	movb   $0x1,(%rdi)
    bool, symbolize, true,
    "If set, use the online symbolizer from common sanitizer runtime to turn "
    "virtual addresses to file/line locations.")
COMMON_FLAG(
  40864a:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  408651:	00 
    const char *, external_symbolizer_path, nullptr,
    "Path to external symbolizer. If empty, the tool will search $PATH for "
    "the symbolizer.")
COMMON_FLAG(
  408652:	c6 47 10 00          	movb   $0x0,0x10(%rdi)
    "If set, allows online symbolizer to run addr2line binary to symbolize "
    "stack traces (addr2line will only be used if llvm-symbolizer binary is "
    "unavailable.")
COMMON_FLAG(const char *, strip_path_prefix, "",
            "Strips this prefix from file paths in error reports.")
COMMON_FLAG(bool, fast_unwind_on_check, false,
  408656:	c6 47 20 00          	movb   $0x0,0x20(%rdi)
COMMON_FLAG(
    bool, allow_addr2line, false,
    "If set, allows online symbolizer to run addr2line binary to symbolize "
    "stack traces (addr2line will only be used if llvm-symbolizer binary is "
    "unavailable.")
COMMON_FLAG(const char *, strip_path_prefix, "",
  40865a:	48 89 47 18          	mov    %rax,0x18(%rdi)
            "If available, use the fast frame-pointer-based unwinder on "
            "malloc/free.")
COMMON_FLAG(bool, handle_ioctl, false, "Intercept and handle ioctl requests.")
COMMON_FLAG(int, malloc_context_size, 1,
            "Max number of stack frames kept for each allocation/deallocation.")
COMMON_FLAG(
  40865e:	48 8d 05 a6 fe 00 00 	lea    0xfea6(%rip),%rax        # 41850b <.LC13>
COMMON_FLAG(const char *, strip_path_prefix, "",
            "Strips this prefix from file paths in error reports.")
COMMON_FLAG(bool, fast_unwind_on_check, false,
            "If available, use the fast frame-pointer-based unwinder on "
            "internal CHECK failures.")
COMMON_FLAG(bool, fast_unwind_on_fatal, false,
  408665:	c6 47 21 00          	movb   $0x0,0x21(%rdi)
            "If available, use the fast frame-pointer-based unwinder on fatal "
            "errors.")
COMMON_FLAG(bool, fast_unwind_on_malloc, true,
  408669:	c6 47 22 01          	movb   $0x1,0x22(%rdi)
            "If available, use the fast frame-pointer-based unwinder on "
            "malloc/free.")
COMMON_FLAG(bool, handle_ioctl, false, "Intercept and handle ioctl requests.")
  40866d:	c6 47 23 00          	movb   $0x0,0x23(%rdi)
COMMON_FLAG(int, malloc_context_size, 1,
            "Max number of stack frames kept for each allocation/deallocation.")
COMMON_FLAG(
  408671:	48 89 47 28          	mov    %rax,0x28(%rdi)
            "If set, deadlock detection is enabled.")
COMMON_FLAG(
    uptr, clear_shadow_mmap_threshold, 64 * 1024,
    "Large shadow regions are zero-filled using mmap(NORESERVE) instead of "
    "memset(). This is the threshold size in bytes.")
COMMON_FLAG(const char *, color, "auto",
  408675:	48 8d 05 2a 00 01 00 	lea    0x1002a(%rip),%rax        # 4186a6 <.LC14>
            "errors.")
COMMON_FLAG(bool, fast_unwind_on_malloc, true,
            "If available, use the fast frame-pointer-based unwinder on "
            "malloc/free.")
COMMON_FLAG(bool, handle_ioctl, false, "Intercept and handle ioctl requests.")
COMMON_FLAG(int, malloc_context_size, 1,
  40867c:	c7 47 24 01 00 00 00 	movl   $0x1,0x24(%rdi)
            "Max number of stack frames kept for each allocation/deallocation.")
COMMON_FLAG(
    const char *, log_path, "stderr",
    "Write logs to \"log_path.pid\". The special values are \"stdout\" and "
    "\"stderr\". The default is \"stderr\".")
COMMON_FLAG(
  408683:	c6 47 30 00          	movb   $0x0,0x30(%rdi)
    bool, log_exe_name, false,
    "Mention name of executable when reporting error and "
    "append executable name to logs (as in \"log_path.exe_name.pid\").")
COMMON_FLAG(
  408687:	c6 47 31 00          	movb   $0x0,0x31(%rdi)
            "If set, deadlock detection is enabled.")
COMMON_FLAG(
    uptr, clear_shadow_mmap_threshold, 64 * 1024,
    "Large shadow regions are zero-filled using mmap(NORESERVE) instead of "
    "memset(). This is the threshold size in bytes.")
COMMON_FLAG(const char *, color, "auto",
  40868b:	48 89 47 50          	mov    %rax,0x50(%rdi)
            " to coverage counters will be dumped.")
COMMON_FLAG(bool, coverage_direct, SANITIZER_ANDROID,
            "If set, coverage information will be dumped directly to a memory "
            "mapped file. This way data is not lost even if the process is "
            "suddenly killed.")
COMMON_FLAG(const char *, coverage_dir, ".",
  40868f:	48 8d 05 15 00 01 00 	lea    0x10015(%rip),%rax        # 4186ab <.LC15>
    "append executable name to logs (as in \"log_path.exe_name.pid\").")
COMMON_FLAG(
    bool, log_to_syslog, SANITIZER_ANDROID,
    "Write all sanitizer output to syslog in addition to other means of "
    "logging.")
COMMON_FLAG(
  408696:	c7 47 34 00 00 00 00 	movl   $0x0,0x34(%rdi)
    int, verbosity, 0,
    "Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).")
COMMON_FLAG(bool, detect_leaks, true, "Enable memory leak detection.")
  40869d:	c6 47 38 01          	movb   $0x1,0x38(%rdi)
COMMON_FLAG(
  4086a1:	c6 47 39 01          	movb   $0x1,0x39(%rdi)
    bool, leak_check_at_exit, true,
    "Invoke leak checking in an atexit handler. Has no effect if "
    "detect_leaks=false, or if __lsan_do_leak_check() is called before the "
    "handler has a chance to run.")
COMMON_FLAG(bool, allocator_may_return_null, false,
  4086a5:	c6 47 3a 00          	movb   $0x0,0x3a(%rdi)
            "If false, the allocator will crash instead of returning 0 on "
            "out-of-memory.")
COMMON_FLAG(bool, print_summary, true,
  4086a9:	c6 47 3b 01          	movb   $0x1,0x3b(%rdi)
            "If false, disable printing error summaries in addition to error "
            "reports.")
COMMON_FLAG(bool, check_printf, true, "Check printf arguments.")
  4086ad:	c6 47 3c 01          	movb   $0x1,0x3c(%rdi)
COMMON_FLAG(bool, handle_segv, SANITIZER_NEEDS_SEGV,
  4086b1:	c6 47 3d 01          	movb   $0x1,0x3d(%rdi)
            "If set, registers the tool's custom SIGSEGV/SIGBUS handler.")
COMMON_FLAG(bool, handle_abort, false,
  4086b5:	c6 47 3e 00          	movb   $0x0,0x3e(%rdi)
            "If set, registers the tool's custom SIGABRT handler.")
COMMON_FLAG(bool, handle_sigfpe, true,
  4086b9:	c6 47 3f 01          	movb   $0x1,0x3f(%rdi)
            "If set, registers the tool's custom SIGFPE handler.")
COMMON_FLAG(bool, allow_user_segv_handler, false,
  4086bd:	c6 47 40 00          	movb   $0x0,0x40(%rdi)
            "If set, allows user to register a SEGV handler even if the tool "
            "registers one.")
COMMON_FLAG(bool, use_sigaltstack, true,
  4086c1:	c6 47 41 01          	movb   $0x1,0x41(%rdi)
            "If set, uses alternate stack for signal handling.")
COMMON_FLAG(bool, detect_deadlocks, false,
  4086c5:	c6 47 42 00          	movb   $0x0,0x42(%rdi)
            "If set, deadlock detection is enabled.")
COMMON_FLAG(
  4086c9:	48 c7 47 48 00 00 01 	movq   $0x10000,0x48(%rdi)
  4086d0:	00 
    uptr, clear_shadow_mmap_threshold, 64 * 1024,
    "Large shadow regions are zero-filled using mmap(NORESERVE) instead of "
    "memset(). This is the threshold size in bytes.")
COMMON_FLAG(const char *, color, "auto",
            "Colorize reports: (always|never|auto).")
COMMON_FLAG(
  4086d1:	c6 47 58 00          	movb   $0x0,0x58(%rdi)
    bool, legacy_pthread_cond, false,
    "Enables support for dynamic libraries linked with libpthread 2.2.5.")
COMMON_FLAG(bool, intercept_tls_get_addr, false, "Intercept __tls_get_addr.")
  4086d5:	c6 47 59 00          	movb   $0x0,0x59(%rdi)
COMMON_FLAG(bool, help, false, "Print the flag descriptions.")
  4086d9:	c6 47 5a 00          	movb   $0x0,0x5a(%rdi)
COMMON_FLAG(uptr, mmap_limit_mb, 0,
  4086dd:	48 c7 47 60 00 00 00 	movq   $0x0,0x60(%rdi)
  4086e4:	00 
            "Limit the amount of mmap-ed memory (excluding shadow) in Mb; "
            "not a user-facing flag, used mosly for testing the tools")
COMMON_FLAG(uptr, hard_rss_limit_mb, 0,
  4086e5:	48 c7 47 68 00 00 00 	movq   $0x0,0x68(%rdi)
  4086ec:	00 
            "Hard RSS limit in Mb."
            " If non-zero, a background thread is spawned at startup"
            " which periodically reads RSS and aborts the process if the"
            " limit is reached")
COMMON_FLAG(uptr, soft_rss_limit_mb, 0,
  4086ed:	48 c7 47 70 00 00 00 	movq   $0x0,0x70(%rdi)
  4086f4:	00 
            " all subsequent malloc/new calls will fail or return NULL"
            " (depending on the value of allocator_may_return_null)"
            " until the RSS goes below the soft limit."
            " This limit does not affect memory allocations other than"
            " malloc/new.")
COMMON_FLAG(bool, can_use_proc_maps_statm, true,
  4086f5:	c6 47 78 01          	movb   $0x1,0x78(%rdi)
            "If false, do not attempt to read /proc/maps/statm."
            " Mostly useful for testing sanitizers.")
COMMON_FLAG(
  4086f9:	c6 47 79 00          	movb   $0x0,0x79(%rdi)
            " to coverage counters will be dumped.")
COMMON_FLAG(bool, coverage_direct, SANITIZER_ANDROID,
            "If set, coverage information will be dumped directly to a memory "
            "mapped file. This way data is not lost even if the process is "
            "suddenly killed.")
COMMON_FLAG(const char *, coverage_dir, ".",
  4086fd:	48 89 87 80 00 00 00 	mov    %rax,0x80(%rdi)
COMMON_FLAG(bool, symbolize_inline_frames, true,
            "Print inlined frames in stacktraces. Defaults to true.")
COMMON_FLAG(bool, symbolize_vs_style, false,
            "Print file locations in Visual Studio style (e.g: "
            " file(10,42): ...")
COMMON_FLAG(const char *, stack_trace_format, "DEFAULT",
  408704:	48 8d 05 a2 ff 00 00 	lea    0xffa2(%rip),%rax        # 4186ad <.LC0>
            " Mostly useful for testing sanitizers.")
COMMON_FLAG(
    bool, coverage, false,
    "If set, coverage information will be dumped at program shutdown (if the "
    "coverage instrumentation was enabled at compile time).")
COMMON_FLAG(bool, coverage_pcs, true,
  40870b:	c6 47 7a 01          	movb   $0x1,0x7a(%rdi)
            "If set (and if 'coverage' is set too), the coverage information "
            "will be dumped as a set of PC offsets for every module.")
COMMON_FLAG(bool, coverage_order_pcs, false,
  40870f:	c6 47 7b 00          	movb   $0x0,0x7b(%rdi)
             "If true, the PCs will be dumped in the order they've"
             " appeared during the execution.")
COMMON_FLAG(bool, coverage_bitset, false,
  408713:	c6 47 7c 00          	movb   $0x0,0x7c(%rdi)
            "If set (and if 'coverage' is set too), the coverage information "
            "will also be dumped as a bitset to a separate file.")
COMMON_FLAG(bool, coverage_counters, false,
  408717:	c6 47 7d 00          	movb   $0x0,0x7d(%rdi)
            "If set (and if 'coverage' is set too), the bitmap that corresponds"
            " to coverage counters will be dumped.")
COMMON_FLAG(bool, coverage_direct, SANITIZER_ANDROID,
  40871b:	c6 47 7e 00          	movb   $0x0,0x7e(%rdi)
            "mapped file. This way data is not lost even if the process is "
            "suddenly killed.")
COMMON_FLAG(const char *, coverage_dir, ".",
            "Target directory for coverage dumps. Defaults to the current "
            "directory.")
COMMON_FLAG(bool, full_address_space, false,
  40871f:	c6 87 88 00 00 00 00 	movb   $0x0,0x88(%rdi)
            "Sanitize complete address space; "
            "by default kernel area on 32-bit platforms will not be sanitized")
COMMON_FLAG(bool, print_suppressions, true,
  408726:	c6 87 89 00 00 00 01 	movb   $0x1,0x89(%rdi)
            "Print matched suppressions at exit.")
COMMON_FLAG(
  40872d:	c6 87 8a 00 00 00 01 	movb   $0x1,0x8a(%rdi)
    bool, disable_coredump, (SANITIZER_WORDSIZE == 64),
    "Disable core dumping. By default, disable_core=1 on 64-bit to avoid "
    "dumping a 16T+ core file. Ignored on OSes that don't dump core by"
    "default and for sanitizers that don't reserve lots of virtual memory.")
COMMON_FLAG(bool, use_madv_dontdump, true,
  408734:	c6 87 8b 00 00 00 01 	movb   $0x1,0x8b(%rdi)
          "If set, instructs kernel to not store the (huge) shadow "
          "in core file.")
COMMON_FLAG(bool, symbolize_inline_frames, true,
  40873b:	c6 87 8c 00 00 00 01 	movb   $0x1,0x8c(%rdi)
            "Print inlined frames in stacktraces. Defaults to true.")
COMMON_FLAG(bool, symbolize_vs_style, false,
  408742:	c6 87 8d 00 00 00 00 	movb   $0x0,0x8d(%rdi)
            "Print file locations in Visual Studio style (e.g: "
            " file(10,42): ...")
COMMON_FLAG(const char *, stack_trace_format, "DEFAULT",
  408749:	48 89 87 90 00 00 00 	mov    %rax,0x90(%rdi)
            "Format string used to render stack frames. "
            "See sanitizer_stacktrace_printer.h for the format description. "
            "Use DEFAULT to get default format.")
COMMON_FLAG(bool, no_huge_pages_for_shadow, true,
  408750:	c6 87 98 00 00 00 01 	movb   $0x1,0x98(%rdi)
            "If true, the shadow is not allowed to use huge pages. ")
COMMON_FLAG(bool, strict_string_checks, false,
  408757:	c6 87 99 00 00 00 00 	movb   $0x0,0x99(%rdi)
            "If set check that string arguments are properly null-terminated")
COMMON_FLAG(bool, intercept_strstr, true,
  40875e:	c6 87 9a 00 00 00 01 	movb   $0x1,0x9a(%rdi)
            "If set, uses custom wrappers for strstr and strcasestr functions "
            "to find more errors.")
COMMON_FLAG(bool, intercept_strspn, true,
  408765:	c6 87 9b 00 00 00 01 	movb   $0x1,0x9b(%rdi)
            "If set, uses custom wrappers for strspn and strcspn function "
            "to find more errors.")
COMMON_FLAG(bool, intercept_strpbrk, true,
  40876c:	c6 87 9c 00 00 00 01 	movb   $0x1,0x9c(%rdi)
            "If set, uses custom wrappers for strpbrk function "
            "to find more errors.")
COMMON_FLAG(bool, intercept_memcmp, true,
  408773:	c6 87 9d 00 00 00 01 	movb   $0x1,0x9d(%rdi)
            "If set, uses custom wrappers for memcmp function "
            "to find more errors.")
COMMON_FLAG(bool, strict_memcmp, true,
  40877a:	c6 87 9e 00 00 00 01 	movb   $0x1,0x9e(%rdi)
          "If true, assume that memcmp(p1, p2, n) always reads n bytes before "
          "comparing p1 and p2.")
COMMON_FLAG(bool, decorate_proc_maps, false, "If set, decorate sanitizer "
  408781:	c6 87 9f 00 00 00 00 	movb   $0x0,0x9f(%rdi)
                                             "mappings in /proc/self/maps with "
                                             "user-readable names")
COMMON_FLAG(int, exitcode, 1, "Override the program exit status if the tool "
  408788:	c7 87 a0 00 00 00 01 	movl   $0x1,0xa0(%rdi)
  40878f:	00 00 00 
                              "found an error")
COMMON_FLAG(
  408792:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%rdi)
  408799:	c3                   	retq   
  40879a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000004087a0 <_ZN11__sanitizer11CommonFlags8CopyFromERKS0_>:
#include "sanitizer_flags.inc"
#undef COMMON_FLAG
}

void CommonFlags::CopyFrom(const CommonFlags &other) {
  internal_memcpy(this, &other, sizeof(*this));
  4087a0:	ba a8 00 00 00       	mov    $0xa8,%edx
  4087a5:	e9 66 17 00 00       	jmpq   409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
  4087aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000004087b0 <_ZN11__sanitizer20RegisterIncludeFlagsEPNS_10FlagParserEPNS_11CommonFlagsE>:
    }
    return parser_->ParseFile(value, ignore_missing_);
  }
};

void RegisterIncludeFlags(FlagParser *parser, CommonFlags *cf) {
  4087b0:	41 54                	push   %r12

}  // namespace __sanitizer

inline void *operator new(__sanitizer::operator_new_size_type size,
                          __sanitizer::LowLevelAllocator &alloc) {
  return alloc.Allocate(size);
  4087b2:	be 18 00 00 00       	mov    $0x18,%esi
  FlagParser *parser_;
  bool ignore_missing_;

 public:
  explicit FlagHandlerInclude(FlagParser *parser, bool ignore_missing)
      : parser_(parser), ignore_missing_(ignore_missing) {}
  4087b7:	4c 8d 25 d2 86 01 00 	lea    0x186d2(%rip),%r12        # 420e90 <_ZTVN11__sanitizer18FlagHandlerIncludeE+0x10>
    }
    return parser_->ParseFile(value, ignore_missing_);
  }
};

void RegisterIncludeFlags(FlagParser *parser, CommonFlags *cf) {
  4087be:	55                   	push   %rbp
  4087bf:	48 8b 2d e2 5a 01 00 	mov    0x15ae2(%rip),%rbp        # 41e2a8 <_DYNAMIC+0x2a8>
  4087c6:	53                   	push   %rbx
  4087c7:	48 89 fb             	mov    %rdi,%rbx
  4087ca:	48 89 ef             	mov    %rbp,%rdi
  4087cd:	e8 3e aa ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
  FlagHandlerInclude *fh_include = new (FlagParser::Alloc) // NOLINT
      FlagHandlerInclude(parser, /*ignore_missing*/ false);
  parser->RegisterHandler("include", fh_include,
                          "read more options from the given file");
  4087d2:	48 8d 0d a7 d2 00 00 	lea    0xd2a7(%rip),%rcx        # 415a80 <.LC17>
  4087d9:	48 8d 35 d5 fe 00 00 	lea    0xfed5(%rip),%rsi        # 4186b5 <.LC18>
  FlagParser *parser_;
  bool ignore_missing_;

 public:
  explicit FlagHandlerInclude(FlagParser *parser, bool ignore_missing)
      : parser_(parser), ignore_missing_(ignore_missing) {}
  4087e0:	4c 89 20             	mov    %r12,(%rax)
  4087e3:	48 89 58 08          	mov    %rbx,0x8(%rax)

void RegisterIncludeFlags(FlagParser *parser, CommonFlags *cf) {
  FlagHandlerInclude *fh_include = new (FlagParser::Alloc) // NOLINT
      FlagHandlerInclude(parser, /*ignore_missing*/ false);
  parser->RegisterHandler("include", fh_include,
                          "read more options from the given file");
  4087e7:	48 89 c2             	mov    %rax,%rdx
  4087ea:	48 89 df             	mov    %rbx,%rdi
  FlagParser *parser_;
  bool ignore_missing_;

 public:
  explicit FlagHandlerInclude(FlagParser *parser, bool ignore_missing)
      : parser_(parser), ignore_missing_(ignore_missing) {}
  4087ed:	c6 40 10 00          	movb   $0x0,0x10(%rax)

void RegisterIncludeFlags(FlagParser *parser, CommonFlags *cf) {
  FlagHandlerInclude *fh_include = new (FlagParser::Alloc) // NOLINT
      FlagHandlerInclude(parser, /*ignore_missing*/ false);
  parser->RegisterHandler("include", fh_include,
                          "read more options from the given file");
  4087f1:	e8 ca 15 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  4087f6:	48 89 ef             	mov    %rbp,%rdi
  4087f9:	be 18 00 00 00       	mov    $0x18,%esi
  4087fe:	e8 0d aa ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
  FlagHandlerInclude *fh_include_if_exists = new (FlagParser::Alloc) // NOLINT
      FlagHandlerInclude(parser, /*ignore_missing*/ true);
  parser->RegisterHandler(
      "include_if_exists", fh_include_if_exists,
      "read more options from the given file (if it exists)");
  408803:	48 89 df             	mov    %rbx,%rdi
  FlagParser *parser_;
  bool ignore_missing_;

 public:
  explicit FlagHandlerInclude(FlagParser *parser, bool ignore_missing)
      : parser_(parser), ignore_missing_(ignore_missing) {}
  408806:	4c 89 20             	mov    %r12,(%rax)
  408809:	48 89 58 08          	mov    %rbx,0x8(%rax)
  40880d:	c6 40 10 01          	movb   $0x1,0x10(%rax)
                          "read more options from the given file");
  FlagHandlerInclude *fh_include_if_exists = new (FlagParser::Alloc) // NOLINT
      FlagHandlerInclude(parser, /*ignore_missing*/ true);
  parser->RegisterHandler(
      "include_if_exists", fh_include_if_exists,
      "read more options from the given file (if it exists)");
  408811:	48 8d 0d 90 d2 00 00 	lea    0xd290(%rip),%rcx        # 415aa8 <.LC19>
  408818:	48 8d 35 9e fe 00 00 	lea    0xfe9e(%rip),%rsi        # 4186bd <.LC20>
}
  40881f:	5b                   	pop    %rbx
  408820:	5d                   	pop    %rbp
  408821:	41 5c                	pop    %r12
                          "read more options from the given file");
  FlagHandlerInclude *fh_include_if_exists = new (FlagParser::Alloc) // NOLINT
      FlagHandlerInclude(parser, /*ignore_missing*/ true);
  parser->RegisterHandler(
      "include_if_exists", fh_include_if_exists,
      "read more options from the given file (if it exists)");
  408823:	48 89 c2             	mov    %rax,%rdx
  408826:	e9 95 15 00 00       	jmpq   409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  40882b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000408830 <_ZN11__sanitizer19RegisterCommonFlagsEPNS_10FlagParserEPNS_11CommonFlagsE>:
}

void RegisterCommonFlags(FlagParser *parser, CommonFlags *cf) {
  408830:	41 57                	push   %r15
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408832:	4c 8d 3d 37 86 01 00 	lea    0x18637(%rip),%r15        # 420e70 <_ZTVN11__sanitizer11FlagHandlerImEE+0x10>
  408839:	41 56                	push   %r14
  40883b:	4c 8d 35 ee 85 01 00 	lea    0x185ee(%rip),%r14        # 420e30 <_ZTVN11__sanitizer11FlagHandlerIPKcEE+0x10>
  408842:	41 55                	push   %r13
  408844:	4c 8d 2d 05 85 01 00 	lea    0x18505(%rip),%r13        # 420d50 <_ZTVN11__sanitizer11FlagHandlerIbEE+0x10>
  40884b:	41 54                	push   %r12
  40884d:	49 89 f4             	mov    %rsi,%r12
  408850:	be 10 00 00 00       	mov    $0x10,%esi
  408855:	55                   	push   %rbp
  408856:	53                   	push   %rbx
  408857:	48 89 fb             	mov    %rdi,%rbx
  40885a:	48 83 ec 18          	sub    $0x18,%rsp
  40885e:	48 8b 2d 43 5a 01 00 	mov    0x15a43(%rip),%rbp        # 41e2a8 <_DYNAMIC+0x2a8>
  408865:	48 89 ef             	mov    %rbp,%rdi
  408868:	e8 a3 a9 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  40886d:	48 8d 0d 6c d2 00 00 	lea    0xd26c(%rip),%rcx        # 415ae0 <.LC21>
  408874:	48 8d 35 54 fe 00 00 	lea    0xfe54(%rip),%rsi        # 4186cf <.LC22>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  40887b:	4c 89 28             	mov    %r13,(%rax)
  40887e:	4c 89 60 08          	mov    %r12,0x8(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408882:	48 89 c2             	mov    %rax,%rdx
  408885:	48 89 df             	mov    %rbx,%rdi
  408888:	e8 33 15 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  40888d:	48 89 ef             	mov    %rbp,%rdi
  408890:	be 10 00 00 00       	mov    $0x10,%esi
  408895:	e8 76 a9 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>

COMMON_FLAG(
    bool, symbolize, true,
    "If set, use the online symbolizer from common sanitizer runtime to turn "
    "virtual addresses to file/line locations.")
COMMON_FLAG(
  40889a:	49 8d 54 24 08       	lea    0x8(%r12),%rdx
  40889f:	48 8d 0d b2 d2 00 00 	lea    0xd2b2(%rip),%rcx        # 415b58 <.LC23>
  4088a6:	48 8d 35 2c fe 00 00 	lea    0xfe2c(%rip),%rsi        # 4186d9 <.LC24>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  4088ad:	4c 89 30             	mov    %r14,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  4088b0:	48 89 df             	mov    %rbx,%rdi
  4088b3:	48 89 50 08          	mov    %rdx,0x8(%rax)
  4088b7:	48 89 c2             	mov    %rax,%rdx
  4088ba:	e8 01 15 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  4088bf:	48 89 ef             	mov    %rbp,%rdi
  4088c2:	be 10 00 00 00       	mov    $0x10,%esi
  4088c7:	e8 44 a9 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
    const char *, external_symbolizer_path, nullptr,
    "Path to external symbolizer. If empty, the tool will search $PATH for "
    "the symbolizer.")
COMMON_FLAG(
  4088cc:	49 8d 54 24 10       	lea    0x10(%r12),%rdx
  4088d1:	48 8d 0d d8 d2 00 00 	lea    0xd2d8(%rip),%rcx        # 415bb0 <.LC25>
  4088d8:	48 8d 35 13 fe 00 00 	lea    0xfe13(%rip),%rsi        # 4186f2 <.LC26>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  4088df:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  4088e2:	48 89 df             	mov    %rbx,%rdi
  4088e5:	48 89 50 08          	mov    %rdx,0x8(%rax)
  4088e9:	48 89 c2             	mov    %rax,%rdx
  4088ec:	e8 cf 14 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  4088f1:	48 89 ef             	mov    %rbp,%rdi
  4088f4:	be 10 00 00 00       	mov    $0x10,%esi
  4088f9:	e8 12 a9 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
    bool, allow_addr2line, false,
    "If set, allows online symbolizer to run addr2line binary to symbolize "
    "stack traces (addr2line will only be used if llvm-symbolizer binary is "
    "unavailable.")
COMMON_FLAG(const char *, strip_path_prefix, "",
  4088fe:	49 8d 54 24 18       	lea    0x18(%r12),%rdx
  408903:	48 8d 0d 46 d3 00 00 	lea    0xd346(%rip),%rcx        # 415c50 <.LC27>
  40890a:	48 8d 35 f1 fd 00 00 	lea    0xfdf1(%rip),%rsi        # 418702 <.LC28>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408911:	4c 89 30             	mov    %r14,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408914:	48 89 df             	mov    %rbx,%rdi
  408917:	48 89 50 08          	mov    %rdx,0x8(%rax)
  40891b:	48 89 c2             	mov    %rax,%rdx
  40891e:	e8 9d 14 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408923:	48 89 ef             	mov    %rbp,%rdi
  408926:	be 10 00 00 00       	mov    $0x10,%esi
  40892b:	e8 e0 a8 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "Strips this prefix from file paths in error reports.")
COMMON_FLAG(bool, fast_unwind_on_check, false,
  408930:	49 8d 54 24 20       	lea    0x20(%r12),%rdx
  408935:	48 8d 0d 4c d3 00 00 	lea    0xd34c(%rip),%rcx        # 415c88 <.LC29>
  40893c:	48 8d 35 d1 fd 00 00 	lea    0xfdd1(%rip),%rsi        # 418714 <.LC30>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408943:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408946:	48 89 df             	mov    %rbx,%rdi
  408949:	48 89 50 08          	mov    %rdx,0x8(%rax)
  40894d:	48 89 c2             	mov    %rax,%rdx
  408950:	e8 6b 14 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408955:	48 89 ef             	mov    %rbp,%rdi
  408958:	be 10 00 00 00       	mov    $0x10,%esi
  40895d:	e8 ae a8 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If available, use the fast frame-pointer-based unwinder on "
            "internal CHECK failures.")
COMMON_FLAG(bool, fast_unwind_on_fatal, false,
  408962:	49 8d 54 24 21       	lea    0x21(%r12),%rdx
  408967:	48 8d 0d 72 d3 00 00 	lea    0xd372(%rip),%rcx        # 415ce0 <.LC31>
  40896e:	48 8d 35 b4 fd 00 00 	lea    0xfdb4(%rip),%rsi        # 418729 <.LC32>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408975:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408978:	48 89 df             	mov    %rbx,%rdi
  40897b:	48 89 50 08          	mov    %rdx,0x8(%rax)
  40897f:	48 89 c2             	mov    %rax,%rdx
  408982:	e8 39 14 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408987:	48 89 ef             	mov    %rbp,%rdi
  40898a:	be 10 00 00 00       	mov    $0x10,%esi
  40898f:	e8 7c a8 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If available, use the fast frame-pointer-based unwinder on fatal "
            "errors.")
COMMON_FLAG(bool, fast_unwind_on_malloc, true,
  408994:	49 8d 54 24 22       	lea    0x22(%r12),%rdx
  408999:	48 8d 0d 90 d3 00 00 	lea    0xd390(%rip),%rcx        # 415d30 <.LC33>
  4089a0:	48 8d 35 97 fd 00 00 	lea    0xfd97(%rip),%rsi        # 41873e <.LC34>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  4089a7:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  4089aa:	48 89 df             	mov    %rbx,%rdi
  4089ad:	48 89 50 08          	mov    %rdx,0x8(%rax)
  4089b1:	48 89 c2             	mov    %rax,%rdx
  4089b4:	e8 07 14 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  4089b9:	48 89 ef             	mov    %rbp,%rdi
  4089bc:	be 10 00 00 00       	mov    $0x10,%esi
  4089c1:	e8 4a a8 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If available, use the fast frame-pointer-based unwinder on "
            "malloc/free.")
COMMON_FLAG(bool, handle_ioctl, false, "Intercept and handle ioctl requests.")
  4089c6:	49 8d 54 24 23       	lea    0x23(%r12),%rdx
  4089cb:	48 8d 0d a6 d3 00 00 	lea    0xd3a6(%rip),%rcx        # 415d78 <.LC35>
  4089d2:	48 8d 35 7b fd 00 00 	lea    0xfd7b(%rip),%rsi        # 418754 <.LC36>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  4089d9:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  4089dc:	48 89 df             	mov    %rbx,%rdi
  4089df:	48 89 50 08          	mov    %rdx,0x8(%rax)
  4089e3:	48 89 c2             	mov    %rax,%rdx
  4089e6:	e8 d5 13 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  4089eb:	48 89 ef             	mov    %rbp,%rdi
  4089ee:	be 10 00 00 00       	mov    $0x10,%esi
  4089f3:	e8 18 a8 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  4089f8:	4c 8d 05 51 84 01 00 	lea    0x18451(%rip),%r8        # 420e50 <_ZTVN11__sanitizer11FlagHandlerIiEE+0x10>
COMMON_FLAG(int, malloc_context_size, 1,
  4089ff:	49 8d 54 24 24       	lea    0x24(%r12),%rdx

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408a04:	48 8d 0d 95 d3 00 00 	lea    0xd395(%rip),%rcx        # 415da0 <.LC37>
  408a0b:	48 8d 35 4f fd 00 00 	lea    0xfd4f(%rip),%rsi        # 418761 <.LC38>
  408a12:	48 89 df             	mov    %rbx,%rdi
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408a15:	4c 89 00             	mov    %r8,(%rax)
  408a18:	48 89 50 08          	mov    %rdx,0x8(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408a1c:	48 89 c2             	mov    %rax,%rdx
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408a1f:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408a24:	e8 97 13 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408a29:	48 89 ef             	mov    %rbp,%rdi
  408a2c:	be 10 00 00 00       	mov    $0x10,%esi
  408a31:	e8 da a7 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "Max number of stack frames kept for each allocation/deallocation.")
COMMON_FLAG(
  408a36:	49 8d 54 24 28       	lea    0x28(%r12),%rdx
  408a3b:	48 8d 0d a6 d3 00 00 	lea    0xd3a6(%rip),%rcx        # 415de8 <.LC39>
  408a42:	48 8d 35 2c fd 00 00 	lea    0xfd2c(%rip),%rsi        # 418775 <.LC40>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408a49:	4c 89 30             	mov    %r14,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408a4c:	48 89 df             	mov    %rbx,%rdi
  408a4f:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408a53:	48 89 c2             	mov    %rax,%rdx
  408a56:	e8 65 13 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408a5b:	48 89 ef             	mov    %rbp,%rdi
  408a5e:	be 10 00 00 00       	mov    $0x10,%esi
  408a63:	e8 a8 a7 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
    const char *, log_path, "stderr",
    "Write logs to \"log_path.pid\". The special values are \"stdout\" and "
    "\"stderr\". The default is \"stderr\".")
COMMON_FLAG(
  408a68:	49 8d 54 24 30       	lea    0x30(%r12),%rdx
  408a6d:	48 8d 0d dc d3 00 00 	lea    0xd3dc(%rip),%rcx        # 415e50 <.LC41>
  408a74:	48 8d 35 03 fd 00 00 	lea    0xfd03(%rip),%rsi        # 41877e <.LC42>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408a7b:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408a7e:	48 89 df             	mov    %rbx,%rdi
  408a81:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408a85:	48 89 c2             	mov    %rax,%rdx
  408a88:	e8 33 13 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408a8d:	48 89 ef             	mov    %rbp,%rdi
  408a90:	be 10 00 00 00       	mov    $0x10,%esi
  408a95:	e8 76 a7 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
    bool, log_exe_name, false,
    "Mention name of executable when reporting error and "
    "append executable name to logs (as in \"log_path.exe_name.pid\").")
COMMON_FLAG(
  408a9a:	49 8d 54 24 31       	lea    0x31(%r12),%rdx
  408a9f:	48 8d 0d 22 d4 00 00 	lea    0xd422(%rip),%rcx        # 415ec8 <.LC43>
  408aa6:	48 8d 35 de fc 00 00 	lea    0xfcde(%rip),%rsi        # 41878b <.LC44>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408aad:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408ab0:	48 89 df             	mov    %rbx,%rdi
  408ab3:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408ab7:	48 89 c2             	mov    %rax,%rdx
  408aba:	e8 01 13 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408abf:	48 89 ef             	mov    %rbp,%rdi
  408ac2:	be 10 00 00 00       	mov    $0x10,%esi
  408ac7:	e8 44 a7 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408acc:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
    bool, log_to_syslog, SANITIZER_ANDROID,
    "Write all sanitizer output to syslog in addition to other means of "
    "logging.")
COMMON_FLAG(
  408ad1:	49 8d 54 24 34       	lea    0x34(%r12),%rdx

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408ad6:	48 8d 0d 3b d4 00 00 	lea    0xd43b(%rip),%rcx        # 415f18 <.LC45>
  408add:	48 8d 35 b5 fc 00 00 	lea    0xfcb5(%rip),%rsi        # 418799 <.LC46>
  408ae4:	48 89 df             	mov    %rbx,%rdi
  408ae7:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408aeb:	48 89 c2             	mov    %rax,%rdx
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408aee:	4c 89 00             	mov    %r8,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408af1:	e8 ca 12 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408af6:	48 89 ef             	mov    %rbp,%rdi
  408af9:	be 10 00 00 00       	mov    $0x10,%esi
  408afe:	e8 0d a7 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
    int, verbosity, 0,
    "Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).")
COMMON_FLAG(bool, detect_leaks, true, "Enable memory leak detection.")
  408b03:	49 8d 54 24 38       	lea    0x38(%r12),%rdx
  408b08:	48 8d 0d 94 fc 00 00 	lea    0xfc94(%rip),%rcx        # 4187a3 <.LC47>
  408b0f:	48 8d 35 ab fc 00 00 	lea    0xfcab(%rip),%rsi        # 4187c1 <.LC48>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408b16:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408b19:	48 89 df             	mov    %rbx,%rdi
  408b1c:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408b20:	48 89 c2             	mov    %rax,%rdx
  408b23:	e8 98 12 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408b28:	48 89 ef             	mov    %rbp,%rdi
  408b2b:	be 10 00 00 00       	mov    $0x10,%esi
  408b30:	e8 db a6 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
COMMON_FLAG(
  408b35:	49 8d 54 24 39       	lea    0x39(%r12),%rdx
  408b3a:	48 8d 0d 1f d4 00 00 	lea    0xd41f(%rip),%rcx        # 415f60 <.LC49>
  408b41:	48 8d 35 86 fc 00 00 	lea    0xfc86(%rip),%rsi        # 4187ce <.LC50>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408b48:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408b4b:	48 89 df             	mov    %rbx,%rdi
  408b4e:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408b52:	48 89 c2             	mov    %rax,%rdx
  408b55:	e8 66 12 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408b5a:	48 89 ef             	mov    %rbp,%rdi
  408b5d:	be 10 00 00 00       	mov    $0x10,%esi
  408b62:	e8 a9 a6 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
    bool, leak_check_at_exit, true,
    "Invoke leak checking in an atexit handler. Has no effect if "
    "detect_leaks=false, or if __lsan_do_leak_check() is called before the "
    "handler has a chance to run.")
COMMON_FLAG(bool, allocator_may_return_null, false,
  408b67:	49 8d 54 24 3a       	lea    0x3a(%r12),%rdx
  408b6c:	48 8d 0d 8d d4 00 00 	lea    0xd48d(%rip),%rcx        # 416000 <.LC51>
  408b73:	48 8d 35 67 fc 00 00 	lea    0xfc67(%rip),%rsi        # 4187e1 <.LC52>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408b7a:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408b7d:	48 89 df             	mov    %rbx,%rdi
  408b80:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408b84:	48 89 c2             	mov    %rax,%rdx
  408b87:	e8 34 12 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408b8c:	48 89 ef             	mov    %rbp,%rdi
  408b8f:	be 10 00 00 00       	mov    $0x10,%esi
  408b94:	e8 77 a6 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If false, the allocator will crash instead of returning 0 on "
            "out-of-memory.")
COMMON_FLAG(bool, print_summary, true,
  408b99:	49 8d 54 24 3b       	lea    0x3b(%r12),%rdx
  408b9e:	48 8d 0d ab d4 00 00 	lea    0xd4ab(%rip),%rcx        # 416050 <.LC53>
  408ba5:	48 8d 35 4f fc 00 00 	lea    0xfc4f(%rip),%rsi        # 4187fb <.LC54>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408bac:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408baf:	48 89 df             	mov    %rbx,%rdi
  408bb2:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408bb6:	48 89 c2             	mov    %rax,%rdx
  408bb9:	e8 02 12 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408bbe:	48 89 ef             	mov    %rbp,%rdi
  408bc1:	be 10 00 00 00       	mov    $0x10,%esi
  408bc6:	e8 45 a6 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If false, disable printing error summaries in addition to error "
            "reports.")
COMMON_FLAG(bool, check_printf, true, "Check printf arguments.")
  408bcb:	49 8d 54 24 3c       	lea    0x3c(%r12),%rdx
  408bd0:	48 8d 0d 32 fc 00 00 	lea    0xfc32(%rip),%rcx        # 418809 <.LC55>
  408bd7:	48 8d 35 43 fc 00 00 	lea    0xfc43(%rip),%rsi        # 418821 <.LC56>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408bde:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408be1:	48 89 df             	mov    %rbx,%rdi
  408be4:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408be8:	48 89 c2             	mov    %rax,%rdx
  408beb:	e8 d0 11 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408bf0:	48 89 ef             	mov    %rbp,%rdi
  408bf3:	be 10 00 00 00       	mov    $0x10,%esi
  408bf8:	e8 13 a6 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
COMMON_FLAG(bool, handle_segv, SANITIZER_NEEDS_SEGV,
  408bfd:	49 8d 54 24 3d       	lea    0x3d(%r12),%rdx
  408c02:	48 8d 0d 97 d4 00 00 	lea    0xd497(%rip),%rcx        # 4160a0 <.LC57>
  408c09:	48 8d 35 1e fc 00 00 	lea    0xfc1e(%rip),%rsi        # 41882e <.LC58>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408c10:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408c13:	48 89 df             	mov    %rbx,%rdi
  408c16:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408c1a:	48 89 c2             	mov    %rax,%rdx
  408c1d:	e8 9e 11 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408c22:	48 89 ef             	mov    %rbp,%rdi
  408c25:	be 10 00 00 00       	mov    $0x10,%esi
  408c2a:	e8 e1 a5 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set, registers the tool's custom SIGSEGV/SIGBUS handler.")
COMMON_FLAG(bool, handle_abort, false,
  408c2f:	49 8d 54 24 3e       	lea    0x3e(%r12),%rdx
  408c34:	48 8d 0d a5 d4 00 00 	lea    0xd4a5(%rip),%rcx        # 4160e0 <.LC59>
  408c3b:	48 8d 35 f8 fb 00 00 	lea    0xfbf8(%rip),%rsi        # 41883a <.LC60>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408c42:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408c45:	48 89 df             	mov    %rbx,%rdi
  408c48:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408c4c:	48 89 c2             	mov    %rax,%rdx
  408c4f:	e8 6c 11 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408c54:	48 89 ef             	mov    %rbp,%rdi
  408c57:	be 10 00 00 00       	mov    $0x10,%esi
  408c5c:	e8 af a5 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set, registers the tool's custom SIGABRT handler.")
COMMON_FLAG(bool, handle_sigfpe, true,
  408c61:	49 8d 54 24 3f       	lea    0x3f(%r12),%rdx
  408c66:	48 8d 0d ab d4 00 00 	lea    0xd4ab(%rip),%rcx        # 416118 <.LC61>
  408c6d:	48 8d 35 d3 fb 00 00 	lea    0xfbd3(%rip),%rsi        # 418847 <.LC62>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408c74:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408c77:	48 89 df             	mov    %rbx,%rdi
  408c7a:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408c7e:	48 89 c2             	mov    %rax,%rdx
  408c81:	e8 3a 11 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408c86:	48 89 ef             	mov    %rbp,%rdi
  408c89:	be 10 00 00 00       	mov    $0x10,%esi
  408c8e:	e8 7d a5 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set, registers the tool's custom SIGFPE handler.")
COMMON_FLAG(bool, allow_user_segv_handler, false,
  408c93:	49 8d 54 24 40       	lea    0x40(%r12),%rdx
  408c98:	48 8d 0d b1 d4 00 00 	lea    0xd4b1(%rip),%rcx        # 416150 <.LC63>
  408c9f:	48 8d 35 af fb 00 00 	lea    0xfbaf(%rip),%rsi        # 418855 <.LC64>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408ca6:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408ca9:	48 89 df             	mov    %rbx,%rdi
  408cac:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408cb0:	48 89 c2             	mov    %rax,%rdx
  408cb3:	e8 08 11 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408cb8:	48 89 ef             	mov    %rbp,%rdi
  408cbb:	be 10 00 00 00       	mov    $0x10,%esi
  408cc0:	e8 4b a5 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set, allows user to register a SEGV handler even if the tool "
            "registers one.")
COMMON_FLAG(bool, use_sigaltstack, true,
  408cc5:	49 8d 54 24 41       	lea    0x41(%r12),%rdx
  408cca:	48 8d 0d cf d4 00 00 	lea    0xd4cf(%rip),%rcx        # 4161a0 <.LC65>
  408cd1:	48 8d 35 95 fb 00 00 	lea    0xfb95(%rip),%rsi        # 41886d <.LC66>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408cd8:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408cdb:	48 89 df             	mov    %rbx,%rdi
  408cde:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408ce2:	48 89 c2             	mov    %rax,%rdx
  408ce5:	e8 d6 10 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408cea:	48 89 ef             	mov    %rbp,%rdi
  408ced:	be 10 00 00 00       	mov    $0x10,%esi
  408cf2:	e8 19 a5 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set, uses alternate stack for signal handling.")
COMMON_FLAG(bool, detect_deadlocks, false,
  408cf7:	49 8d 54 24 42       	lea    0x42(%r12),%rdx
  408cfc:	48 8d 0d d5 d4 00 00 	lea    0xd4d5(%rip),%rcx        # 4161d8 <.LC67>
  408d03:	48 8d 35 73 fb 00 00 	lea    0xfb73(%rip),%rsi        # 41887d <.LC68>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408d0a:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408d0d:	48 89 df             	mov    %rbx,%rdi
  408d10:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408d14:	48 89 c2             	mov    %rax,%rdx
  408d17:	e8 a4 10 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408d1c:	48 89 ef             	mov    %rbp,%rdi
  408d1f:	be 10 00 00 00       	mov    $0x10,%esi
  408d24:	e8 e7 a4 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set, deadlock detection is enabled.")
COMMON_FLAG(
  408d29:	49 8d 54 24 48       	lea    0x48(%r12),%rdx
  408d2e:	48 8d 0d cb d4 00 00 	lea    0xd4cb(%rip),%rcx        # 416200 <.LC69>
  408d35:	48 8d 35 52 fb 00 00 	lea    0xfb52(%rip),%rsi        # 41888e <.LC70>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408d3c:	4c 89 38             	mov    %r15,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408d3f:	48 89 df             	mov    %rbx,%rdi
  408d42:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408d46:	48 89 c2             	mov    %rax,%rdx
  408d49:	e8 72 10 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408d4e:	48 89 ef             	mov    %rbp,%rdi
  408d51:	be 10 00 00 00       	mov    $0x10,%esi
  408d56:	e8 b5 a4 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
    uptr, clear_shadow_mmap_threshold, 64 * 1024,
    "Large shadow regions are zero-filled using mmap(NORESERVE) instead of "
    "memset(). This is the threshold size in bytes.")
COMMON_FLAG(const char *, color, "auto",
  408d5b:	49 8d 54 24 50       	lea    0x50(%r12),%rdx
  408d60:	48 8d 0d 11 d5 00 00 	lea    0xd511(%rip),%rcx        # 416278 <.LC71>
  408d67:	48 8d 35 3c fb 00 00 	lea    0xfb3c(%rip),%rsi        # 4188aa <.LC72>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408d6e:	4c 89 30             	mov    %r14,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408d71:	48 89 df             	mov    %rbx,%rdi
  408d74:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408d78:	48 89 c2             	mov    %rax,%rdx
  408d7b:	e8 40 10 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408d80:	48 89 ef             	mov    %rbp,%rdi
  408d83:	be 10 00 00 00       	mov    $0x10,%esi
  408d88:	e8 83 a4 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "Colorize reports: (always|never|auto).")
COMMON_FLAG(
  408d8d:	49 8d 54 24 58       	lea    0x58(%r12),%rdx
  408d92:	48 8d 0d 07 d5 00 00 	lea    0xd507(%rip),%rcx        # 4162a0 <.LC73>
  408d99:	48 8d 35 10 fb 00 00 	lea    0xfb10(%rip),%rsi        # 4188b0 <.LC74>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408da0:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408da3:	48 89 df             	mov    %rbx,%rdi
  408da6:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408daa:	48 89 c2             	mov    %rax,%rdx
  408dad:	e8 0e 10 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408db2:	48 89 ef             	mov    %rbp,%rdi
  408db5:	be 10 00 00 00       	mov    $0x10,%esi
  408dba:	e8 51 a4 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
    bool, legacy_pthread_cond, false,
    "Enables support for dynamic libraries linked with libpthread 2.2.5.")
COMMON_FLAG(bool, intercept_tls_get_addr, false, "Intercept __tls_get_addr.")
  408dbf:	49 8d 54 24 59       	lea    0x59(%r12),%rdx
  408dc4:	48 8d 0d f9 fa 00 00 	lea    0xfaf9(%rip),%rcx        # 4188c4 <.LC75>
  408dcb:	48 8d 35 0c fb 00 00 	lea    0xfb0c(%rip),%rsi        # 4188de <.LC76>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408dd2:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408dd5:	48 89 df             	mov    %rbx,%rdi
  408dd8:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408ddc:	48 89 c2             	mov    %rax,%rdx
  408ddf:	e8 dc 0f 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408de4:	48 89 ef             	mov    %rbp,%rdi
  408de7:	be 10 00 00 00       	mov    $0x10,%esi
  408dec:	e8 1f a4 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
COMMON_FLAG(bool, help, false, "Print the flag descriptions.")
  408df1:	49 8d 54 24 5a       	lea    0x5a(%r12),%rdx
  408df6:	48 8d 0d f8 fa 00 00 	lea    0xfaf8(%rip),%rcx        # 4188f5 <.LC77>
  408dfd:	48 8d 35 0e fb 00 00 	lea    0xfb0e(%rip),%rsi        # 418912 <.LC78>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408e04:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408e07:	48 89 df             	mov    %rbx,%rdi
  408e0a:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408e0e:	48 89 c2             	mov    %rax,%rdx
  408e11:	e8 aa 0f 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408e16:	48 89 ef             	mov    %rbp,%rdi
  408e19:	be 10 00 00 00       	mov    $0x10,%esi
  408e1e:	e8 ed a3 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
COMMON_FLAG(uptr, mmap_limit_mb, 0,
  408e23:	49 8d 54 24 60       	lea    0x60(%r12),%rdx
  408e28:	48 8d 0d b9 d4 00 00 	lea    0xd4b9(%rip),%rcx        # 4162e8 <.LC79>
  408e2f:	48 8d 35 e1 fa 00 00 	lea    0xfae1(%rip),%rsi        # 418917 <.LC80>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408e36:	4c 89 38             	mov    %r15,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408e39:	48 89 df             	mov    %rbx,%rdi
  408e3c:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408e40:	48 89 c2             	mov    %rax,%rdx
  408e43:	e8 78 0f 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408e48:	48 89 ef             	mov    %rbp,%rdi
  408e4b:	be 10 00 00 00       	mov    $0x10,%esi
  408e50:	e8 bb a3 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "Limit the amount of mmap-ed memory (excluding shadow) in Mb; "
            "not a user-facing flag, used mosly for testing the tools")
COMMON_FLAG(uptr, hard_rss_limit_mb, 0,
  408e55:	49 8d 54 24 68       	lea    0x68(%r12),%rdx
  408e5a:	48 8d 0d ff d4 00 00 	lea    0xd4ff(%rip),%rcx        # 416360 <.LC81>
  408e61:	48 8d 35 bd fa 00 00 	lea    0xfabd(%rip),%rsi        # 418925 <.LC82>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408e68:	4c 89 38             	mov    %r15,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408e6b:	48 89 df             	mov    %rbx,%rdi
  408e6e:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408e72:	48 89 c2             	mov    %rax,%rdx
  408e75:	e8 46 0f 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408e7a:	48 89 ef             	mov    %rbp,%rdi
  408e7d:	be 10 00 00 00       	mov    $0x10,%esi
  408e82:	e8 89 a3 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "Hard RSS limit in Mb."
            " If non-zero, a background thread is spawned at startup"
            " which periodically reads RSS and aborts the process if the"
            " limit is reached")
COMMON_FLAG(uptr, soft_rss_limit_mb, 0,
  408e87:	49 8d 54 24 70       	lea    0x70(%r12),%rdx
  408e8c:	48 8d 0d 6d d5 00 00 	lea    0xd56d(%rip),%rcx        # 416400 <.LC83>
  408e93:	48 8d 35 9d fa 00 00 	lea    0xfa9d(%rip),%rsi        # 418937 <.LC84>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408e9a:	4c 89 38             	mov    %r15,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408e9d:	48 89 df             	mov    %rbx,%rdi
  408ea0:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408ea4:	48 89 c2             	mov    %rax,%rdx
  408ea7:	e8 14 0f 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408eac:	48 89 ef             	mov    %rbp,%rdi
  408eaf:	be 10 00 00 00       	mov    $0x10,%esi
  408eb4:	e8 57 a3 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            " all subsequent malloc/new calls will fail or return NULL"
            " (depending on the value of allocator_may_return_null)"
            " until the RSS goes below the soft limit."
            " This limit does not affect memory allocations other than"
            " malloc/new.")
COMMON_FLAG(bool, can_use_proc_maps_statm, true,
  408eb9:	49 8d 54 24 78       	lea    0x78(%r12),%rdx
  408ebe:	48 8d 0d 9b d6 00 00 	lea    0xd69b(%rip),%rcx        # 416560 <.LC85>
  408ec5:	48 8d 35 7d fa 00 00 	lea    0xfa7d(%rip),%rsi        # 418949 <.LC86>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408ecc:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408ecf:	48 89 df             	mov    %rbx,%rdi
  408ed2:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408ed6:	48 89 c2             	mov    %rax,%rdx
  408ed9:	e8 e2 0e 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408ede:	48 89 ef             	mov    %rbp,%rdi
  408ee1:	be 10 00 00 00       	mov    $0x10,%esi
  408ee6:	e8 25 a3 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If false, do not attempt to read /proc/maps/statm."
            " Mostly useful for testing sanitizers.")
COMMON_FLAG(
  408eeb:	49 8d 54 24 79       	lea    0x79(%r12),%rdx
  408ef0:	48 8d 0d c9 d6 00 00 	lea    0xd6c9(%rip),%rcx        # 4165c0 <.LC87>
  408ef7:	48 8d 35 63 fa 00 00 	lea    0xfa63(%rip),%rsi        # 418961 <.LC88>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408efe:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408f01:	48 89 df             	mov    %rbx,%rdi
  408f04:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408f08:	48 89 c2             	mov    %rax,%rdx
  408f0b:	e8 b0 0e 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408f10:	48 89 ef             	mov    %rbp,%rdi
  408f13:	be 10 00 00 00       	mov    $0x10,%esi
  408f18:	e8 f3 a2 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
    bool, coverage, false,
    "If set, coverage information will be dumped at program shutdown (if the "
    "coverage instrumentation was enabled at compile time).")
COMMON_FLAG(bool, coverage_pcs, true,
  408f1d:	49 8d 54 24 7a       	lea    0x7a(%r12),%rdx
  408f22:	48 8d 0d 17 d7 00 00 	lea    0xd717(%rip),%rcx        # 416640 <.LC89>
  408f29:	48 8d 35 3a fa 00 00 	lea    0xfa3a(%rip),%rsi        # 41896a <.LC90>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408f30:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408f33:	48 89 df             	mov    %rbx,%rdi
  408f36:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408f3a:	48 89 c2             	mov    %rax,%rdx
  408f3d:	e8 7e 0e 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408f42:	48 89 ef             	mov    %rbp,%rdi
  408f45:	be 10 00 00 00       	mov    $0x10,%esi
  408f4a:	e8 c1 a2 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set (and if 'coverage' is set too), the coverage information "
            "will be dumped as a set of PC offsets for every module.")
COMMON_FLAG(bool, coverage_order_pcs, false,
  408f4f:	49 8d 54 24 7b       	lea    0x7b(%r12),%rdx
  408f54:	48 8d 0d 5d d7 00 00 	lea    0xd75d(%rip),%rcx        # 4166b8 <.LC91>
  408f5b:	48 8d 35 15 fa 00 00 	lea    0xfa15(%rip),%rsi        # 418977 <.LC92>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408f62:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408f65:	48 89 df             	mov    %rbx,%rdi
  408f68:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408f6c:	48 89 c2             	mov    %rax,%rdx
  408f6f:	e8 4c 0e 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408f74:	48 89 ef             	mov    %rbp,%rdi
  408f77:	be 10 00 00 00       	mov    $0x10,%esi
  408f7c:	e8 8f a2 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
             "If true, the PCs will be dumped in the order they've"
             " appeared during the execution.")
COMMON_FLAG(bool, coverage_bitset, false,
  408f81:	49 8d 54 24 7c       	lea    0x7c(%r12),%rdx
  408f86:	48 8d 0d 83 d7 00 00 	lea    0xd783(%rip),%rcx        # 416710 <.LC93>
  408f8d:	48 8d 35 f6 f9 00 00 	lea    0xf9f6(%rip),%rsi        # 41898a <.LC94>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408f94:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408f97:	48 89 df             	mov    %rbx,%rdi
  408f9a:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408f9e:	48 89 c2             	mov    %rax,%rdx
  408fa1:	e8 1a 0e 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408fa6:	48 89 ef             	mov    %rbp,%rdi
  408fa9:	be 10 00 00 00       	mov    $0x10,%esi
  408fae:	e8 5d a2 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set (and if 'coverage' is set too), the coverage information "
            "will also be dumped as a bitset to a separate file.")
COMMON_FLAG(bool, coverage_counters, false,
  408fb3:	49 8d 54 24 7d       	lea    0x7d(%r12),%rdx
  408fb8:	48 8d 0d c9 d7 00 00 	lea    0xd7c9(%rip),%rcx        # 416788 <.LC95>
  408fbf:	48 8d 35 d4 f9 00 00 	lea    0xf9d4(%rip),%rsi        # 41899a <.LC96>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408fc6:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408fc9:	48 89 df             	mov    %rbx,%rdi
  408fcc:	48 89 50 08          	mov    %rdx,0x8(%rax)
  408fd0:	48 89 c2             	mov    %rax,%rdx
  408fd3:	e8 e8 0d 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  408fd8:	48 89 ef             	mov    %rbp,%rdi
  408fdb:	be 10 00 00 00       	mov    $0x10,%esi
  408fe0:	e8 2b a2 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set (and if 'coverage' is set too), the bitmap that corresponds"
            " to coverage counters will be dumped.")
COMMON_FLAG(bool, coverage_direct, SANITIZER_ANDROID,
  408fe5:	49 8d 54 24 7e       	lea    0x7e(%r12),%rdx
  408fea:	48 8d 0d ff d7 00 00 	lea    0xd7ff(%rip),%rcx        # 4167f0 <.LC97>
  408ff1:	48 8d 35 b4 f9 00 00 	lea    0xf9b4(%rip),%rsi        # 4189ac <.LC98>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  408ff8:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  408ffb:	48 89 df             	mov    %rbx,%rdi
  408ffe:	48 89 50 08          	mov    %rdx,0x8(%rax)
  409002:	48 89 c2             	mov    %rax,%rdx
  409005:	e8 b6 0d 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  40900a:	48 89 ef             	mov    %rbp,%rdi
  40900d:	be 10 00 00 00       	mov    $0x10,%esi
  409012:	e8 f9 a1 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set, coverage information will be dumped directly to a memory "
            "mapped file. This way data is not lost even if the process is "
            "suddenly killed.")
COMMON_FLAG(const char *, coverage_dir, ".",
  409017:	49 8d 94 24 80 00 00 	lea    0x80(%r12),%rdx
  40901e:	00 
  40901f:	48 8d 0d 5a d8 00 00 	lea    0xd85a(%rip),%rcx        # 416880 <.LC99>
  409026:	48 8d 35 8f f9 00 00 	lea    0xf98f(%rip),%rsi        # 4189bc <.LC100>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  40902d:	4c 89 30             	mov    %r14,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  409030:	48 89 df             	mov    %rbx,%rdi
  409033:	48 89 50 08          	mov    %rdx,0x8(%rax)
  409037:	48 89 c2             	mov    %rax,%rdx
  40903a:	e8 81 0d 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  40903f:	48 89 ef             	mov    %rbp,%rdi
  409042:	be 10 00 00 00       	mov    $0x10,%esi
  409047:	e8 c4 a1 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "Target directory for coverage dumps. Defaults to the current "
            "directory.")
COMMON_FLAG(bool, full_address_space, false,
  40904c:	49 8d 94 24 88 00 00 	lea    0x88(%r12),%rdx
  409053:	00 
  409054:	48 8d 0d 6d d8 00 00 	lea    0xd86d(%rip),%rcx        # 4168c8 <.LC101>
  40905b:	48 8d 35 67 f9 00 00 	lea    0xf967(%rip),%rsi        # 4189c9 <.LC102>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  409062:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  409065:	48 89 df             	mov    %rbx,%rdi
  409068:	48 89 50 08          	mov    %rdx,0x8(%rax)
  40906c:	48 89 c2             	mov    %rax,%rdx
  40906f:	e8 4c 0d 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  409074:	48 89 ef             	mov    %rbp,%rdi
  409077:	be 10 00 00 00       	mov    $0x10,%esi
  40907c:	e8 8f a1 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "Sanitize complete address space; "
            "by default kernel area on 32-bit platforms will not be sanitized")
COMMON_FLAG(bool, print_suppressions, true,
  409081:	49 8d 94 24 89 00 00 	lea    0x89(%r12),%rdx
  409088:	00 
  409089:	48 8d 0d a0 d8 00 00 	lea    0xd8a0(%rip),%rcx        # 416930 <.LC103>
  409090:	48 8d 35 45 f9 00 00 	lea    0xf945(%rip),%rsi        # 4189dc <.LC104>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  409097:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  40909a:	48 89 df             	mov    %rbx,%rdi
  40909d:	48 89 50 08          	mov    %rdx,0x8(%rax)
  4090a1:	48 89 c2             	mov    %rax,%rdx
  4090a4:	e8 17 0d 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  4090a9:	48 89 ef             	mov    %rbp,%rdi
  4090ac:	be 10 00 00 00       	mov    $0x10,%esi
  4090b1:	e8 5a a1 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "Print matched suppressions at exit.")
COMMON_FLAG(
  4090b6:	49 8d 94 24 8a 00 00 	lea    0x8a(%r12),%rdx
  4090bd:	00 
  4090be:	48 8d 0d 93 d8 00 00 	lea    0xd893(%rip),%rcx        # 416958 <.LC105>
  4090c5:	48 8d 35 23 f9 00 00 	lea    0xf923(%rip),%rsi        # 4189ef <.LC106>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  4090cc:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  4090cf:	48 89 df             	mov    %rbx,%rdi
  4090d2:	48 89 50 08          	mov    %rdx,0x8(%rax)
  4090d6:	48 89 c2             	mov    %rax,%rdx
  4090d9:	e8 e2 0c 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  4090de:	48 89 ef             	mov    %rbp,%rdi
  4090e1:	be 10 00 00 00       	mov    $0x10,%esi
  4090e6:	e8 25 a1 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
    bool, disable_coredump, (SANITIZER_WORDSIZE == 64),
    "Disable core dumping. By default, disable_core=1 on 64-bit to avoid "
    "dumping a 16T+ core file. Ignored on OSes that don't dump core by"
    "default and for sanitizers that don't reserve lots of virtual memory.")
COMMON_FLAG(bool, use_madv_dontdump, true,
  4090eb:	49 8d 94 24 8b 00 00 	lea    0x8b(%r12),%rdx
  4090f2:	00 
  4090f3:	48 8d 0d 2e d9 00 00 	lea    0xd92e(%rip),%rcx        # 416a28 <.LC107>
  4090fa:	48 8d 35 ff f8 00 00 	lea    0xf8ff(%rip),%rsi        # 418a00 <.LC108>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  409101:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  409104:	48 89 df             	mov    %rbx,%rdi
  409107:	48 89 50 08          	mov    %rdx,0x8(%rax)
  40910b:	48 89 c2             	mov    %rax,%rdx
  40910e:	e8 ad 0c 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  409113:	48 89 ef             	mov    %rbp,%rdi
  409116:	be 10 00 00 00       	mov    $0x10,%esi
  40911b:	e8 f0 a0 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
          "If set, instructs kernel to not store the (huge) shadow "
          "in core file.")
COMMON_FLAG(bool, symbolize_inline_frames, true,
  409120:	49 8d 94 24 8c 00 00 	lea    0x8c(%r12),%rdx
  409127:	00 
  409128:	48 8d 0d 41 d9 00 00 	lea    0xd941(%rip),%rcx        # 416a70 <.LC109>
  40912f:	48 8d 35 dc f8 00 00 	lea    0xf8dc(%rip),%rsi        # 418a12 <.LC110>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  409136:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  409139:	48 89 df             	mov    %rbx,%rdi
  40913c:	48 89 50 08          	mov    %rdx,0x8(%rax)
  409140:	48 89 c2             	mov    %rax,%rdx
  409143:	e8 78 0c 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  409148:	48 89 ef             	mov    %rbp,%rdi
  40914b:	be 10 00 00 00       	mov    $0x10,%esi
  409150:	e8 bb a0 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "Print inlined frames in stacktraces. Defaults to true.")
COMMON_FLAG(bool, symbolize_vs_style, false,
  409155:	49 8d 94 24 8d 00 00 	lea    0x8d(%r12),%rdx
  40915c:	00 
  40915d:	48 8d 0d 44 d9 00 00 	lea    0xd944(%rip),%rcx        # 416aa8 <.LC111>
  409164:	48 8d 35 bf f8 00 00 	lea    0xf8bf(%rip),%rsi        # 418a2a <.LC112>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  40916b:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  40916e:	48 89 df             	mov    %rbx,%rdi
  409171:	48 89 50 08          	mov    %rdx,0x8(%rax)
  409175:	48 89 c2             	mov    %rax,%rdx
  409178:	e8 43 0c 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  40917d:	48 89 ef             	mov    %rbp,%rdi
  409180:	be 10 00 00 00       	mov    $0x10,%esi
  409185:	e8 86 a0 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "Print file locations in Visual Studio style (e.g: "
            " file(10,42): ...")
COMMON_FLAG(const char *, stack_trace_format, "DEFAULT",
  40918a:	49 8d 94 24 90 00 00 	lea    0x90(%r12),%rdx
  409191:	00 
  409192:	48 8d 0d 57 d9 00 00 	lea    0xd957(%rip),%rcx        # 416af0 <.LC113>
  409199:	48 8d 35 9d f8 00 00 	lea    0xf89d(%rip),%rsi        # 418a3d <.LC114>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  4091a0:	4c 89 30             	mov    %r14,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  4091a3:	48 89 df             	mov    %rbx,%rdi
  4091a6:	48 89 50 08          	mov    %rdx,0x8(%rax)
  4091aa:	48 89 c2             	mov    %rax,%rdx
  4091ad:	e8 0e 0c 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  4091b2:	48 89 ef             	mov    %rbp,%rdi
  4091b5:	be 10 00 00 00       	mov    $0x10,%esi
  4091ba:	e8 51 a0 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "Format string used to render stack frames. "
            "See sanitizer_stacktrace_printer.h for the format description. "
            "Use DEFAULT to get default format.")
COMMON_FLAG(bool, no_huge_pages_for_shadow, true,
  4091bf:	49 8d 94 24 98 00 00 	lea    0x98(%r12),%rdx
  4091c6:	00 
  4091c7:	48 8d 0d b2 d9 00 00 	lea    0xd9b2(%rip),%rcx        # 416b80 <.LC115>
  4091ce:	48 8d 35 7b f8 00 00 	lea    0xf87b(%rip),%rsi        # 418a50 <.LC116>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  4091d5:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  4091d8:	48 89 df             	mov    %rbx,%rdi
  4091db:	48 89 50 08          	mov    %rdx,0x8(%rax)
  4091df:	48 89 c2             	mov    %rax,%rdx
  4091e2:	e8 d9 0b 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  4091e7:	48 89 ef             	mov    %rbp,%rdi
  4091ea:	be 10 00 00 00       	mov    $0x10,%esi
  4091ef:	e8 1c a0 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If true, the shadow is not allowed to use huge pages. ")
COMMON_FLAG(bool, strict_string_checks, false,
  4091f4:	49 8d 94 24 99 00 00 	lea    0x99(%r12),%rdx
  4091fb:	00 
  4091fc:	48 8d 0d b5 d9 00 00 	lea    0xd9b5(%rip),%rcx        # 416bb8 <.LC117>
  409203:	48 8d 35 5f f8 00 00 	lea    0xf85f(%rip),%rsi        # 418a69 <.LC118>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  40920a:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  40920d:	48 89 df             	mov    %rbx,%rdi
  409210:	48 89 50 08          	mov    %rdx,0x8(%rax)
  409214:	48 89 c2             	mov    %rax,%rdx
  409217:	e8 a4 0b 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  40921c:	48 89 ef             	mov    %rbp,%rdi
  40921f:	be 10 00 00 00       	mov    $0x10,%esi
  409224:	e8 e7 9f ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set check that string arguments are properly null-terminated")
COMMON_FLAG(bool, intercept_strstr, true,
  409229:	49 8d 94 24 9a 00 00 	lea    0x9a(%r12),%rdx
  409230:	00 
  409231:	48 8d 0d c0 d9 00 00 	lea    0xd9c0(%rip),%rcx        # 416bf8 <.LC119>
  409238:	48 8d 35 3f f8 00 00 	lea    0xf83f(%rip),%rsi        # 418a7e <.LC120>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  40923f:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  409242:	48 89 df             	mov    %rbx,%rdi
  409245:	48 89 50 08          	mov    %rdx,0x8(%rax)
  409249:	48 89 c2             	mov    %rax,%rdx
  40924c:	e8 6f 0b 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  409251:	48 89 ef             	mov    %rbp,%rdi
  409254:	be 10 00 00 00       	mov    $0x10,%esi
  409259:	e8 b2 9f ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set, uses custom wrappers for strstr and strcasestr functions "
            "to find more errors.")
COMMON_FLAG(bool, intercept_strspn, true,
  40925e:	49 8d 94 24 9b 00 00 	lea    0x9b(%r12),%rdx
  409265:	00 
  409266:	48 8d 0d e3 d9 00 00 	lea    0xd9e3(%rip),%rcx        # 416c50 <.LC121>
  40926d:	48 8d 35 1b f8 00 00 	lea    0xf81b(%rip),%rsi        # 418a8f <.LC122>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  409274:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  409277:	48 89 df             	mov    %rbx,%rdi
  40927a:	48 89 50 08          	mov    %rdx,0x8(%rax)
  40927e:	48 89 c2             	mov    %rax,%rdx
  409281:	e8 3a 0b 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  409286:	48 89 ef             	mov    %rbp,%rdi
  409289:	be 10 00 00 00       	mov    $0x10,%esi
  40928e:	e8 7d 9f ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set, uses custom wrappers for strspn and strcspn function "
            "to find more errors.")
COMMON_FLAG(bool, intercept_strpbrk, true,
  409293:	49 8d 94 24 9c 00 00 	lea    0x9c(%r12),%rdx
  40929a:	00 
  40929b:	48 8d 0d 06 da 00 00 	lea    0xda06(%rip),%rcx        # 416ca8 <.LC123>
  4092a2:	48 8d 35 f7 f7 00 00 	lea    0xf7f7(%rip),%rsi        # 418aa0 <.LC124>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  4092a9:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  4092ac:	48 89 df             	mov    %rbx,%rdi
  4092af:	48 89 50 08          	mov    %rdx,0x8(%rax)
  4092b3:	48 89 c2             	mov    %rax,%rdx
  4092b6:	e8 05 0b 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  4092bb:	48 89 ef             	mov    %rbp,%rdi
  4092be:	be 10 00 00 00       	mov    $0x10,%esi
  4092c3:	e8 48 9f ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set, uses custom wrappers for strpbrk function "
            "to find more errors.")
COMMON_FLAG(bool, intercept_memcmp, true,
  4092c8:	49 8d 94 24 9d 00 00 	lea    0x9d(%r12),%rdx
  4092cf:	00 
  4092d0:	48 8d 0d 19 da 00 00 	lea    0xda19(%rip),%rcx        # 416cf0 <.LC125>
  4092d7:	48 8d 35 d4 f7 00 00 	lea    0xf7d4(%rip),%rsi        # 418ab2 <.LC126>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  4092de:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  4092e1:	48 89 df             	mov    %rbx,%rdi
  4092e4:	48 89 50 08          	mov    %rdx,0x8(%rax)
  4092e8:	48 89 c2             	mov    %rax,%rdx
  4092eb:	e8 d0 0a 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  4092f0:	48 89 ef             	mov    %rbp,%rdi
  4092f3:	be 10 00 00 00       	mov    $0x10,%esi
  4092f8:	e8 13 9f ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
            "If set, uses custom wrappers for memcmp function "
            "to find more errors.")
COMMON_FLAG(bool, strict_memcmp, true,
  4092fd:	49 8d 94 24 9e 00 00 	lea    0x9e(%r12),%rdx
  409304:	00 
  409305:	48 8d 0d 2c da 00 00 	lea    0xda2c(%rip),%rcx        # 416d38 <.LC127>
  40930c:	48 8d 35 b0 f7 00 00 	lea    0xf7b0(%rip),%rsi        # 418ac3 <.LC128>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  409313:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  409316:	48 89 df             	mov    %rbx,%rdi
  409319:	48 89 50 08          	mov    %rdx,0x8(%rax)
  40931d:	48 89 c2             	mov    %rax,%rdx
  409320:	e8 9b 0a 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  409325:	48 89 ef             	mov    %rbp,%rdi
  409328:	be 10 00 00 00       	mov    $0x10,%esi
  40932d:	e8 de 9e ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
          "If true, assume that memcmp(p1, p2, n) always reads n bytes before "
          "comparing p1 and p2.")
COMMON_FLAG(bool, decorate_proc_maps, false, "If set, decorate sanitizer "
  409332:	49 8d 94 24 9f 00 00 	lea    0x9f(%r12),%rdx
  409339:	00 
  40933a:	48 8d 0d 4f da 00 00 	lea    0xda4f(%rip),%rcx        # 416d90 <.LC129>
  409341:	48 8d 35 89 f7 00 00 	lea    0xf789(%rip),%rsi        # 418ad1 <.LC130>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  409348:	4c 89 28             	mov    %r13,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  40934b:	48 89 df             	mov    %rbx,%rdi
  40934e:	48 89 50 08          	mov    %rdx,0x8(%rax)
  409352:	48 89 c2             	mov    %rax,%rdx
  409355:	e8 66 0a 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  40935a:	48 89 ef             	mov    %rbp,%rdi
  40935d:	be 10 00 00 00       	mov    $0x10,%esi
  409362:	e8 a9 9e ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  409367:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
                                             "mappings in /proc/self/maps with "
                                             "user-readable names")
COMMON_FLAG(int, exitcode, 1, "Override the program exit status if the tool "
  40936c:	49 8d 94 24 a0 00 00 	lea    0xa0(%r12),%rdx
  409373:	00 

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  409374:	48 8d 0d 65 da 00 00 	lea    0xda65(%rip),%rcx        # 416de0 <.LC131>
  40937b:	48 8d 35 62 f7 00 00 	lea    0xf762(%rip),%rsi        # 418ae4 <.LC132>
  409382:	48 89 df             	mov    %rbx,%rdi
                              "found an error")
COMMON_FLAG(
  409385:	49 81 c4 a4 00 00 00 	add    $0xa4,%r12
          "If true, assume that memcmp(p1, p2, n) always reads n bytes before "
          "comparing p1 and p2.")
COMMON_FLAG(bool, decorate_proc_maps, false, "If set, decorate sanitizer "
                                             "mappings in /proc/self/maps with "
                                             "user-readable names")
COMMON_FLAG(int, exitcode, 1, "Override the program exit status if the tool "
  40938c:	48 89 50 08          	mov    %rdx,0x8(%rax)
  409390:	48 89 c2             	mov    %rax,%rdx
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  409393:	4c 89 00             	mov    %r8,(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  409396:	e8 25 0a 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  40939b:	48 89 ef             	mov    %rbp,%rdi
  40939e:	be 10 00 00 00       	mov    $0x10,%esi
  4093a3:	e8 68 9e ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
  4093a8:	48 8d 0d 71 da 00 00 	lea    0xda71(%rip),%rcx        # 416e20 <.LC133>
  4093af:	48 8d 35 37 f7 00 00 	lea    0xf737(%rip),%rsi        # 418aed <.LC134>
template <typename T>
class FlagHandler : public FlagHandlerBase {
  T *t_;

 public:
  explicit FlagHandler(T *t) : t_(t) {}
  4093b6:	4c 89 28             	mov    %r13,(%rax)
                              "found an error")
COMMON_FLAG(
  4093b9:	4c 89 60 08          	mov    %r12,0x8(%rax)

template <typename T>
static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,
                         T *var) {
  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT
  parser->RegisterHandler(name, fh, desc);
  4093bd:	48 89 c2             	mov    %rax,%rdx
  4093c0:	48 89 df             	mov    %rbx,%rdi
  4093c3:	e8 f8 09 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  FlagParser *parser_;
  bool ignore_missing_;

 public:
  explicit FlagHandlerInclude(FlagParser *parser, bool ignore_missing)
      : parser_(parser), ignore_missing_(ignore_missing) {}
  4093c8:	4c 8d 25 c1 7a 01 00 	lea    0x17ac1(%rip),%r12        # 420e90 <_ZTVN11__sanitizer18FlagHandlerIncludeE+0x10>
  4093cf:	48 89 ef             	mov    %rbp,%rdi
  4093d2:	be 18 00 00 00       	mov    $0x18,%esi
  4093d7:	e8 34 9e ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>

void RegisterIncludeFlags(FlagParser *parser, CommonFlags *cf) {
  FlagHandlerInclude *fh_include = new (FlagParser::Alloc) // NOLINT
      FlagHandlerInclude(parser, /*ignore_missing*/ false);
  parser->RegisterHandler("include", fh_include,
                          "read more options from the given file");
  4093dc:	48 8d 0d 9d c6 00 00 	lea    0xc69d(%rip),%rcx        # 415a80 <.LC17>
  4093e3:	48 8d 35 cb f2 00 00 	lea    0xf2cb(%rip),%rsi        # 4186b5 <.LC18>
  FlagParser *parser_;
  bool ignore_missing_;

 public:
  explicit FlagHandlerInclude(FlagParser *parser, bool ignore_missing)
      : parser_(parser), ignore_missing_(ignore_missing) {}
  4093ea:	4c 89 20             	mov    %r12,(%rax)
  4093ed:	48 89 58 08          	mov    %rbx,0x8(%rax)

void RegisterIncludeFlags(FlagParser *parser, CommonFlags *cf) {
  FlagHandlerInclude *fh_include = new (FlagParser::Alloc) // NOLINT
      FlagHandlerInclude(parser, /*ignore_missing*/ false);
  parser->RegisterHandler("include", fh_include,
                          "read more options from the given file");
  4093f1:	48 89 c2             	mov    %rax,%rdx
  4093f4:	48 89 df             	mov    %rbx,%rdi
  FlagParser *parser_;
  bool ignore_missing_;

 public:
  explicit FlagHandlerInclude(FlagParser *parser, bool ignore_missing)
      : parser_(parser), ignore_missing_(ignore_missing) {}
  4093f7:	c6 40 10 00          	movb   $0x0,0x10(%rax)

void RegisterIncludeFlags(FlagParser *parser, CommonFlags *cf) {
  FlagHandlerInclude *fh_include = new (FlagParser::Alloc) // NOLINT
      FlagHandlerInclude(parser, /*ignore_missing*/ false);
  parser->RegisterHandler("include", fh_include,
                          "read more options from the given file");
  4093fb:	e8 c0 09 00 00       	callq  409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  409400:	48 89 ef             	mov    %rbp,%rdi
  409403:	be 18 00 00 00       	mov    $0x18,%esi
  409408:	e8 03 9e ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
  FlagParser *parser_;
  bool ignore_missing_;

 public:
  explicit FlagHandlerInclude(FlagParser *parser, bool ignore_missing)
      : parser_(parser), ignore_missing_(ignore_missing) {}
  40940d:	4c 89 20             	mov    %r12,(%rax)
  409410:	48 89 58 08          	mov    %rbx,0x8(%rax)
                          "read more options from the given file");
  FlagHandlerInclude *fh_include_if_exists = new (FlagParser::Alloc) // NOLINT
      FlagHandlerInclude(parser, /*ignore_missing*/ true);
  parser->RegisterHandler(
      "include_if_exists", fh_include_if_exists,
      "read more options from the given file (if it exists)");
  409414:	48 89 df             	mov    %rbx,%rdi
  FlagParser *parser_;
  bool ignore_missing_;

 public:
  explicit FlagHandlerInclude(FlagParser *parser, bool ignore_missing)
      : parser_(parser), ignore_missing_(ignore_missing) {}
  409417:	c6 40 10 01          	movb   $0x1,0x10(%rax)
  RegisterFlag(parser, #Name, Description, &cf->Name);
#include "sanitizer_flags.inc"
#undef COMMON_FLAG

  RegisterIncludeFlags(parser, cf);
}
  40941b:	48 83 c4 18          	add    $0x18,%rsp
                          "read more options from the given file");
  FlagHandlerInclude *fh_include_if_exists = new (FlagParser::Alloc) // NOLINT
      FlagHandlerInclude(parser, /*ignore_missing*/ true);
  parser->RegisterHandler(
      "include_if_exists", fh_include_if_exists,
      "read more options from the given file (if it exists)");
  40941f:	48 8d 0d 82 c6 00 00 	lea    0xc682(%rip),%rcx        # 415aa8 <.LC19>
  RegisterFlag(parser, #Name, Description, &cf->Name);
#include "sanitizer_flags.inc"
#undef COMMON_FLAG

  RegisterIncludeFlags(parser, cf);
}
  409426:	5b                   	pop    %rbx
  409427:	5d                   	pop    %rbp
  409428:	41 5c                	pop    %r12
  40942a:	41 5d                	pop    %r13
  40942c:	41 5e                	pop    %r14
  40942e:	41 5f                	pop    %r15
                          "read more options from the given file");
  FlagHandlerInclude *fh_include_if_exists = new (FlagParser::Alloc) // NOLINT
      FlagHandlerInclude(parser, /*ignore_missing*/ true);
  parser->RegisterHandler(
      "include_if_exists", fh_include_if_exists,
      "read more options from the given file (if it exists)");
  409430:	48 8d 35 86 f2 00 00 	lea    0xf286(%rip),%rsi        # 4186bd <.LC20>
  409437:	48 89 c2             	mov    %rax,%rdx
  40943a:	e9 81 09 00 00       	jmpq   409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>
  40943f:	90                   	nop

0000000000409440 <_ZN11__sanitizer11FlagHandlerIPKcE5ParseES2_>:
  Printf("ERROR: Invalid value for bool option: '%s'\n", value);
  return false;
}

template <>
inline bool FlagHandler<const char *>::Parse(const char *value) {
  409440:	53                   	push   %rbx
  *t_ = internal_strdup(value);
  409441:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
  409445:	48 89 f7             	mov    %rsi,%rdi
  409448:	e8 73 0f 00 00       	callq  40a3c0 <_ZN11__sanitizer15internal_strdupEPKc>
  40944d:	48 89 03             	mov    %rax,(%rbx)
  return true;
}
  409450:	b8 01 00 00 00       	mov    $0x1,%eax
  409455:	5b                   	pop    %rbx
  409456:	c3                   	retq   
  409457:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40945e:	00 00 

0000000000409460 <_ZN11__sanitizer11FlagHandlerIiE5ParseEPKc>:

template <>
inline bool FlagHandler<int>::Parse(const char *value) {
  409460:	55                   	push   %rbp
  char *value_end;
  *t_ = internal_simple_strtoll(value, &value_end, 10);
  409461:	ba 0a 00 00 00       	mov    $0xa,%edx
  *t_ = internal_strdup(value);
  return true;
}

template <>
inline bool FlagHandler<int>::Parse(const char *value) {
  409466:	53                   	push   %rbx
  409467:	48 89 f3             	mov    %rsi,%rbx
  40946a:	48 83 ec 18          	sub    $0x18,%rsp
  char *value_end;
  *t_ = internal_simple_strtoll(value, &value_end, 10);
  40946e:	48 8b 6f 08          	mov    0x8(%rdi),%rbp
  409472:	48 89 df             	mov    %rbx,%rdi
  409475:	48 89 e6             	mov    %rsp,%rsi
  409478:	e8 63 16 00 00       	callq  40aae0 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci>
  40947d:	89 45 00             	mov    %eax,0x0(%rbp)
  bool ok = *value_end == 0;
  409480:	48 8b 04 24          	mov    (%rsp),%rax
  409484:	80 38 00             	cmpb   $0x0,(%rax)
  if (!ok) Printf("ERROR: Invalid value for int option: '%s'\n", value);
  409487:	40 0f 94 c5          	sete   %bpl
  40948b:	74 11                	je     40949e <_ZN11__sanitizer11FlagHandlerIiE5ParseEPKc+0x3e>
  40948d:	48 8d 3d 1c c5 00 00 	lea    0xc51c(%rip),%rdi        # 4159b0 <.LC0>
  409494:	48 89 de             	mov    %rbx,%rsi
  409497:	31 c0                	xor    %eax,%eax
  409499:	e8 52 45 00 00       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  return ok;
}
  40949e:	48 83 c4 18          	add    $0x18,%rsp
  4094a2:	89 e8                	mov    %ebp,%eax
  4094a4:	5b                   	pop    %rbx
  4094a5:	5d                   	pop    %rbp
  4094a6:	c3                   	retq   
  4094a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4094ae:	00 00 

00000000004094b0 <_ZN11__sanitizer11FlagHandlerImE5ParseEPKc>:

template <>
inline bool FlagHandler<uptr>::Parse(const char *value) {
  4094b0:	55                   	push   %rbp
  char *value_end;
  *t_ = internal_simple_strtoll(value, &value_end, 10);
  4094b1:	ba 0a 00 00 00       	mov    $0xa,%edx
  if (!ok) Printf("ERROR: Invalid value for int option: '%s'\n", value);
  return ok;
}

template <>
inline bool FlagHandler<uptr>::Parse(const char *value) {
  4094b6:	53                   	push   %rbx
  4094b7:	48 89 f3             	mov    %rsi,%rbx
  4094ba:	48 83 ec 18          	sub    $0x18,%rsp
  char *value_end;
  *t_ = internal_simple_strtoll(value, &value_end, 10);
  4094be:	48 8b 6f 08          	mov    0x8(%rdi),%rbp
  4094c2:	48 89 df             	mov    %rbx,%rdi
  4094c5:	48 89 e6             	mov    %rsp,%rsi
  4094c8:	e8 13 16 00 00       	callq  40aae0 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci>
  4094cd:	48 89 45 00          	mov    %rax,0x0(%rbp)
  bool ok = *value_end == 0;
  4094d1:	48 8b 04 24          	mov    (%rsp),%rax
  4094d5:	80 38 00             	cmpb   $0x0,(%rax)
  if (!ok) Printf("ERROR: Invalid value for uptr option: '%s'\n", value);
  4094d8:	40 0f 94 c5          	sete   %bpl
  4094dc:	74 11                	je     4094ef <_ZN11__sanitizer11FlagHandlerImE5ParseEPKc+0x3f>
  4094de:	48 8d 3d fb c4 00 00 	lea    0xc4fb(%rip),%rdi        # 4159e0 <.LC1>
  4094e5:	48 89 de             	mov    %rbx,%rsi
  4094e8:	31 c0                	xor    %eax,%eax
  4094ea:	e8 01 45 00 00       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  return ok;
}
  4094ef:	48 83 c4 18          	add    $0x18,%rsp
  4094f3:	89 e8                	mov    %ebp,%eax
  4094f5:	5b                   	pop    %rbx
  4094f6:	5d                   	pop    %rbp
  4094f7:	c3                   	retq   
  4094f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4094ff:	00 

0000000000409500 <_ZN11__sanitizer18FlagHandlerInclude5ParseEPKc>:
  bool ignore_missing_;

 public:
  explicit FlagHandlerInclude(FlagParser *parser, bool ignore_missing)
      : parser_(parser), ignore_missing_(ignore_missing) {}
  bool Parse(const char *value) final {
  409500:	41 56                	push   %r14
  409502:	41 55                	push   %r13
  409504:	49 89 fd             	mov    %rdi,%r13
  409507:	41 54                	push   %r12
  409509:	55                   	push   %rbp
  40950a:	48 89 f5             	mov    %rsi,%rbp
    if (internal_strchr(value, '%')) {
  40950d:	be 25 00 00 00       	mov    $0x25,%esi
  409512:	48 89 ef             	mov    %rbp,%rdi
  bool ignore_missing_;

 public:
  explicit FlagHandlerInclude(FlagParser *parser, bool ignore_missing)
      : parser_(parser), ignore_missing_(ignore_missing) {}
  bool Parse(const char *value) final {
  409515:	53                   	push   %rbx
    if (internal_strchr(value, '%')) {
  409516:	e8 55 13 00 00       	callq  40a870 <_ZN11__sanitizer15internal_strchrEPKci>
  40951b:	48 85 c0             	test   %rax,%rax
  40951e:	0f 84 bc 00 00 00    	je     4095e0 <_ZN11__sanitizer18FlagHandlerInclude5ParseEPKc+0xe0>
      char *buf = (char *)MmapOrDie(kMaxPathLength, "FlagHandlerInclude");
  409524:	48 8d 35 58 f1 00 00 	lea    0xf158(%rip),%rsi        # 418683 <.LC9>
  40952b:	bf 00 10 00 00       	mov    $0x1000,%edi
  409530:	e8 6b 2e 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  409535:	49 89 c6             	mov    %rax,%r14
  409538:	48 89 c3             	mov    %rax,%rbx
}

// Copy the string from "s" to "out", replacing "%b" with the binary basename.
static void SubstituteBinaryName(const char *s, char *out, uptr out_size) {
  char *out_end = out + out_size;
  while (*s && out < out_end - 1) {
  40953b:	4c 8d a0 ff 0f 00 00 	lea    0xfff(%rax),%r12
  409542:	eb 0e                	jmp    409552 <_ZN11__sanitizer18FlagHandlerInclude5ParseEPKc+0x52>
  409544:	0f 1f 40 00          	nopl   0x0(%rax)
    if (s[0] != '%' || s[1] != 'b') { *out++ = *s++; continue; }
  409548:	88 13                	mov    %dl,(%rbx)
  40954a:	48 83 c5 01          	add    $0x1,%rbp
  40954e:	48 83 c3 01          	add    $0x1,%rbx
}

// Copy the string from "s" to "out", replacing "%b" with the binary basename.
static void SubstituteBinaryName(const char *s, char *out, uptr out_size) {
  char *out_end = out + out_size;
  while (*s && out < out_end - 1) {
  409552:	0f b6 55 00          	movzbl 0x0(%rbp),%edx
  409556:	84 d2                	test   %dl,%dl
  409558:	74 56                	je     4095b0 <_ZN11__sanitizer18FlagHandlerInclude5ParseEPKc+0xb0>
  40955a:	4c 39 e3             	cmp    %r12,%rbx
  40955d:	73 51                	jae    4095b0 <_ZN11__sanitizer18FlagHandlerInclude5ParseEPKc+0xb0>
    if (s[0] != '%' || s[1] != 'b') { *out++ = *s++; continue; }
  40955f:	80 fa 25             	cmp    $0x25,%dl
  409562:	75 e4                	jne    409548 <_ZN11__sanitizer18FlagHandlerInclude5ParseEPKc+0x48>
  409564:	80 7d 01 62          	cmpb   $0x62,0x1(%rbp)
  409568:	75 de                	jne    409548 <_ZN11__sanitizer18FlagHandlerInclude5ParseEPKc+0x48>
    const char *base = GetProcessName();
  40956a:	e8 11 c9 ff ff       	callq  405e80 <_ZN11__sanitizer14GetProcessNameEv>
    CHECK(base);
  40956f:	48 85 c0             	test   %rax,%rax
  409572:	0f 84 81 00 00 00    	je     4095f9 <_ZN11__sanitizer18FlagHandlerInclude5ParseEPKc+0xf9>
    while (*base && out < out_end - 1)
  409578:	0f b6 08             	movzbl (%rax),%ecx
  40957b:	84 c9                	test   %cl,%cl
  40957d:	75 0e                	jne    40958d <_ZN11__sanitizer18FlagHandlerInclude5ParseEPKc+0x8d>
  40957f:	90                   	nop
  409580:	eb 1d                	jmp    40959f <_ZN11__sanitizer18FlagHandlerInclude5ParseEPKc+0x9f>
  409582:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  409588:	4c 39 e3             	cmp    %r12,%rbx
  40958b:	74 12                	je     40959f <_ZN11__sanitizer18FlagHandlerInclude5ParseEPKc+0x9f>
      *out++ = *base++;
  40958d:	48 83 c3 01          	add    $0x1,%rbx
  409591:	48 83 c0 01          	add    $0x1,%rax
  409595:	88 4b ff             	mov    %cl,-0x1(%rbx)
  char *out_end = out + out_size;
  while (*s && out < out_end - 1) {
    if (s[0] != '%' || s[1] != 'b') { *out++ = *s++; continue; }
    const char *base = GetProcessName();
    CHECK(base);
    while (*base && out < out_end - 1)
  409598:	0f b6 08             	movzbl (%rax),%ecx
  40959b:	84 c9                	test   %cl,%cl
  40959d:	75 e9                	jne    409588 <_ZN11__sanitizer18FlagHandlerInclude5ParseEPKc+0x88>
      *out++ = *base++;
    s += 2; // skip "%b"
  40959f:	48 83 c5 02          	add    $0x2,%rbp
}

// Copy the string from "s" to "out", replacing "%b" with the binary basename.
static void SubstituteBinaryName(const char *s, char *out, uptr out_size) {
  char *out_end = out + out_size;
  while (*s && out < out_end - 1) {
  4095a3:	0f b6 55 00          	movzbl 0x0(%rbp),%edx
  4095a7:	84 d2                	test   %dl,%dl
  4095a9:	75 af                	jne    40955a <_ZN11__sanitizer18FlagHandlerInclude5ParseEPKc+0x5a>
  4095ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    CHECK(base);
    while (*base && out < out_end - 1)
      *out++ = *base++;
    s += 2; // skip "%b"
  }
  *out = '\0';
  4095b0:	c6 03 00             	movb   $0x0,(%rbx)
      : parser_(parser), ignore_missing_(ignore_missing) {}
  bool Parse(const char *value) final {
    if (internal_strchr(value, '%')) {
      char *buf = (char *)MmapOrDie(kMaxPathLength, "FlagHandlerInclude");
      SubstituteBinaryName(value, buf, kMaxPathLength);
      bool res = parser_->ParseFile(buf, ignore_missing_);
  4095b3:	41 0f b6 55 10       	movzbl 0x10(%r13),%edx
  4095b8:	4c 89 f6             	mov    %r14,%rsi
  4095bb:	49 8b 7d 08          	mov    0x8(%r13),%rdi
  4095bf:	e8 1c 06 00 00       	callq  409be0 <_ZN11__sanitizer10FlagParser9ParseFileEPKcb>
      UnmapOrDie(buf, kMaxPathLength);
  4095c4:	4c 89 f7             	mov    %r14,%rdi
      : parser_(parser), ignore_missing_(ignore_missing) {}
  bool Parse(const char *value) final {
    if (internal_strchr(value, '%')) {
      char *buf = (char *)MmapOrDie(kMaxPathLength, "FlagHandlerInclude");
      SubstituteBinaryName(value, buf, kMaxPathLength);
      bool res = parser_->ParseFile(buf, ignore_missing_);
  4095c7:	89 c3                	mov    %eax,%ebx
      UnmapOrDie(buf, kMaxPathLength);
  4095c9:	be 00 10 00 00       	mov    $0x1000,%esi
  4095ce:	e8 6d 2e 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
      return res;
    }
    return parser_->ParseFile(value, ignore_missing_);
  }
  4095d3:	89 d8                	mov    %ebx,%eax
  4095d5:	5b                   	pop    %rbx
  4095d6:	5d                   	pop    %rbp
  4095d7:	41 5c                	pop    %r12
  4095d9:	41 5d                	pop    %r13
  4095db:	41 5e                	pop    %r14
  4095dd:	c3                   	retq   
  4095de:	66 90                	xchg   %ax,%ax
  4095e0:	5b                   	pop    %rbx
      SubstituteBinaryName(value, buf, kMaxPathLength);
      bool res = parser_->ParseFile(buf, ignore_missing_);
      UnmapOrDie(buf, kMaxPathLength);
      return res;
    }
    return parser_->ParseFile(value, ignore_missing_);
  4095e1:	48 89 ee             	mov    %rbp,%rsi
  4095e4:	41 0f b6 55 10       	movzbl 0x10(%r13),%edx
  4095e9:	49 8b 7d 08          	mov    0x8(%r13),%rdi
  }
  4095ed:	5d                   	pop    %rbp
  4095ee:	41 5c                	pop    %r12
  4095f0:	41 5d                	pop    %r13
  4095f2:	41 5e                	pop    %r14
      SubstituteBinaryName(value, buf, kMaxPathLength);
      bool res = parser_->ParseFile(buf, ignore_missing_);
      UnmapOrDie(buf, kMaxPathLength);
      return res;
    }
    return parser_->ParseFile(value, ignore_missing_);
  4095f4:	e9 e7 05 00 00       	jmpq   409be0 <_ZN11__sanitizer10FlagParser9ParseFileEPKcb>
static void SubstituteBinaryName(const char *s, char *out, uptr out_size) {
  char *out_end = out + out_size;
  while (*s && out < out_end - 1) {
    if (s[0] != '%' || s[1] != 'b') { *out++ = *s++; continue; }
    const char *base = GetProcessName();
    CHECK(base);
  4095f9:	48 8d 15 96 f0 00 00 	lea    0xf096(%rip),%rdx        # 418696 <.LC10>
  409600:	48 8d 3d 09 c4 00 00 	lea    0xc409(%rip),%rdi        # 415a10 <.LC11>
  409607:	45 31 c0             	xor    %r8d,%r8d
  40960a:	31 c9                	xor    %ecx,%ecx
  40960c:	be 36 00 00 00       	mov    $0x36,%esi
  409611:	e8 da bd ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  409616:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40961d:	00 00 00 

0000000000409620 <_ZN11__sanitizer23ReportUnrecognizedFlagsEv>:
    CHECK_LT(n_unknown_flags_, kMaxUnknownFlags);
    unknown_flags_[n_unknown_flags_++] = name;
  }

  void Report() {
    if (!n_unknown_flags_) return;
  409620:	8b 35 3a 83 26 00    	mov    0x26833a(%rip),%esi        # 671960 <_ZN11__sanitizer13unknown_flagsE+0xa0>
  409626:	85 f6                	test   %esi,%esi
  409628:	75 06                	jne    409630 <_ZN11__sanitizer23ReportUnrecognizedFlagsEv+0x10>

UnknownFlags unknown_flags;

void ReportUnrecognizedFlags() {
  unknown_flags.Report();
}
  40962a:	c3                   	retq   
  40962b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  }
};

UnknownFlags unknown_flags;

void ReportUnrecognizedFlags() {
  409630:	55                   	push   %rbp
    unknown_flags_[n_unknown_flags_++] = name;
  }

  void Report() {
    if (!n_unknown_flags_) return;
    Printf("WARNING: found %d unrecognized flag(s):\n", n_unknown_flags_);
  409631:	48 8d 3d 40 d8 00 00 	lea    0xd840(%rip),%rdi        # 416e78 <.LC0>
  409638:	31 c0                	xor    %eax,%eax
  40963a:	48 8d 2d 7f 82 26 00 	lea    0x26827f(%rip),%rbp        # 6718c0 <_ZN11__sanitizer13unknown_flagsE>
  }
};

UnknownFlags unknown_flags;

void ReportUnrecognizedFlags() {
  409641:	53                   	push   %rbx
  }

  void Report() {
    if (!n_unknown_flags_) return;
    Printf("WARNING: found %d unrecognized flag(s):\n", n_unknown_flags_);
    for (int i = 0; i < n_unknown_flags_; ++i)
  409642:	31 db                	xor    %ebx,%ebx
  }
};

UnknownFlags unknown_flags;

void ReportUnrecognizedFlags() {
  409644:	48 83 ec 08          	sub    $0x8,%rsp
    unknown_flags_[n_unknown_flags_++] = name;
  }

  void Report() {
    if (!n_unknown_flags_) return;
    Printf("WARNING: found %d unrecognized flag(s):\n", n_unknown_flags_);
  409648:	e8 a3 43 00 00       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
    for (int i = 0; i < n_unknown_flags_; ++i)
  40964d:	8b 05 0d 83 26 00    	mov    0x26830d(%rip),%eax        # 671960 <_ZN11__sanitizer13unknown_flagsE+0xa0>
  409653:	85 c0                	test   %eax,%eax
  409655:	7e 2a                	jle    409681 <_ZN11__sanitizer23ReportUnrecognizedFlagsEv+0x61>
  409657:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40965e:	00 00 
      Printf("    %s\n", unknown_flags_[i]);
  409660:	48 8b 75 00          	mov    0x0(%rbp),%rsi
  409664:	48 8d 3d 91 f4 00 00 	lea    0xf491(%rip),%rdi        # 418afc <.LC1>
  40966b:	31 c0                	xor    %eax,%eax
  }

  void Report() {
    if (!n_unknown_flags_) return;
    Printf("WARNING: found %d unrecognized flag(s):\n", n_unknown_flags_);
    for (int i = 0; i < n_unknown_flags_; ++i)
  40966d:	83 c3 01             	add    $0x1,%ebx
  409670:	48 83 c5 08          	add    $0x8,%rbp
      Printf("    %s\n", unknown_flags_[i]);
  409674:	e8 77 43 00 00       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  }

  void Report() {
    if (!n_unknown_flags_) return;
    Printf("WARNING: found %d unrecognized flag(s):\n", n_unknown_flags_);
    for (int i = 0; i < n_unknown_flags_; ++i)
  409679:	3b 1d e1 82 26 00    	cmp    0x2682e1(%rip),%ebx        # 671960 <_ZN11__sanitizer13unknown_flagsE+0xa0>
  40967f:	7c df                	jl     409660 <_ZN11__sanitizer23ReportUnrecognizedFlagsEv+0x40>
      Printf("    %s\n", unknown_flags_[i]);
    n_unknown_flags_ = 0;
  409681:	c7 05 d5 82 26 00 00 	movl   $0x0,0x2682d5(%rip)        # 671960 <_ZN11__sanitizer13unknown_flagsE+0xa0>
  409688:	00 00 00 

UnknownFlags unknown_flags;

void ReportUnrecognizedFlags() {
  unknown_flags.Report();
}
  40968b:	48 83 c4 08          	add    $0x8,%rsp
  40968f:	5b                   	pop    %rbx
  409690:	5d                   	pop    %rbp
  409691:	c3                   	retq   
  409692:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  409699:	1f 84 00 00 00 00 00 

00000000004096a0 <_ZN11__sanitizer10FlagParser10ll_strndupEPKcm>:

char *FlagParser::ll_strndup(const char *s, uptr n) {
  4096a0:	41 54                	push   %r12
  4096a2:	49 89 f4             	mov    %rsi,%r12
  uptr len = internal_strnlen(s, n);
  4096a5:	48 89 d6             	mov    %rdx,%rsi
  4096a8:	4c 89 e7             	mov    %r12,%rdi

void ReportUnrecognizedFlags() {
  unknown_flags.Report();
}

char *FlagParser::ll_strndup(const char *s, uptr n) {
  4096ab:	55                   	push   %rbp
  4096ac:	53                   	push   %rbx
  uptr len = internal_strnlen(s, n);
  4096ad:	e8 5e 13 00 00       	callq  40aa10 <_ZN11__sanitizer16internal_strnlenEPKcm>
  char *s2 = (char*)Alloc.Allocate(len + 1);
  4096b2:	48 8d 3d b7 82 26 00 	lea    0x2682b7(%rip),%rdi        # 671970 <_ZN11__sanitizer10FlagParser5AllocE>
  4096b9:	48 8d 70 01          	lea    0x1(%rax),%rsi
void ReportUnrecognizedFlags() {
  unknown_flags.Report();
}

char *FlagParser::ll_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  4096bd:	48 89 c3             	mov    %rax,%rbx
  char *s2 = (char*)Alloc.Allocate(len + 1);
  4096c0:	e8 4b 9b ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
  internal_memcpy(s2, s, len);
  4096c5:	48 89 da             	mov    %rbx,%rdx
  unknown_flags.Report();
}

char *FlagParser::ll_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  char *s2 = (char*)Alloc.Allocate(len + 1);
  4096c8:	48 89 c5             	mov    %rax,%rbp
  internal_memcpy(s2, s, len);
  4096cb:	4c 89 e6             	mov    %r12,%rsi
  4096ce:	48 89 c7             	mov    %rax,%rdi
  4096d1:	e8 3a 08 00 00       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
  s2[len] = 0;
  4096d6:	c6 44 1d 00 00       	movb   $0x0,0x0(%rbp,%rbx,1)
  return s2;
}
  4096db:	48 89 e8             	mov    %rbp,%rax
  4096de:	5b                   	pop    %rbx
  4096df:	5d                   	pop    %rbp
  4096e0:	41 5c                	pop    %r12
  4096e2:	c3                   	retq   
  4096e3:	90                   	nop
  4096e4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4096eb:	00 00 00 00 00 

00000000004096f0 <_ZN11__sanitizer10FlagParser21PrintFlagDescriptionsEv>:

void FlagParser::PrintFlagDescriptions() {
  4096f0:	41 54                	push   %r12
  Printf("Available flags for %s:\n", SanitizerToolName);
  4096f2:	48 8b 05 b7 4b 01 00 	mov    0x14bb7(%rip),%rax        # 41e2b0 <_DYNAMIC+0x2b0>
  internal_memcpy(s2, s, len);
  s2[len] = 0;
  return s2;
}

void FlagParser::PrintFlagDescriptions() {
  4096f9:	49 89 fc             	mov    %rdi,%r12
  Printf("Available flags for %s:\n", SanitizerToolName);
  4096fc:	48 8d 3d 01 f4 00 00 	lea    0xf401(%rip),%rdi        # 418b04 <.LC2>
  internal_memcpy(s2, s, len);
  s2[len] = 0;
  return s2;
}

void FlagParser::PrintFlagDescriptions() {
  409703:	55                   	push   %rbp
  Printf("Available flags for %s:\n", SanitizerToolName);
  for (int i = 0; i < n_flags_; ++i)
  409704:	31 ed                	xor    %ebp,%ebp
  internal_memcpy(s2, s, len);
  s2[len] = 0;
  return s2;
}

void FlagParser::PrintFlagDescriptions() {
  409706:	53                   	push   %rbx
  Printf("Available flags for %s:\n", SanitizerToolName);
  409707:	48 8b 30             	mov    (%rax),%rsi
  40970a:	31 c0                	xor    %eax,%eax
  for (int i = 0; i < n_flags_; ++i)
  40970c:	31 db                	xor    %ebx,%ebx
  s2[len] = 0;
  return s2;
}

void FlagParser::PrintFlagDescriptions() {
  Printf("Available flags for %s:\n", SanitizerToolName);
  40970e:	e8 dd 42 00 00       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  for (int i = 0; i < n_flags_; ++i)
  409713:	41 8b 44 24 08       	mov    0x8(%r12),%eax
  409718:	85 c0                	test   %eax,%eax
  40971a:	7e 2e                	jle    40974a <_ZN11__sanitizer10FlagParser21PrintFlagDescriptionsEv+0x5a>
  40971c:	0f 1f 40 00          	nopl   0x0(%rax)
    Printf("\t%s\n\t\t- %s\n", flags_[i].name, flags_[i].desc);
  409720:	48 89 e8             	mov    %rbp,%rax
  409723:	49 03 04 24          	add    (%r12),%rax
  409727:	48 8d 3d ef f3 00 00 	lea    0xf3ef(%rip),%rdi        # 418b1d <.LC3>
  return s2;
}

void FlagParser::PrintFlagDescriptions() {
  Printf("Available flags for %s:\n", SanitizerToolName);
  for (int i = 0; i < n_flags_; ++i)
  40972e:	83 c3 01             	add    $0x1,%ebx
  409731:	48 83 c5 18          	add    $0x18,%rbp
    Printf("\t%s\n\t\t- %s\n", flags_[i].name, flags_[i].desc);
  409735:	48 8b 50 08          	mov    0x8(%rax),%rdx
  409739:	48 8b 30             	mov    (%rax),%rsi
  40973c:	31 c0                	xor    %eax,%eax
  40973e:	e8 ad 42 00 00       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  return s2;
}

void FlagParser::PrintFlagDescriptions() {
  Printf("Available flags for %s:\n", SanitizerToolName);
  for (int i = 0; i < n_flags_; ++i)
  409743:	41 39 5c 24 08       	cmp    %ebx,0x8(%r12)
  409748:	7f d6                	jg     409720 <_ZN11__sanitizer10FlagParser21PrintFlagDescriptionsEv+0x30>
    Printf("\t%s\n\t\t- %s\n", flags_[i].name, flags_[i].desc);
}
  40974a:	5b                   	pop    %rbx
  40974b:	5d                   	pop    %rbp
  40974c:	41 5c                	pop    %r12
  40974e:	c3                   	retq   
  40974f:	90                   	nop

0000000000409750 <_ZN11__sanitizer10FlagParser11fatal_errorEPKc>:

void FlagParser::fatal_error(const char *err) {
  Printf("ERROR: %s\n", err);
  409750:	48 8d 3d d2 f3 00 00 	lea    0xf3d2(%rip),%rdi        # 418b29 <.LC4>
  Printf("Available flags for %s:\n", SanitizerToolName);
  for (int i = 0; i < n_flags_; ++i)
    Printf("\t%s\n\t\t- %s\n", flags_[i].name, flags_[i].desc);
}

void FlagParser::fatal_error(const char *err) {
  409757:	48 83 ec 08          	sub    $0x8,%rsp
  Printf("ERROR: %s\n", err);
  40975b:	31 c0                	xor    %eax,%eax
  40975d:	e8 8e 42 00 00       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  Die();
  409762:	e8 f9 ba ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  409767:	90                   	nop
  409768:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40976f:	00 

0000000000409770 <_ZN11__sanitizer10FlagParser8is_spaceEc>:
}

bool FlagParser::is_space(char c) {
  return c == ' ' || c == ',' || c == ':' || c == '\n' || c == '\t' ||
  409770:	40 80 fe 20          	cmp    $0x20,%sil
  409774:	74 22                	je     409798 <_ZN11__sanitizer10FlagParser8is_spaceEc+0x28>
  409776:	40 80 fe 2c          	cmp    $0x2c,%sil
  40977a:	74 1c                	je     409798 <_ZN11__sanitizer10FlagParser8is_spaceEc+0x28>
  40977c:	40 80 fe 3a          	cmp    $0x3a,%sil
  409780:	74 16                	je     409798 <_ZN11__sanitizer10FlagParser8is_spaceEc+0x28>
  409782:	40 80 fe 0a          	cmp    $0xa,%sil
  409786:	74 10                	je     409798 <_ZN11__sanitizer10FlagParser8is_spaceEc+0x28>
  409788:	83 e6 fb             	and    $0xfffffffb,%esi
  40978b:	40 80 fe 09          	cmp    $0x9,%sil
  40978f:	0f 94 c0             	sete   %al
  409792:	c3                   	retq   
  409793:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  409798:	b8 01 00 00 00       	mov    $0x1,%eax
         c == '\r';
}
  40979d:	c3                   	retq   
  40979e:	66 90                	xchg   %ax,%ax

00000000004097a0 <_ZN11__sanitizer10FlagParser15skip_whitespaceEv>:

void FlagParser::skip_whitespace() {
  4097a0:	48 8b 4f 10          	mov    0x10(%rdi),%rcx
  4097a4:	48 8b 57 18          	mov    0x18(%rdi),%rdx
  while (is_space(buf_[pos_])) ++pos_;
  4097a8:	eb 0e                	jmp    4097b8 <_ZN11__sanitizer10FlagParser15skip_whitespaceEv+0x18>
  4097aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  4097b0:	48 83 c2 01          	add    $0x1,%rdx
  4097b4:	48 89 57 18          	mov    %rdx,0x18(%rdi)
  4097b8:	0f b6 04 11          	movzbl (%rcx,%rdx,1),%eax
  Printf("ERROR: %s\n", err);
  Die();
}

bool FlagParser::is_space(char c) {
  return c == ' ' || c == ',' || c == ':' || c == '\n' || c == '\t' ||
  4097bc:	3c 20                	cmp    $0x20,%al
  4097be:	74 f0                	je     4097b0 <_ZN11__sanitizer10FlagParser15skip_whitespaceEv+0x10>
  4097c0:	3c 2c                	cmp    $0x2c,%al
  4097c2:	74 ec                	je     4097b0 <_ZN11__sanitizer10FlagParser15skip_whitespaceEv+0x10>
  4097c4:	3c 3a                	cmp    $0x3a,%al
  4097c6:	74 e8                	je     4097b0 <_ZN11__sanitizer10FlagParser15skip_whitespaceEv+0x10>
  4097c8:	8d 70 f7             	lea    -0x9(%rax),%esi
         c == '\r';
}

void FlagParser::skip_whitespace() {
  while (is_space(buf_[pos_])) ++pos_;
  4097cb:	40 80 fe 01          	cmp    $0x1,%sil
  4097cf:	76 df                	jbe    4097b0 <_ZN11__sanitizer10FlagParser15skip_whitespaceEv+0x10>
  4097d1:	3c 0d                	cmp    $0xd,%al
  4097d3:	74 db                	je     4097b0 <_ZN11__sanitizer10FlagParser15skip_whitespaceEv+0x10>
}
  4097d5:	f3 c3                	repz retq 
  4097d7:	90                   	nop
  4097d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4097df:	00 

00000000004097e0 <_ZN11__sanitizer10FlagParser10parse_flagEv>:

void FlagParser::parse_flag() {
  4097e0:	41 56                	push   %r14
  4097e2:	41 55                	push   %r13
  4097e4:	41 54                	push   %r12
  4097e6:	55                   	push   %rbp
  4097e7:	53                   	push   %rbx
  uptr name_start = pos_;
  4097e8:	48 8b 77 18          	mov    0x18(%rdi),%rsi

void FlagParser::skip_whitespace() {
  while (is_space(buf_[pos_])) ++pos_;
}

void FlagParser::parse_flag() {
  4097ec:	48 89 fb             	mov    %rdi,%rbx
  uptr name_start = pos_;
  while (buf_[pos_] != 0 && buf_[pos_] != '=' && !is_space(buf_[pos_])) ++pos_;
  4097ef:	48 8b 4f 10          	mov    0x10(%rdi),%rcx
  4097f3:	4c 8d 24 31          	lea    (%rcx,%rsi,1),%r12
  4097f7:	41 0f b6 04 24       	movzbl (%r12),%eax
  4097fc:	a8 df                	test   $0xdf,%al
  4097fe:	74 08                	je     409808 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x28>
  409800:	3c 3d                	cmp    $0x3d,%al
  409802:	0f 85 68 01 00 00    	jne    409970 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x190>
  409808:	48 89 f2             	mov    %rsi,%rdx
  if (buf_[pos_] != '=') fatal_error("expected '='");
  40980b:	3c 3d                	cmp    $0x3d,%al
  40980d:	0f 85 a5 01 00 00    	jne    4099b8 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x1d8>
  char *name = ll_strndup(buf_ + name_start, pos_ - name_start);
  409813:	48 29 f2             	sub    %rsi,%rdx
void ReportUnrecognizedFlags() {
  unknown_flags.Report();
}

char *FlagParser::ll_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  409816:	4c 89 e7             	mov    %r12,%rdi

void FlagParser::parse_flag() {
  uptr name_start = pos_;
  while (buf_[pos_] != 0 && buf_[pos_] != '=' && !is_space(buf_[pos_])) ++pos_;
  if (buf_[pos_] != '=') fatal_error("expected '='");
  char *name = ll_strndup(buf_ + name_start, pos_ - name_start);
  409819:	48 89 d6             	mov    %rdx,%rsi
void ReportUnrecognizedFlags() {
  unknown_flags.Report();
}

char *FlagParser::ll_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  40981c:	e8 ef 11 00 00       	callq  40aa10 <_ZN11__sanitizer16internal_strnlenEPKcm>
  char *s2 = (char*)Alloc.Allocate(len + 1);
  409821:	48 8d 3d 48 81 26 00 	lea    0x268148(%rip),%rdi        # 671970 <_ZN11__sanitizer10FlagParser5AllocE>
  409828:	48 8d 70 01          	lea    0x1(%rax),%rsi
void ReportUnrecognizedFlags() {
  unknown_flags.Report();
}

char *FlagParser::ll_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  40982c:	48 89 c5             	mov    %rax,%rbp
  char *s2 = (char*)Alloc.Allocate(len + 1);
  40982f:	e8 dc 99 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
  internal_memcpy(s2, s, len);
  409834:	48 89 ea             	mov    %rbp,%rdx
  unknown_flags.Report();
}

char *FlagParser::ll_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  char *s2 = (char*)Alloc.Allocate(len + 1);
  409837:	49 89 c5             	mov    %rax,%r13
  internal_memcpy(s2, s, len);
  40983a:	4c 89 e6             	mov    %r12,%rsi
  40983d:	48 89 c7             	mov    %rax,%rdi
  409840:	e8 cb 06 00 00       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
  s2[len] = 0;
  409845:	41 c6 44 2d 00 00    	movb   $0x0,0x0(%r13,%rbp,1)
  uptr name_start = pos_;
  while (buf_[pos_] != 0 && buf_[pos_] != '=' && !is_space(buf_[pos_])) ++pos_;
  if (buf_[pos_] != '=') fatal_error("expected '='");
  char *name = ll_strndup(buf_ + name_start, pos_ - name_start);

  uptr value_start = ++pos_;
  40984b:	4c 8b 53 18          	mov    0x18(%rbx),%r10
  char *value;
  if (buf_[pos_] == '\'' || buf_[pos_] == '"') {
  40984f:	4c 8b 43 10          	mov    0x10(%rbx),%r8
  uptr name_start = pos_;
  while (buf_[pos_] != 0 && buf_[pos_] != '=' && !is_space(buf_[pos_])) ++pos_;
  if (buf_[pos_] != '=') fatal_error("expected '='");
  char *name = ll_strndup(buf_ + name_start, pos_ - name_start);

  uptr value_start = ++pos_;
  409853:	49 8d 52 01          	lea    0x1(%r10),%rdx
  char *value;
  if (buf_[pos_] == '\'' || buf_[pos_] == '"') {
  409857:	49 8d 2c 10          	lea    (%r8,%rdx,1),%rbp
  uptr name_start = pos_;
  while (buf_[pos_] != 0 && buf_[pos_] != '=' && !is_space(buf_[pos_])) ++pos_;
  if (buf_[pos_] != '=') fatal_error("expected '='");
  char *name = ll_strndup(buf_ + name_start, pos_ - name_start);

  uptr value_start = ++pos_;
  40985b:	48 89 53 18          	mov    %rdx,0x18(%rbx)
  char *value;
  if (buf_[pos_] == '\'' || buf_[pos_] == '"') {
  40985f:	0f b6 45 00          	movzbl 0x0(%rbp),%eax
  409863:	3c 22                	cmp    $0x22,%al
  409865:	0f 84 a5 00 00 00    	je     409910 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x130>
  40986b:	3c 27                	cmp    $0x27,%al
  40986d:	0f 84 9d 00 00 00    	je     409910 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x130>
    while (buf_[pos_] != 0 && buf_[pos_] != quote) ++pos_;
    if (buf_[pos_] == 0) fatal_error("unterminated string");
    value = ll_strndup(buf_ + value_start + 1, pos_ - value_start - 1);
    ++pos_; // consume the closing quote
  } else {
    while (buf_[pos_] != 0 && !is_space(buf_[pos_])) ++pos_;
  409873:	31 f6                	xor    %esi,%esi
  409875:	84 c0                	test   %al,%al
  409877:	0f 85 53 01 00 00    	jne    4099d0 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x1f0>
void ReportUnrecognizedFlags() {
  unknown_flags.Report();
}

char *FlagParser::ll_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  40987d:	48 89 ef             	mov    %rbp,%rdi
  409880:	e8 8b 11 00 00       	callq  40aa10 <_ZN11__sanitizer16internal_strnlenEPKcm>
  char *s2 = (char*)Alloc.Allocate(len + 1);
  409885:	48 8d 3d e4 80 26 00 	lea    0x2680e4(%rip),%rdi        # 671970 <_ZN11__sanitizer10FlagParser5AllocE>
  40988c:	48 8d 70 01          	lea    0x1(%rax),%rsi
void ReportUnrecognizedFlags() {
  unknown_flags.Report();
}

char *FlagParser::ll_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  409890:	49 89 c4             	mov    %rax,%r12
  char *s2 = (char*)Alloc.Allocate(len + 1);
  409893:	e8 78 99 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
  internal_memcpy(s2, s, len);
  409898:	4c 89 e2             	mov    %r12,%rdx
  unknown_flags.Report();
}

char *FlagParser::ll_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  char *s2 = (char*)Alloc.Allocate(len + 1);
  40989b:	49 89 c6             	mov    %rax,%r14
  internal_memcpy(s2, s, len);
  40989e:	48 89 ee             	mov    %rbp,%rsi
  4098a1:	48 89 c7             	mov    %rax,%rdi
  4098a4:	e8 67 06 00 00       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
  s2[len] = 0;
  4098a9:	43 c6 04 26 00       	movb   $0x0,(%r14,%r12,1)
  UnmapOrDie(data, data_mapped_size);
  return true;
}

bool FlagParser::run_handler(const char *name, const char *value) {
  for (int i = 0; i < n_flags_; ++i) {
  4098ae:	8b 43 08             	mov    0x8(%rbx),%eax
  4098b1:	31 ed                	xor    %ebp,%ebp
  4098b3:	45 31 e4             	xor    %r12d,%r12d
  4098b6:	85 c0                	test   %eax,%eax
  4098b8:	7f 18                	jg     4098d2 <_ZN11__sanitizer10FlagParser10parse_flagEv+0xf2>
  4098ba:	e9 91 01 00 00       	jmpq   409a50 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x270>
  4098bf:	90                   	nop
  4098c0:	41 83 c4 01          	add    $0x1,%r12d
  4098c4:	48 83 c5 18          	add    $0x18,%rbp
  4098c8:	44 3b 63 08          	cmp    0x8(%rbx),%r12d
  4098cc:	0f 8d 7e 01 00 00    	jge    409a50 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x270>
    if (internal_strcmp(name, flags_[i].name) == 0)
  4098d2:	48 8b 03             	mov    (%rbx),%rax
  4098d5:	4c 89 ef             	mov    %r13,%rdi
  4098d8:	48 8b 34 28          	mov    (%rax,%rbp,1),%rsi
  4098dc:	e8 ff 0e 00 00       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
  4098e1:	85 c0                	test   %eax,%eax
  4098e3:	75 db                	jne    4098c0 <_ZN11__sanitizer10FlagParser10parse_flagEv+0xe0>
      return flags_[i].handler->Parse(value);
  4098e5:	48 8b 03             	mov    (%rbx),%rax
  4098e8:	4c 89 f6             	mov    %r14,%rsi
  4098eb:	48 8b 7c 28 10       	mov    0x10(%rax,%rbp,1),%rdi
  4098f0:	48 8b 07             	mov    (%rdi),%rax
  4098f3:	ff 10                	callq  *(%rax)
      fatal_error("expected separator or eol");
    value = ll_strndup(buf_ + value_start, pos_ - value_start);
  }

  bool res = run_handler(name, value);
  if (!res) fatal_error("Flag parsing failed.");
  4098f5:	84 c0                	test   %al,%al
  4098f7:	0f 85 76 01 00 00    	jne    409a73 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x293>
  4098fd:	48 8d 35 3d f2 00 00 	lea    0xf23d(%rip),%rsi        # 418b41 <.LC8>
  409904:	48 89 df             	mov    %rbx,%rdi
  409907:	e8 44 fe ff ff       	callq  409750 <_ZN11__sanitizer10FlagParser11fatal_errorEPKc>
  40990c:	0f 1f 40 00          	nopl   0x0(%rax)
  char *name = ll_strndup(buf_ + name_start, pos_ - name_start);

  uptr value_start = ++pos_;
  char *value;
  if (buf_[pos_] == '\'' || buf_[pos_] == '"') {
    char quote = buf_[pos_++];
  409910:	49 8d 42 02          	lea    0x2(%r10),%rax
  409914:	48 89 43 18          	mov    %rax,0x18(%rbx)
  409918:	44 0f b6 4d 00       	movzbl 0x0(%rbp),%r9d
    while (buf_[pos_] != 0 && buf_[pos_] != quote) ++pos_;
  40991d:	49 8d 2c 00          	lea    (%r8,%rax,1),%rbp
  409921:	0f b6 55 00          	movzbl 0x0(%rbp),%edx
  409925:	84 d2                	test   %dl,%dl
  409927:	74 34                	je     40995d <_ZN11__sanitizer10FlagParser10parse_flagEv+0x17d>
  409929:	41 38 d1             	cmp    %dl,%r9b
  40992c:	0f 84 4e 01 00 00    	je     409a80 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x2a0>
  409932:	49 8d 42 03          	lea    0x3(%r10),%rax
  409936:	eb 18                	jmp    409950 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x170>
  409938:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40993f:	00 
  409940:	41 38 d1             	cmp    %dl,%r9b
  409943:	48 8d 48 01          	lea    0x1(%rax),%rcx
  409947:	0f 84 33 01 00 00    	je     409a80 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x2a0>
  40994d:	48 89 c8             	mov    %rcx,%rax
  409950:	48 89 43 18          	mov    %rax,0x18(%rbx)
  409954:	41 0f b6 14 00       	movzbl (%r8,%rax,1),%edx
  409959:	84 d2                	test   %dl,%dl
  40995b:	75 e3                	jne    409940 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x160>
    if (buf_[pos_] == 0) fatal_error("unterminated string");
  40995d:	48 8d 35 f2 f1 00 00 	lea    0xf1f2(%rip),%rsi        # 418b56 <.LC9>
  409964:	48 89 df             	mov    %rbx,%rdi
  409967:	e8 e4 fd ff ff       	callq  409750 <_ZN11__sanitizer10FlagParser11fatal_errorEPKc>
  40996c:	0f 1f 40 00          	nopl   0x0(%rax)
  Printf("ERROR: %s\n", err);
  Die();
}

bool FlagParser::is_space(char c) {
  return c == ' ' || c == ',' || c == ':' || c == '\n' || c == '\t' ||
  409970:	3c 2c                	cmp    $0x2c,%al
  409972:	74 44                	je     4099b8 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x1d8>
  409974:	3c 3a                	cmp    $0x3a,%al
  409976:	74 40                	je     4099b8 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x1d8>
  409978:	3c 0a                	cmp    $0xa,%al
  while (is_space(buf_[pos_])) ++pos_;
}

void FlagParser::parse_flag() {
  uptr name_start = pos_;
  while (buf_[pos_] != 0 && buf_[pos_] != '=' && !is_space(buf_[pos_])) ++pos_;
  40997a:	48 89 f2             	mov    %rsi,%rdx
  Printf("ERROR: %s\n", err);
  Die();
}

bool FlagParser::is_space(char c) {
  return c == ' ' || c == ',' || c == ':' || c == '\n' || c == '\t' ||
  40997d:	74 39                	je     4099b8 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x1d8>
  40997f:	90                   	nop
  409980:	83 e0 fb             	and    $0xfffffffb,%eax
  while (is_space(buf_[pos_])) ++pos_;
}

void FlagParser::parse_flag() {
  uptr name_start = pos_;
  while (buf_[pos_] != 0 && buf_[pos_] != '=' && !is_space(buf_[pos_])) ++pos_;
  409983:	3c 09                	cmp    $0x9,%al
  409985:	74 31                	je     4099b8 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x1d8>
  409987:	48 83 c2 01          	add    $0x1,%rdx
  40998b:	48 89 53 18          	mov    %rdx,0x18(%rbx)
  40998f:	0f b6 04 11          	movzbl (%rcx,%rdx,1),%eax
  409993:	a8 df                	test   $0xdf,%al
  409995:	0f 84 70 fe ff ff    	je     40980b <_ZN11__sanitizer10FlagParser10parse_flagEv+0x2b>
  40999b:	3c 3d                	cmp    $0x3d,%al
  40999d:	0f 84 68 fe ff ff    	je     40980b <_ZN11__sanitizer10FlagParser10parse_flagEv+0x2b>
  Printf("ERROR: %s\n", err);
  Die();
}

bool FlagParser::is_space(char c) {
  return c == ' ' || c == ',' || c == ':' || c == '\n' || c == '\t' ||
  4099a3:	3c 2c                	cmp    $0x2c,%al
  4099a5:	74 11                	je     4099b8 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x1d8>
  4099a7:	3c 0a                	cmp    $0xa,%al
  4099a9:	74 0d                	je     4099b8 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x1d8>
  4099ab:	3c 3a                	cmp    $0x3a,%al
  4099ad:	0f 1f 00             	nopl   (%rax)
  4099b0:	75 ce                	jne    409980 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x1a0>
  4099b2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
}

void FlagParser::parse_flag() {
  uptr name_start = pos_;
  while (buf_[pos_] != 0 && buf_[pos_] != '=' && !is_space(buf_[pos_])) ++pos_;
  if (buf_[pos_] != '=') fatal_error("expected '='");
  4099b8:	48 8d 35 75 f1 00 00 	lea    0xf175(%rip),%rsi        # 418b34 <.LC5>
  4099bf:	48 89 df             	mov    %rbx,%rdi
  4099c2:	e8 89 fd ff ff       	callq  409750 <_ZN11__sanitizer10FlagParser11fatal_errorEPKc>
  4099c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4099ce:	00 00 
  Printf("ERROR: %s\n", err);
  Die();
}

bool FlagParser::is_space(char c) {
  return c == ' ' || c == ',' || c == ':' || c == '\n' || c == '\t' ||
  4099d0:	3c 2c                	cmp    $0x2c,%al
  4099d2:	74 6c                	je     409a40 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x260>
  4099d4:	3c 20                	cmp    $0x20,%al
  4099d6:	74 68                	je     409a40 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x260>
  4099d8:	3c 3a                	cmp    $0x3a,%al
  4099da:	74 64                	je     409a40 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x260>
  4099dc:	8d 48 f7             	lea    -0x9(%rax),%ecx
    while (buf_[pos_] != 0 && buf_[pos_] != quote) ++pos_;
    if (buf_[pos_] == 0) fatal_error("unterminated string");
    value = ll_strndup(buf_ + value_start + 1, pos_ - value_start - 1);
    ++pos_; // consume the closing quote
  } else {
    while (buf_[pos_] != 0 && !is_space(buf_[pos_])) ++pos_;
  4099df:	80 f9 01             	cmp    $0x1,%cl
  4099e2:	76 5c                	jbe    409a40 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x260>
  4099e4:	3c 0d                	cmp    $0xd,%al
  4099e6:	74 58                	je     409a40 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x260>
  4099e8:	49 8d 42 02          	lea    0x2(%r10),%rax
  4099ec:	48 89 43 18          	mov    %rax,0x18(%rbx)
  4099f0:	41 0f b6 0c 00       	movzbl (%r8,%rax,1),%ecx
  4099f5:	84 c9                	test   %cl,%cl
  4099f7:	74 37                	je     409a30 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x250>
  Printf("ERROR: %s\n", err);
  Die();
}

bool FlagParser::is_space(char c) {
  return c == ' ' || c == ',' || c == ':' || c == '\n' || c == '\t' ||
  4099f9:	80 f9 2c             	cmp    $0x2c,%cl
  4099fc:	74 32                	je     409a30 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x250>
  4099fe:	80 f9 20             	cmp    $0x20,%cl
  409a01:	74 2d                	je     409a30 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x250>
  409a03:	80 f9 3a             	cmp    $0x3a,%cl
  409a06:	74 28                	je     409a30 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x250>
  409a08:	8d 79 f7             	lea    -0x9(%rcx),%edi
  409a0b:	48 8d 70 01          	lea    0x1(%rax),%rsi
    while (buf_[pos_] != 0 && buf_[pos_] != quote) ++pos_;
    if (buf_[pos_] == 0) fatal_error("unterminated string");
    value = ll_strndup(buf_ + value_start + 1, pos_ - value_start - 1);
    ++pos_; // consume the closing quote
  } else {
    while (buf_[pos_] != 0 && !is_space(buf_[pos_])) ++pos_;
  409a0f:	40 80 ff 01          	cmp    $0x1,%dil
  409a13:	76 1b                	jbe    409a30 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x250>
  409a15:	80 f9 0d             	cmp    $0xd,%cl
  409a18:	74 16                	je     409a30 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x250>
  409a1a:	48 89 f0             	mov    %rsi,%rax
  409a1d:	48 89 43 18          	mov    %rax,0x18(%rbx)
  409a21:	41 0f b6 0c 00       	movzbl (%r8,%rax,1),%ecx
  409a26:	84 c9                	test   %cl,%cl
  409a28:	75 cf                	jne    4099f9 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x219>
  409a2a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  409a30:	48 29 d0             	sub    %rdx,%rax
  409a33:	48 89 c6             	mov    %rax,%rsi
  409a36:	e9 42 fe ff ff       	jmpq   40987d <_ZN11__sanitizer10FlagParser10parse_flagEv+0x9d>
  409a3b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  409a40:	48 89 d0             	mov    %rdx,%rax
  409a43:	48 29 d0             	sub    %rdx,%rax
  409a46:	48 89 c6             	mov    %rax,%rsi
  409a49:	e9 2f fe ff ff       	jmpq   40987d <_ZN11__sanitizer10FlagParser10parse_flagEv+0x9d>
  409a4e:	66 90                	xchg   %ax,%ax
  const char *unknown_flags_[kMaxUnknownFlags];
  int n_unknown_flags_;

 public:
  void Add(const char *name) {
    CHECK_LT(n_unknown_flags_, kMaxUnknownFlags);
  409a50:	8b 05 0a 7f 26 00    	mov    0x267f0a(%rip),%eax        # 671960 <_ZN11__sanitizer13unknown_flagsE+0xa0>
  409a56:	48 63 c8             	movslq %eax,%rcx
  409a59:	48 83 f9 13          	cmp    $0x13,%rcx
  409a5d:	77 63                	ja     409ac2 <_ZN11__sanitizer10FlagParser10parse_flagEv+0x2e2>
    unknown_flags_[n_unknown_flags_++] = name;
  409a5f:	83 c0 01             	add    $0x1,%eax
  409a62:	89 05 f8 7e 26 00    	mov    %eax,0x267ef8(%rip)        # 671960 <_ZN11__sanitizer13unknown_flagsE+0xa0>
  409a68:	48 8d 05 51 7e 26 00 	lea    0x267e51(%rip),%rax        # 6718c0 <_ZN11__sanitizer13unknown_flagsE>
  409a6f:	4c 89 2c c8          	mov    %r13,(%rax,%rcx,8)
    value = ll_strndup(buf_ + value_start, pos_ - value_start);
  }

  bool res = run_handler(name, value);
  if (!res) fatal_error("Flag parsing failed.");
}
  409a73:	5b                   	pop    %rbx
  409a74:	5d                   	pop    %rbp
  409a75:	41 5c                	pop    %r12
  409a77:	41 5d                	pop    %r13
  409a79:	41 5e                	pop    %r14
  409a7b:	c3                   	retq   
  409a7c:	0f 1f 40 00          	nopl   0x0(%rax)
  char *value;
  if (buf_[pos_] == '\'' || buf_[pos_] == '"') {
    char quote = buf_[pos_++];
    while (buf_[pos_] != 0 && buf_[pos_] != quote) ++pos_;
    if (buf_[pos_] == 0) fatal_error("unterminated string");
    value = ll_strndup(buf_ + value_start + 1, pos_ - value_start - 1);
  409a80:	4c 29 d0             	sub    %r10,%rax
void ReportUnrecognizedFlags() {
  unknown_flags.Report();
}

char *FlagParser::ll_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  409a83:	48 89 ef             	mov    %rbp,%rdi
  char *value;
  if (buf_[pos_] == '\'' || buf_[pos_] == '"') {
    char quote = buf_[pos_++];
    while (buf_[pos_] != 0 && buf_[pos_] != quote) ++pos_;
    if (buf_[pos_] == 0) fatal_error("unterminated string");
    value = ll_strndup(buf_ + value_start + 1, pos_ - value_start - 1);
  409a86:	48 8d 70 fe          	lea    -0x2(%rax),%rsi
void ReportUnrecognizedFlags() {
  unknown_flags.Report();
}

char *FlagParser::ll_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  409a8a:	e8 81 0f 00 00       	callq  40aa10 <_ZN11__sanitizer16internal_strnlenEPKcm>
  char *s2 = (char*)Alloc.Allocate(len + 1);
  409a8f:	48 8d 3d da 7e 26 00 	lea    0x267eda(%rip),%rdi        # 671970 <_ZN11__sanitizer10FlagParser5AllocE>
  409a96:	48 8d 70 01          	lea    0x1(%rax),%rsi
void ReportUnrecognizedFlags() {
  unknown_flags.Report();
}

char *FlagParser::ll_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  409a9a:	49 89 c4             	mov    %rax,%r12
  char *s2 = (char*)Alloc.Allocate(len + 1);
  409a9d:	e8 6e 97 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
  internal_memcpy(s2, s, len);
  409aa2:	4c 89 e2             	mov    %r12,%rdx
  unknown_flags.Report();
}

char *FlagParser::ll_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  char *s2 = (char*)Alloc.Allocate(len + 1);
  409aa5:	49 89 c6             	mov    %rax,%r14
  internal_memcpy(s2, s, len);
  409aa8:	48 89 ee             	mov    %rbp,%rsi
  409aab:	48 89 c7             	mov    %rax,%rdi
  409aae:	e8 5d 04 00 00       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
  s2[len] = 0;
  409ab3:	43 c6 04 26 00       	movb   $0x0,(%r14,%r12,1)
  if (buf_[pos_] == '\'' || buf_[pos_] == '"') {
    char quote = buf_[pos_++];
    while (buf_[pos_] != 0 && buf_[pos_] != quote) ++pos_;
    if (buf_[pos_] == 0) fatal_error("unterminated string");
    value = ll_strndup(buf_ + value_start + 1, pos_ - value_start - 1);
    ++pos_; // consume the closing quote
  409ab8:	48 83 43 18 01       	addq   $0x1,0x18(%rbx)
  409abd:	e9 ec fd ff ff       	jmpq   4098ae <_ZN11__sanitizer10FlagParser10parse_flagEv+0xce>
  const char *unknown_flags_[kMaxUnknownFlags];
  int n_unknown_flags_;

 public:
  void Add(const char *name) {
    CHECK_LT(n_unknown_flags_, kMaxUnknownFlags);
  409ac2:	48 8d 15 df d3 00 00 	lea    0xd3df(%rip),%rdx        # 416ea8 <.LC6>
  409ac9:	48 8d 3d 08 d4 00 00 	lea    0xd408(%rip),%rdi        # 416ed8 <.LC7>
  409ad0:	41 b8 14 00 00 00    	mov    $0x14,%r8d
  409ad6:	be 20 00 00 00       	mov    $0x20,%esi
  409adb:	e8 10 b9 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

0000000000409ae0 <_ZN11__sanitizer10FlagParser11parse_flagsEv>:

  bool res = run_handler(name, value);
  if (!res) fatal_error("Flag parsing failed.");
}

void FlagParser::parse_flags() {
  409ae0:	53                   	push   %rbx
  409ae1:	48 89 fb             	mov    %rdi,%rbx
  409ae4:	48 8b 57 18          	mov    0x18(%rdi),%rdx
  409ae8:	48 8b 4f 10          	mov    0x10(%rdi),%rcx
  409aec:	eb 0a                	jmp    409af8 <_ZN11__sanitizer10FlagParser11parse_flagsEv+0x18>
  409aee:	66 90                	xchg   %ax,%ax
  return c == ' ' || c == ',' || c == ':' || c == '\n' || c == '\t' ||
         c == '\r';
}

void FlagParser::skip_whitespace() {
  while (is_space(buf_[pos_])) ++pos_;
  409af0:	48 83 c2 01          	add    $0x1,%rdx
  409af4:	48 89 53 18          	mov    %rdx,0x18(%rbx)
  409af8:	0f b6 04 11          	movzbl (%rcx,%rdx,1),%eax
  Printf("ERROR: %s\n", err);
  Die();
}

bool FlagParser::is_space(char c) {
  return c == ' ' || c == ',' || c == ':' || c == '\n' || c == '\t' ||
  409afc:	3c 20                	cmp    $0x20,%al
  409afe:	74 f0                	je     409af0 <_ZN11__sanitizer10FlagParser11parse_flagsEv+0x10>
  409b00:	3c 2c                	cmp    $0x2c,%al
  409b02:	74 ec                	je     409af0 <_ZN11__sanitizer10FlagParser11parse_flagsEv+0x10>
  409b04:	3c 3a                	cmp    $0x3a,%al
  409b06:	74 e8                	je     409af0 <_ZN11__sanitizer10FlagParser11parse_flagsEv+0x10>
  409b08:	8d 70 f7             	lea    -0x9(%rax),%esi
         c == '\r';
}

void FlagParser::skip_whitespace() {
  while (is_space(buf_[pos_])) ++pos_;
  409b0b:	40 80 fe 01          	cmp    $0x1,%sil
  409b0f:	76 df                	jbe    409af0 <_ZN11__sanitizer10FlagParser11parse_flagsEv+0x10>
  409b11:	3c 0d                	cmp    $0xd,%al
  409b13:	74 db                	je     409af0 <_ZN11__sanitizer10FlagParser11parse_flagsEv+0x10>
}

void FlagParser::parse_flags() {
  while (true) {
    skip_whitespace();
    if (buf_[pos_] == 0) break;
  409b15:	84 c0                	test   %al,%al
  409b17:	74 12                	je     409b2b <_ZN11__sanitizer10FlagParser11parse_flagsEv+0x4b>
    parse_flag();
  409b19:	48 89 df             	mov    %rbx,%rdi
  409b1c:	e8 bf fc ff ff       	callq  4097e0 <_ZN11__sanitizer10FlagParser10parse_flagEv>
  409b21:	48 8b 4b 10          	mov    0x10(%rbx),%rcx
  409b25:	48 8b 53 18          	mov    0x18(%rbx),%rdx

  bool res = run_handler(name, value);
  if (!res) fatal_error("Flag parsing failed.");
}

void FlagParser::parse_flags() {
  409b29:	eb cd                	jmp    409af8 <_ZN11__sanitizer10FlagParser11parse_flagsEv+0x18>
    if (buf_[pos_] == 0) break;
    parse_flag();
  }

  // Do a sanity check for certain flags.
  if (common_flags_dont_use.malloc_context_size < 1)
  409b2b:	48 8b 05 86 47 01 00 	mov    0x14786(%rip),%rax        # 41e2b8 <_DYNAMIC+0x2b8>
  409b32:	8b 50 24             	mov    0x24(%rax),%edx
  409b35:	85 d2                	test   %edx,%edx
  409b37:	7e 02                	jle    409b3b <_ZN11__sanitizer10FlagParser11parse_flagsEv+0x5b>
    common_flags_dont_use.malloc_context_size = 1;
}
  409b39:	5b                   	pop    %rbx
  409b3a:	c3                   	retq   
    parse_flag();
  }

  // Do a sanity check for certain flags.
  if (common_flags_dont_use.malloc_context_size < 1)
    common_flags_dont_use.malloc_context_size = 1;
  409b3b:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%rax)
}
  409b42:	5b                   	pop    %rbx
  409b43:	c3                   	retq   
  409b44:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  409b4b:	00 00 00 00 00 

0000000000409b50 <_ZN11__sanitizer10FlagParser11ParseStringEPKc>:

void FlagParser::ParseString(const char *s) {
  if (!s) return;
  409b50:	48 85 f6             	test   %rsi,%rsi
  409b53:	74 7e                	je     409bd3 <_ZN11__sanitizer10FlagParser11ParseStringEPKc+0x83>
  // Do a sanity check for certain flags.
  if (common_flags_dont_use.malloc_context_size < 1)
    common_flags_dont_use.malloc_context_size = 1;
}

void FlagParser::ParseString(const char *s) {
  409b55:	41 54                	push   %r12
  if (!s) return;
  // Backup current parser state to allow nested ParseString() calls.
  const char *old_buf_ = buf_;
  uptr old_pos_ = pos_;
  buf_ = s;
  pos_ = 0;
  409b57:	31 d2                	xor    %edx,%edx
  // Do a sanity check for certain flags.
  if (common_flags_dont_use.malloc_context_size < 1)
    common_flags_dont_use.malloc_context_size = 1;
}

void FlagParser::ParseString(const char *s) {
  409b59:	55                   	push   %rbp
  409b5a:	53                   	push   %rbx
  409b5b:	48 89 fb             	mov    %rdi,%rbx
  if (!s) return;
  // Backup current parser state to allow nested ParseString() calls.
  const char *old_buf_ = buf_;
  409b5e:	4c 8b 67 10          	mov    0x10(%rdi),%r12
  uptr old_pos_ = pos_;
  409b62:	48 8b 6f 18          	mov    0x18(%rdi),%rbp
  buf_ = s;
  409b66:	48 89 77 10          	mov    %rsi,0x10(%rdi)
  pos_ = 0;
  409b6a:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
  409b71:	00 
  409b72:	eb 0c                	jmp    409b80 <_ZN11__sanitizer10FlagParser11ParseStringEPKc+0x30>
  409b74:	0f 1f 40 00          	nopl   0x0(%rax)
  return c == ' ' || c == ',' || c == ':' || c == '\n' || c == '\t' ||
         c == '\r';
}

void FlagParser::skip_whitespace() {
  while (is_space(buf_[pos_])) ++pos_;
  409b78:	48 83 c2 01          	add    $0x1,%rdx
  409b7c:	48 89 53 18          	mov    %rdx,0x18(%rbx)
  409b80:	0f b6 04 16          	movzbl (%rsi,%rdx,1),%eax
  Printf("ERROR: %s\n", err);
  Die();
}

bool FlagParser::is_space(char c) {
  return c == ' ' || c == ',' || c == ':' || c == '\n' || c == '\t' ||
  409b84:	3c 20                	cmp    $0x20,%al
  409b86:	74 f0                	je     409b78 <_ZN11__sanitizer10FlagParser11ParseStringEPKc+0x28>
  409b88:	3c 2c                	cmp    $0x2c,%al
  409b8a:	74 ec                	je     409b78 <_ZN11__sanitizer10FlagParser11ParseStringEPKc+0x28>
  409b8c:	3c 3a                	cmp    $0x3a,%al
  409b8e:	74 e8                	je     409b78 <_ZN11__sanitizer10FlagParser11ParseStringEPKc+0x28>
  409b90:	8d 48 f7             	lea    -0x9(%rax),%ecx
         c == '\r';
}

void FlagParser::skip_whitespace() {
  while (is_space(buf_[pos_])) ++pos_;
  409b93:	80 f9 01             	cmp    $0x1,%cl
  409b96:	76 e0                	jbe    409b78 <_ZN11__sanitizer10FlagParser11ParseStringEPKc+0x28>
  409b98:	3c 0d                	cmp    $0xd,%al
  409b9a:	74 dc                	je     409b78 <_ZN11__sanitizer10FlagParser11ParseStringEPKc+0x28>
}

void FlagParser::parse_flags() {
  while (true) {
    skip_whitespace();
    if (buf_[pos_] == 0) break;
  409b9c:	84 c0                	test   %al,%al
  409b9e:	74 12                	je     409bb2 <_ZN11__sanitizer10FlagParser11ParseStringEPKc+0x62>
    parse_flag();
  409ba0:	48 89 df             	mov    %rbx,%rdi
  409ba3:	e8 38 fc ff ff       	callq  4097e0 <_ZN11__sanitizer10FlagParser10parse_flagEv>
  409ba8:	48 8b 73 10          	mov    0x10(%rbx),%rsi
  409bac:	48 8b 53 18          	mov    0x18(%rbx),%rdx
  409bb0:	eb ce                	jmp    409b80 <_ZN11__sanitizer10FlagParser11ParseStringEPKc+0x30>
  }

  // Do a sanity check for certain flags.
  if (common_flags_dont_use.malloc_context_size < 1)
  409bb2:	48 8b 05 ff 46 01 00 	mov    0x146ff(%rip),%rax        # 41e2b8 <_DYNAMIC+0x2b8>
  409bb9:	8b 50 24             	mov    0x24(%rax),%edx
  409bbc:	85 d2                	test   %edx,%edx
  409bbe:	7f 07                	jg     409bc7 <_ZN11__sanitizer10FlagParser11ParseStringEPKc+0x77>
    common_flags_dont_use.malloc_context_size = 1;
  409bc0:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%rax)
  buf_ = s;
  pos_ = 0;

  parse_flags();

  buf_ = old_buf_;
  409bc7:	4c 89 63 10          	mov    %r12,0x10(%rbx)
  pos_ = old_pos_;
  409bcb:	48 89 6b 18          	mov    %rbp,0x18(%rbx)
}
  409bcf:	5b                   	pop    %rbx
  409bd0:	5d                   	pop    %rbp
  409bd1:	41 5c                	pop    %r12
  409bd3:	f3 c3                	repz retq 
  409bd5:	90                   	nop
  409bd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  409bdd:	00 00 00 

0000000000409be0 <_ZN11__sanitizer10FlagParser9ParseFileEPKcb>:

bool FlagParser::ParseFile(const char *path, bool ignore_missing) {
  409be0:	41 55                	push   %r13
  409be2:	49 89 fd             	mov    %rdi,%r13
  409be5:	41 54                	push   %r12
  409be7:	41 89 d4             	mov    %edx,%r12d
  409bea:	55                   	push   %rbp
  409beb:	48 89 f5             	mov    %rsi,%rbp
  409bee:	53                   	push   %rbx
  409bef:	48 83 ec 48          	sub    $0x48,%rsp
  char *data;
  uptr data_mapped_size;
  error_t err;
  uptr len;
  if (!ReadFileToBuffer(path, &data, &data_mapped_size, &len,
                        Max(kMaxIncludeSize, GetPageSizeCached()), &err)) {
  409bf3:	e8 b8 b4 ff ff       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
}

// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
  409bf8:	41 b8 00 80 00 00    	mov    $0x8000,%r8d
  409bfe:	48 3d ff 7f 00 00    	cmp    $0x7fff,%rax
  409c04:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
  409c09:	48 8d 54 24 20       	lea    0x20(%rsp),%rdx
  409c0e:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
  409c13:	4c 0f 47 c0          	cmova  %rax,%r8
  409c17:	49 89 e1             	mov    %rsp,%r9
  409c1a:	48 89 ef             	mov    %rbp,%rdi
  409c1d:	e8 ce b9 ff ff       	callq  4055f0 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi>
  static const uptr kMaxIncludeSize = 1 << 15;
  char *data;
  uptr data_mapped_size;
  error_t err;
  uptr len;
  if (!ReadFileToBuffer(path, &data, &data_mapped_size, &len,
  409c22:	84 c0                	test   %al,%al
                        Max(kMaxIncludeSize, GetPageSizeCached()), &err)) {
  409c24:	89 c3                	mov    %eax,%ebx
  static const uptr kMaxIncludeSize = 1 << 15;
  char *data;
  uptr data_mapped_size;
  error_t err;
  uptr len;
  if (!ReadFileToBuffer(path, &data, &data_mapped_size, &len,
  409c26:	75 20                	jne    409c48 <_ZN11__sanitizer10FlagParser9ParseFileEPKcb+0x68>
                        Max(kMaxIncludeSize, GetPageSizeCached()), &err)) {
    if (ignore_missing)
  409c28:	45 84 e4             	test   %r12b,%r12b
  409c2b:	0f 84 b7 00 00 00    	je     409ce8 <_ZN11__sanitizer10FlagParser9ParseFileEPKcb+0x108>
    return false;
  }
  ParseString(data);
  UnmapOrDie(data, data_mapped_size);
  return true;
}
  409c31:	48 83 c4 48          	add    $0x48,%rsp
  error_t err;
  uptr len;
  if (!ReadFileToBuffer(path, &data, &data_mapped_size, &len,
                        Max(kMaxIncludeSize, GetPageSizeCached()), &err)) {
    if (ignore_missing)
      return true;
  409c35:	bb 01 00 00 00       	mov    $0x1,%ebx
    return false;
  }
  ParseString(data);
  UnmapOrDie(data, data_mapped_size);
  return true;
}
  409c3a:	89 d8                	mov    %ebx,%eax
  409c3c:	5b                   	pop    %rbx
  409c3d:	5d                   	pop    %rbp
  409c3e:	41 5c                	pop    %r12
  409c40:	41 5d                	pop    %r13
  409c42:	c3                   	retq   
  409c43:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    if (ignore_missing)
      return true;
    Printf("Failed to read options from '%s': error %d\n", path, err);
    return false;
  }
  ParseString(data);
  409c48:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  if (common_flags_dont_use.malloc_context_size < 1)
    common_flags_dont_use.malloc_context_size = 1;
}

void FlagParser::ParseString(const char *s) {
  if (!s) return;
  409c4d:	31 ff                	xor    %edi,%edi
  409c4f:	48 85 c0             	test   %rax,%rax
  409c52:	74 7d                	je     409cd1 <_ZN11__sanitizer10FlagParser9ParseFileEPKcb+0xf1>
  // Backup current parser state to allow nested ParseString() calls.
  const char *old_buf_ = buf_;
  409c54:	4d 8b 65 10          	mov    0x10(%r13),%r12
  uptr old_pos_ = pos_;
  409c58:	49 8b 6d 18          	mov    0x18(%r13),%rbp
  buf_ = s;
  pos_ = 0;
  409c5c:	31 c9                	xor    %ecx,%ecx
void FlagParser::ParseString(const char *s) {
  if (!s) return;
  // Backup current parser state to allow nested ParseString() calls.
  const char *old_buf_ = buf_;
  uptr old_pos_ = pos_;
  buf_ = s;
  409c5e:	49 89 45 10          	mov    %rax,0x10(%r13)
  pos_ = 0;
  409c62:	49 c7 45 18 00 00 00 	movq   $0x0,0x18(%r13)
  409c69:	00 
  409c6a:	eb 0c                	jmp    409c78 <_ZN11__sanitizer10FlagParser9ParseFileEPKcb+0x98>
  409c6c:	0f 1f 40 00          	nopl   0x0(%rax)
  return c == ' ' || c == ',' || c == ':' || c == '\n' || c == '\t' ||
         c == '\r';
}

void FlagParser::skip_whitespace() {
  while (is_space(buf_[pos_])) ++pos_;
  409c70:	48 83 c1 01          	add    $0x1,%rcx
  409c74:	49 89 4d 18          	mov    %rcx,0x18(%r13)
  409c78:	0f b6 14 08          	movzbl (%rax,%rcx,1),%edx
  Printf("ERROR: %s\n", err);
  Die();
}

bool FlagParser::is_space(char c) {
  return c == ' ' || c == ',' || c == ':' || c == '\n' || c == '\t' ||
  409c7c:	80 fa 20             	cmp    $0x20,%dl
  409c7f:	74 ef                	je     409c70 <_ZN11__sanitizer10FlagParser9ParseFileEPKcb+0x90>
  409c81:	80 fa 2c             	cmp    $0x2c,%dl
  409c84:	74 ea                	je     409c70 <_ZN11__sanitizer10FlagParser9ParseFileEPKcb+0x90>
  409c86:	80 fa 3a             	cmp    $0x3a,%dl
  409c89:	74 e5                	je     409c70 <_ZN11__sanitizer10FlagParser9ParseFileEPKcb+0x90>
  409c8b:	8d 72 f7             	lea    -0x9(%rdx),%esi
         c == '\r';
}

void FlagParser::skip_whitespace() {
  while (is_space(buf_[pos_])) ++pos_;
  409c8e:	40 80 fe 01          	cmp    $0x1,%sil
  409c92:	76 dc                	jbe    409c70 <_ZN11__sanitizer10FlagParser9ParseFileEPKcb+0x90>
  409c94:	80 fa 0d             	cmp    $0xd,%dl
  409c97:	74 d7                	je     409c70 <_ZN11__sanitizer10FlagParser9ParseFileEPKcb+0x90>
}

void FlagParser::parse_flags() {
  while (true) {
    skip_whitespace();
    if (buf_[pos_] == 0) break;
  409c99:	84 d2                	test   %dl,%dl
  409c9b:	74 12                	je     409caf <_ZN11__sanitizer10FlagParser9ParseFileEPKcb+0xcf>
    parse_flag();
  409c9d:	4c 89 ef             	mov    %r13,%rdi
  409ca0:	e8 3b fb ff ff       	callq  4097e0 <_ZN11__sanitizer10FlagParser10parse_flagEv>
  409ca5:	49 8b 4d 18          	mov    0x18(%r13),%rcx
  409ca9:	49 8b 45 10          	mov    0x10(%r13),%rax
  409cad:	eb c9                	jmp    409c78 <_ZN11__sanitizer10FlagParser9ParseFileEPKcb+0x98>
  }

  // Do a sanity check for certain flags.
  if (common_flags_dont_use.malloc_context_size < 1)
  409caf:	48 8b 05 02 46 01 00 	mov    0x14602(%rip),%rax        # 41e2b8 <_DYNAMIC+0x2b8>
  409cb6:	8b 50 24             	mov    0x24(%rax),%edx
  409cb9:	85 d2                	test   %edx,%edx
  409cbb:	7f 07                	jg     409cc4 <_ZN11__sanitizer10FlagParser9ParseFileEPKcb+0xe4>
    common_flags_dont_use.malloc_context_size = 1;
  409cbd:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%rax)
  409cc4:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  buf_ = s;
  pos_ = 0;

  parse_flags();

  buf_ = old_buf_;
  409cc9:	4d 89 65 10          	mov    %r12,0x10(%r13)
  pos_ = old_pos_;
  409ccd:	49 89 6d 18          	mov    %rbp,0x18(%r13)
      return true;
    Printf("Failed to read options from '%s': error %d\n", path, err);
    return false;
  }
  ParseString(data);
  UnmapOrDie(data, data_mapped_size);
  409cd1:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
  409cd6:	e8 65 27 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  return true;
}
  409cdb:	48 83 c4 48          	add    $0x48,%rsp
  409cdf:	89 d8                	mov    %ebx,%eax
  409ce1:	5b                   	pop    %rbx
  409ce2:	5d                   	pop    %rbp
  409ce3:	41 5c                	pop    %r12
  409ce5:	41 5d                	pop    %r13
  409ce7:	c3                   	retq   
  uptr len;
  if (!ReadFileToBuffer(path, &data, &data_mapped_size, &len,
                        Max(kMaxIncludeSize, GetPageSizeCached()), &err)) {
    if (ignore_missing)
      return true;
    Printf("Failed to read options from '%s': error %d\n", path, err);
  409ce8:	8b 14 24             	mov    (%rsp),%edx
  409ceb:	48 8d 3d 5e d2 00 00 	lea    0xd25e(%rip),%rdi        # 416f50 <.LC10>
  409cf2:	48 89 ee             	mov    %rbp,%rsi
  409cf5:	31 c0                	xor    %eax,%eax
  409cf7:	e8 f4 3c 00 00       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
    return false;
  }
  ParseString(data);
  UnmapOrDie(data, data_mapped_size);
  return true;
}
  409cfc:	48 83 c4 48          	add    $0x48,%rsp
  409d00:	89 d8                	mov    %ebx,%eax
  409d02:	5b                   	pop    %rbx
  409d03:	5d                   	pop    %rbp
  409d04:	41 5c                	pop    %r12
  409d06:	41 5d                	pop    %r13
  409d08:	c3                   	retq   
  409d09:	90                   	nop
  409d0a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000409d10 <_ZN11__sanitizer10FlagParser11run_handlerEPKcS2_>:

bool FlagParser::run_handler(const char *name, const char *value) {
  409d10:	41 56                	push   %r14
  409d12:	49 89 d6             	mov    %rdx,%r14
  409d15:	41 55                	push   %r13
  409d17:	49 89 f5             	mov    %rsi,%r13
  409d1a:	41 54                	push   %r12
  409d1c:	49 89 fc             	mov    %rdi,%r12
  409d1f:	55                   	push   %rbp
  for (int i = 0; i < n_flags_; ++i) {
  409d20:	31 ed                	xor    %ebp,%ebp
  ParseString(data);
  UnmapOrDie(data, data_mapped_size);
  return true;
}

bool FlagParser::run_handler(const char *name, const char *value) {
  409d22:	53                   	push   %rbx
  for (int i = 0; i < n_flags_; ++i) {
  409d23:	8b 47 08             	mov    0x8(%rdi),%eax
  409d26:	31 db                	xor    %ebx,%ebx
  409d28:	85 c0                	test   %eax,%eax
  409d2a:	7f 12                	jg     409d3e <_ZN11__sanitizer10FlagParser11run_handlerEPKcS2_+0x2e>
  409d2c:	eb 42                	jmp    409d70 <_ZN11__sanitizer10FlagParser11run_handlerEPKcS2_+0x60>
  409d2e:	66 90                	xchg   %ax,%ax
  409d30:	83 c5 01             	add    $0x1,%ebp
  409d33:	48 83 c3 18          	add    $0x18,%rbx
  409d37:	41 39 6c 24 08       	cmp    %ebp,0x8(%r12)
  409d3c:	7e 32                	jle    409d70 <_ZN11__sanitizer10FlagParser11run_handlerEPKcS2_+0x60>
    if (internal_strcmp(name, flags_[i].name) == 0)
  409d3e:	49 8b 04 24          	mov    (%r12),%rax
  409d42:	4c 89 ef             	mov    %r13,%rdi
  409d45:	48 8b 34 18          	mov    (%rax,%rbx,1),%rsi
  409d49:	e8 92 0a 00 00       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
  409d4e:	85 c0                	test   %eax,%eax
  409d50:	75 de                	jne    409d30 <_ZN11__sanitizer10FlagParser11run_handlerEPKcS2_+0x20>
      return flags_[i].handler->Parse(value);
  409d52:	49 8b 04 24          	mov    (%r12),%rax
  409d56:	4c 89 f6             	mov    %r14,%rsi
  409d59:	48 8b 7c 18 10       	mov    0x10(%rax,%rbx,1),%rdi
  }
  // Unrecognized flag. This is not a fatal error, we may print a warning later.
  unknown_flags.Add(name);
  return true;
}
  409d5e:	5b                   	pop    %rbx
  409d5f:	5d                   	pop    %rbp
  409d60:	41 5c                	pop    %r12
}

bool FlagParser::run_handler(const char *name, const char *value) {
  for (int i = 0; i < n_flags_; ++i) {
    if (internal_strcmp(name, flags_[i].name) == 0)
      return flags_[i].handler->Parse(value);
  409d62:	48 8b 07             	mov    (%rdi),%rax
  }
  // Unrecognized flag. This is not a fatal error, we may print a warning later.
  unknown_flags.Add(name);
  return true;
}
  409d65:	41 5d                	pop    %r13
  409d67:	41 5e                	pop    %r14
}

bool FlagParser::run_handler(const char *name, const char *value) {
  for (int i = 0; i < n_flags_; ++i) {
    if (internal_strcmp(name, flags_[i].name) == 0)
      return flags_[i].handler->Parse(value);
  409d69:	48 8b 00             	mov    (%rax),%rax
  409d6c:	ff e0                	jmpq   *%rax
  409d6e:	66 90                	xchg   %ax,%ax
  const char *unknown_flags_[kMaxUnknownFlags];
  int n_unknown_flags_;

 public:
  void Add(const char *name) {
    CHECK_LT(n_unknown_flags_, kMaxUnknownFlags);
  409d70:	8b 05 ea 7b 26 00    	mov    0x267bea(%rip),%eax        # 671960 <_ZN11__sanitizer13unknown_flagsE+0xa0>
  409d76:	48 63 c8             	movslq %eax,%rcx
  409d79:	48 83 f9 13          	cmp    $0x13,%rcx
  409d7d:	77 22                	ja     409da1 <_ZN11__sanitizer10FlagParser11run_handlerEPKcS2_+0x91>
    unknown_flags_[n_unknown_flags_++] = name;
  409d7f:	83 c0 01             	add    $0x1,%eax
  409d82:	89 05 d8 7b 26 00    	mov    %eax,0x267bd8(%rip)        # 671960 <_ZN11__sanitizer13unknown_flagsE+0xa0>
  409d88:	48 8d 05 31 7b 26 00 	lea    0x267b31(%rip),%rax        # 6718c0 <_ZN11__sanitizer13unknown_flagsE>
  409d8f:	4c 89 2c c8          	mov    %r13,(%rax,%rcx,8)
      return flags_[i].handler->Parse(value);
  }
  // Unrecognized flag. This is not a fatal error, we may print a warning later.
  unknown_flags.Add(name);
  return true;
}
  409d93:	b8 01 00 00 00       	mov    $0x1,%eax
  409d98:	5b                   	pop    %rbx
  409d99:	5d                   	pop    %rbp
  409d9a:	41 5c                	pop    %r12
  409d9c:	41 5d                	pop    %r13
  409d9e:	41 5e                	pop    %r14
  409da0:	c3                   	retq   
  const char *unknown_flags_[kMaxUnknownFlags];
  int n_unknown_flags_;

 public:
  void Add(const char *name) {
    CHECK_LT(n_unknown_flags_, kMaxUnknownFlags);
  409da1:	48 8d 15 00 d1 00 00 	lea    0xd100(%rip),%rdx        # 416ea8 <.LC6>
  409da8:	48 8d 3d 29 d1 00 00 	lea    0xd129(%rip),%rdi        # 416ed8 <.LC7>
  409daf:	41 b8 14 00 00 00    	mov    $0x14,%r8d
  409db5:	be 20 00 00 00       	mov    $0x20,%esi
  409dba:	e8 31 b6 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  409dbf:	90                   	nop

0000000000409dc0 <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_>:
  return true;
}

void FlagParser::RegisterHandler(const char *name, FlagHandlerBase *handler,
                                 const char *desc) {
  CHECK_LT(n_flags_, kMaxFlags);
  409dc0:	44 8b 47 08          	mov    0x8(%rdi),%r8d
  409dc4:	49 63 c0             	movslq %r8d,%rax
  409dc7:	48 3d c7 00 00 00    	cmp    $0xc7,%rax
  409dcd:	77 1f                	ja     409dee <_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_+0x2e>
  flags_[n_flags_].name = name;
  409dcf:	4c 8d 0c 40          	lea    (%rax,%rax,2),%r9
  409dd3:	48 8b 07             	mov    (%rdi),%rax
  flags_[n_flags_].desc = desc;
  flags_[n_flags_].handler = handler;
  ++n_flags_;
  409dd6:	41 83 c0 01          	add    $0x1,%r8d
}

void FlagParser::RegisterHandler(const char *name, FlagHandlerBase *handler,
                                 const char *desc) {
  CHECK_LT(n_flags_, kMaxFlags);
  flags_[n_flags_].name = name;
  409dda:	4a 8d 04 c8          	lea    (%rax,%r9,8),%rax
  409dde:	48 89 30             	mov    %rsi,(%rax)
  flags_[n_flags_].desc = desc;
  409de1:	48 89 48 08          	mov    %rcx,0x8(%rax)
  flags_[n_flags_].handler = handler;
  409de5:	48 89 50 10          	mov    %rdx,0x10(%rax)
  ++n_flags_;
  409de9:	44 89 47 08          	mov    %r8d,0x8(%rdi)
  409ded:	c3                   	retq   
  return true;
}

void FlagParser::RegisterHandler(const char *name, FlagHandlerBase *handler,
                                 const char *desc) {
  CHECK_LT(n_flags_, kMaxFlags);
  409dee:	48 8d 3d e3 d0 00 00 	lea    0xd0e3(%rip),%rdi        # 416ed8 <.LC7>
  unknown_flags.Add(name);
  return true;
}

void FlagParser::RegisterHandler(const char *name, FlagHandlerBase *handler,
                                 const char *desc) {
  409df5:	52                   	push   %rdx
  CHECK_LT(n_flags_, kMaxFlags);
  409df6:	48 8d 15 6d ed 00 00 	lea    0xed6d(%rip),%rdx        # 418b6a <.LC11>
  409dfd:	41 b8 c8 00 00 00    	mov    $0xc8,%r8d
  409e03:	48 89 c1             	mov    %rax,%rcx
  409e06:	be a0 00 00 00       	mov    $0xa0,%esi
  409e0b:	e8 e0 b5 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

0000000000409e10 <_ZN11__sanitizer10FlagParserC1Ev>:
  flags_[n_flags_].desc = desc;
  flags_[n_flags_].handler = handler;
  ++n_flags_;
}

FlagParser::FlagParser() : n_flags_(0), buf_(nullptr), pos_(0) {
  409e10:	53                   	push   %rbx
  409e11:	48 89 fb             	mov    %rdi,%rbx
  409e14:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%rdi)
  409e1b:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  409e22:	00 
  409e23:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
  409e2a:	00 
  flags_ = (Flag *)Alloc.Allocate(sizeof(Flag) * kMaxFlags);
  409e2b:	48 8d 3d 3e 7b 26 00 	lea    0x267b3e(%rip),%rdi        # 671970 <_ZN11__sanitizer10FlagParser5AllocE>
  409e32:	be c0 12 00 00       	mov    $0x12c0,%esi
  409e37:	e8 d4 93 ff ff       	callq  403210 <_ZN11__sanitizer17LowLevelAllocator8AllocateEm>
  409e3c:	48 89 03             	mov    %rax,(%rbx)
}
  409e3f:	5b                   	pop    %rbx
  409e40:	c3                   	retq   
  409e41:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  409e48:	0f 1f 84 00 00 00 00 
  409e4f:	00 

0000000000409e50 <_ZN11__sanitizer15internal_memchrEPKvim>:
  return internal_simple_strtoll(nptr, nullptr, 10);
}

void *internal_memchr(const void *s, int c, uptr n) {
  const char *t = (const char *)s;
  for (uptr i = 0; i < n; ++i, ++t)
  409e50:	48 85 d2             	test   %rdx,%rdx
  409e53:	74 23                	je     409e78 <_ZN11__sanitizer15internal_memchrEPKvim+0x28>
    if (*t == c)
  409e55:	0f be 07             	movsbl (%rdi),%eax
  409e58:	39 f0                	cmp    %esi,%eax
  409e5a:	74 24                	je     409e80 <_ZN11__sanitizer15internal_memchrEPKvim+0x30>
  409e5c:	48 01 fa             	add    %rdi,%rdx
  409e5f:	eb 0e                	jmp    409e6f <_ZN11__sanitizer15internal_memchrEPKvim+0x1f>
  409e61:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  409e68:	0f be 07             	movsbl (%rdi),%eax
  409e6b:	39 f0                	cmp    %esi,%eax
  409e6d:	74 11                	je     409e80 <_ZN11__sanitizer15internal_memchrEPKvim+0x30>
  return internal_simple_strtoll(nptr, nullptr, 10);
}

void *internal_memchr(const void *s, int c, uptr n) {
  const char *t = (const char *)s;
  for (uptr i = 0; i < n; ++i, ++t)
  409e6f:	48 83 c7 01          	add    $0x1,%rdi
  409e73:	48 39 d7             	cmp    %rdx,%rdi
  409e76:	75 f0                	jne    409e68 <_ZN11__sanitizer15internal_memchrEPKvim+0x18>
    if (*t == c)
      return reinterpret_cast<void *>(const_cast<char *>(t));
  return nullptr;
  409e78:	31 c0                	xor    %eax,%eax
  409e7a:	c3                   	retq   
  409e7b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  return internal_simple_strtoll(nptr, nullptr, 10);
}

void *internal_memchr(const void *s, int c, uptr n) {
  const char *t = (const char *)s;
  for (uptr i = 0; i < n; ++i, ++t)
  409e80:	48 89 f8             	mov    %rdi,%rax
    if (*t == c)
      return reinterpret_cast<void *>(const_cast<char *>(t));
  return nullptr;
}
  409e83:	c3                   	retq   
  409e84:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  409e8b:	00 00 00 00 00 

0000000000409e90 <_ZN11__sanitizer16internal_memrchrEPKvim>:

void *internal_memrchr(const void *s, int c, uptr n) {
  const char *t = (const char *)s;
  void *res = nullptr;
  for (uptr i = 0; i < n; ++i, ++t) {
  409e90:	48 85 d2             	test   %rdx,%rdx
  409e93:	74 1f                	je     409eb4 <_ZN11__sanitizer16internal_memrchrEPKvim+0x24>
  409e95:	48 01 fa             	add    %rdi,%rdx
  return nullptr;
}

void *internal_memrchr(const void *s, int c, uptr n) {
  const char *t = (const char *)s;
  void *res = nullptr;
  409e98:	31 c0                	xor    %eax,%eax
  409e9a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  for (uptr i = 0; i < n; ++i, ++t) {
    if (*t == c) res = reinterpret_cast<void *>(const_cast<char *>(t));
  409ea0:	0f be 0f             	movsbl (%rdi),%ecx
  409ea3:	39 f1                	cmp    %esi,%ecx
  409ea5:	48 0f 44 c7          	cmove  %rdi,%rax
}

void *internal_memrchr(const void *s, int c, uptr n) {
  const char *t = (const char *)s;
  void *res = nullptr;
  for (uptr i = 0; i < n; ++i, ++t) {
  409ea9:	48 83 c7 01          	add    $0x1,%rdi
  409ead:	48 39 d7             	cmp    %rdx,%rdi
  409eb0:	75 ee                	jne    409ea0 <_ZN11__sanitizer16internal_memrchrEPKvim+0x10>
  409eb2:	f3 c3                	repz retq 
  return nullptr;
}

void *internal_memrchr(const void *s, int c, uptr n) {
  const char *t = (const char *)s;
  void *res = nullptr;
  409eb4:	31 c0                	xor    %eax,%eax
  for (uptr i = 0; i < n; ++i, ++t) {
    if (*t == c) res = reinterpret_cast<void *>(const_cast<char *>(t));
  }
  return res;
}
  409eb6:	c3                   	retq   
  409eb7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  409ebe:	00 00 

0000000000409ec0 <_ZN11__sanitizer15internal_memcmpEPKvS1_m>:

int internal_memcmp(const void* s1, const void* s2, uptr n) {
  const char *t1 = (const char *)s1;
  const char *t2 = (const char *)s2;
  for (uptr i = 0; i < n; ++i, ++t1, ++t2)
  409ec0:	48 85 d2             	test   %rdx,%rdx
  409ec3:	74 2a                	je     409eef <_ZN11__sanitizer15internal_memcmpEPKvS1_m+0x2f>
    if (*t1 != *t2)
  409ec5:	44 0f b6 07          	movzbl (%rdi),%r8d
  409ec9:	0f b6 0e             	movzbl (%rsi),%ecx
}

int internal_memcmp(const void* s1, const void* s2, uptr n) {
  const char *t1 = (const char *)s1;
  const char *t2 = (const char *)s2;
  for (uptr i = 0; i < n; ++i, ++t1, ++t2)
  409ecc:	31 c0                	xor    %eax,%eax
    if (*t1 != *t2)
  409ece:	41 38 c8             	cmp    %cl,%r8b
  409ed1:	74 13                	je     409ee6 <_ZN11__sanitizer15internal_memcmpEPKvS1_m+0x26>
  409ed3:	eb 23                	jmp    409ef8 <_ZN11__sanitizer15internal_memcmpEPKvS1_m+0x38>
  409ed5:	0f 1f 00             	nopl   (%rax)
  409ed8:	44 0f b6 04 07       	movzbl (%rdi,%rax,1),%r8d
  409edd:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
  409ee1:	41 38 c8             	cmp    %cl,%r8b
  409ee4:	75 12                	jne    409ef8 <_ZN11__sanitizer15internal_memcmpEPKvS1_m+0x38>
}

int internal_memcmp(const void* s1, const void* s2, uptr n) {
  const char *t1 = (const char *)s1;
  const char *t2 = (const char *)s2;
  for (uptr i = 0; i < n; ++i, ++t1, ++t2)
  409ee6:	48 83 c0 01          	add    $0x1,%rax
  409eea:	48 39 d0             	cmp    %rdx,%rax
  409eed:	75 e9                	jne    409ed8 <_ZN11__sanitizer15internal_memcmpEPKvS1_m+0x18>
    if (*t1 != *t2)
      return *t1 < *t2 ? -1 : 1;
  return 0;
  409eef:	31 c0                	xor    %eax,%eax
}
  409ef1:	c3                   	retq   
  409ef2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
int internal_memcmp(const void* s1, const void* s2, uptr n) {
  const char *t1 = (const char *)s1;
  const char *t2 = (const char *)s2;
  for (uptr i = 0; i < n; ++i, ++t1, ++t2)
    if (*t1 != *t2)
      return *t1 < *t2 ? -1 : 1;
  409ef8:	31 c0                	xor    %eax,%eax
  409efa:	41 38 c8             	cmp    %cl,%r8b
  409efd:	0f 9d c0             	setge  %al
  409f00:	8d 44 00 ff          	lea    -0x1(%rax,%rax,1),%eax
  409f04:	c3                   	retq   
  409f05:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  409f0c:	00 00 00 00 

0000000000409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>:
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  409f10:	48 85 d2             	test   %rdx,%rdx
    if (*t1 != *t2)
      return *t1 < *t2 ? -1 : 1;
  return 0;
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  409f13:	48 89 f8             	mov    %rdi,%rax
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  409f16:	0f 84 b4 01 00 00    	je     40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
  409f1c:	48 8d 4f 10          	lea    0x10(%rdi),%rcx
  409f20:	48 39 ce             	cmp    %rcx,%rsi
  409f23:	48 8d 4e 10          	lea    0x10(%rsi),%rcx
  409f27:	40 0f 93 c7          	setae  %dil
  409f2b:	48 39 c8             	cmp    %rcx,%rax
  409f2e:	0f 93 c1             	setae  %cl
  409f31:	40 08 cf             	or     %cl,%dil
  409f34:	0f 84 76 01 00 00    	je     40a0b0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1a0>
  409f3a:	48 83 fa 0f          	cmp    $0xf,%rdx
  409f3e:	0f 86 6c 01 00 00    	jbe    40a0b0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1a0>
  409f44:	49 89 d0             	mov    %rdx,%r8
  409f47:	31 ff                	xor    %edi,%edi
  409f49:	45 31 c9             	xor    %r9d,%r9d
  409f4c:	49 c1 e8 04          	shr    $0x4,%r8
  409f50:	4c 89 c1             	mov    %r8,%rcx
  409f53:	48 c1 e1 04          	shl    $0x4,%rcx
    d[i] = s[i];
  409f57:	f3 0f 6f 04 3e       	movdqu (%rsi,%rdi,1),%xmm0
  409f5c:	49 83 c1 01          	add    $0x1,%r9
  409f60:	f3 0f 7f 04 38       	movdqu %xmm0,(%rax,%rdi,1)
  409f65:	48 83 c7 10          	add    $0x10,%rdi
  409f69:	4d 39 c8             	cmp    %r9,%r8
  409f6c:	77 e9                	ja     409f57 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x47>
  409f6e:	48 39 ca             	cmp    %rcx,%rdx
  409f71:	0f 84 59 01 00 00    	je     40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
  409f77:	0f b6 3c 0e          	movzbl (%rsi,%rcx,1),%edi
  409f7b:	40 88 3c 08          	mov    %dil,(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  409f7f:	48 8d 79 01          	lea    0x1(%rcx),%rdi
  409f83:	48 39 fa             	cmp    %rdi,%rdx
  409f86:	0f 86 44 01 00 00    	jbe    40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
    d[i] = s[i];
  409f8c:	0f b6 7c 0e 01       	movzbl 0x1(%rsi,%rcx,1),%edi
  409f91:	40 88 7c 08 01       	mov    %dil,0x1(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  409f96:	48 8d 79 02          	lea    0x2(%rcx),%rdi
  409f9a:	48 39 fa             	cmp    %rdi,%rdx
  409f9d:	0f 86 2d 01 00 00    	jbe    40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
    d[i] = s[i];
  409fa3:	0f b6 7c 0e 02       	movzbl 0x2(%rsi,%rcx,1),%edi
  409fa8:	40 88 7c 08 02       	mov    %dil,0x2(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  409fad:	48 8d 79 03          	lea    0x3(%rcx),%rdi
  409fb1:	48 39 fa             	cmp    %rdi,%rdx
  409fb4:	0f 86 16 01 00 00    	jbe    40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
    d[i] = s[i];
  409fba:	0f b6 7c 0e 03       	movzbl 0x3(%rsi,%rcx,1),%edi
  409fbf:	40 88 7c 08 03       	mov    %dil,0x3(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  409fc4:	48 8d 79 04          	lea    0x4(%rcx),%rdi
  409fc8:	48 39 fa             	cmp    %rdi,%rdx
  409fcb:	0f 86 ff 00 00 00    	jbe    40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
    d[i] = s[i];
  409fd1:	0f b6 7c 0e 04       	movzbl 0x4(%rsi,%rcx,1),%edi
  409fd6:	40 88 7c 08 04       	mov    %dil,0x4(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  409fdb:	48 8d 79 05          	lea    0x5(%rcx),%rdi
  409fdf:	48 39 fa             	cmp    %rdi,%rdx
  409fe2:	0f 86 e8 00 00 00    	jbe    40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
    d[i] = s[i];
  409fe8:	0f b6 7c 0e 05       	movzbl 0x5(%rsi,%rcx,1),%edi
  409fed:	40 88 7c 08 05       	mov    %dil,0x5(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  409ff2:	48 8d 79 06          	lea    0x6(%rcx),%rdi
  409ff6:	48 39 fa             	cmp    %rdi,%rdx
  409ff9:	0f 86 d1 00 00 00    	jbe    40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
    d[i] = s[i];
  409fff:	0f b6 7c 0e 06       	movzbl 0x6(%rsi,%rcx,1),%edi
  40a004:	40 88 7c 08 06       	mov    %dil,0x6(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a009:	48 8d 79 07          	lea    0x7(%rcx),%rdi
  40a00d:	48 39 fa             	cmp    %rdi,%rdx
  40a010:	0f 86 ba 00 00 00    	jbe    40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
    d[i] = s[i];
  40a016:	0f b6 7c 0e 07       	movzbl 0x7(%rsi,%rcx,1),%edi
  40a01b:	40 88 7c 08 07       	mov    %dil,0x7(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a020:	48 8d 79 08          	lea    0x8(%rcx),%rdi
  40a024:	48 39 fa             	cmp    %rdi,%rdx
  40a027:	0f 86 a3 00 00 00    	jbe    40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
    d[i] = s[i];
  40a02d:	0f b6 7c 0e 08       	movzbl 0x8(%rsi,%rcx,1),%edi
  40a032:	40 88 7c 08 08       	mov    %dil,0x8(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a037:	48 8d 79 09          	lea    0x9(%rcx),%rdi
  40a03b:	48 39 fa             	cmp    %rdi,%rdx
  40a03e:	0f 86 8c 00 00 00    	jbe    40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
    d[i] = s[i];
  40a044:	0f b6 7c 0e 09       	movzbl 0x9(%rsi,%rcx,1),%edi
  40a049:	40 88 7c 08 09       	mov    %dil,0x9(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a04e:	48 8d 79 0a          	lea    0xa(%rcx),%rdi
  40a052:	48 39 fa             	cmp    %rdi,%rdx
  40a055:	76 79                	jbe    40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
    d[i] = s[i];
  40a057:	0f b6 7c 0e 0a       	movzbl 0xa(%rsi,%rcx,1),%edi
  40a05c:	40 88 7c 08 0a       	mov    %dil,0xa(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a061:	48 8d 79 0b          	lea    0xb(%rcx),%rdi
  40a065:	48 39 fa             	cmp    %rdi,%rdx
  40a068:	76 66                	jbe    40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
    d[i] = s[i];
  40a06a:	0f b6 7c 0e 0b       	movzbl 0xb(%rsi,%rcx,1),%edi
  40a06f:	40 88 7c 08 0b       	mov    %dil,0xb(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a074:	48 8d 79 0c          	lea    0xc(%rcx),%rdi
  40a078:	48 39 fa             	cmp    %rdi,%rdx
  40a07b:	76 53                	jbe    40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
    d[i] = s[i];
  40a07d:	0f b6 7c 0e 0c       	movzbl 0xc(%rsi,%rcx,1),%edi
  40a082:	40 88 7c 08 0c       	mov    %dil,0xc(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a087:	48 8d 79 0d          	lea    0xd(%rcx),%rdi
  40a08b:	48 39 fa             	cmp    %rdi,%rdx
  40a08e:	76 40                	jbe    40a0d0 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c0>
    d[i] = s[i];
  40a090:	0f b6 7c 0e 0d       	movzbl 0xd(%rsi,%rcx,1),%edi
  40a095:	40 88 7c 08 0d       	mov    %dil,0xd(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a09a:	48 8d 79 0e          	lea    0xe(%rcx),%rdi
  40a09e:	48 39 fa             	cmp    %rdi,%rdx
  40a0a1:	76 35                	jbe    40a0d8 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1c8>
    d[i] = s[i];
  40a0a3:	0f b6 54 0e 0e       	movzbl 0xe(%rsi,%rcx,1),%edx
  40a0a8:	88 54 08 0e          	mov    %dl,0xe(%rax,%rcx,1)
  40a0ac:	c3                   	retq   
  40a0ad:	0f 1f 00             	nopl   (%rax)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a0b0:	31 c9                	xor    %ecx,%ecx
  40a0b2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    d[i] = s[i];
  40a0b8:	0f b6 3c 0e          	movzbl (%rsi,%rcx,1),%edi
  40a0bc:	40 88 3c 08          	mov    %dil,(%rax,%rcx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a0c0:	48 83 c1 01          	add    $0x1,%rcx
  40a0c4:	48 39 d1             	cmp    %rdx,%rcx
  40a0c7:	75 ef                	jne    40a0b8 <_ZN11__sanitizer15internal_memcpyEPvPKvm+0x1a8>
  40a0c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    d[i] = s[i];
  return dest;
}
  40a0d0:	f3 c3                	repz retq 
  40a0d2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40a0d8:	f3 c3                	repz retq 
  40a0da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000040a0e0 <_ZN11__sanitizer16internal_memmoveEPvPKvm>:
void *internal_memmove(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
  40a0e0:	48 39 f7             	cmp    %rsi,%rdi
  for (uptr i = 0; i < n; ++i)
    d[i] = s[i];
  return dest;
}

void *internal_memmove(void *dest, const void *src, uptr n) {
  40a0e3:	48 89 f8             	mov    %rdi,%rax
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
  40a0e6:	0f 83 9c 01 00 00    	jae    40a288 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1a8>
    for (i = 0; i < signed_n; ++i)
  40a0ec:	48 85 d2             	test   %rdx,%rdx
  40a0ef:	0f 8e 9b 01 00 00    	jle    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
  40a0f5:	48 8d 4f 10          	lea    0x10(%rdi),%rcx
  40a0f9:	48 39 ce             	cmp    %rcx,%rsi
  40a0fc:	48 8d 4e 10          	lea    0x10(%rsi),%rcx
  40a100:	40 0f 93 c7          	setae  %dil
  40a104:	48 39 c8             	cmp    %rcx,%rax
  40a107:	0f 93 c1             	setae  %cl
  40a10a:	40 08 cf             	or     %cl,%dil
  40a10d:	0f 84 a5 01 00 00    	je     40a2b8 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1d8>
  40a113:	48 83 fa 0f          	cmp    $0xf,%rdx
  40a117:	0f 86 9b 01 00 00    	jbe    40a2b8 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1d8>
  40a11d:	49 89 d0             	mov    %rdx,%r8
  40a120:	31 ff                	xor    %edi,%edi
  40a122:	45 31 c9             	xor    %r9d,%r9d
  40a125:	49 c1 e8 04          	shr    $0x4,%r8
  40a129:	4c 89 c1             	mov    %r8,%rcx
  40a12c:	48 c1 e1 04          	shl    $0x4,%rcx
      d[i] = s[i];
  40a130:	f3 0f 6f 04 3e       	movdqu (%rsi,%rdi,1),%xmm0
  40a135:	49 83 c1 01          	add    $0x1,%r9
  40a139:	f3 0f 7f 04 38       	movdqu %xmm0,(%rax,%rdi,1)
  40a13e:	48 83 c7 10          	add    $0x10,%rdi
  40a142:	4d 39 c8             	cmp    %r9,%r8
  40a145:	77 e9                	ja     40a130 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x50>
  40a147:	48 39 ca             	cmp    %rcx,%rdx
  40a14a:	0f 84 40 01 00 00    	je     40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
  40a150:	0f b6 3c 0e          	movzbl (%rsi,%rcx,1),%edi
  40a154:	40 88 3c 08          	mov    %dil,(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a158:	48 8d 79 01          	lea    0x1(%rcx),%rdi
  40a15c:	48 39 fa             	cmp    %rdi,%rdx
  40a15f:	0f 8e 2b 01 00 00    	jle    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
      d[i] = s[i];
  40a165:	0f b6 7c 0e 01       	movzbl 0x1(%rsi,%rcx,1),%edi
  40a16a:	40 88 7c 08 01       	mov    %dil,0x1(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a16f:	48 8d 79 02          	lea    0x2(%rcx),%rdi
  40a173:	48 39 fa             	cmp    %rdi,%rdx
  40a176:	0f 8e 14 01 00 00    	jle    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
      d[i] = s[i];
  40a17c:	0f b6 7c 0e 02       	movzbl 0x2(%rsi,%rcx,1),%edi
  40a181:	40 88 7c 08 02       	mov    %dil,0x2(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a186:	48 8d 79 03          	lea    0x3(%rcx),%rdi
  40a18a:	48 39 fa             	cmp    %rdi,%rdx
  40a18d:	0f 8e fd 00 00 00    	jle    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
      d[i] = s[i];
  40a193:	0f b6 7c 0e 03       	movzbl 0x3(%rsi,%rcx,1),%edi
  40a198:	40 88 7c 08 03       	mov    %dil,0x3(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a19d:	48 8d 79 04          	lea    0x4(%rcx),%rdi
  40a1a1:	48 39 fa             	cmp    %rdi,%rdx
  40a1a4:	0f 8e e6 00 00 00    	jle    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
      d[i] = s[i];
  40a1aa:	0f b6 7c 0e 04       	movzbl 0x4(%rsi,%rcx,1),%edi
  40a1af:	40 88 7c 08 04       	mov    %dil,0x4(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a1b4:	48 8d 79 05          	lea    0x5(%rcx),%rdi
  40a1b8:	48 39 fa             	cmp    %rdi,%rdx
  40a1bb:	0f 8e cf 00 00 00    	jle    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
      d[i] = s[i];
  40a1c1:	0f b6 7c 0e 05       	movzbl 0x5(%rsi,%rcx,1),%edi
  40a1c6:	40 88 7c 08 05       	mov    %dil,0x5(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a1cb:	48 8d 79 06          	lea    0x6(%rcx),%rdi
  40a1cf:	48 39 fa             	cmp    %rdi,%rdx
  40a1d2:	0f 8e b8 00 00 00    	jle    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
      d[i] = s[i];
  40a1d8:	0f b6 7c 0e 06       	movzbl 0x6(%rsi,%rcx,1),%edi
  40a1dd:	40 88 7c 08 06       	mov    %dil,0x6(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a1e2:	48 8d 79 07          	lea    0x7(%rcx),%rdi
  40a1e6:	48 39 fa             	cmp    %rdi,%rdx
  40a1e9:	0f 8e a1 00 00 00    	jle    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
      d[i] = s[i];
  40a1ef:	0f b6 7c 0e 07       	movzbl 0x7(%rsi,%rcx,1),%edi
  40a1f4:	40 88 7c 08 07       	mov    %dil,0x7(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a1f9:	48 8d 79 08          	lea    0x8(%rcx),%rdi
  40a1fd:	48 39 fa             	cmp    %rdi,%rdx
  40a200:	0f 8e 8a 00 00 00    	jle    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
      d[i] = s[i];
  40a206:	0f b6 7c 0e 08       	movzbl 0x8(%rsi,%rcx,1),%edi
  40a20b:	40 88 7c 08 08       	mov    %dil,0x8(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a210:	48 8d 79 09          	lea    0x9(%rcx),%rdi
  40a214:	48 39 fa             	cmp    %rdi,%rdx
  40a217:	7e 77                	jle    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
      d[i] = s[i];
  40a219:	0f b6 7c 0e 09       	movzbl 0x9(%rsi,%rcx,1),%edi
  40a21e:	40 88 7c 08 09       	mov    %dil,0x9(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a223:	48 8d 79 0a          	lea    0xa(%rcx),%rdi
  40a227:	48 39 fa             	cmp    %rdi,%rdx
  40a22a:	7e 64                	jle    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
      d[i] = s[i];
  40a22c:	0f b6 7c 0e 0a       	movzbl 0xa(%rsi,%rcx,1),%edi
  40a231:	40 88 7c 08 0a       	mov    %dil,0xa(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a236:	48 8d 79 0b          	lea    0xb(%rcx),%rdi
  40a23a:	48 39 fa             	cmp    %rdi,%rdx
  40a23d:	7e 51                	jle    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
      d[i] = s[i];
  40a23f:	0f b6 7c 0e 0b       	movzbl 0xb(%rsi,%rcx,1),%edi
  40a244:	40 88 7c 08 0b       	mov    %dil,0xb(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a249:	48 8d 79 0c          	lea    0xc(%rcx),%rdi
  40a24d:	48 39 fa             	cmp    %rdi,%rdx
  40a250:	7e 3e                	jle    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
      d[i] = s[i];
  40a252:	0f b6 7c 0e 0c       	movzbl 0xc(%rsi,%rcx,1),%edi
  40a257:	40 88 7c 08 0c       	mov    %dil,0xc(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a25c:	48 8d 79 0d          	lea    0xd(%rcx),%rdi
  40a260:	48 39 fa             	cmp    %rdi,%rdx
  40a263:	7e 2b                	jle    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
      d[i] = s[i];
  40a265:	0f b6 7c 0e 0d       	movzbl 0xd(%rsi,%rcx,1),%edi
  40a26a:	40 88 7c 08 0d       	mov    %dil,0xd(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a26f:	48 8d 79 0e          	lea    0xe(%rcx),%rdi
  40a273:	48 39 fa             	cmp    %rdi,%rdx
  40a276:	7e 5b                	jle    40a2d3 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1f3>
      d[i] = s[i];
  40a278:	0f b6 54 0e 0e       	movzbl 0xe(%rsi,%rcx,1),%edx
  40a27d:	88 54 08 0e          	mov    %dl,0xe(%rax,%rcx,1)
  40a281:	c3                   	retq   
  40a282:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  } else {
    if (d > s && signed_n > 0)
  40a288:	76 06                	jbe    40a290 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b0>
  40a28a:	48 85 d2             	test   %rdx,%rdx
  40a28d:	7f 09                	jg     40a298 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1b8>
  40a28f:	90                   	nop
      for (i = signed_n - 1; i >= 0 ; --i) {
        d[i] = s[i];
      }
  }
  return dest;
}
  40a290:	f3 c3                	repz retq 
  40a292:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
      d[i] = s[i];
  } else {
    if (d > s && signed_n > 0)
      for (i = signed_n - 1; i >= 0 ; --i) {
  40a298:	48 83 ea 01          	sub    $0x1,%rdx
  40a29c:	0f 1f 40 00          	nopl   0x0(%rax)
        d[i] = s[i];
  40a2a0:	0f b6 0c 16          	movzbl (%rsi,%rdx,1),%ecx
  40a2a4:	88 0c 10             	mov    %cl,(%rax,%rdx,1)
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
      d[i] = s[i];
  } else {
    if (d > s && signed_n > 0)
      for (i = signed_n - 1; i >= 0 ; --i) {
  40a2a7:	48 83 ea 01          	sub    $0x1,%rdx
  40a2ab:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
  40a2af:	75 ef                	jne    40a2a0 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1c0>
        d[i] = s[i];
      }
  }
  return dest;
}
  40a2b1:	f3 c3                	repz retq 
  40a2b3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a2b8:	31 c9                	xor    %ecx,%ecx
  40a2ba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      d[i] = s[i];
  40a2c0:	0f b6 3c 0e          	movzbl (%rsi,%rcx,1),%edi
  40a2c4:	40 88 3c 08          	mov    %dil,(%rax,%rcx,1)
  char *d = (char*)dest;
  const char *s = (const char *)src;
  sptr i, signed_n = (sptr)n;
  CHECK_GE(signed_n, 0);
  if (d < s) {
    for (i = 0; i < signed_n; ++i)
  40a2c8:	48 83 c1 01          	add    $0x1,%rcx
  40a2cc:	48 39 ca             	cmp    %rcx,%rdx
  40a2cf:	75 ef                	jne    40a2c0 <_ZN11__sanitizer16internal_memmoveEPvPKvm+0x1e0>
  40a2d1:	f3 c3                	repz retq 
  40a2d3:	f3 c3                	repz retq 
  40a2d5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  40a2dc:	00 00 00 00 

000000000040a2e0 <_ZN11__sanitizer24internal_bzero_aligned16EPvm>:
}

// Semi-fast bzero for 16-aligned data. Still far from peak performance.
void internal_bzero_aligned16(void *s, uptr n) {
  struct S16 { u64 a, b; } ALIGNED(16);
  CHECK_EQ((reinterpret_cast<uptr>(s) | n) & 15, 0);
  40a2e0:	48 89 f9             	mov    %rdi,%rcx
  40a2e3:	48 09 f1             	or     %rsi,%rcx
  40a2e6:	83 e1 0f             	and    $0xf,%ecx
  40a2e9:	75 2f                	jne    40a31a <_ZN11__sanitizer24internal_bzero_aligned16EPvm+0x3a>
  for (S16 *p = reinterpret_cast<S16*>(s), *end = p + n / 16; p < end; p++) {
  40a2eb:	48 83 e6 f0          	and    $0xfffffffffffffff0,%rsi
// memset/memcpy/etc.
static inline void SanitizerBreakOptimization(void *arg) {
#if _MSC_VER && !defined(__clang__)
  _ReadWriteBarrier();
#else
  __asm__ __volatile__("" : : "r" (arg) : "memory");
  40a2ef:	31 c0                	xor    %eax,%eax
  40a2f1:	48 01 fe             	add    %rdi,%rsi
  40a2f4:	48 39 f7             	cmp    %rsi,%rdi
  40a2f7:	73 1f                	jae    40a318 <_ZN11__sanitizer24internal_bzero_aligned16EPvm+0x38>
  40a2f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    p->a = p->b = 0;
  40a300:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  40a307:	00 
  40a308:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)

// Semi-fast bzero for 16-aligned data. Still far from peak performance.
void internal_bzero_aligned16(void *s, uptr n) {
  struct S16 { u64 a, b; } ALIGNED(16);
  CHECK_EQ((reinterpret_cast<uptr>(s) | n) & 15, 0);
  for (S16 *p = reinterpret_cast<S16*>(s), *end = p + n / 16; p < end; p++) {
  40a30f:	48 83 c7 10          	add    $0x10,%rdi
  40a313:	48 39 fe             	cmp    %rdi,%rsi
  40a316:	77 e8                	ja     40a300 <_ZN11__sanitizer24internal_bzero_aligned16EPvm+0x20>
  40a318:	f3 c3                	repz retq 
}

// Semi-fast bzero for 16-aligned data. Still far from peak performance.
void internal_bzero_aligned16(void *s, uptr n) {
  struct S16 { u64 a, b; } ALIGNED(16);
  CHECK_EQ((reinterpret_cast<uptr>(s) | n) & 15, 0);
  40a31a:	48 8d 15 5f cc 00 00 	lea    0xcc5f(%rip),%rdx        # 416f80 <.LC0>
  40a321:	48 8d 3d 90 cc 00 00 	lea    0xcc90(%rip),%rdi        # 416fb8 <.LC1>
  }
  return dest;
}

// Semi-fast bzero for 16-aligned data. Still far from peak performance.
void internal_bzero_aligned16(void *s, uptr n) {
  40a328:	48 83 ec 08          	sub    $0x8,%rsp
  struct S16 { u64 a, b; } ALIGNED(16);
  CHECK_EQ((reinterpret_cast<uptr>(s) | n) & 15, 0);
  40a32c:	45 31 c0             	xor    %r8d,%r8d
  40a32f:	be 4e 00 00 00       	mov    $0x4e,%esi
  40a334:	e8 b7 b0 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40a339:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000040a340 <_ZN11__sanitizer15internal_memsetEPvim>:
  // The next line prevents Clang from making a call to memset() instead of the
  // loop below.
  // FIXME: building the runtime with -ffreestanding is a better idea. However
  // there currently are linktime problems due to PR12396.
  char volatile *t = (char*)s;
  for (uptr i = 0; i < n; ++i, ++t) {
  40a340:	48 85 d2             	test   %rdx,%rdx
    // Make sure this does not become memset.
    SanitizerBreakOptimization(nullptr);
  }
}

void *internal_memset(void* s, int c, uptr n) {
  40a343:	48 89 f8             	mov    %rdi,%rax
  40a346:	4c 8d 04 17          	lea    (%rdi,%rdx,1),%r8
  // The next line prevents Clang from making a call to memset() instead of the
  // loop below.
  // FIXME: building the runtime with -ffreestanding is a better idea. However
  // there currently are linktime problems due to PR12396.
  char volatile *t = (char*)s;
  40a34a:	48 89 f9             	mov    %rdi,%rcx
  for (uptr i = 0; i < n; ++i, ++t) {
  40a34d:	74 0d                	je     40a35c <_ZN11__sanitizer15internal_memsetEPvim+0x1c>
  40a34f:	90                   	nop
    *t = c;
  40a350:	40 88 31             	mov    %sil,(%rcx)
  // The next line prevents Clang from making a call to memset() instead of the
  // loop below.
  // FIXME: building the runtime with -ffreestanding is a better idea. However
  // there currently are linktime problems due to PR12396.
  char volatile *t = (char*)s;
  for (uptr i = 0; i < n; ++i, ++t) {
  40a353:	48 83 c1 01          	add    $0x1,%rcx
  40a357:	4c 39 c1             	cmp    %r8,%rcx
  40a35a:	75 f4                	jne    40a350 <_ZN11__sanitizer15internal_memsetEPvim+0x10>
    *t = c;
  }
  return s;
}
  40a35c:	f3 c3                	repz retq 
  40a35e:	66 90                	xchg   %ax,%ax

000000000040a360 <_ZN11__sanitizer16internal_strcspnEPKcS1_>:

uptr internal_strcspn(const char *s, const char *reject) {
  uptr i;
  for (i = 0; s[i]; i++) {
  40a360:	44 0f b6 07          	movzbl (%rdi),%r8d
  40a364:	45 84 c0             	test   %r8b,%r8b
  40a367:	74 41                	je     40a3aa <_ZN11__sanitizer16internal_strcspnEPKcS1_+0x4a>
  40a369:	44 0f b6 0e          	movzbl (%rsi),%r9d
  40a36d:	31 c0                	xor    %eax,%eax
  40a36f:	90                   	nop
  return 0;
}

char* internal_strchr(const char *s, int c) {
  while (true) {
    if (*s == (char)c)
  40a370:	45 38 c1             	cmp    %r8b,%r9b
  40a373:	74 33                	je     40a3a8 <_ZN11__sanitizer16internal_strcspnEPKcS1_+0x48>
      return const_cast<char *>(s);
    if (*s == 0)
  40a375:	45 84 c9             	test   %r9b,%r9b
  40a378:	74 1e                	je     40a398 <_ZN11__sanitizer16internal_strcspnEPKcS1_+0x38>
  40a37a:	48 89 f2             	mov    %rsi,%rdx
  40a37d:	eb 05                	jmp    40a384 <_ZN11__sanitizer16internal_strcspnEPKcS1_+0x24>
  40a37f:	90                   	nop
  40a380:	84 c9                	test   %cl,%cl
  40a382:	74 14                	je     40a398 <_ZN11__sanitizer16internal_strcspnEPKcS1_+0x38>
      return nullptr;
    s++;
  40a384:	48 83 c2 01          	add    $0x1,%rdx
  return 0;
}

char* internal_strchr(const char *s, int c) {
  while (true) {
    if (*s == (char)c)
  40a388:	0f b6 0a             	movzbl (%rdx),%ecx
  40a38b:	41 38 c8             	cmp    %cl,%r8b
  40a38e:	75 f0                	jne    40a380 <_ZN11__sanitizer16internal_strcspnEPKcS1_+0x20>
  40a390:	f3 c3                	repz retq 
  40a392:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  return s;
}

uptr internal_strcspn(const char *s, const char *reject) {
  uptr i;
  for (i = 0; s[i]; i++) {
  40a398:	48 83 c0 01          	add    $0x1,%rax
  40a39c:	44 0f b6 04 07       	movzbl (%rdi,%rax,1),%r8d
  40a3a1:	45 84 c0             	test   %r8b,%r8b
  40a3a4:	75 ca                	jne    40a370 <_ZN11__sanitizer16internal_strcspnEPKcS1_+0x10>
    if (internal_strchr(reject, s[i]))
      return i;
  }
  return i;
}
  40a3a6:	f3 c3                	repz retq 
  40a3a8:	f3 c3                	repz retq 
  return s;
}

uptr internal_strcspn(const char *s, const char *reject) {
  uptr i;
  for (i = 0; s[i]; i++) {
  40a3aa:	31 c0                	xor    %eax,%eax
  40a3ac:	0f 1f 40 00          	nopl   0x0(%rax)
  40a3b0:	c3                   	retq   
  40a3b1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40a3b8:	0f 1f 84 00 00 00 00 
  40a3bf:	00 

000000000040a3c0 <_ZN11__sanitizer15internal_strdupEPKc>:
      return i;
  }
  return i;
}

char* internal_strdup(const char *s) {
  40a3c0:	55                   	push   %rbp
  40a3c1:	48 89 fd             	mov    %rdi,%rbp
  40a3c4:	53                   	push   %rbx
  40a3c5:	48 83 ec 08          	sub    $0x8,%rsp
  return const_cast<char *>(res);
}

uptr internal_strlen(const char *s) {
  uptr i = 0;
  while (s[i]) i++;
  40a3c9:	80 3f 00             	cmpb   $0x0,(%rdi)
  40a3cc:	0f 84 d2 01 00 00    	je     40a5a4 <_ZN11__sanitizer15internal_strdupEPKc+0x1e4>
  }
  return const_cast<char *>(res);
}

uptr internal_strlen(const char *s) {
  uptr i = 0;
  40a3d2:	31 c0                	xor    %eax,%eax
  40a3d4:	eb 0d                	jmp    40a3e3 <_ZN11__sanitizer15internal_strdupEPKc+0x23>
  40a3d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40a3dd:	00 00 00 
  while (s[i]) i++;
  40a3e0:	48 89 d8             	mov    %rbx,%rax
  40a3e3:	80 7c 05 01 00       	cmpb   $0x0,0x1(%rbp,%rax,1)
  40a3e8:	48 8d 58 01          	lea    0x1(%rax),%rbx
  40a3ec:	75 f2                	jne    40a3e0 <_ZN11__sanitizer15internal_strdupEPKc+0x20>
  return i;
}

char* internal_strdup(const char *s) {
  uptr len = internal_strlen(s);
  char *s2 = (char*)InternalAlloc(len + 1);
  40a3ee:	48 8d 78 02          	lea    0x2(%rax),%rdi
  40a3f2:	31 f6                	xor    %esi,%esi
  40a3f4:	e8 37 8f ff ff       	callq  403330 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE>
  40a3f9:	48 8d 50 10          	lea    0x10(%rax),%rdx
  40a3fd:	48 39 d5             	cmp    %rdx,%rbp
  40a400:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  40a404:	0f 93 c1             	setae  %cl
  40a407:	48 39 d0             	cmp    %rdx,%rax
  40a40a:	0f 93 c2             	setae  %dl
  40a40d:	08 d1                	or     %dl,%cl
  40a40f:	0f 84 6b 01 00 00    	je     40a580 <_ZN11__sanitizer15internal_strdupEPKc+0x1c0>
  40a415:	48 83 fb 0f          	cmp    $0xf,%rbx
  40a419:	0f 86 61 01 00 00    	jbe    40a580 <_ZN11__sanitizer15internal_strdupEPKc+0x1c0>
  40a41f:	48 89 de             	mov    %rbx,%rsi
  40a422:	31 c9                	xor    %ecx,%ecx
  40a424:	31 ff                	xor    %edi,%edi
  40a426:	48 c1 ee 04          	shr    $0x4,%rsi
  40a42a:	48 89 f2             	mov    %rsi,%rdx
  40a42d:	48 c1 e2 04          	shl    $0x4,%rdx

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
    d[i] = s[i];
  40a431:	f3 0f 6f 44 0d 00    	movdqu 0x0(%rbp,%rcx,1),%xmm0
  40a437:	48 83 c7 01          	add    $0x1,%rdi
  40a43b:	f3 0f 7f 04 08       	movdqu %xmm0,(%rax,%rcx,1)
  40a440:	48 83 c1 10          	add    $0x10,%rcx
  40a444:	48 39 fe             	cmp    %rdi,%rsi
  40a447:	77 e8                	ja     40a431 <_ZN11__sanitizer15internal_strdupEPKc+0x71>
  40a449:	48 39 d3             	cmp    %rdx,%rbx
  40a44c:	0f 84 20 01 00 00    	je     40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
  40a452:	0f b6 4c 15 00       	movzbl 0x0(%rbp,%rdx,1),%ecx
  40a457:	88 0c 10             	mov    %cl,(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a45a:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  40a45e:	48 39 d9             	cmp    %rbx,%rcx
  40a461:	0f 83 0b 01 00 00    	jae    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
    d[i] = s[i];
  40a467:	0f b6 4c 15 01       	movzbl 0x1(%rbp,%rdx,1),%ecx
  40a46c:	88 4c 10 01          	mov    %cl,0x1(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a470:	48 8d 4a 02          	lea    0x2(%rdx),%rcx
  40a474:	48 39 cb             	cmp    %rcx,%rbx
  40a477:	0f 86 f5 00 00 00    	jbe    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
    d[i] = s[i];
  40a47d:	0f b6 4c 15 02       	movzbl 0x2(%rbp,%rdx,1),%ecx
  40a482:	88 4c 10 02          	mov    %cl,0x2(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a486:	48 8d 4a 03          	lea    0x3(%rdx),%rcx
  40a48a:	48 39 cb             	cmp    %rcx,%rbx
  40a48d:	0f 86 df 00 00 00    	jbe    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
    d[i] = s[i];
  40a493:	0f b6 4c 15 03       	movzbl 0x3(%rbp,%rdx,1),%ecx
  40a498:	88 4c 10 03          	mov    %cl,0x3(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a49c:	48 8d 4a 04          	lea    0x4(%rdx),%rcx
  40a4a0:	48 39 cb             	cmp    %rcx,%rbx
  40a4a3:	0f 86 c9 00 00 00    	jbe    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
    d[i] = s[i];
  40a4a9:	0f b6 4c 15 04       	movzbl 0x4(%rbp,%rdx,1),%ecx
  40a4ae:	88 4c 10 04          	mov    %cl,0x4(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a4b2:	48 8d 4a 05          	lea    0x5(%rdx),%rcx
  40a4b6:	48 39 cb             	cmp    %rcx,%rbx
  40a4b9:	0f 86 b3 00 00 00    	jbe    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
    d[i] = s[i];
  40a4bf:	0f b6 4c 15 05       	movzbl 0x5(%rbp,%rdx,1),%ecx
  40a4c4:	88 4c 10 05          	mov    %cl,0x5(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a4c8:	48 8d 4a 06          	lea    0x6(%rdx),%rcx
  40a4cc:	48 39 cb             	cmp    %rcx,%rbx
  40a4cf:	0f 86 9d 00 00 00    	jbe    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
    d[i] = s[i];
  40a4d5:	0f b6 4c 15 06       	movzbl 0x6(%rbp,%rdx,1),%ecx
  40a4da:	88 4c 10 06          	mov    %cl,0x6(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a4de:	48 8d 4a 07          	lea    0x7(%rdx),%rcx
  40a4e2:	48 39 cb             	cmp    %rcx,%rbx
  40a4e5:	0f 86 87 00 00 00    	jbe    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
    d[i] = s[i];
  40a4eb:	0f b6 4c 15 07       	movzbl 0x7(%rbp,%rdx,1),%ecx
  40a4f0:	88 4c 10 07          	mov    %cl,0x7(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a4f4:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  40a4f8:	48 39 cb             	cmp    %rcx,%rbx
  40a4fb:	76 75                	jbe    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
    d[i] = s[i];
  40a4fd:	0f b6 4c 15 08       	movzbl 0x8(%rbp,%rdx,1),%ecx
  40a502:	88 4c 10 08          	mov    %cl,0x8(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a506:	48 8d 4a 09          	lea    0x9(%rdx),%rcx
  40a50a:	48 39 cb             	cmp    %rcx,%rbx
  40a50d:	76 63                	jbe    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
    d[i] = s[i];
  40a50f:	0f b6 4c 15 09       	movzbl 0x9(%rbp,%rdx,1),%ecx
  40a514:	88 4c 10 09          	mov    %cl,0x9(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a518:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  40a51c:	48 39 cb             	cmp    %rcx,%rbx
  40a51f:	76 51                	jbe    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
    d[i] = s[i];
  40a521:	0f b6 4c 15 0a       	movzbl 0xa(%rbp,%rdx,1),%ecx
  40a526:	88 4c 10 0a          	mov    %cl,0xa(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a52a:	48 8d 4a 0b          	lea    0xb(%rdx),%rcx
  40a52e:	48 39 cb             	cmp    %rcx,%rbx
  40a531:	76 3f                	jbe    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
    d[i] = s[i];
  40a533:	0f b6 4c 15 0b       	movzbl 0xb(%rbp,%rdx,1),%ecx
  40a538:	88 4c 10 0b          	mov    %cl,0xb(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a53c:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  40a540:	48 39 cb             	cmp    %rcx,%rbx
  40a543:	76 2d                	jbe    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
    d[i] = s[i];
  40a545:	0f b6 4c 15 0c       	movzbl 0xc(%rbp,%rdx,1),%ecx
  40a54a:	88 4c 10 0c          	mov    %cl,0xc(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a54e:	48 8d 4a 0d          	lea    0xd(%rdx),%rcx
  40a552:	48 39 cb             	cmp    %rcx,%rbx
  40a555:	76 1b                	jbe    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
    d[i] = s[i];
  40a557:	0f b6 4c 15 0d       	movzbl 0xd(%rbp,%rdx,1),%ecx
  40a55c:	88 4c 10 0d          	mov    %cl,0xd(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a560:	48 8d 4a 0e          	lea    0xe(%rdx),%rcx
  40a564:	48 39 cb             	cmp    %rcx,%rbx
  40a567:	76 09                	jbe    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
    d[i] = s[i];
  40a569:	0f b6 4c 15 0e       	movzbl 0xe(%rbp,%rdx,1),%ecx
  40a56e:	88 4c 10 0e          	mov    %cl,0xe(%rax,%rdx,1)

char* internal_strdup(const char *s) {
  uptr len = internal_strlen(s);
  char *s2 = (char*)InternalAlloc(len + 1);
  internal_memcpy(s2, s, len);
  s2[len] = 0;
  40a572:	c6 04 18 00          	movb   $0x0,(%rax,%rbx,1)
  return s2;
}
  40a576:	48 83 c4 08          	add    $0x8,%rsp
  40a57a:	5b                   	pop    %rbx
  40a57b:	5d                   	pop    %rbp
  40a57c:	c3                   	retq   
  40a57d:	0f 1f 00             	nopl   (%rax)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a580:	31 d2                	xor    %edx,%edx
  40a582:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    d[i] = s[i];
  40a588:	0f b6 4c 15 00       	movzbl 0x0(%rbp,%rdx,1),%ecx
  40a58d:	88 0c 10             	mov    %cl,(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a590:	48 83 c2 01          	add    $0x1,%rdx
  40a594:	48 39 da             	cmp    %rbx,%rdx
  40a597:	75 ef                	jne    40a588 <_ZN11__sanitizer15internal_strdupEPKc+0x1c8>

char* internal_strdup(const char *s) {
  uptr len = internal_strlen(s);
  char *s2 = (char*)InternalAlloc(len + 1);
  internal_memcpy(s2, s, len);
  s2[len] = 0;
  40a599:	c6 04 18 00          	movb   $0x0,(%rax,%rbx,1)
  return s2;
}
  40a59d:	48 83 c4 08          	add    $0x8,%rsp
  40a5a1:	5b                   	pop    %rbx
  40a5a2:	5d                   	pop    %rbp
  40a5a3:	c3                   	retq   
  return i;
}

char* internal_strdup(const char *s) {
  uptr len = internal_strlen(s);
  char *s2 = (char*)InternalAlloc(len + 1);
  40a5a4:	31 f6                	xor    %esi,%esi
  40a5a6:	bf 01 00 00 00       	mov    $0x1,%edi
  }
  return const_cast<char *>(res);
}

uptr internal_strlen(const char *s) {
  uptr i = 0;
  40a5ab:	31 db                	xor    %ebx,%ebx
  return i;
}

char* internal_strdup(const char *s) {
  uptr len = internal_strlen(s);
  char *s2 = (char*)InternalAlloc(len + 1);
  40a5ad:	e8 7e 8d ff ff       	callq  403330 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE>
  40a5b2:	eb be                	jmp    40a572 <_ZN11__sanitizer15internal_strdupEPKc+0x1b2>
  40a5b4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40a5bb:	00 00 00 00 00 

000000000040a5c0 <_ZN11__sanitizer16internal_strndupEPKcm>:
  internal_memcpy(s2, s, len);
  s2[len] = 0;
  return s2;
}

char* internal_strndup(const char *s, uptr n) {
  40a5c0:	41 54                	push   %r12
  return dst;
}

uptr internal_strnlen(const char *s, uptr maxlen) {
  uptr i = 0;
  while (i < maxlen && s[i]) i++;
  40a5c2:	48 85 f6             	test   %rsi,%rsi
  internal_memcpy(s2, s, len);
  s2[len] = 0;
  return s2;
}

char* internal_strndup(const char *s, uptr n) {
  40a5c5:	49 89 f4             	mov    %rsi,%r12
  40a5c8:	55                   	push   %rbp
  40a5c9:	53                   	push   %rbx
  return dst;
}

uptr internal_strnlen(const char *s, uptr maxlen) {
  uptr i = 0;
  while (i < maxlen && s[i]) i++;
  40a5ca:	0f 84 f2 01 00 00    	je     40a7c2 <_ZN11__sanitizer16internal_strndupEPKcm+0x202>
  40a5d0:	80 3f 00             	cmpb   $0x0,(%rdi)
  40a5d3:	48 89 fd             	mov    %rdi,%rbp
  40a5d6:	0f 84 e6 01 00 00    	je     40a7c2 <_ZN11__sanitizer16internal_strndupEPKcm+0x202>
  internal_memset(dst + i, '\0', n - i);
  return dst;
}

uptr internal_strnlen(const char *s, uptr maxlen) {
  uptr i = 0;
  40a5dc:	31 c0                	xor    %eax,%eax
  40a5de:	eb 0e                	jmp    40a5ee <_ZN11__sanitizer16internal_strndupEPKcm+0x2e>
  while (i < maxlen && s[i]) i++;
  40a5e0:	80 7c 05 01 00       	cmpb   $0x0,0x1(%rbp,%rax,1)
  40a5e5:	0f 84 9d 01 00 00    	je     40a788 <_ZN11__sanitizer16internal_strndupEPKcm+0x1c8>
  40a5eb:	48 89 d8             	mov    %rbx,%rax
  40a5ee:	48 8d 58 01          	lea    0x1(%rax),%rbx
  40a5f2:	4c 39 e3             	cmp    %r12,%rbx
  40a5f5:	75 e9                	jne    40a5e0 <_ZN11__sanitizer16internal_strndupEPKcm+0x20>
  return s2;
}

char* internal_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  char *s2 = (char*)InternalAlloc(len + 1);
  40a5f7:	48 8d 78 02          	lea    0x2(%rax),%rdi
  40a5fb:	31 f6                	xor    %esi,%esi
  40a5fd:	e8 2e 8d ff ff       	callq  403330 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE>
  40a602:	48 8d 50 10          	lea    0x10(%rax),%rdx
  40a606:	48 39 d5             	cmp    %rdx,%rbp
  40a609:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  40a60d:	0f 93 c1             	setae  %cl
  40a610:	48 39 d0             	cmp    %rdx,%rax
  40a613:	0f 93 c2             	setae  %dl
  40a616:	08 d1                	or     %dl,%cl
  40a618:	0f 84 82 01 00 00    	je     40a7a0 <_ZN11__sanitizer16internal_strndupEPKcm+0x1e0>
  40a61e:	49 83 fc 0f          	cmp    $0xf,%r12
  40a622:	0f 86 78 01 00 00    	jbe    40a7a0 <_ZN11__sanitizer16internal_strndupEPKcm+0x1e0>
  40a628:	4c 89 e6             	mov    %r12,%rsi
  return dst;
}

uptr internal_strnlen(const char *s, uptr maxlen) {
  uptr i = 0;
  while (i < maxlen && s[i]) i++;
  40a62b:	31 c9                	xor    %ecx,%ecx
  40a62d:	31 ff                	xor    %edi,%edi
  40a62f:	48 c1 ee 04          	shr    $0x4,%rsi
  40a633:	48 89 f2             	mov    %rsi,%rdx
  40a636:	48 c1 e2 04          	shl    $0x4,%rdx

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
    d[i] = s[i];
  40a63a:	f3 0f 6f 44 0d 00    	movdqu 0x0(%rbp,%rcx,1),%xmm0
  40a640:	48 83 c7 01          	add    $0x1,%rdi
  40a644:	f3 0f 7f 04 08       	movdqu %xmm0,(%rax,%rcx,1)
  40a649:	48 83 c1 10          	add    $0x10,%rcx
  40a64d:	48 39 fe             	cmp    %rdi,%rsi
  40a650:	77 e8                	ja     40a63a <_ZN11__sanitizer16internal_strndupEPKcm+0x7a>
  40a652:	49 39 d4             	cmp    %rdx,%r12
  40a655:	0f 84 20 01 00 00    	je     40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
  40a65b:	0f b6 4c 15 00       	movzbl 0x0(%rbp,%rdx,1),%ecx
  40a660:	88 0c 10             	mov    %cl,(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a663:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  40a667:	4c 39 e1             	cmp    %r12,%rcx
  40a66a:	0f 83 0b 01 00 00    	jae    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
    d[i] = s[i];
  40a670:	0f b6 4c 15 01       	movzbl 0x1(%rbp,%rdx,1),%ecx
  40a675:	88 4c 10 01          	mov    %cl,0x1(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a679:	48 8d 4a 02          	lea    0x2(%rdx),%rcx
  40a67d:	4c 39 e1             	cmp    %r12,%rcx
  40a680:	0f 83 f5 00 00 00    	jae    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
    d[i] = s[i];
  40a686:	0f b6 4c 15 02       	movzbl 0x2(%rbp,%rdx,1),%ecx
  40a68b:	88 4c 10 02          	mov    %cl,0x2(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a68f:	48 8d 4a 03          	lea    0x3(%rdx),%rcx
  40a693:	4c 39 e1             	cmp    %r12,%rcx
  40a696:	0f 83 df 00 00 00    	jae    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
    d[i] = s[i];
  40a69c:	0f b6 4c 15 03       	movzbl 0x3(%rbp,%rdx,1),%ecx
  40a6a1:	88 4c 10 03          	mov    %cl,0x3(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a6a5:	48 8d 4a 04          	lea    0x4(%rdx),%rcx
  40a6a9:	4c 39 e1             	cmp    %r12,%rcx
  40a6ac:	0f 83 c9 00 00 00    	jae    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
    d[i] = s[i];
  40a6b2:	0f b6 4c 15 04       	movzbl 0x4(%rbp,%rdx,1),%ecx
  40a6b7:	88 4c 10 04          	mov    %cl,0x4(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a6bb:	48 8d 4a 05          	lea    0x5(%rdx),%rcx
  40a6bf:	4c 39 e1             	cmp    %r12,%rcx
  40a6c2:	0f 83 b3 00 00 00    	jae    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
    d[i] = s[i];
  40a6c8:	0f b6 4c 15 05       	movzbl 0x5(%rbp,%rdx,1),%ecx
  40a6cd:	88 4c 10 05          	mov    %cl,0x5(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a6d1:	48 8d 4a 06          	lea    0x6(%rdx),%rcx
  40a6d5:	4c 39 e1             	cmp    %r12,%rcx
  40a6d8:	0f 83 9d 00 00 00    	jae    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
    d[i] = s[i];
  40a6de:	0f b6 4c 15 06       	movzbl 0x6(%rbp,%rdx,1),%ecx
  40a6e3:	88 4c 10 06          	mov    %cl,0x6(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a6e7:	48 8d 4a 07          	lea    0x7(%rdx),%rcx
  40a6eb:	4c 39 e1             	cmp    %r12,%rcx
  40a6ee:	0f 83 87 00 00 00    	jae    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
    d[i] = s[i];
  40a6f4:	0f b6 4c 15 07       	movzbl 0x7(%rbp,%rdx,1),%ecx
  40a6f9:	88 4c 10 07          	mov    %cl,0x7(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a6fd:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  40a701:	4c 39 e1             	cmp    %r12,%rcx
  40a704:	73 75                	jae    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
    d[i] = s[i];
  40a706:	0f b6 4c 15 08       	movzbl 0x8(%rbp,%rdx,1),%ecx
  40a70b:	88 4c 10 08          	mov    %cl,0x8(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a70f:	48 8d 4a 09          	lea    0x9(%rdx),%rcx
  40a713:	4c 39 e1             	cmp    %r12,%rcx
  40a716:	73 63                	jae    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
    d[i] = s[i];
  40a718:	0f b6 4c 15 09       	movzbl 0x9(%rbp,%rdx,1),%ecx
  40a71d:	88 4c 10 09          	mov    %cl,0x9(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a721:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  40a725:	4c 39 e1             	cmp    %r12,%rcx
  40a728:	73 51                	jae    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
    d[i] = s[i];
  40a72a:	0f b6 4c 15 0a       	movzbl 0xa(%rbp,%rdx,1),%ecx
  40a72f:	88 4c 10 0a          	mov    %cl,0xa(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a733:	48 8d 4a 0b          	lea    0xb(%rdx),%rcx
  40a737:	4c 39 e1             	cmp    %r12,%rcx
  40a73a:	73 3f                	jae    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
    d[i] = s[i];
  40a73c:	0f b6 4c 15 0b       	movzbl 0xb(%rbp,%rdx,1),%ecx
  40a741:	88 4c 10 0b          	mov    %cl,0xb(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a745:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  40a749:	4c 39 e1             	cmp    %r12,%rcx
  40a74c:	73 2d                	jae    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
    d[i] = s[i];
  40a74e:	0f b6 4c 15 0c       	movzbl 0xc(%rbp,%rdx,1),%ecx
  40a753:	88 4c 10 0c          	mov    %cl,0xc(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a757:	48 8d 4a 0d          	lea    0xd(%rdx),%rcx
  40a75b:	4c 39 e1             	cmp    %r12,%rcx
  40a75e:	73 1b                	jae    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
    d[i] = s[i];
  40a760:	0f b6 4c 15 0d       	movzbl 0xd(%rbp,%rdx,1),%ecx
  40a765:	88 4c 10 0d          	mov    %cl,0xd(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a769:	48 8d 4a 0e          	lea    0xe(%rdx),%rcx
  40a76d:	4c 39 e1             	cmp    %r12,%rcx
  40a770:	73 09                	jae    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
    d[i] = s[i];
  40a772:	0f b6 4c 15 0e       	movzbl 0xe(%rbp,%rdx,1),%ecx
  40a777:	88 4c 10 0e          	mov    %cl,0xe(%rax,%rdx,1)

char* internal_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  char *s2 = (char*)InternalAlloc(len + 1);
  internal_memcpy(s2, s, len);
  s2[len] = 0;
  40a77b:	c6 04 18 00          	movb   $0x0,(%rax,%rbx,1)
  return s2;
}
  40a77f:	5b                   	pop    %rbx
  40a780:	5d                   	pop    %rbp
  40a781:	41 5c                	pop    %r12
  40a783:	c3                   	retq   
  40a784:	0f 1f 40 00          	nopl   0x0(%rax)
  return s2;
}

char* internal_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  char *s2 = (char*)InternalAlloc(len + 1);
  40a788:	48 8d 78 02          	lea    0x2(%rax),%rdi
  40a78c:	31 f6                	xor    %esi,%esi
  40a78e:	e8 9d 8b ff ff       	callq  403330 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE>
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a793:	48 85 db             	test   %rbx,%rbx
  40a796:	74 e3                	je     40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
  return dst;
}

uptr internal_strnlen(const char *s, uptr maxlen) {
  uptr i = 0;
  while (i < maxlen && s[i]) i++;
  40a798:	49 89 dc             	mov    %rbx,%r12
  40a79b:	e9 62 fe ff ff       	jmpq   40a602 <_ZN11__sanitizer16internal_strndupEPKcm+0x42>
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a7a0:	31 d2                	xor    %edx,%edx
  40a7a2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    d[i] = s[i];
  40a7a8:	0f b6 4c 15 00       	movzbl 0x0(%rbp,%rdx,1),%ecx
  40a7ad:	88 0c 10             	mov    %cl,(%rax,%rdx,1)
}

void *internal_memcpy(void *dest, const void *src, uptr n) {
  char *d = (char*)dest;
  const char *s = (const char *)src;
  for (uptr i = 0; i < n; ++i)
  40a7b0:	48 83 c2 01          	add    $0x1,%rdx
  40a7b4:	4c 39 e2             	cmp    %r12,%rdx
  40a7b7:	75 ef                	jne    40a7a8 <_ZN11__sanitizer16internal_strndupEPKcm+0x1e8>

char* internal_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  char *s2 = (char*)InternalAlloc(len + 1);
  internal_memcpy(s2, s, len);
  s2[len] = 0;
  40a7b9:	c6 04 18 00          	movb   $0x0,(%rax,%rbx,1)
  return s2;
}
  40a7bd:	5b                   	pop    %rbx
  40a7be:	5d                   	pop    %rbp
  40a7bf:	41 5c                	pop    %r12
  40a7c1:	c3                   	retq   
  return s2;
}

char* internal_strndup(const char *s, uptr n) {
  uptr len = internal_strnlen(s, n);
  char *s2 = (char*)InternalAlloc(len + 1);
  40a7c2:	31 f6                	xor    %esi,%esi
  40a7c4:	bf 01 00 00 00       	mov    $0x1,%edi
  40a7c9:	31 db                	xor    %ebx,%ebx
  40a7cb:	e8 60 8b ff ff       	callq  403330 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE>
  40a7d0:	eb a9                	jmp    40a77b <_ZN11__sanitizer16internal_strndupEPKcm+0x1bb>
  40a7d2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40a7d9:	1f 84 00 00 00 00 00 

000000000040a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>:
  internal_memcpy(s2, s, len);
  s2[len] = 0;
  return s2;
}

int internal_strcmp(const char *s1, const char *s2) {
  40a7e0:	eb 12                	jmp    40a7f4 <_ZN11__sanitizer15internal_strcmpEPKcS1_+0x14>
  40a7e2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  while (true) {
    unsigned c1 = *s1;
    unsigned c2 = *s2;
    if (c1 != c2) return (c1 < c2) ? -1 : 1;
    if (c1 == 0) break;
  40a7e8:	85 c0                	test   %eax,%eax
  40a7ea:	74 24                	je     40a810 <_ZN11__sanitizer15internal_strcmpEPKcS1_+0x30>
    s1++;
  40a7ec:	48 83 c7 01          	add    $0x1,%rdi
    s2++;
  40a7f0:	48 83 c6 01          	add    $0x1,%rsi
  return s2;
}

int internal_strcmp(const char *s1, const char *s2) {
  while (true) {
    unsigned c1 = *s1;
  40a7f4:	0f be 07             	movsbl (%rdi),%eax
    unsigned c2 = *s2;
  40a7f7:	0f be 16             	movsbl (%rsi),%edx
    if (c1 != c2) return (c1 < c2) ? -1 : 1;
  40a7fa:	39 d0                	cmp    %edx,%eax
  40a7fc:	74 ea                	je     40a7e8 <_ZN11__sanitizer15internal_strcmpEPKcS1_+0x8>
  40a7fe:	39 d0                	cmp    %edx,%eax
  40a800:	19 c0                	sbb    %eax,%eax
  40a802:	83 c8 01             	or     $0x1,%eax
  40a805:	c3                   	retq   
  40a806:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40a80d:	00 00 00 
    if (c1 == 0) break;
    s1++;
    s2++;
  }
  return 0;
  40a810:	31 c0                	xor    %eax,%eax
}
  40a812:	c3                   	retq   
  40a813:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40a81a:	84 00 00 00 00 00 

000000000040a820 <_ZN11__sanitizer16internal_strncmpEPKcS1_m>:

int internal_strncmp(const char *s1, const char *s2, uptr n) {
  for (uptr i = 0; i < n; i++) {
  40a820:	48 85 d2             	test   %rdx,%rdx
  40a823:	74 36                	je     40a85b <_ZN11__sanitizer16internal_strncmpEPKcS1_m+0x3b>
    unsigned c1 = *s1;
  40a825:	0f be 0f             	movsbl (%rdi),%ecx
    unsigned c2 = *s2;
  40a828:	44 0f be 06          	movsbl (%rsi),%r8d
    if (c1 != c2) return (c1 < c2) ? -1 : 1;
  40a82c:	44 39 c1             	cmp    %r8d,%ecx
  40a82f:	75 2f                	jne    40a860 <_ZN11__sanitizer16internal_strncmpEPKcS1_m+0x40>
    if (c1 == 0) break;
  40a831:	85 c9                	test   %ecx,%ecx
  40a833:	74 26                	je     40a85b <_ZN11__sanitizer16internal_strncmpEPKcS1_m+0x3b>
  }
  return 0;
}

int internal_strncmp(const char *s1, const char *s2, uptr n) {
  for (uptr i = 0; i < n; i++) {
  40a835:	31 c0                	xor    %eax,%eax
  40a837:	eb 19                	jmp    40a852 <_ZN11__sanitizer16internal_strncmpEPKcS1_m+0x32>
  40a839:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    unsigned c1 = *s1;
  40a840:	0f be 0c 07          	movsbl (%rdi,%rax,1),%ecx
    unsigned c2 = *s2;
  40a844:	44 0f be 04 06       	movsbl (%rsi,%rax,1),%r8d
    if (c1 != c2) return (c1 < c2) ? -1 : 1;
  40a849:	44 39 c1             	cmp    %r8d,%ecx
  40a84c:	75 12                	jne    40a860 <_ZN11__sanitizer16internal_strncmpEPKcS1_m+0x40>
    if (c1 == 0) break;
  40a84e:	85 c9                	test   %ecx,%ecx
  40a850:	74 09                	je     40a85b <_ZN11__sanitizer16internal_strncmpEPKcS1_m+0x3b>
  }
  return 0;
}

int internal_strncmp(const char *s1, const char *s2, uptr n) {
  for (uptr i = 0; i < n; i++) {
  40a852:	48 83 c0 01          	add    $0x1,%rax
  40a856:	48 39 d0             	cmp    %rdx,%rax
  40a859:	75 e5                	jne    40a840 <_ZN11__sanitizer16internal_strncmpEPKcS1_m+0x20>
    if (c1 != c2) return (c1 < c2) ? -1 : 1;
    if (c1 == 0) break;
    s1++;
    s2++;
  }
  return 0;
  40a85b:	31 c0                	xor    %eax,%eax
}
  40a85d:	c3                   	retq   
  40a85e:	66 90                	xchg   %ax,%ax

int internal_strncmp(const char *s1, const char *s2, uptr n) {
  for (uptr i = 0; i < n; i++) {
    unsigned c1 = *s1;
    unsigned c2 = *s2;
    if (c1 != c2) return (c1 < c2) ? -1 : 1;
  40a860:	44 39 c1             	cmp    %r8d,%ecx
  40a863:	19 c0                	sbb    %eax,%eax
  40a865:	83 c8 01             	or     $0x1,%eax
  40a868:	c3                   	retq   
  40a869:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000040a870 <_ZN11__sanitizer15internal_strchrEPKci>:
  return 0;
}

char* internal_strchr(const char *s, int c) {
  while (true) {
    if (*s == (char)c)
  40a870:	0f b6 07             	movzbl (%rdi),%eax
  40a873:	89 f2                	mov    %esi,%edx
  40a875:	40 38 f0             	cmp    %sil,%al
  40a878:	75 11                	jne    40a88b <_ZN11__sanitizer15internal_strchrEPKci+0x1b>
  40a87a:	eb 1c                	jmp    40a898 <_ZN11__sanitizer15internal_strchrEPKci+0x28>
  40a87c:	0f 1f 40 00          	nopl   0x0(%rax)
      return const_cast<char *>(s);
    if (*s == 0)
      return nullptr;
    s++;
  40a880:	48 83 c7 01          	add    $0x1,%rdi
  return 0;
}

char* internal_strchr(const char *s, int c) {
  while (true) {
    if (*s == (char)c)
  40a884:	0f b6 07             	movzbl (%rdi),%eax
  40a887:	38 d0                	cmp    %dl,%al
  40a889:	74 0d                	je     40a898 <_ZN11__sanitizer15internal_strchrEPKci+0x28>
      return const_cast<char *>(s);
    if (*s == 0)
  40a88b:	84 c0                	test   %al,%al
  40a88d:	75 f1                	jne    40a880 <_ZN11__sanitizer15internal_strchrEPKci+0x10>
      return nullptr;
  40a88f:	31 c0                	xor    %eax,%eax
    s++;
  }
}
  40a891:	c3                   	retq   
  40a892:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  return 0;
}

char* internal_strchr(const char *s, int c) {
  while (true) {
    if (*s == (char)c)
  40a898:	48 89 f8             	mov    %rdi,%rax
  40a89b:	c3                   	retq   
  40a89c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040a8a0 <_ZN11__sanitizer18internal_strchrnulEPKci>:
  40a8a0:	0f b6 07             	movzbl (%rdi),%eax
  40a8a3:	89 f1                	mov    %esi,%ecx
  40a8a5:	40 38 f0             	cmp    %sil,%al
  40a8a8:	74 3d                	je     40a8e7 <_ZN11__sanitizer18internal_strchrnulEPKci+0x47>
      return const_cast<char *>(s);
    if (*s == 0)
  40a8aa:	84 c0                	test   %al,%al
  40a8ac:	48 89 f8             	mov    %rdi,%rax
  40a8af:	75 0b                	jne    40a8bc <_ZN11__sanitizer18internal_strchrnulEPKci+0x1c>
  40a8b1:	eb 38                	jmp    40a8eb <_ZN11__sanitizer18internal_strchrnulEPKci+0x4b>
  40a8b3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  40a8b8:	84 d2                	test   %dl,%dl
  40a8ba:	74 14                	je     40a8d0 <_ZN11__sanitizer18internal_strchrnulEPKci+0x30>
      return nullptr;
    s++;
  40a8bc:	48 83 c0 01          	add    $0x1,%rax
  return 0;
}

char* internal_strchr(const char *s, int c) {
  while (true) {
    if (*s == (char)c)
  40a8c0:	0f b6 10             	movzbl (%rax),%edx
  40a8c3:	38 ca                	cmp    %cl,%dl
  40a8c5:	75 f1                	jne    40a8b8 <_ZN11__sanitizer18internal_strchrnulEPKci+0x18>
  40a8c7:	f3 c3                	repz retq 
  40a8c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40a8d0:	48 83 c7 01          	add    $0x1,%rdi
  40a8d4:	0f 1f 40 00          	nopl   0x0(%rax)
  return const_cast<char *>(res);
}

uptr internal_strlen(const char *s) {
  uptr i = 0;
  while (s[i]) i++;
  40a8d8:	48 89 f8             	mov    %rdi,%rax
  40a8db:	48 83 c7 01          	add    $0x1,%rdi
  40a8df:	80 7f ff 00          	cmpb   $0x0,-0x1(%rdi)
  40a8e3:	75 f3                	jne    40a8d8 <_ZN11__sanitizer18internal_strchrnulEPKci+0x38>
  40a8e5:	f3 c3                	repz retq 
  return 0;
}

char* internal_strchr(const char *s, int c) {
  while (true) {
    if (*s == (char)c)
  40a8e7:	48 89 f8             	mov    %rdi,%rax
char *internal_strchrnul(const char *s, int c) {
  char *res = internal_strchr(s, c);
  if (!res)
    res = const_cast<char *>(s) + internal_strlen(s);
  return res;
}
  40a8ea:	c3                   	retq   
  40a8eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  40a8f0:	f3 c3                	repz retq 
  40a8f2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40a8f9:	1f 84 00 00 00 00 00 

000000000040a900 <_ZN11__sanitizer16internal_strrchrEPKci>:

char *internal_strrchr(const char *s, int c) {
  const char *res = nullptr;
  for (uptr i = 0; s[i]; i++) {
  40a900:	0f be 0f             	movsbl (%rdi),%ecx
  40a903:	84 c9                	test   %cl,%cl
  40a905:	74 20                	je     40a927 <_ZN11__sanitizer16internal_strrchrEPKci+0x27>
  40a907:	48 8d 57 01          	lea    0x1(%rdi),%rdx
    res = const_cast<char *>(s) + internal_strlen(s);
  return res;
}

char *internal_strrchr(const char *s, int c) {
  const char *res = nullptr;
  40a90b:	31 c0                	xor    %eax,%eax
  40a90d:	0f 1f 00             	nopl   (%rax)
  40a910:	39 f1                	cmp    %esi,%ecx
  40a912:	48 0f 44 c7          	cmove  %rdi,%rax
  for (uptr i = 0; s[i]; i++) {
  40a916:	48 89 d7             	mov    %rdx,%rdi
  40a919:	48 83 c2 01          	add    $0x1,%rdx
  40a91d:	0f be 4a ff          	movsbl -0x1(%rdx),%ecx
  40a921:	84 c9                	test   %cl,%cl
  40a923:	75 eb                	jne    40a910 <_ZN11__sanitizer16internal_strrchrEPKci+0x10>
  40a925:	f3 c3                	repz retq 
    res = const_cast<char *>(s) + internal_strlen(s);
  return res;
}

char *internal_strrchr(const char *s, int c) {
  const char *res = nullptr;
  40a927:	31 c0                	xor    %eax,%eax
  for (uptr i = 0; s[i]; i++) {
    if (s[i] == c) res = s + i;
  }
  return const_cast<char *>(res);
}
  40a929:	c3                   	retq   
  40a92a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000040a930 <_ZN11__sanitizer15internal_strlenEPKc>:

uptr internal_strlen(const char *s) {
  uptr i = 0;
  40a930:	31 c0                	xor    %eax,%eax
  while (s[i]) i++;
  40a932:	80 3f 00             	cmpb   $0x0,(%rdi)
  40a935:	74 15                	je     40a94c <_ZN11__sanitizer15internal_strlenEPKc+0x1c>
  40a937:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40a93e:	00 00 
  40a940:	48 83 c0 01          	add    $0x1,%rax
  40a944:	80 3c 07 00          	cmpb   $0x0,(%rdi,%rax,1)
  40a948:	75 f6                	jne    40a940 <_ZN11__sanitizer15internal_strlenEPKc+0x10>
  40a94a:	f3 c3                	repz retq 
  return i;
}
  40a94c:	f3 c3                	repz retq 
  40a94e:	66 90                	xchg   %ax,%ax

000000000040a950 <_ZN11__sanitizer16internal_strncatEPcPKcm>:
  }
  return const_cast<char *>(res);
}

uptr internal_strlen(const char *s) {
  uptr i = 0;
  40a950:	45 31 c0             	xor    %r8d,%r8d
  while (s[i]) i++;
  40a953:	80 3f 00             	cmpb   $0x0,(%rdi)
  return i;
}

char *internal_strncat(char *dst, const char *src, uptr n) {
  40a956:	48 89 f8             	mov    %rdi,%rax
  return const_cast<char *>(res);
}

uptr internal_strlen(const char *s) {
  uptr i = 0;
  while (s[i]) i++;
  40a959:	74 10                	je     40a96b <_ZN11__sanitizer16internal_strncatEPcPKcm+0x1b>
  40a95b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  40a960:	49 83 c0 01          	add    $0x1,%r8
  40a964:	42 80 3c 00 00       	cmpb   $0x0,(%rax,%r8,1)
  40a969:	75 f5                	jne    40a960 <_ZN11__sanitizer16internal_strncatEPcPKcm+0x10>
}

char *internal_strncat(char *dst, const char *src, uptr n) {
  uptr len = internal_strlen(dst);
  uptr i;
  for (i = 0; i < n && src[i]; i++)
  40a96b:	48 85 d2             	test   %rdx,%rdx
  40a96e:	74 32                	je     40a9a2 <_ZN11__sanitizer16internal_strncatEPcPKcm+0x52>
  40a970:	44 0f b6 0e          	movzbl (%rsi),%r9d
  40a974:	45 84 c9             	test   %r9b,%r9b
  40a977:	74 29                	je     40a9a2 <_ZN11__sanitizer16internal_strncatEPcPKcm+0x52>
  40a979:	31 c9                	xor    %ecx,%ecx
  40a97b:	4a 8d 3c 00          	lea    (%rax,%r8,1),%rdi
  40a97f:	eb 11                	jmp    40a992 <_ZN11__sanitizer16internal_strncatEPcPKcm+0x42>
  40a981:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40a988:	44 0f b6 0c 0e       	movzbl (%rsi,%rcx,1),%r9d
  40a98d:	45 84 c9             	test   %r9b,%r9b
  40a990:	74 0d                	je     40a99f <_ZN11__sanitizer16internal_strncatEPcPKcm+0x4f>
    dst[len + i] = src[i];
  40a992:	44 88 0c 0f          	mov    %r9b,(%rdi,%rcx,1)
}

char *internal_strncat(char *dst, const char *src, uptr n) {
  uptr len = internal_strlen(dst);
  uptr i;
  for (i = 0; i < n && src[i]; i++)
  40a996:	48 83 c1 01          	add    $0x1,%rcx
  40a99a:	48 39 d1             	cmp    %rdx,%rcx
  40a99d:	75 e9                	jne    40a988 <_ZN11__sanitizer16internal_strncatEPcPKcm+0x38>
  40a99f:	49 01 c8             	add    %rcx,%r8
    dst[len + i] = src[i];
  dst[len + i] = 0;
  40a9a2:	42 c6 04 00 00       	movb   $0x0,(%rax,%r8,1)
  return dst;
}
  40a9a7:	c3                   	retq   
  40a9a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40a9af:	00 

000000000040a9b0 <_ZN11__sanitizer16internal_strncpyEPcPKcm>:

char *internal_strncpy(char *dst, const char *src, uptr n) {
  uptr i;
  for (i = 0; i < n && src[i]; i++)
  40a9b0:	48 85 d2             	test   %rdx,%rdx
    dst[len + i] = src[i];
  dst[len + i] = 0;
  return dst;
}

char *internal_strncpy(char *dst, const char *src, uptr n) {
  40a9b3:	48 89 f8             	mov    %rdi,%rax
  uptr i;
  for (i = 0; i < n && src[i]; i++)
  40a9b6:	74 27                	je     40a9df <_ZN11__sanitizer16internal_strncpyEPcPKcm+0x2f>
  40a9b8:	44 0f b6 06          	movzbl (%rsi),%r8d
  40a9bc:	31 c9                	xor    %ecx,%ecx
  40a9be:	45 84 c0             	test   %r8b,%r8b
  40a9c1:	75 0f                	jne    40a9d2 <_ZN11__sanitizer16internal_strncpyEPcPKcm+0x22>
  40a9c3:	eb 23                	jmp    40a9e8 <_ZN11__sanitizer16internal_strncpyEPcPKcm+0x38>
  40a9c5:	0f 1f 00             	nopl   (%rax)
  40a9c8:	44 0f b6 04 0e       	movzbl (%rsi,%rcx,1),%r8d
  40a9cd:	45 84 c0             	test   %r8b,%r8b
  40a9d0:	74 16                	je     40a9e8 <_ZN11__sanitizer16internal_strncpyEPcPKcm+0x38>
    dst[i] = src[i];
  40a9d2:	44 88 04 08          	mov    %r8b,(%rax,%rcx,1)
  return dst;
}

char *internal_strncpy(char *dst, const char *src, uptr n) {
  uptr i;
  for (i = 0; i < n && src[i]; i++)
  40a9d6:	48 83 c1 01          	add    $0x1,%rcx
  40a9da:	48 39 d1             	cmp    %rdx,%rcx
  40a9dd:	75 e9                	jne    40a9c8 <_ZN11__sanitizer16internal_strncpyEPcPKcm+0x18>
    dst[i] = src[i];
  internal_memset(dst + i, '\0', n - i);
  return dst;
}
  40a9df:	f3 c3                	repz retq 
  40a9e1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  // The next line prevents Clang from making a call to memset() instead of the
  // loop below.
  // FIXME: building the runtime with -ffreestanding is a better idea. However
  // there currently are linktime problems due to PR12396.
  char volatile *t = (char*)s;
  for (uptr i = 0; i < n; ++i, ++t) {
  40a9e8:	48 29 ca             	sub    %rcx,%rdx

char *internal_strncpy(char *dst, const char *src, uptr n) {
  uptr i;
  for (i = 0; i < n && src[i]; i++)
    dst[i] = src[i];
  internal_memset(dst + i, '\0', n - i);
  40a9eb:	48 8d 34 08          	lea    (%rax,%rcx,1),%rsi
  // The next line prevents Clang from making a call to memset() instead of the
  // loop below.
  // FIXME: building the runtime with -ffreestanding is a better idea. However
  // there currently are linktime problems due to PR12396.
  char volatile *t = (char*)s;
  for (uptr i = 0; i < n; ++i, ++t) {
  40a9ef:	74 ee                	je     40a9df <_ZN11__sanitizer16internal_strncpyEPcPKcm+0x2f>
  40a9f1:	48 01 f2             	add    %rsi,%rdx
  40a9f4:	0f 1f 40 00          	nopl   0x0(%rax)
    *t = c;
  40a9f8:	c6 06 00             	movb   $0x0,(%rsi)
  // The next line prevents Clang from making a call to memset() instead of the
  // loop below.
  // FIXME: building the runtime with -ffreestanding is a better idea. However
  // there currently are linktime problems due to PR12396.
  char volatile *t = (char*)s;
  for (uptr i = 0; i < n; ++i, ++t) {
  40a9fb:	48 83 c6 01          	add    $0x1,%rsi
  40a9ff:	48 39 d6             	cmp    %rdx,%rsi
  40aa02:	75 f4                	jne    40a9f8 <_ZN11__sanitizer16internal_strncpyEPcPKcm+0x48>
  uptr i;
  for (i = 0; i < n && src[i]; i++)
    dst[i] = src[i];
  internal_memset(dst + i, '\0', n - i);
  return dst;
}
  40aa04:	f3 c3                	repz retq 
  40aa06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40aa0d:	00 00 00 

000000000040aa10 <_ZN11__sanitizer16internal_strnlenEPKcm>:

uptr internal_strnlen(const char *s, uptr maxlen) {
  uptr i = 0;
  40aa10:	31 c0                	xor    %eax,%eax
  while (i < maxlen && s[i]) i++;
  40aa12:	48 85 f6             	test   %rsi,%rsi
  40aa15:	74 23                	je     40aa3a <_ZN11__sanitizer16internal_strnlenEPKcm+0x2a>
  40aa17:	80 3f 00             	cmpb   $0x0,(%rdi)
  40aa1a:	75 0a                	jne    40aa26 <_ZN11__sanitizer16internal_strnlenEPKcm+0x16>
  40aa1c:	eb 11                	jmp    40aa2f <_ZN11__sanitizer16internal_strnlenEPKcm+0x1f>
  40aa1e:	66 90                	xchg   %ax,%ax
  40aa20:	80 3c 07 00          	cmpb   $0x0,(%rdi,%rax,1)
  40aa24:	74 12                	je     40aa38 <_ZN11__sanitizer16internal_strnlenEPKcm+0x28>
  40aa26:	48 83 c0 01          	add    $0x1,%rax
  40aa2a:	48 39 f0             	cmp    %rsi,%rax
  40aa2d:	75 f1                	jne    40aa20 <_ZN11__sanitizer16internal_strnlenEPKcm+0x10>
  return i;
}
  40aa2f:	f3 c3                	repz retq 
  40aa31:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40aa38:	f3 c3                	repz retq 
  40aa3a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40aa40:	f3 c3                	repz retq 
  40aa42:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40aa49:	1f 84 00 00 00 00 00 

000000000040aa50 <_ZN11__sanitizer15internal_strstrEPKcS1_>:
  return const_cast<char *>(res);
}

uptr internal_strlen(const char *s) {
  uptr i = 0;
  while (s[i]) i++;
  40aa50:	0f b6 17             	movzbl (%rdi),%edx
  }
  return const_cast<char *>(res);
}

uptr internal_strlen(const char *s) {
  uptr i = 0;
  40aa53:	31 c0                	xor    %eax,%eax
  while (s[i]) i++;
  40aa55:	84 d2                	test   %dl,%dl
  40aa57:	74 11                	je     40aa6a <_ZN11__sanitizer15internal_strstrEPKcS1_+0x1a>
  40aa59:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40aa60:	48 83 c0 01          	add    $0x1,%rax
  40aa64:	80 3c 07 00          	cmpb   $0x0,(%rdi,%rax,1)
  40aa68:	75 f6                	jne    40aa60 <_ZN11__sanitizer15internal_strstrEPKcS1_+0x10>
  40aa6a:	44 0f b6 16          	movzbl (%rsi),%r10d
  40aa6e:	45 84 d2             	test   %r10b,%r10b
  40aa71:	74 49                	je     40aabc <_ZN11__sanitizer15internal_strstrEPKcS1_+0x6c>
  40aa73:	31 c9                	xor    %ecx,%ecx
  40aa75:	0f 1f 00             	nopl   (%rax)
  40aa78:	48 83 c1 01          	add    $0x1,%rcx
  40aa7c:	80 3c 0e 00          	cmpb   $0x0,(%rsi,%rcx,1)
  40aa80:	75 f6                	jne    40aa78 <_ZN11__sanitizer15internal_strstrEPKcS1_+0x28>

char *internal_strstr(const char *haystack, const char *needle) {
  // This is O(N^2), but we are not using it in hot places.
  uptr len1 = internal_strlen(haystack);
  uptr len2 = internal_strlen(needle);
  if (len1 < len2) return nullptr;
  40aa82:	48 39 c8             	cmp    %rcx,%rax
  40aa85:	72 4f                	jb     40aad6 <_ZN11__sanitizer15internal_strstrEPKcS1_+0x86>
  40aa87:	4c 8d 47 01          	lea    0x1(%rdi),%r8
  for (uptr pos = 0; pos <= len1 - len2; pos++) {
  40aa8b:	48 29 c8             	sub    %rcx,%rax
  40aa8e:	45 31 c9             	xor    %r9d,%r9d
  40aa91:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

int internal_memcmp(const void* s1, const void* s2, uptr n) {
  const char *t1 = (const char *)s1;
  const char *t2 = (const char *)s2;
  for (uptr i = 0; i < n; ++i, ++t1, ++t2)
    if (*t1 != *t2)
  40aa98:	44 38 d2             	cmp    %r10b,%dl
  40aa9b:	75 23                	jne    40aac0 <_ZN11__sanitizer15internal_strstrEPKcS1_+0x70>
}

int internal_memcmp(const void* s1, const void* s2, uptr n) {
  const char *t1 = (const char *)s1;
  const char *t2 = (const char *)s2;
  for (uptr i = 0; i < n; ++i, ++t1, ++t2)
  40aa9d:	31 d2                	xor    %edx,%edx
  40aa9f:	eb 12                	jmp    40aab3 <_ZN11__sanitizer15internal_strstrEPKcS1_+0x63>
  40aaa1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    if (*t1 != *t2)
  40aaa8:	44 0f b6 1c 16       	movzbl (%rsi,%rdx,1),%r11d
  40aaad:	44 38 1c 17          	cmp    %r11b,(%rdi,%rdx,1)
  40aab1:	75 0d                	jne    40aac0 <_ZN11__sanitizer15internal_strstrEPKcS1_+0x70>
}

int internal_memcmp(const void* s1, const void* s2, uptr n) {
  const char *t1 = (const char *)s1;
  const char *t2 = (const char *)s2;
  for (uptr i = 0; i < n; ++i, ++t1, ++t2)
  40aab3:	48 83 c2 01          	add    $0x1,%rdx
  40aab7:	48 39 ca             	cmp    %rcx,%rdx
  40aaba:	75 ec                	jne    40aaa8 <_ZN11__sanitizer15internal_strstrEPKcS1_+0x58>
  return const_cast<char *>(res);
}

uptr internal_strlen(const char *s) {
  uptr i = 0;
  while (s[i]) i++;
  40aabc:	48 89 f8             	mov    %rdi,%rax
  40aabf:	c3                   	retq   
char *internal_strstr(const char *haystack, const char *needle) {
  // This is O(N^2), but we are not using it in hot places.
  uptr len1 = internal_strlen(haystack);
  uptr len2 = internal_strlen(needle);
  if (len1 < len2) return nullptr;
  for (uptr pos = 0; pos <= len1 - len2; pos++) {
  40aac0:	49 83 c1 01          	add    $0x1,%r9
  40aac4:	49 39 c1             	cmp    %rax,%r9
  40aac7:	77 0d                	ja     40aad6 <_ZN11__sanitizer15internal_strstrEPKcS1_+0x86>
    if (internal_memcmp(haystack + pos, needle, len2) == 0)
  40aac9:	4c 89 c7             	mov    %r8,%rdi
  40aacc:	41 0f b6 10          	movzbl (%r8),%edx
  40aad0:	49 83 c0 01          	add    $0x1,%r8
  40aad4:	eb c2                	jmp    40aa98 <_ZN11__sanitizer15internal_strstrEPKcS1_+0x48>

char *internal_strstr(const char *haystack, const char *needle) {
  // This is O(N^2), but we are not using it in hot places.
  uptr len1 = internal_strlen(haystack);
  uptr len2 = internal_strlen(needle);
  if (len1 < len2) return nullptr;
  40aad6:	31 c0                	xor    %eax,%eax
  40aad8:	c3                   	retq   
  40aad9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000040aae0 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci>:
  }
  return nullptr;
}

s64 internal_simple_strtoll(const char *nptr, char **endptr, int base) {
  CHECK_EQ(base, 10);
  40aae0:	48 63 ca             	movslq %edx,%rcx
  40aae3:	48 83 f9 0a          	cmp    $0xa,%rcx
  40aae7:	0f 85 03 01 00 00    	jne    40abf0 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci+0x110>
  40aaed:	0f 1f 00             	nopl   (%rax)
  while (IsSpace(*nptr)) nptr++;
  40aaf0:	0f be 07             	movsbl (%rdi),%eax
}

// Char handling
INLINE bool IsSpace(int c) {
  return (c == ' ') || (c == '\n') || (c == '\t') ||
         (c == '\f') || (c == '\r') || (c == '\v');
  40aaf3:	3c 20                	cmp    $0x20,%al
  40aaf5:	0f 84 9d 00 00 00    	je     40ab98 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci+0xb8>
  b = tmp;
}

// Char handling
INLINE bool IsSpace(int c) {
  return (c == ' ') || (c == '\n') || (c == '\t') ||
  40aafb:	8d 50 f7             	lea    -0x9(%rax),%edx
  40aafe:	80 fa 04             	cmp    $0x4,%dl
  40ab01:	0f 86 91 00 00 00    	jbe    40ab98 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci+0xb8>
  int sgn = 1;
  u64 res = 0;
  bool have_digits = false;
  char *old_nptr = const_cast<char *>(nptr);
  if (*nptr == '+') {
  40ab07:	3c 2b                	cmp    $0x2b,%al
  40ab09:	0f 84 99 00 00 00    	je     40aba8 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci+0xc8>
    sgn = 1;
    nptr++;
  } else if (*nptr == '-') {
  40ab0f:	3c 2d                	cmp    $0x2d,%al
  40ab11:	48 89 f9             	mov    %rdi,%rcx
}

s64 internal_simple_strtoll(const char *nptr, char **endptr, int base) {
  CHECK_EQ(base, 10);
  while (IsSpace(*nptr)) nptr++;
  int sgn = 1;
  40ab14:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  bool have_digits = false;
  char *old_nptr = const_cast<char *>(nptr);
  if (*nptr == '+') {
    sgn = 1;
    nptr++;
  } else if (*nptr == '-') {
  40ab1a:	0f 84 a0 00 00 00    	je     40abc0 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci+0xe0>
         (c == '\f') || (c == '\r') || (c == '\v');
}
INLINE bool IsDigit(int c) {
  return (c >= '0') && (c <= '9');
  40ab20:	8d 50 d0             	lea    -0x30(%rax),%edx
    sgn = -1;
    nptr++;
  }
  while (IsDigit(*nptr)) {
  40ab23:	83 fa 09             	cmp    $0x9,%edx
  40ab26:	ba 00 00 00 00       	mov    $0x0,%edx
  40ab2b:	77 46                	ja     40ab73 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci+0x93>
  40ab2d:	49 ba 99 99 99 99 99 	movabs $0x1999999999999999,%r10
  40ab34:	99 99 19 
  40ab37:	49 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%r8
  40ab3e:	66 90                	xchg   %ax,%ax
    res = (res <= UINT64_MAX / 10) ? res * 10 : UINT64_MAX;
  40ab40:	48 8d 3c 92          	lea    (%rdx,%rdx,4),%rdi
  40ab44:	48 01 ff             	add    %rdi,%rdi
  40ab47:	4c 39 d2             	cmp    %r10,%rdx
  40ab4a:	49 0f 47 f8          	cmova  %r8,%rdi
    int digit = ((*nptr) - '0');
  40ab4e:	83 e8 30             	sub    $0x30,%eax
    res = (res <= UINT64_MAX - digit) ? res + digit : UINT64_MAX;
  40ab51:	48 98                	cltq   
  40ab53:	48 8d 14 07          	lea    (%rdi,%rax,1),%rdx
  40ab57:	48 f7 d0             	not    %rax
  40ab5a:	48 39 c7             	cmp    %rax,%rdi
  40ab5d:	49 0f 47 d0          	cmova  %r8,%rdx
    have_digits = true;
    nptr++;
  40ab61:	48 83 c1 01          	add    $0x1,%rcx
  40ab65:	0f be 01             	movsbl (%rcx),%eax
  40ab68:	8d 78 d0             	lea    -0x30(%rax),%edi
    nptr++;
  } else if (*nptr == '-') {
    sgn = -1;
    nptr++;
  }
  while (IsDigit(*nptr)) {
  40ab6b:	83 ff 09             	cmp    $0x9,%edi
  40ab6e:	76 d0                	jbe    40ab40 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci+0x60>
    res = (res <= UINT64_MAX / 10) ? res * 10 : UINT64_MAX;
    int digit = ((*nptr) - '0');
    res = (res <= UINT64_MAX - digit) ? res + digit : UINT64_MAX;
    have_digits = true;
    nptr++;
  40ab70:	48 89 cf             	mov    %rcx,%rdi
  }
  if (endptr) {
  40ab73:	48 85 f6             	test   %rsi,%rsi
  40ab76:	74 03                	je     40ab7b <_ZN11__sanitizer23internal_simple_strtollEPKcPPci+0x9b>
    *endptr = (have_digits) ? const_cast<char *>(nptr) : old_nptr;
  40ab78:	48 89 3e             	mov    %rdi,(%rsi)
  }
  if (sgn > 0) {
  40ab7b:	41 83 f9 01          	cmp    $0x1,%r9d
  40ab7f:	75 57                	jne    40abd8 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci+0xf8>
  40ab81:	48 b8 ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rax
  40ab88:	ff ff 7f 
  40ab8b:	48 39 c2             	cmp    %rax,%rdx
  40ab8e:	48 0f 46 c2          	cmovbe %rdx,%rax
    return (s64)(Min((u64)INT64_MAX, res));
  40ab92:	c3                   	retq   
  40ab93:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  return nullptr;
}

s64 internal_simple_strtoll(const char *nptr, char **endptr, int base) {
  CHECK_EQ(base, 10);
  while (IsSpace(*nptr)) nptr++;
  40ab98:	48 83 c7 01          	add    $0x1,%rdi
  40ab9c:	e9 4f ff ff ff       	jmpq   40aaf0 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci+0x10>
  40aba1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  u64 res = 0;
  bool have_digits = false;
  char *old_nptr = const_cast<char *>(nptr);
  if (*nptr == '+') {
    sgn = 1;
    nptr++;
  40aba8:	48 8d 4f 01          	lea    0x1(%rdi),%rcx
  40abac:	0f be 47 01          	movsbl 0x1(%rdi),%eax
  int sgn = 1;
  u64 res = 0;
  bool have_digits = false;
  char *old_nptr = const_cast<char *>(nptr);
  if (*nptr == '+') {
    sgn = 1;
  40abb0:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  40abb6:	e9 65 ff ff ff       	jmpq   40ab20 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci+0x40>
  40abbb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    nptr++;
  } else if (*nptr == '-') {
    sgn = -1;
    nptr++;
  40abc0:	48 8d 4f 01          	lea    0x1(%rdi),%rcx
  40abc4:	0f be 47 01          	movsbl 0x1(%rdi),%eax
  char *old_nptr = const_cast<char *>(nptr);
  if (*nptr == '+') {
    sgn = 1;
    nptr++;
  } else if (*nptr == '-') {
    sgn = -1;
  40abc8:	41 b9 ff ff ff ff    	mov    $0xffffffff,%r9d
  40abce:	e9 4d ff ff ff       	jmpq   40ab20 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci+0x40>
  40abd3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    *endptr = (have_digits) ? const_cast<char *>(nptr) : old_nptr;
  }
  if (sgn > 0) {
    return (s64)(Min((u64)INT64_MAX, res));
  } else {
    return (res > INT64_MAX) ? INT64_MIN : ((s64)res * -1);
  40abd8:	48 89 d1             	mov    %rdx,%rcx
  40abdb:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
  40abe2:	00 00 80 
  40abe5:	48 f7 d9             	neg    %rcx
  40abe8:	48 85 d2             	test   %rdx,%rdx
  40abeb:	48 0f 49 c1          	cmovns %rcx,%rax
  40abef:	c3                   	retq   
  }
  return nullptr;
}

s64 internal_simple_strtoll(const char *nptr, char **endptr, int base) {
  CHECK_EQ(base, 10);
  40abf0:	48 8d 15 90 df 00 00 	lea    0xdf90(%rip),%rdx        # 418b87 <.LC2>
  40abf7:	48 8d 3d ba c3 00 00 	lea    0xc3ba(%rip),%rdi        # 416fb8 <.LC1>
      return const_cast<char *>(haystack) + pos;
  }
  return nullptr;
}

s64 internal_simple_strtoll(const char *nptr, char **endptr, int base) {
  40abfe:	48 83 ec 08          	sub    $0x8,%rsp
  CHECK_EQ(base, 10);
  40ac02:	41 b8 0a 00 00 00    	mov    $0xa,%r8d
  40ac08:	be d6 00 00 00       	mov    $0xd6,%esi
  40ac0d:	e8 de a7 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40ac12:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40ac19:	1f 84 00 00 00 00 00 

000000000040ac20 <_ZN11__sanitizer14internal_atollEPKc>:
#include "sanitizer_libc.h"

namespace __sanitizer {

s64 internal_atoll(const char *nptr) {
  return internal_simple_strtoll(nptr, nullptr, 10);
  40ac20:	ba 0a 00 00 00       	mov    $0xa,%edx
  40ac25:	31 f6                	xor    %esi,%esi
  40ac27:	e9 b4 fe ff ff       	jmpq   40aae0 <_ZN11__sanitizer23internal_simple_strtollEPKcPPci>
  40ac2c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040ac30 <_ZN11__sanitizer11mem_is_zeroEPKcm>:
  } else {
    return (res > INT64_MAX) ? INT64_MIN : ((s64)res * -1);
  }
}

bool mem_is_zero(const char *beg, uptr size) {
  40ac30:	55                   	push   %rbp
  CHECK_LE(size, 1ULL << FIRST_32_SECOND_64(30, 40));  // Sanity check.
  40ac31:	49 b8 00 00 00 00 00 	movabs $0x10000000000,%r8
  40ac38:	01 00 00 
  } else {
    return (res > INT64_MAX) ? INT64_MIN : ((s64)res * -1);
  }
}

bool mem_is_zero(const char *beg, uptr size) {
  40ac3b:	53                   	push   %rbx
  40ac3c:	48 83 ec 18          	sub    $0x18,%rsp
  CHECK_LE(size, 1ULL << FIRST_32_SECOND_64(30, 40));  // Sanity check.
  40ac40:	4c 39 c6             	cmp    %r8,%rsi
  40ac43:	0f 87 1e 04 00 00    	ja     40b067 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x437>
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  return (size + boundary - 1) & ~(boundary - 1);
  40ac49:	48 8d 4f 07          	lea    0x7(%rdi),%rcx
  const char *end = beg + size;
  40ac4d:	48 01 fe             	add    %rdi,%rsi
}

INLINE uptr RoundDownTo(uptr x, uptr boundary) {
  return x & ~(boundary - 1);
  40ac50:	49 89 f1             	mov    %rsi,%r9
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  return (size + boundary - 1) & ~(boundary - 1);
  40ac53:	48 83 e1 f8          	and    $0xfffffffffffffff8,%rcx
}

INLINE uptr RoundDownTo(uptr x, uptr boundary) {
  return x & ~(boundary - 1);
  40ac57:	49 83 e1 f8          	and    $0xfffffffffffffff8,%r9
  uptr *aligned_beg = (uptr *)RoundUpTo((uptr)beg, sizeof(uptr));
  uptr *aligned_end = (uptr *)RoundDownTo((uptr)end, sizeof(uptr));
  uptr all = 0;
  // Prologue.
  for (const char *mem = beg; mem < (char*)aligned_beg && mem < end; mem++)
  40ac5b:	48 39 cf             	cmp    %rcx,%rdi
  40ac5e:	0f 83 fc 03 00 00    	jae    40b060 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x430>
  40ac64:	48 39 f7             	cmp    %rsi,%rdi
  40ac67:	0f 83 f3 03 00 00    	jae    40b060 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x430>
  40ac6d:	48 89 fa             	mov    %rdi,%rdx
bool mem_is_zero(const char *beg, uptr size) {
  CHECK_LE(size, 1ULL << FIRST_32_SECOND_64(30, 40));  // Sanity check.
  const char *end = beg + size;
  uptr *aligned_beg = (uptr *)RoundUpTo((uptr)beg, sizeof(uptr));
  uptr *aligned_end = (uptr *)RoundDownTo((uptr)end, sizeof(uptr));
  uptr all = 0;
  40ac70:	31 c0                	xor    %eax,%eax
  40ac72:	eb 09                	jmp    40ac7d <_ZN11__sanitizer11mem_is_zeroEPKcm+0x4d>
  40ac74:	0f 1f 40 00          	nopl   0x0(%rax)
  // Prologue.
  for (const char *mem = beg; mem < (char*)aligned_beg && mem < end; mem++)
  40ac78:	48 39 ca             	cmp    %rcx,%rdx
  40ac7b:	73 10                	jae    40ac8d <_ZN11__sanitizer11mem_is_zeroEPKcm+0x5d>
    all |= *mem;
  40ac7d:	4c 0f be 02          	movsbq (%rdx),%r8
  const char *end = beg + size;
  uptr *aligned_beg = (uptr *)RoundUpTo((uptr)beg, sizeof(uptr));
  uptr *aligned_end = (uptr *)RoundDownTo((uptr)end, sizeof(uptr));
  uptr all = 0;
  // Prologue.
  for (const char *mem = beg; mem < (char*)aligned_beg && mem < end; mem++)
  40ac81:	48 83 c2 01          	add    $0x1,%rdx
    all |= *mem;
  40ac85:	4c 09 c0             	or     %r8,%rax
  const char *end = beg + size;
  uptr *aligned_beg = (uptr *)RoundUpTo((uptr)beg, sizeof(uptr));
  uptr *aligned_end = (uptr *)RoundDownTo((uptr)end, sizeof(uptr));
  uptr all = 0;
  // Prologue.
  for (const char *mem = beg; mem < (char*)aligned_beg && mem < end; mem++)
  40ac88:	48 39 d6             	cmp    %rdx,%rsi
  40ac8b:	77 eb                	ja     40ac78 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x48>
    all |= *mem;
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
  40ac8d:	4c 39 c9             	cmp    %r9,%rcx
  40ac90:	0f 83 f7 00 00 00    	jae    40ad8d <_ZN11__sanitizer11mem_is_zeroEPKcm+0x15d>
  40ac96:	48 89 ca             	mov    %rcx,%rdx
  40ac99:	4c 8d 59 01          	lea    0x1(%rcx),%r11
  40ac9d:	49 89 c8             	mov    %rcx,%r8
  40aca0:	48 f7 d2             	not    %rdx
  40aca3:	4c 01 ca             	add    %r9,%rdx
  40aca6:	48 c1 ea 03          	shr    $0x3,%rdx
  40acaa:	4d 39 d9             	cmp    %r11,%r9
  40acad:	4c 8d 52 01          	lea    0x1(%rdx),%r10
  40acb1:	ba 01 00 00 00       	mov    $0x1,%edx
  40acb6:	49 0f 43 d2          	cmovae %r10,%rdx
  40acba:	49 c1 e0 3c          	shl    $0x3c,%r8
  40acbe:	49 c1 f8 3f          	sar    $0x3f,%r8
  40acc2:	41 83 e0 01          	and    $0x1,%r8d
  40acc6:	49 39 d0             	cmp    %rdx,%r8
  40acc9:	4c 0f 47 c2          	cmova  %rdx,%r8
  40accd:	49 83 fa 07          	cmp    $0x7,%r10
  40acd1:	0f 87 59 03 00 00    	ja     40b030 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x400>
  40acd7:	49 89 d0             	mov    %rdx,%r8
    all |= *aligned_beg;
  40acda:	48 0b 01             	or     (%rcx),%rax
  40acdd:	49 83 f8 01          	cmp    $0x1,%r8
  uptr all = 0;
  // Prologue.
  for (const char *mem = beg; mem < (char*)aligned_beg && mem < end; mem++)
    all |= *mem;
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
  40ace1:	4c 8d 51 08          	lea    0x8(%rcx),%r10
  40ace5:	76 4e                	jbe    40ad35 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x105>
    all |= *aligned_beg;
  40ace7:	48 0b 41 08          	or     0x8(%rcx),%rax
  40aceb:	49 83 f8 02          	cmp    $0x2,%r8
  uptr all = 0;
  // Prologue.
  for (const char *mem = beg; mem < (char*)aligned_beg && mem < end; mem++)
    all |= *mem;
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
  40acef:	4c 8d 51 10          	lea    0x10(%rcx),%r10
  40acf3:	76 40                	jbe    40ad35 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x105>
    all |= *aligned_beg;
  40acf5:	48 0b 41 10          	or     0x10(%rcx),%rax
  40acf9:	49 83 f8 03          	cmp    $0x3,%r8
  uptr all = 0;
  // Prologue.
  for (const char *mem = beg; mem < (char*)aligned_beg && mem < end; mem++)
    all |= *mem;
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
  40acfd:	4c 8d 51 18          	lea    0x18(%rcx),%r10
  40ad01:	76 32                	jbe    40ad35 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x105>
    all |= *aligned_beg;
  40ad03:	48 0b 41 18          	or     0x18(%rcx),%rax
  40ad07:	49 83 f8 04          	cmp    $0x4,%r8
  uptr all = 0;
  // Prologue.
  for (const char *mem = beg; mem < (char*)aligned_beg && mem < end; mem++)
    all |= *mem;
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
  40ad0b:	4c 8d 51 20          	lea    0x20(%rcx),%r10
  40ad0f:	76 24                	jbe    40ad35 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x105>
    all |= *aligned_beg;
  40ad11:	48 0b 41 20          	or     0x20(%rcx),%rax
  40ad15:	49 83 f8 05          	cmp    $0x5,%r8
  uptr all = 0;
  // Prologue.
  for (const char *mem = beg; mem < (char*)aligned_beg && mem < end; mem++)
    all |= *mem;
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
  40ad19:	4c 8d 51 28          	lea    0x28(%rcx),%r10
  40ad1d:	76 16                	jbe    40ad35 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x105>
    all |= *aligned_beg;
  40ad1f:	48 0b 41 28          	or     0x28(%rcx),%rax
  40ad23:	49 83 f8 06          	cmp    $0x6,%r8
  uptr all = 0;
  // Prologue.
  for (const char *mem = beg; mem < (char*)aligned_beg && mem < end; mem++)
    all |= *mem;
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
  40ad27:	4c 8d 51 30          	lea    0x30(%rcx),%r10
  40ad2b:	76 08                	jbe    40ad35 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x105>
    all |= *aligned_beg;
  40ad2d:	48 0b 41 30          	or     0x30(%rcx),%rax
  uptr all = 0;
  // Prologue.
  for (const char *mem = beg; mem < (char*)aligned_beg && mem < end; mem++)
    all |= *mem;
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
  40ad31:	4c 8d 51 38          	lea    0x38(%rcx),%r10
  40ad35:	4c 39 c2             	cmp    %r8,%rdx
  40ad38:	74 53                	je     40ad8d <_ZN11__sanitizer11mem_is_zeroEPKcm+0x15d>
  40ad3a:	48 89 d3             	mov    %rdx,%rbx
  40ad3d:	4c 29 c3             	sub    %r8,%rbx
  40ad40:	49 89 db             	mov    %rbx,%r11
  40ad43:	49 d1 eb             	shr    %r11
  40ad46:	4c 89 dd             	mov    %r11,%rbp
  40ad49:	48 01 ed             	add    %rbp,%rbp
  40ad4c:	74 3c                	je     40ad8a <_ZN11__sanitizer11mem_is_zeroEPKcm+0x15a>
  40ad4e:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40ad52:	4a 8d 0c c1          	lea    (%rcx,%r8,8),%rcx
  40ad56:	31 d2                	xor    %edx,%edx
  40ad58:	48 83 c2 01          	add    $0x1,%rdx
    all |= *aligned_beg;
  40ad5c:	66 0f eb 01          	por    (%rcx),%xmm0
  40ad60:	48 83 c1 10          	add    $0x10,%rcx
  40ad64:	4c 39 da             	cmp    %r11,%rdx
  40ad67:	72 ef                	jb     40ad58 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x128>
  40ad69:	66 0f 6f f8          	movdqa %xmm0,%xmm7
  40ad6d:	4d 8d 14 ea          	lea    (%r10,%rbp,8),%r10
  40ad71:	66 0f 73 df 08       	psrldq $0x8,%xmm7
  40ad76:	66 0f eb c7          	por    %xmm7,%xmm0
  40ad7a:	66 0f d6 44 24 08    	movq   %xmm0,0x8(%rsp)
  40ad80:	48 0b 44 24 08       	or     0x8(%rsp),%rax
  40ad85:	48 39 eb             	cmp    %rbp,%rbx
  40ad88:	74 03                	je     40ad8d <_ZN11__sanitizer11mem_is_zeroEPKcm+0x15d>
  40ad8a:	49 0b 02             	or     (%r10),%rax
  // Epilogue.
  if ((char*)aligned_end >= beg)
  40ad8d:	4c 39 cf             	cmp    %r9,%rdi
  40ad90:	0f 87 83 02 00 00    	ja     40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40ad96:	4c 39 ce             	cmp    %r9,%rsi
  40ad99:	0f 86 7a 02 00 00    	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
  40ad9f:	4c 89 ca             	mov    %r9,%rdx
  40ada2:	49 89 f0             	mov    %rsi,%r8
  40ada5:	48 f7 da             	neg    %rdx
  40ada8:	4d 29 c8             	sub    %r9,%r8
  40adab:	83 e2 0f             	and    $0xf,%edx
  40adae:	4c 39 c2             	cmp    %r8,%rdx
  40adb1:	49 0f 47 d0          	cmova  %r8,%rdx
  40adb5:	49 83 f8 13          	cmp    $0x13,%r8
  40adb9:	49 0f 46 d0          	cmovbe %r8,%rdx
  40adbd:	48 85 d2             	test   %rdx,%rdx
  40adc0:	49 89 d2             	mov    %rdx,%r10
  40adc3:	0f 84 87 02 00 00    	je     40b050 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x420>
  40adc9:	4a 8d 3c 0a          	lea    (%rdx,%r9,1),%rdi
  40adcd:	4c 89 ca             	mov    %r9,%rdx
      all |= *mem;
  40add0:	48 0f be 0a          	movsbq (%rdx),%rcx
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40add4:	48 83 c2 01          	add    $0x1,%rdx
      all |= *mem;
  40add8:	48 09 c8             	or     %rcx,%rax
  40addb:	48 39 fa             	cmp    %rdi,%rdx
  40adde:	75 f0                	jne    40add0 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x1a0>
  40ade0:	4d 39 c2             	cmp    %r8,%r10
  40ade3:	0f 84 30 02 00 00    	je     40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
  40ade9:	4d 29 d0             	sub    %r10,%r8
  40adec:	4c 89 c7             	mov    %r8,%rdi
  40adef:	48 c1 ef 04          	shr    $0x4,%rdi
  40adf3:	48 89 f9             	mov    %rdi,%rcx
  40adf6:	48 c1 e1 04          	shl    $0x4,%rcx
  40adfa:	48 85 c9             	test   %rcx,%rcx
  40adfd:	0f 84 09 01 00 00    	je     40af0c <_ZN11__sanitizer11mem_is_zeroEPKcm+0x2dc>
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40ae03:	66 0f ef c9          	pxor   %xmm1,%xmm1
  40ae07:	4d 01 d1             	add    %r10,%r9
  40ae0a:	45 31 db             	xor    %r11d,%r11d
      all |= *mem;
  40ae0d:	66 45 0f ef c9       	pxor   %xmm9,%xmm9
  40ae12:	66 0f ef ff          	pxor   %xmm7,%xmm7
  40ae16:	66 0f ef d2          	pxor   %xmm2,%xmm2
  40ae1a:	66 41 0f 6f 19       	movdqa (%r9),%xmm3
  40ae1f:	66 41 0f 6f c1       	movdqa %xmm9,%xmm0
  40ae24:	66 44 0f 6f c2       	movdqa %xmm2,%xmm8
  40ae29:	49 83 c3 01          	add    $0x1,%r11
  40ae2d:	66 0f 64 c3          	pcmpgtb %xmm3,%xmm0
  40ae31:	66 0f 6f e3          	movdqa %xmm3,%xmm4
  40ae35:	49 83 c1 10          	add    $0x10,%r9
  40ae39:	4c 39 df             	cmp    %r11,%rdi
  40ae3c:	66 0f 60 e0          	punpcklbw %xmm0,%xmm4
  40ae40:	66 0f 68 d8          	punpckhbw %xmm0,%xmm3
  40ae44:	66 0f 6f c7          	movdqa %xmm7,%xmm0
  40ae48:	66 0f 6f ec          	movdqa %xmm4,%xmm5
  40ae4c:	66 0f 65 c4          	pcmpgtw %xmm4,%xmm0
  40ae50:	66 0f 6f f4          	movdqa %xmm4,%xmm6
  40ae54:	66 0f 6f e3          	movdqa %xmm3,%xmm4
  40ae58:	66 0f 61 f0          	punpcklwd %xmm0,%xmm6
  40ae5c:	66 0f 69 e8          	punpckhwd %xmm0,%xmm5
  40ae60:	66 0f 6f c7          	movdqa %xmm7,%xmm0
  40ae64:	66 0f 65 c3          	pcmpgtw %xmm3,%xmm0
  40ae68:	66 44 0f 66 c6       	pcmpgtd %xmm6,%xmm8
  40ae6d:	66 44 0f 6f d5       	movdqa %xmm5,%xmm10
  40ae72:	66 0f 61 e0          	punpcklwd %xmm0,%xmm4
  40ae76:	66 0f 69 d8          	punpckhwd %xmm0,%xmm3
  40ae7a:	66 0f 6f c6          	movdqa %xmm6,%xmm0
  40ae7e:	66 41 0f 62 f0       	punpckldq %xmm8,%xmm6
  40ae83:	66 41 0f 6a c0       	punpckhdq %xmm8,%xmm0
  40ae88:	66 0f eb c6          	por    %xmm6,%xmm0
  40ae8c:	66 0f 6f f2          	movdqa %xmm2,%xmm6
  40ae90:	66 0f 66 f5          	pcmpgtd %xmm5,%xmm6
  40ae94:	66 44 0f 62 d6       	punpckldq %xmm6,%xmm10
  40ae99:	66 0f 6a ee          	punpckhdq %xmm6,%xmm5
  40ae9d:	66 0f 6f f4          	movdqa %xmm4,%xmm6
  40aea1:	66 41 0f eb c2       	por    %xmm10,%xmm0
  40aea6:	66 0f eb c5          	por    %xmm5,%xmm0
  40aeaa:	66 0f 6f ea          	movdqa %xmm2,%xmm5
  40aeae:	66 0f 66 ec          	pcmpgtd %xmm4,%xmm5
  40aeb2:	66 0f 62 f5          	punpckldq %xmm5,%xmm6
  40aeb6:	66 0f 6a e5          	punpckhdq %xmm5,%xmm4
  40aeba:	66 0f 6f eb          	movdqa %xmm3,%xmm5
  40aebe:	66 0f eb c6          	por    %xmm6,%xmm0
  40aec2:	66 0f eb c4          	por    %xmm4,%xmm0
  40aec6:	66 0f 6f e2          	movdqa %xmm2,%xmm4
  40aeca:	66 0f 66 e3          	pcmpgtd %xmm3,%xmm4
  40aece:	66 0f 62 ec          	punpckldq %xmm4,%xmm5
  40aed2:	66 0f 6a dc          	punpckhdq %xmm4,%xmm3
  40aed6:	66 0f eb c5          	por    %xmm5,%xmm0
  40aeda:	66 0f eb c3          	por    %xmm3,%xmm0
  40aede:	66 0f eb c8          	por    %xmm0,%xmm1
  40aee2:	0f 87 32 ff ff ff    	ja     40ae1a <_ZN11__sanitizer11mem_is_zeroEPKcm+0x1ea>
  40aee8:	66 0f 6f d1          	movdqa %xmm1,%xmm2
  40aeec:	48 01 ca             	add    %rcx,%rdx
  40aeef:	66 0f 73 da 08       	psrldq $0x8,%xmm2
  40aef4:	66 0f eb ca          	por    %xmm2,%xmm1
  40aef8:	66 0f d6 4c 24 08    	movq   %xmm1,0x8(%rsp)
  40aefe:	48 0b 44 24 08       	or     0x8(%rsp),%rax
  40af03:	49 39 c8             	cmp    %rcx,%r8
  40af06:	0f 84 0d 01 00 00    	je     40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
  40af0c:	48 0f be 0a          	movsbq (%rdx),%rcx
  40af10:	48 09 c8             	or     %rcx,%rax
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40af13:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  40af17:	48 39 ce             	cmp    %rcx,%rsi
  40af1a:	0f 86 f9 00 00 00    	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
      all |= *mem;
  40af20:	48 0f be 4a 01       	movsbq 0x1(%rdx),%rcx
  40af25:	48 09 c8             	or     %rcx,%rax
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40af28:	48 8d 4a 02          	lea    0x2(%rdx),%rcx
  40af2c:	48 39 ce             	cmp    %rcx,%rsi
  40af2f:	0f 86 e4 00 00 00    	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
      all |= *mem;
  40af35:	48 0f be 4a 02       	movsbq 0x2(%rdx),%rcx
  40af3a:	48 09 c8             	or     %rcx,%rax
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40af3d:	48 8d 4a 03          	lea    0x3(%rdx),%rcx
  40af41:	48 39 ce             	cmp    %rcx,%rsi
  40af44:	0f 86 cf 00 00 00    	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
      all |= *mem;
  40af4a:	48 0f be 4a 03       	movsbq 0x3(%rdx),%rcx
  40af4f:	48 09 c8             	or     %rcx,%rax
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40af52:	48 8d 4a 04          	lea    0x4(%rdx),%rcx
  40af56:	48 39 ce             	cmp    %rcx,%rsi
  40af59:	0f 86 ba 00 00 00    	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
      all |= *mem;
  40af5f:	48 0f be 4a 04       	movsbq 0x4(%rdx),%rcx
  40af64:	48 09 c8             	or     %rcx,%rax
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40af67:	48 8d 4a 05          	lea    0x5(%rdx),%rcx
  40af6b:	48 39 ce             	cmp    %rcx,%rsi
  40af6e:	0f 86 a5 00 00 00    	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
      all |= *mem;
  40af74:	48 0f be 4a 05       	movsbq 0x5(%rdx),%rcx
  40af79:	48 09 c8             	or     %rcx,%rax
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40af7c:	48 8d 4a 06          	lea    0x6(%rdx),%rcx
  40af80:	48 39 ce             	cmp    %rcx,%rsi
  40af83:	0f 86 90 00 00 00    	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
      all |= *mem;
  40af89:	48 0f be 4a 06       	movsbq 0x6(%rdx),%rcx
  40af8e:	48 09 c8             	or     %rcx,%rax
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40af91:	48 8d 4a 07          	lea    0x7(%rdx),%rcx
  40af95:	48 39 ce             	cmp    %rcx,%rsi
  40af98:	76 7f                	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
      all |= *mem;
  40af9a:	48 0f be 4a 07       	movsbq 0x7(%rdx),%rcx
  40af9f:	48 09 c8             	or     %rcx,%rax
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40afa2:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  40afa6:	48 39 ce             	cmp    %rcx,%rsi
  40afa9:	76 6e                	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
      all |= *mem;
  40afab:	48 0f be 4a 08       	movsbq 0x8(%rdx),%rcx
  40afb0:	48 09 c8             	or     %rcx,%rax
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40afb3:	48 8d 4a 09          	lea    0x9(%rdx),%rcx
  40afb7:	48 39 ce             	cmp    %rcx,%rsi
  40afba:	76 5d                	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
      all |= *mem;
  40afbc:	48 0f be 4a 09       	movsbq 0x9(%rdx),%rcx
  40afc1:	48 09 c8             	or     %rcx,%rax
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40afc4:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  40afc8:	48 39 ce             	cmp    %rcx,%rsi
  40afcb:	76 4c                	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
      all |= *mem;
  40afcd:	48 0f be 4a 0a       	movsbq 0xa(%rdx),%rcx
  40afd2:	48 09 c8             	or     %rcx,%rax
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40afd5:	48 8d 4a 0b          	lea    0xb(%rdx),%rcx
  40afd9:	48 39 ce             	cmp    %rcx,%rsi
  40afdc:	76 3b                	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
      all |= *mem;
  40afde:	48 0f be 4a 0b       	movsbq 0xb(%rdx),%rcx
  40afe3:	48 09 c8             	or     %rcx,%rax
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40afe6:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  40afea:	48 39 ce             	cmp    %rcx,%rsi
  40afed:	76 2a                	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
      all |= *mem;
  40afef:	48 0f be 4a 0c       	movsbq 0xc(%rdx),%rcx
  40aff4:	48 09 c8             	or     %rcx,%rax
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40aff7:	48 8d 4a 0d          	lea    0xd(%rdx),%rcx
  40affb:	48 39 ce             	cmp    %rcx,%rsi
  40affe:	76 19                	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
      all |= *mem;
  40b000:	48 0f be 4a 0d       	movsbq 0xd(%rdx),%rcx
  40b005:	48 09 c8             	or     %rcx,%rax
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40b008:	48 8d 4a 0e          	lea    0xe(%rdx),%rcx
  40b00c:	48 39 ce             	cmp    %rcx,%rsi
  40b00f:	76 08                	jbe    40b019 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x3e9>
      all |= *mem;
  40b011:	48 0f be 52 0e       	movsbq 0xe(%rdx),%rdx
  40b016:	48 09 d0             	or     %rdx,%rax
  return all == 0;
  40b019:	48 85 c0             	test   %rax,%rax
  40b01c:	0f 94 c0             	sete   %al
}
  40b01f:	48 83 c4 18          	add    $0x18,%rsp
  40b023:	5b                   	pop    %rbx
  40b024:	5d                   	pop    %rbp
  40b025:	c3                   	retq   
  40b026:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40b02d:	00 00 00 
  40b030:	4d 39 d9             	cmp    %r11,%r9
  40b033:	0f 82 9e fc ff ff    	jb     40acd7 <_ZN11__sanitizer11mem_is_zeroEPKcm+0xa7>
  40b039:	4d 85 c0             	test   %r8,%r8
  40b03c:	0f 85 98 fc ff ff    	jne    40acda <_ZN11__sanitizer11mem_is_zeroEPKcm+0xaa>
  uptr all = 0;
  // Prologue.
  for (const char *mem = beg; mem < (char*)aligned_beg && mem < end; mem++)
    all |= *mem;
  // Aligned loop.
  for (; aligned_beg < aligned_end; aligned_beg++)
  40b042:	45 31 c0             	xor    %r8d,%r8d
  40b045:	49 89 ca             	mov    %rcx,%r10
  40b048:	e9 ed fc ff ff       	jmpq   40ad3a <_ZN11__sanitizer11mem_is_zeroEPKcm+0x10a>
  40b04d:	0f 1f 00             	nopl   (%rax)
    all |= *aligned_beg;
  // Epilogue.
  if ((char*)aligned_end >= beg)
    for (const char *mem = (char*)aligned_end; mem < end; mem++)
  40b050:	4c 89 ca             	mov    %r9,%rdx
  40b053:	e9 91 fd ff ff       	jmpq   40ade9 <_ZN11__sanitizer11mem_is_zeroEPKcm+0x1b9>
  40b058:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b05f:	00 
bool mem_is_zero(const char *beg, uptr size) {
  CHECK_LE(size, 1ULL << FIRST_32_SECOND_64(30, 40));  // Sanity check.
  const char *end = beg + size;
  uptr *aligned_beg = (uptr *)RoundUpTo((uptr)beg, sizeof(uptr));
  uptr *aligned_end = (uptr *)RoundDownTo((uptr)end, sizeof(uptr));
  uptr all = 0;
  40b060:	31 c0                	xor    %eax,%eax
  40b062:	e9 26 fc ff ff       	jmpq   40ac8d <_ZN11__sanitizer11mem_is_zeroEPKcm+0x5d>
    return (res > INT64_MAX) ? INT64_MIN : ((s64)res * -1);
  }
}

bool mem_is_zero(const char *beg, uptr size) {
  CHECK_LE(size, 1ULL << FIRST_32_SECOND_64(30, 40));  // Sanity check.
  40b067:	48 8d 15 2c db 00 00 	lea    0xdb2c(%rip),%rdx        # 418b9a <.LC3>
  40b06e:	48 8d 3d 43 bf 00 00 	lea    0xbf43(%rip),%rdi        # 416fb8 <.LC1>
  40b075:	48 89 f1             	mov    %rsi,%rcx
  40b078:	be f5 00 00 00       	mov    $0xf5,%esi
  40b07d:	e8 6e a3 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40b082:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40b089:	1f 84 00 00 00 00 00 

000000000040b090 <_ZN11__sanitizer9LibIgnoreC1E17LinkerInitialized>:
#include "sanitizer_posix.h"
#include "sanitizer_procmaps.h"

namespace __sanitizer {

LibIgnore::LibIgnore(LinkerInitialized) {
  40b090:	48 81 c7 08 08 00 00 	add    $0x808,%rdi
  40b097:	e9 04 08 00 00       	jmpq   40b8a0 <_ZN11__sanitizer13BlockingMutexC1Ev>
  40b09c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040b0a0 <_ZN11__sanitizer9LibIgnore17AddIgnoredLibraryEPKc>:
}

void LibIgnore::AddIgnoredLibrary(const char *name_templ) {
  40b0a0:	41 55                	push   %r13
  40b0a2:	49 89 f5             	mov    %rsi,%r13
  40b0a5:	41 54                	push   %r12
  BlockingMutexLock lock(&mutex_);
  40b0a7:	4c 8d a7 08 08 00 00 	lea    0x808(%rdi),%r12
namespace __sanitizer {

LibIgnore::LibIgnore(LinkerInitialized) {
}

void LibIgnore::AddIgnoredLibrary(const char *name_templ) {
  40b0ae:	55                   	push   %rbp
  40b0af:	53                   	push   %rbx
  40b0b0:	48 89 fb             	mov    %rdi,%rbx
template<typename MutexType>
class GenericScopedLock {
 public:
  explicit GenericScopedLock(MutexType *mu)
      : mu_(mu) {
    mu_->Lock();
  40b0b3:	4c 89 e7             	mov    %r12,%rdi
  40b0b6:	48 83 ec 08          	sub    $0x8,%rsp
  40b0ba:	e8 f1 07 00 00       	callq  40b8b0 <_ZN11__sanitizer13BlockingMutex4LockEv>
  BlockingMutexLock lock(&mutex_);
  if (count_ >= kMaxLibs) {
  40b0bf:	48 8b 83 60 08 00 00 	mov    0x860(%rbx),%rax
  40b0c6:	48 83 f8 7f          	cmp    $0x7f,%rax
  40b0ca:	77 48                	ja     40b114 <_ZN11__sanitizer9LibIgnore17AddIgnoredLibraryEPKc+0x74>
    Report("%s: too many ignored libraries (max: %d)\n", SanitizerToolName,
           kMaxLibs);
    Die();
  }
  Lib *lib = &libs_[count_++];
  40b0cc:	48 8d 50 01          	lea    0x1(%rax),%rdx
  40b0d0:	48 83 c0 43          	add    $0x43,%rax
  lib->templ = internal_strdup(name_templ);
  40b0d4:	4c 89 ef             	mov    %r13,%rdi
  if (count_ >= kMaxLibs) {
    Report("%s: too many ignored libraries (max: %d)\n", SanitizerToolName,
           kMaxLibs);
    Die();
  }
  Lib *lib = &libs_[count_++];
  40b0d7:	48 c1 e0 05          	shl    $0x5,%rax
  40b0db:	48 89 93 60 08 00 00 	mov    %rdx,0x860(%rbx)
  40b0e2:	48 01 c3             	add    %rax,%rbx
  lib->templ = internal_strdup(name_templ);
  40b0e5:	e8 d6 f2 ff ff       	callq  40a3c0 <_ZN11__sanitizer15internal_strdupEPKc>
  lib->name = nullptr;
  40b0ea:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  40b0f1:	00 
    Report("%s: too many ignored libraries (max: %d)\n", SanitizerToolName,
           kMaxLibs);
    Die();
  }
  Lib *lib = &libs_[count_++];
  lib->templ = internal_strdup(name_templ);
  40b0f2:	48 89 43 08          	mov    %rax,0x8(%rbx)
  }

  ~GenericScopedLock() {
    mu_->Unlock();
  40b0f6:	4c 89 e7             	mov    %r12,%rdi
  lib->name = nullptr;
  lib->real_name = nullptr;
  40b0f9:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
  40b100:	00 
  lib->loaded = false;
  40b101:	c6 43 20 00          	movb   $0x0,0x20(%rbx)
}
  40b105:	48 83 c4 08          	add    $0x8,%rsp
  40b109:	5b                   	pop    %rbx
  40b10a:	5d                   	pop    %rbp
  40b10b:	41 5c                	pop    %r12
  40b10d:	41 5d                	pop    %r13
  40b10f:	e9 0c 08 00 00       	jmpq   40b920 <_ZN11__sanitizer13BlockingMutex6UnlockEv>

void LibIgnore::AddIgnoredLibrary(const char *name_templ) {
  BlockingMutexLock lock(&mutex_);
  if (count_ >= kMaxLibs) {
    Report("%s: too many ignored libraries (max: %d)\n", SanitizerToolName,
           kMaxLibs);
  40b114:	48 8b 05 95 31 01 00 	mov    0x13195(%rip),%rax        # 41e2b0 <_DYNAMIC+0x2b0>
  40b11b:	48 8d 3d 06 bf 00 00 	lea    0xbf06(%rip),%rdi        # 417028 <.LC0>
  40b122:	ba 80 00 00 00       	mov    $0x80,%edx
  40b127:	48 8b 30             	mov    (%rax),%rsi
  40b12a:	31 c0                	xor    %eax,%eax
  40b12c:	e8 5f 29 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
    Die();
  40b131:	e8 2a a1 ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  40b136:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40b13d:	00 00 00 

000000000040b140 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc>:
  lib->name = nullptr;
  lib->real_name = nullptr;
  lib->loaded = false;
}

void LibIgnore::OnLibraryLoaded(const char *name) {
  40b140:	41 57                	push   %r15
  40b142:	48 89 f8             	mov    %rdi,%rax
  BlockingMutexLock lock(&mutex_);
  40b145:	48 05 08 08 00 00    	add    $0x808,%rax
  lib->name = nullptr;
  lib->real_name = nullptr;
  lib->loaded = false;
}

void LibIgnore::OnLibraryLoaded(const char *name) {
  40b14b:	41 56                	push   %r14
  40b14d:	41 55                	push   %r13
  40b14f:	41 54                	push   %r12
  40b151:	49 89 f4             	mov    %rsi,%r12
  40b154:	55                   	push   %rbp
  40b155:	53                   	push   %rbx
  40b156:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
  40b15d:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
template<typename MutexType>
class GenericScopedLock {
 public:
  explicit GenericScopedLock(MutexType *mu)
      : mu_(mu) {
    mu_->Lock();
  40b162:	48 89 c7             	mov    %rax,%rdi
  BlockingMutexLock lock(&mutex_);
  40b165:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
  40b16a:	e8 41 07 00 00       	callq  40b8b0 <_ZN11__sanitizer13BlockingMutex4LockEv>
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  40b16f:	48 8d 35 03 d4 00 00 	lea    0xd403(%rip),%rsi        # 418579 <.LC1>
  40b176:	bf 00 10 00 00       	mov    $0x1000,%edi
  40b17b:	e8 20 12 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  // Try to match suppressions with symlink target.
  InternalScopedString buf(kMaxPathLength);
  if (name && internal_readlink(name, buf.data(), buf.size() - 1) > 0 &&
  40b180:	4d 85 e4             	test   %r12,%r12
  40b183:	48 89 44 24 30       	mov    %rax,0x30(%rsp)

class InternalScopedString : public InternalScopedBuffer<char> {
 public:
  explicit InternalScopedString(uptr max_length)
      : InternalScopedBuffer<char>(max_length), length_(0) {
    (*this)[0] = '\0';
  40b188:	c6 00 00             	movb   $0x0,(%rax)
  40b18b:	74 59                	je     40b1e6 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0xa6>
  40b18d:	ba ff 0f 00 00       	mov    $0xfff,%edx
  40b192:	48 89 c6             	mov    %rax,%rsi
  40b195:	4c 89 e7             	mov    %r12,%rdi
  40b198:	e8 53 04 00 00       	callq  40b5f0 <_ZN11__sanitizer17internal_readlinkEPKcPcm>
  40b19d:	48 85 c0             	test   %rax,%rax
  40b1a0:	74 44                	je     40b1e6 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0xa6>
  40b1a2:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  40b1a7:	80 38 00             	cmpb   $0x0,(%rax)
  40b1aa:	74 3a                	je     40b1e6 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0xa6>
  40b1ac:	4c 8b 6c 24 28       	mov    0x28(%rsp),%r13
      buf[0]) {
    for (uptr i = 0; i < count_; i++) {
  40b1b1:	31 ed                	xor    %ebp,%ebp
  40b1b3:	49 8b 85 60 08 00 00 	mov    0x860(%r13),%rax
  40b1ba:	4c 89 eb             	mov    %r13,%rbx
  40b1bd:	48 85 c0             	test   %rax,%rax
  40b1c0:	74 24                	je     40b1e6 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0xa6>
      Lib *lib = &libs_[i];
      if (!lib->loaded && (!lib->real_name) &&
  40b1c2:	80 bb 80 08 00 00 00 	cmpb   $0x0,0x880(%rbx)
  40b1c9:	75 0e                	jne    40b1d9 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x99>
  40b1cb:	48 83 bb 78 08 00 00 	cmpq   $0x0,0x878(%rbx)
  40b1d2:	00 
  40b1d3:	0f 84 fb 01 00 00    	je     40b3d4 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x294>
  BlockingMutexLock lock(&mutex_);
  // Try to match suppressions with symlink target.
  InternalScopedString buf(kMaxPathLength);
  if (name && internal_readlink(name, buf.data(), buf.size() - 1) > 0 &&
      buf[0]) {
    for (uptr i = 0; i < count_; i++) {
  40b1d9:	48 83 c5 01          	add    $0x1,%rbp
  40b1dd:	48 83 c3 20          	add    $0x20,%rbx
  40b1e1:	48 39 e8             	cmp    %rbp,%rax
  40b1e4:	77 dc                	ja     40b1c2 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x82>
        lib->real_name = internal_strdup(buf.data());
    }
  }

  // Scan suppressions list and find newly loaded and unloaded libraries.
  MemoryMappingLayout proc_maps(/*cache_enabled*/false);
  40b1e6:	48 8d ac 24 80 00 00 	lea    0x80(%rsp),%rbp
  40b1ed:	00 
  40b1ee:	31 f6                	xor    %esi,%esi
  40b1f0:	48 89 ef             	mov    %rbp,%rdi
  40b1f3:	e8 18 2b 00 00       	callq  40dd10 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb>
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  40b1f8:	48 8d 35 7a d3 00 00 	lea    0xd37a(%rip),%rsi        # 418579 <.LC1>
  40b1ff:	bf 00 10 00 00       	mov    $0x1000,%edi
  40b204:	e8 97 11 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  40b209:	48 89 c3             	mov    %rax,%rbx

class InternalScopedString : public InternalScopedBuffer<char> {
 public:
  explicit InternalScopedString(uptr max_length)
      : InternalScopedBuffer<char>(max_length), length_(0) {
    (*this)[0] = '\0';
  40b20c:	c6 00 00             	movb   $0x0,(%rax)
  InternalScopedString module(kMaxPathLength);
  for (uptr i = 0; i < count_; i++) {
  40b20f:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  40b214:	48 83 b8 60 08 00 00 	cmpq   $0x0,0x860(%rax)
  40b21b:	00 
  40b21c:	0f 84 a0 00 00 00    	je     40b2c2 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x182>
  40b222:	48 05 68 08 00 00    	add    $0x868,%rax
  40b228:	4c 8d 74 24 60       	lea    0x60(%rsp),%r14
  40b22d:	4c 8d 6c 24 50       	lea    0x50(%rsp),%r13
  40b232:	4c 8d 7c 24 40       	lea    0x40(%rsp),%r15
  40b237:	4c 8d 64 24 70       	lea    0x70(%rsp),%r12
  40b23c:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40b241:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
  40b248:	00 00 
  40b24a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    Lib *lib = &libs_[i];
    bool loaded = false;
    proc_maps.Reset();
  40b250:	48 89 ef             	mov    %rbp,%rdi
  40b253:	e8 78 2c 00 00       	callq  40ded0 <_ZN11__sanitizer19MemoryMappingLayout5ResetEv>
  // Scan suppressions list and find newly loaded and unloaded libraries.
  MemoryMappingLayout proc_maps(/*cache_enabled*/false);
  InternalScopedString module(kMaxPathLength);
  for (uptr i = 0; i < count_; i++) {
    Lib *lib = &libs_[i];
    bool loaded = false;
  40b258:	c6 44 24 1f 00       	movb   $0x0,0x1f(%rsp)
    proc_maps.Reset();
    uptr b, e, off, prot;
    while (proc_maps.Next(&b, &e, &off, module.data(), module.size(), &prot)) {
  40b25d:	eb 0c                	jmp    40b26b <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x12b>
  40b25f:	90                   	nop
      if ((prot & MemoryMappingLayout::kProtectionExecute) == 0)
  40b260:	f6 44 24 70 04       	testb  $0x4,0x70(%rsp)
  40b265:	0f 85 9d 00 00 00    	jne    40b308 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x1c8>
  for (uptr i = 0; i < count_; i++) {
    Lib *lib = &libs_[i];
    bool loaded = false;
    proc_maps.Reset();
    uptr b, e, off, prot;
    while (proc_maps.Next(&b, &e, &off, module.data(), module.size(), &prot)) {
  40b26b:	4c 89 24 24          	mov    %r12,(%rsp)
  40b26f:	41 b9 00 10 00 00    	mov    $0x1000,%r9d
  40b275:	49 89 d8             	mov    %rbx,%r8
  40b278:	4c 89 f1             	mov    %r14,%rcx
  40b27b:	4c 89 ea             	mov    %r13,%rdx
  40b27e:	4c 89 fe             	mov    %r15,%rsi
  40b281:	48 89 ef             	mov    %rbp,%rdi
  40b284:	e8 d7 31 00 00       	callq  40e460 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_>
  40b289:	84 c0                	test   %al,%al
  40b28b:	75 d3                	jne    40b260 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x120>
        code_ranges_[idx].begin = b;
        code_ranges_[idx].end = e;
        atomic_store(&loaded_count_, idx + 1, memory_order_release);
      }
    }
    if (lib->loaded && !loaded) {
  40b28d:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  40b292:	80 78 18 00          	cmpb   $0x0,0x18(%rax)
  40b296:	74 0b                	je     40b2a3 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x163>
  40b298:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%rsp)
  40b29d:	0f 84 6d 01 00 00    	je     40b410 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x2d0>
  }

  // Scan suppressions list and find newly loaded and unloaded libraries.
  MemoryMappingLayout proc_maps(/*cache_enabled*/false);
  InternalScopedString module(kMaxPathLength);
  for (uptr i = 0; i < count_; i++) {
  40b2a3:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  40b2a8:	48 83 44 24 20 01    	addq   $0x1,0x20(%rsp)
  40b2ae:	48 83 44 24 10 20    	addq   $0x20,0x10(%rsp)
  40b2b4:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
  40b2b9:	48 39 88 60 08 00 00 	cmp    %rcx,0x860(%rax)
  40b2c0:	77 8e                	ja     40b250 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x110>
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  }
  ~InternalScopedBuffer() {
    UnmapOrDie(ptr_, cnt_ * sizeof(T));
  40b2c2:	be 00 10 00 00       	mov    $0x1000,%esi
  40b2c7:	48 89 df             	mov    %rbx,%rdi
  40b2ca:	e8 71 11 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
        lib->real_name = internal_strdup(buf.data());
    }
  }

  // Scan suppressions list and find newly loaded and unloaded libraries.
  MemoryMappingLayout proc_maps(/*cache_enabled*/false);
  40b2cf:	48 89 ef             	mov    %rbp,%rdi
  40b2d2:	e8 c9 2b 00 00       	callq  40dea0 <_ZN11__sanitizer19MemoryMappingLayoutD1Ev>
  40b2d7:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
  40b2dc:	be 00 10 00 00       	mov    $0x1000,%esi
  40b2e1:	e8 5a 11 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  }

  ~GenericScopedLock() {
    mu_->Unlock();
  40b2e6:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
  40b2eb:	e8 30 06 00 00       	callq  40b920 <_ZN11__sanitizer13BlockingMutex6UnlockEv>
             " suppression '%s' is unloaded\n",
             SanitizerToolName, lib->name, lib->templ);
      Die();
    }
  }
}
  40b2f0:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
  40b2f7:	5b                   	pop    %rbx
  40b2f8:	5d                   	pop    %rbp
  40b2f9:	41 5c                	pop    %r12
  40b2fb:	41 5d                	pop    %r13
  40b2fd:	41 5e                	pop    %r14
  40b2ff:	41 5f                	pop    %r15
  40b301:	c3                   	retq   
  40b302:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    proc_maps.Reset();
    uptr b, e, off, prot;
    while (proc_maps.Next(&b, &e, &off, module.data(), module.size(), &prot)) {
      if ((prot & MemoryMappingLayout::kProtectionExecute) == 0)
        continue;
      if (TemplateMatch(lib->templ, module.data()) ||
  40b308:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  40b30d:	48 89 de             	mov    %rbx,%rsi
  40b310:	48 8b 38             	mov    (%rax),%rdi
  40b313:	e8 98 a8 ff ff       	callq  405bb0 <_ZN11__sanitizer13TemplateMatchEPKcS1_>
  40b318:	84 c0                	test   %al,%al
  40b31a:	75 22                	jne    40b33e <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x1fe>
  40b31c:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  40b321:	48 8b 78 10          	mov    0x10(%rax),%rdi
  40b325:	48 85 ff             	test   %rdi,%rdi
  40b328:	0f 84 3d ff ff ff    	je     40b26b <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x12b>
          (lib->real_name &&
          internal_strcmp(lib->real_name, module.data()) == 0)) {
  40b32e:	48 89 de             	mov    %rbx,%rsi
  40b331:	e8 aa f4 ff ff       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
    uptr b, e, off, prot;
    while (proc_maps.Next(&b, &e, &off, module.data(), module.size(), &prot)) {
      if ((prot & MemoryMappingLayout::kProtectionExecute) == 0)
        continue;
      if (TemplateMatch(lib->templ, module.data()) ||
          (lib->real_name &&
  40b336:	85 c0                	test   %eax,%eax
  40b338:	0f 85 2d ff ff ff    	jne    40b26b <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x12b>
          internal_strcmp(lib->real_name, module.data()) == 0)) {
        if (loaded) {
  40b33e:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%rsp)
  40b343:	0f 85 eb 00 00 00    	jne    40b434 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x2f4>
                 " 2 libraries: '%s' and '%s'\n",
                 SanitizerToolName, lib->templ, lib->name, module.data());
          Die();
        }
        loaded = true;
        if (lib->loaded)
  40b349:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
          Report("%s: called_from_lib suppression '%s' is matched against"
                 " 2 libraries: '%s' and '%s'\n",
                 SanitizerToolName, lib->templ, lib->name, module.data());
          Die();
        }
        loaded = true;
  40b34e:	c6 44 24 1f 01       	movb   $0x1,0x1f(%rsp)
        if (lib->loaded)
  40b353:	80 78 18 00          	cmpb   $0x0,0x18(%rax)
  40b357:	0f 85 0e ff ff ff    	jne    40b26b <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x12b>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  40b35d:	48 8b 05 5c 2f 01 00 	mov    0x12f5c(%rip),%rax        # 41e2c0 <_DYNAMIC+0x2c0>
  40b364:	8b 00                	mov    (%rax),%eax
          continue;
        VReport(1,
  40b366:	85 c0                	test   %eax,%eax
  40b368:	75 4f                	jne    40b3b9 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x279>
                "Matched called_from_lib suppression '%s' against library"
                " '%s'\n",
                lib->templ, module.data());
        lib->loaded = true;
  40b36a:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
        lib->name = internal_strdup(module.data());
  40b36f:	48 89 df             	mov    %rbx,%rdi
          continue;
        VReport(1,
                "Matched called_from_lib suppression '%s' against library"
                " '%s'\n",
                lib->templ, module.data());
        lib->loaded = true;
  40b372:	c6 40 18 01          	movb   $0x1,0x18(%rax)
        lib->name = internal_strdup(module.data());
  40b376:	e8 45 f0 ff ff       	callq  40a3c0 <_ZN11__sanitizer15internal_strdupEPKc>
  40b37b:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  40b380:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
        const uptr idx = atomic_load(&loaded_count_, memory_order_relaxed);
        code_ranges_[idx].begin = b;
  40b385:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
        VReport(1,
                "Matched called_from_lib suppression '%s' against library"
                " '%s'\n",
                lib->templ, module.data());
        lib->loaded = true;
        lib->name = internal_strdup(module.data());
  40b38a:	48 89 42 08          	mov    %rax,0x8(%rdx)
  40b38e:	48 8b 06             	mov    (%rsi),%rax
  40b391:	48 89 c2             	mov    %rax,%rdx
        const uptr idx = atomic_load(&loaded_count_, memory_order_relaxed);
        code_ranges_[idx].begin = b;
        code_ranges_[idx].end = e;
        atomic_store(&loaded_count_, idx + 1, memory_order_release);
  40b394:	48 83 c0 01          	add    $0x1,%rax
  40b398:	48 c1 e2 04          	shl    $0x4,%rdx
  40b39c:	48 01 f2             	add    %rsi,%rdx
                " '%s'\n",
                lib->templ, module.data());
        lib->loaded = true;
        lib->name = internal_strdup(module.data());
        const uptr idx = atomic_load(&loaded_count_, memory_order_relaxed);
        code_ranges_[idx].begin = b;
  40b39f:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
        code_ranges_[idx].end = e;
  40b3a3:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
  40b3a8:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  40b3ac:	48 89 06             	mov    %rax,(%rsi)
          Report("%s: called_from_lib suppression '%s' is matched against"
                 " 2 libraries: '%s' and '%s'\n",
                 SanitizerToolName, lib->templ, lib->name, module.data());
          Die();
        }
        loaded = true;
  40b3af:	c6 44 24 1f 01       	movb   $0x1,0x1f(%rsp)
  40b3b4:	e9 b2 fe ff ff       	jmpq   40b26b <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x12b>
        if (lib->loaded)
          continue;
        VReport(1,
  40b3b9:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  40b3be:	48 8d 3d eb bc 00 00 	lea    0xbceb(%rip),%rdi        # 4170b0 <.LC3>
  40b3c5:	48 89 da             	mov    %rbx,%rdx
  40b3c8:	48 8b 30             	mov    (%rax),%rsi
  40b3cb:	31 c0                	xor    %eax,%eax
  40b3cd:	e8 be 26 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
  40b3d2:	eb 96                	jmp    40b36a <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x22a>
  if (name && internal_readlink(name, buf.data(), buf.size() - 1) > 0 &&
      buf[0]) {
    for (uptr i = 0; i < count_; i++) {
      Lib *lib = &libs_[i];
      if (!lib->loaded && (!lib->real_name) &&
          TemplateMatch(lib->templ, name))
  40b3d4:	48 8b bb 68 08 00 00 	mov    0x868(%rbx),%rdi
  40b3db:	4c 89 e6             	mov    %r12,%rsi
  40b3de:	e8 cd a7 ff ff       	callq  405bb0 <_ZN11__sanitizer13TemplateMatchEPKcS1_>
  InternalScopedString buf(kMaxPathLength);
  if (name && internal_readlink(name, buf.data(), buf.size() - 1) > 0 &&
      buf[0]) {
    for (uptr i = 0; i < count_; i++) {
      Lib *lib = &libs_[i];
      if (!lib->loaded && (!lib->real_name) &&
  40b3e3:	84 c0                	test   %al,%al
  40b3e5:	74 1d                	je     40b404 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x2c4>
          TemplateMatch(lib->templ, name))
        lib->real_name = internal_strdup(buf.data());
  40b3e7:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
  40b3ec:	e8 cf ef ff ff       	callq  40a3c0 <_ZN11__sanitizer15internal_strdupEPKc>
  40b3f1:	48 89 83 78 08 00 00 	mov    %rax,0x878(%rbx)
  40b3f8:	49 8b 85 60 08 00 00 	mov    0x860(%r13),%rax
  40b3ff:	e9 d5 fd ff ff       	jmpq   40b1d9 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x99>
  40b404:	49 8b 85 60 08 00 00 	mov    0x860(%r13),%rax
  40b40b:	e9 c9 fd ff ff       	jmpq   40b1d9 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc+0x99>
      }
    }
    if (lib->loaded && !loaded) {
      Report("%s: library '%s' that was matched against called_from_lib"
             " suppression '%s' is unloaded\n",
             SanitizerToolName, lib->name, lib->templ);
  40b410:	48 8b 50 08          	mov    0x8(%rax),%rdx
  40b414:	48 8b 08             	mov    (%rax),%rcx
  40b417:	48 8d 3d d2 bc 00 00 	lea    0xbcd2(%rip),%rdi        # 4170f0 <.LC4>
  40b41e:	48 8b 05 8b 2e 01 00 	mov    0x12e8b(%rip),%rax        # 41e2b0 <_DYNAMIC+0x2b0>
  40b425:	48 8b 30             	mov    (%rax),%rsi
  40b428:	31 c0                	xor    %eax,%eax
  40b42a:	e8 61 26 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
      Die();
  40b42f:	e8 2c 9e ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
          (lib->real_name &&
          internal_strcmp(lib->real_name, module.data()) == 0)) {
        if (loaded) {
          Report("%s: called_from_lib suppression '%s' is matched against"
                 " 2 libraries: '%s' and '%s'\n",
                 SanitizerToolName, lib->templ, lib->name, module.data());
  40b434:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  40b439:	48 8d 3d 18 bc 00 00 	lea    0xbc18(%rip),%rdi        # 417058 <.LC2>
  40b440:	49 89 d8             	mov    %rbx,%r8
  40b443:	48 8b 48 08          	mov    0x8(%rax),%rcx
  40b447:	48 8b 10             	mov    (%rax),%rdx
  40b44a:	48 8b 05 5f 2e 01 00 	mov    0x12e5f(%rip),%rax        # 41e2b0 <_DYNAMIC+0x2b0>
  40b451:	48 8b 30             	mov    (%rax),%rsi
  40b454:	31 c0                	xor    %eax,%eax
  40b456:	e8 35 26 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
          Die();
  40b45b:	e8 00 9e ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>

000000000040b460 <_ZN11__sanitizer9LibIgnore17OnLibraryUnloadedEv>:
    }
  }
}

void LibIgnore::OnLibraryUnloaded() {
  OnLibraryLoaded(nullptr);
  40b460:	31 f6                	xor    %esi,%esi
  40b462:	e9 d9 fc ff ff       	jmpq   40b140 <_ZN11__sanitizer9LibIgnore15OnLibraryLoadedEPKc>
  40b467:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40b46e:	00 00 

000000000040b470 <_ZN11__sanitizer16internal_iserrorEmPi>:
  if (retval >= (uptr)-4095) {
    if (rverrno)
      *rverrno = -retval;
    return true;
  }
  return false;
  40b470:	31 c0                	xor    %eax,%eax
               "memory", "cc");
  return retval;
}

bool internal_iserror(uptr retval, int *rverrno) {
  if (retval >= (uptr)-4095) {
  40b472:	48 81 ff 00 f0 ff ff 	cmp    $0xfffffffffffff000,%rdi
  40b479:	76 1d                	jbe    40b498 <_ZN11__sanitizer16internal_iserrorEmPi+0x28>
    if (rverrno)
  40b47b:	48 85 f6             	test   %rsi,%rsi
  40b47e:	74 10                	je     40b490 <_ZN11__sanitizer16internal_iserrorEmPi+0x20>
      *rverrno = -retval;
  40b480:	f7 df                	neg    %edi
    return true;
  40b482:	b8 01 00 00 00       	mov    $0x1,%eax
}

bool internal_iserror(uptr retval, int *rverrno) {
  if (retval >= (uptr)-4095) {
    if (rverrno)
      *rverrno = -retval;
  40b487:	89 3e                	mov    %edi,(%rsi)
  40b489:	c3                   	retq   
  40b48a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    return true;
  40b490:	b8 01 00 00 00       	mov    $0x1,%eax
  40b495:	0f 1f 00             	nopl   (%rax)
  }
  return false;
}
  40b498:	f3 c3                	repz retq 
  40b49a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000040b4a0 <_ZN11__sanitizer13internal_mmapEPvmiiiy>:
#include "sanitizer_syscall_generic.inc"
#endif

// --------------- sanitizer_libc.h
uptr internal_mmap(void *addr, uptr length, int prot, int flags, int fd,
                   OFF_T offset) {
  40b4a0:	41 54                	push   %r12
               "mov %6, %%r8;"
               "mov %7, %%r9;"
               "syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3), "r"((u64)arg4), "r"((u64)arg5),
               "r"((u64)arg6) : "rcx", "r11", "r10", "r8", "r9",
               "memory", "cc");
  40b4a2:	48 63 d2             	movslq %edx,%rdx
  40b4a5:	4d 89 cc             	mov    %r9,%r12
  40b4a8:	b8 09 00 00 00       	mov    $0x9,%eax
  40b4ad:	55                   	push   %rbp
  40b4ae:	49 63 e8             	movslq %r8d,%rbp
  40b4b1:	53                   	push   %rbx
  40b4b2:	48 63 d9             	movslq %ecx,%rbx
  40b4b5:	49 89 da             	mov    %rbx,%r10
  40b4b8:	49 89 e8             	mov    %rbp,%r8
  40b4bb:	4d 89 e1             	mov    %r12,%r9
  40b4be:	0f 05                	syscall 
  // mmap2 specifies file offset in 4096-byte units.
  CHECK(IsAligned(offset, 4096));
  return internal_syscall(SYSCALL(mmap2), addr, length, prot, flags, fd,
                          offset / 4096);
#endif
}
  40b4c0:	5b                   	pop    %rbx
  40b4c1:	5d                   	pop    %rbp
  40b4c2:	41 5c                	pop    %r12
  40b4c4:	c3                   	retq   
  40b4c5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  40b4cc:	00 00 00 00 

000000000040b4d0 <_ZN11__sanitizer15internal_munmapEPvm>:

template <typename T1, typename T2>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2) : "rcx", "r11", "memory", "cc");
  40b4d0:	b8 0b 00 00 00       	mov    $0xb,%eax
  40b4d5:	0f 05                	syscall 

uptr internal_munmap(void *addr, uptr length) {
  return internal_syscall(SYSCALL(munmap), (uptr)addr, length);
}
  40b4d7:	c3                   	retq   
  40b4d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b4df:	00 

000000000040b4e0 <_ZN11__sanitizer17internal_mprotectEPvmi>:

template <typename T1, typename T2, typename T3>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3) : "rcx", "r11", "memory", "cc");
  40b4e0:	48 63 d2             	movslq %edx,%rdx
  40b4e3:	b8 0a 00 00 00       	mov    $0xa,%eax
  40b4e8:	0f 05                	syscall 

int internal_mprotect(void *addr, uptr length, int prot) {
  return internal_syscall(SYSCALL(mprotect), (uptr)addr, length, prot);
}
  40b4ea:	c3                   	retq   
  40b4eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000040b4f0 <_ZN11__sanitizer14internal_closeEi>:

template <typename T1>
static uptr internal_syscall(u64 nr, T1 arg1) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1) :
               "rcx", "r11", "memory", "cc");
  40b4f0:	48 63 ff             	movslq %edi,%rdi
  40b4f3:	b8 03 00 00 00       	mov    $0x3,%eax
  40b4f8:	0f 05                	syscall 

uptr internal_close(fd_t fd) {
  return internal_syscall(SYSCALL(close), fd);
}
  40b4fa:	c3                   	retq   
  40b4fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000040b500 <_ZN11__sanitizer13internal_openEPKci>:

template <typename T1, typename T2>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2) : "rcx", "r11", "memory", "cc");
  40b500:	48 63 f6             	movslq %esi,%rsi
  40b503:	b8 02 00 00 00       	mov    $0x2,%eax
  40b508:	0f 05                	syscall 
#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS
  return internal_syscall(SYSCALL(openat), AT_FDCWD, (uptr)filename, flags);
#else
  return internal_syscall(SYSCALL(open), (uptr)filename, flags);
#endif
}
  40b50a:	c3                   	retq   
  40b50b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000040b510 <_ZN11__sanitizer13internal_openEPKcij>:

template <typename T1, typename T2, typename T3>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3) : "rcx", "r11", "memory", "cc");
  40b510:	48 63 f6             	movslq %esi,%rsi
  40b513:	89 d2                	mov    %edx,%edx
  40b515:	b8 02 00 00 00       	mov    $0x2,%eax
  40b51a:	0f 05                	syscall 
  return internal_syscall(SYSCALL(openat), AT_FDCWD, (uptr)filename, flags,
                          mode);
#else
  return internal_syscall(SYSCALL(open), (uptr)filename, flags, mode);
#endif
}
  40b51c:	c3                   	retq   
  40b51d:	0f 1f 00             	nopl   (%rax)

000000000040b520 <_ZN11__sanitizer13internal_readEiPvm>:

uptr internal_read(fd_t fd, void *buf, uptr count) {
  40b520:	48 63 ff             	movslq %edi,%rdi
  40b523:	45 31 c0             	xor    %r8d,%r8d
  40b526:	4c 89 c0             	mov    %r8,%rax
  40b529:	0f 05                	syscall 
               "memory", "cc");
  return retval;
}

bool internal_iserror(uptr retval, int *rverrno) {
  if (retval >= (uptr)-4095) {
  40b52b:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
  40b531:	76 05                	jbe    40b538 <_ZN11__sanitizer13internal_readEiPvm+0x18>
  sptr res;
  HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(read), fd, (uptr)buf,
  40b533:	83 f8 fc             	cmp    $0xfffffffc,%eax
  40b536:	74 ee                	je     40b526 <_ZN11__sanitizer13internal_readEiPvm+0x6>
               count));
  return res;
}
  40b538:	f3 c3                	repz retq 
  40b53a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000040b540 <_ZN11__sanitizer14internal_writeEiPKvm>:

uptr internal_write(fd_t fd, const void *buf, uptr count) {
  40b540:	48 63 ff             	movslq %edi,%rdi

template <typename T1, typename T2, typename T3>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3) : "rcx", "r11", "memory", "cc");
  40b543:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  40b549:	4c 89 c0             	mov    %r8,%rax
  40b54c:	0f 05                	syscall 
               "memory", "cc");
  return retval;
}

bool internal_iserror(uptr retval, int *rverrno) {
  if (retval >= (uptr)-4095) {
  40b54e:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
  40b554:	76 05                	jbe    40b55b <_ZN11__sanitizer14internal_writeEiPKvm+0x1b>
  sptr res;
  HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(write), fd, (uptr)buf,
  40b556:	83 f8 fc             	cmp    $0xfffffffc,%eax
  40b559:	74 ee                	je     40b549 <_ZN11__sanitizer14internal_writeEiPKvm+0x9>
               count));
  return res;
}
  40b55b:	f3 c3                	repz retq 
  40b55d:	0f 1f 00             	nopl   (%rax)

000000000040b560 <_ZN11__sanitizer18internal_ftruncateEim>:

uptr internal_ftruncate(fd_t fd, uptr size) {
  40b560:	48 63 ff             	movslq %edi,%rdi

template <typename T1, typename T2>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2) : "rcx", "r11", "memory", "cc");
  40b563:	ba 4d 00 00 00       	mov    $0x4d,%edx
  40b568:	48 89 d0             	mov    %rdx,%rax
  40b56b:	0f 05                	syscall 
               "memory", "cc");
  return retval;
}

bool internal_iserror(uptr retval, int *rverrno) {
  if (retval >= (uptr)-4095) {
  40b56d:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
  40b573:	76 05                	jbe    40b57a <_ZN11__sanitizer18internal_ftruncateEim+0x1a>
  sptr res;
  HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(ftruncate), fd,
  40b575:	83 f8 fc             	cmp    $0xfffffffc,%eax
  40b578:	74 ee                	je     40b568 <_ZN11__sanitizer18internal_ftruncateEim+0x8>
               (OFF_T)size));
  return res;
}
  40b57a:	f3 c3                	repz retq 
  40b57c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040b580 <_ZN11__sanitizer13internal_statEPKcPv>:

template <typename T1, typename T2>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2) : "rcx", "r11", "memory", "cc");
  40b580:	b8 04 00 00 00       	mov    $0x4,%eax
  40b585:	0f 05                	syscall 
  struct stat64 buf64;
  int res = internal_syscall(SYSCALL(stat64), path, &buf64);
  stat64_to_stat(&buf64, (struct stat *)buf);
  return res;
#endif
}
  40b587:	c3                   	retq   
  40b588:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b58f:	00 

000000000040b590 <_ZN11__sanitizer14internal_lstatEPKcPv>:
  40b590:	b8 06 00 00 00       	mov    $0x6,%eax
  40b595:	0f 05                	syscall 
  struct stat64 buf64;
  int res = internal_syscall(SYSCALL(lstat64), path, &buf64);
  stat64_to_stat(&buf64, (struct stat *)buf);
  return res;
#endif
}
  40b597:	c3                   	retq   
  40b598:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b59f:	00 

000000000040b5a0 <_ZN11__sanitizer14internal_fstatEiPv>:
  40b5a0:	48 63 ff             	movslq %edi,%rdi
  40b5a3:	b8 05 00 00 00       	mov    $0x5,%eax
  40b5a8:	0f 05                	syscall 
  struct stat64 buf64;
  int res = internal_syscall(SYSCALL(fstat64), fd, &buf64);
  stat64_to_stat(&buf64, (struct stat *)buf);
  return res;
#endif
}
  40b5aa:	c3                   	retq   
  40b5ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000040b5b0 <_ZN11__sanitizer17internal_filesizeEi>:

uptr internal_filesize(fd_t fd) {
  40b5b0:	48 83 ec 20          	sub    $0x20,%rsp
  40b5b4:	48 63 ff             	movslq %edi,%rdi
  40b5b7:	b8 05 00 00 00       	mov    $0x5,%eax
#endif
}

uptr internal_fstat(fd_t fd, void *buf) {
#if SANITIZER_FREEBSD || SANITIZER_LINUX_USES_64BIT_SYSCALLS
  return internal_syscall(SYSCALL(fstat), fd, (uptr)buf);
  40b5bc:	48 8d 74 24 88       	lea    -0x78(%rsp),%rsi
  40b5c1:	0f 05                	syscall 

uptr internal_filesize(fd_t fd) {
  struct stat st;
  if (internal_fstat(fd, &st))
    return -1;
  return (uptr)st.st_size;
  40b5c3:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  40b5ca:	48 85 c0             	test   %rax,%rax
  40b5cd:	48 0f 44 54 24 b8    	cmove  -0x48(%rsp),%rdx
}
  40b5d3:	48 83 c4 20          	add    $0x20,%rsp
  40b5d7:	48 89 d0             	mov    %rdx,%rax
  40b5da:	c3                   	retq   
  40b5db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000040b5e0 <_ZN11__sanitizer13internal_dup2Eii>:
  40b5e0:	48 63 ff             	movslq %edi,%rdi
  40b5e3:	48 63 f6             	movslq %esi,%rsi
  40b5e6:	b8 21 00 00 00       	mov    $0x21,%eax
  40b5eb:	0f 05                	syscall 
#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS
  return internal_syscall(SYSCALL(dup3), oldfd, newfd, 0);
#else
  return internal_syscall(SYSCALL(dup2), oldfd, newfd);
#endif
}
  40b5ed:	c3                   	retq   
  40b5ee:	66 90                	xchg   %ax,%ax

000000000040b5f0 <_ZN11__sanitizer17internal_readlinkEPKcPcm>:

template <typename T1, typename T2, typename T3>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3) : "rcx", "r11", "memory", "cc");
  40b5f0:	b8 59 00 00 00       	mov    $0x59,%eax
  40b5f5:	0f 05                	syscall 
  return internal_syscall(SYSCALL(readlinkat), AT_FDCWD,
                          (uptr)path, (uptr)buf, bufsize);
#else
  return internal_syscall(SYSCALL(readlink), (uptr)path, (uptr)buf, bufsize);
#endif
}
  40b5f7:	c3                   	retq   
  40b5f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b5ff:	00 

000000000040b600 <_ZN11__sanitizer15internal_unlinkEPKc>:

template <typename T1>
static uptr internal_syscall(u64 nr, T1 arg1) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1) :
               "rcx", "r11", "memory", "cc");
  40b600:	b8 57 00 00 00       	mov    $0x57,%eax
  40b605:	0f 05                	syscall 
#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS
  return internal_syscall(SYSCALL(unlinkat), AT_FDCWD, (uptr)path, 0);
#else
  return internal_syscall(SYSCALL(unlink), (uptr)path);
#endif
}
  40b607:	c3                   	retq   
  40b608:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b60f:	00 

000000000040b610 <_ZN11__sanitizer15internal_renameEPKcS1_>:

template <typename T1, typename T2>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2) : "rcx", "r11", "memory", "cc");
  40b610:	b8 52 00 00 00       	mov    $0x52,%eax
  40b615:	0f 05                	syscall 
  return internal_syscall(SYSCALL(renameat), AT_FDCWD, (uptr)oldpath, AT_FDCWD,
                          (uptr)newpath);
#else
  return internal_syscall(SYSCALL(rename), (uptr)oldpath, (uptr)newpath);
#endif
}
  40b617:	c3                   	retq   
  40b618:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b61f:	00 

000000000040b620 <_ZN11__sanitizer20internal_sched_yieldEv>:
#define SYSCALL(name) __NR_ ## name

static uptr internal_syscall(u64 nr) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr) : "rcx", "r11",
               "memory", "cc");
  40b620:	b8 18 00 00 00       	mov    $0x18,%eax
  40b625:	0f 05                	syscall 

uptr internal_sched_yield() {
  return internal_syscall(SYSCALL(sched_yield));
}
  40b627:	c3                   	retq   
  40b628:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b62f:	00 

000000000040b630 <_ZN11__sanitizer14internal__exitEi>:

void internal__exit(int exitcode) {
  40b630:	48 83 ec 08          	sub    $0x8,%rsp

template <typename T1>
static uptr internal_syscall(u64 nr, T1 arg1) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1) :
               "rcx", "r11", "memory", "cc");
  40b634:	48 63 ff             	movslq %edi,%rdi
  40b637:	b8 e7 00 00 00       	mov    $0xe7,%eax
  40b63c:	0f 05                	syscall 
#if SANITIZER_FREEBSD
  internal_syscall(SYSCALL(exit), exitcode);
#else
  internal_syscall(SYSCALL(exit_group), exitcode);
#endif
  Die();  // Unreachable.
  40b63e:	e8 1d 9c ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  40b643:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40b64a:	84 00 00 00 00 00 

000000000040b650 <_ZN11__sanitizer15internal_execveEPKcPKPcS4_>:

template <typename T1, typename T2, typename T3>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3) : "rcx", "r11", "memory", "cc");
  40b650:	b8 3b 00 00 00       	mov    $0x3b,%eax
  40b655:	0f 05                	syscall 

uptr internal_execve(const char *filename, char *const argv[],
                     char *const envp[]) {
  return internal_syscall(SYSCALL(execve), (uptr)filename, (uptr)argv,
                          (uptr)envp);
}
  40b657:	c3                   	retq   
  40b658:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b65f:	00 

000000000040b660 <_ZN11__sanitizer10FileExistsEPKc>:

// ----------------- sanitizer_common.h
bool FileExists(const char *filename) {
  40b660:	48 83 ec 20          	sub    $0x20,%rsp

template <typename T1, typename T2>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2) : "rcx", "r11", "memory", "cc");
  40b664:	b8 04 00 00 00       	mov    $0x4,%eax
  struct kernel_stat kbuf;
  int res = internal_syscall(SYSCALL(stat), path, &kbuf);
  kernel_stat_to_stat(&kbuf, (struct stat *)buf);
  return res;
# else
  return internal_syscall(SYSCALL(stat), (uptr)path, (uptr)buf);
  40b669:	48 8d 74 24 88       	lea    -0x78(%rsp),%rsi
  40b66e:	0f 05                	syscall 
#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS
  if (internal_syscall(SYSCALL(newfstatat), AT_FDCWD, filename, &st, 0))
#else
  if (internal_stat(filename, &st))
#endif
    return false;
  40b670:	31 d2                	xor    %edx,%edx
bool FileExists(const char *filename) {
  struct stat st;
#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS
  if (internal_syscall(SYSCALL(newfstatat), AT_FDCWD, filename, &st, 0))
#else
  if (internal_stat(filename, &st))
  40b672:	48 85 c0             	test   %rax,%rax
  40b675:	75 11                	jne    40b688 <_ZN11__sanitizer10FileExistsEPKc+0x28>
#endif
    return false;
  // Sanity check: filename is a regular file.
  return S_ISREG(st.st_mode);
  40b677:	8b 44 24 a0          	mov    -0x60(%rsp),%eax
  40b67b:	25 00 f0 00 00       	and    $0xf000,%eax
  40b680:	3d 00 80 00 00       	cmp    $0x8000,%eax
  40b685:	0f 94 c2             	sete   %dl
}
  40b688:	89 d0                	mov    %edx,%eax
  40b68a:	48 83 c4 20          	add    $0x20,%rsp
  40b68e:	c3                   	retq   
  40b68f:	90                   	nop

000000000040b690 <_ZN11__sanitizer6GetTidEv>:
#define SYSCALL(name) __NR_ ## name

static uptr internal_syscall(u64 nr) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr) : "rcx", "r11",
               "memory", "cc");
  40b690:	b8 ba 00 00 00       	mov    $0xba,%eax
  40b695:	0f 05                	syscall 
#if SANITIZER_FREEBSD
  return (uptr)pthread_self();
#else
  return internal_syscall(SYSCALL(gettid));
#endif
}
  40b697:	c3                   	retq   
  40b698:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b69f:	00 

000000000040b6a0 <_ZN11__sanitizer8NanoTimeEv>:

u64 NanoTime() {
  40b6a0:	53                   	push   %rbx
#if SANITIZER_FREEBSD
  timeval tv;
#else
  kernel_timeval tv;
#endif
  internal_memset(&tv, 0, sizeof(tv));
  40b6a1:	31 f6                	xor    %esi,%esi
  40b6a3:	ba 10 00 00 00       	mov    $0x10,%edx
#else
  return internal_syscall(SYSCALL(gettid));
#endif
}

u64 NanoTime() {
  40b6a8:	48 83 ec 10          	sub    $0x10,%rsp
#if SANITIZER_FREEBSD
  timeval tv;
#else
  kernel_timeval tv;
#endif
  internal_memset(&tv, 0, sizeof(tv));
  40b6ac:	48 89 e7             	mov    %rsp,%rdi
  40b6af:	e8 8c ec ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>

template <typename T1, typename T2>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2) : "rcx", "r11", "memory", "cc");
  40b6b4:	31 f6                	xor    %esi,%esi
  40b6b6:	b8 60 00 00 00       	mov    $0x60,%eax
  40b6bb:	48 89 e7             	mov    %rsp,%rdi
  40b6be:	0f 05                	syscall 
  internal_syscall(SYSCALL(gettimeofday), (uptr)&tv, 0);
  return (u64)tv.tv_sec * 1000*1000*1000 + tv.tv_usec * 1000;
  40b6c0:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  40b6c5:	48 8b 0c 24          	mov    (%rsp),%rcx
}
  40b6c9:	48 83 c4 10          	add    $0x10,%rsp
  40b6cd:	5b                   	pop    %rbx
#else
  kernel_timeval tv;
#endif
  internal_memset(&tv, 0, sizeof(tv));
  internal_syscall(SYSCALL(gettimeofday), (uptr)&tv, 0);
  return (u64)tv.tv_sec * 1000*1000*1000 + tv.tv_usec * 1000;
  40b6ce:	48 69 d0 e8 03 00 00 	imul   $0x3e8,%rax,%rdx
  40b6d5:	48 69 c1 00 ca 9a 3b 	imul   $0x3b9aca00,%rcx,%rax
  40b6dc:	48 01 d0             	add    %rdx,%rax
}
  40b6df:	c3                   	retq   

000000000040b6e0 <_ZN11__sanitizer6GetEnvEPKc>:

// Like getenv, but reads env directly from /proc (on Linux) or parses the
// 'environ' array (on FreeBSD) and does not use libc. This function should be
// called first inside __asan_init.
const char *GetEnv(const char *name) {
  40b6e0:	41 55                	push   %r13
  40b6e2:	49 89 fd             	mov    %rdi,%r13
  40b6e5:	41 54                	push   %r12
  40b6e7:	55                   	push   %rbp
  40b6e8:	53                   	push   %rbx
  40b6e9:	48 83 ec 18          	sub    $0x18,%rsp
  return 0;  // Not found.
#elif SANITIZER_LINUX
  static char *environ;
  static uptr len;
  static bool inited;
  if (!inited) {
  40b6ed:	80 3d ac 62 26 00 00 	cmpb   $0x0,0x2662ac(%rip)        # 6719a0 <_ZZN11__sanitizer6GetEnvEPKcE6inited>
  40b6f4:	0f 84 a6 00 00 00    	je     40b7a0 <_ZN11__sanitizer6GetEnvEPKc+0xc0>
  40b6fa:	48 8b 05 8f 62 26 00 	mov    0x26628f(%rip),%rax        # 671990 <_ZZN11__sanitizer6GetEnvEPKcE7environ>
    inited = true;
    uptr environ_size;
    if (!ReadFileToBuffer("/proc/self/environ", &environ, &environ_size, &len))
      environ = nullptr;
  }
  if (!environ || len == 0) return nullptr;
  40b701:	48 85 c0             	test   %rax,%rax
  40b704:	0f 84 d6 00 00 00    	je     40b7e0 <_ZN11__sanitizer6GetEnvEPKc+0x100>
  40b70a:	48 83 3d 6e 62 26 00 	cmpq   $0x0,0x26626e(%rip)        # 671980 <_ZZN11__sanitizer6GetEnvEPKcE3len>
  40b711:	00 
  40b712:	0f 84 c8 00 00 00    	je     40b7e0 <_ZN11__sanitizer6GetEnvEPKc+0x100>
  uptr namelen = internal_strlen(name);
  40b718:	4c 89 ef             	mov    %r13,%rdi
  40b71b:	e8 10 f2 ff ff       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  const char *p = environ;
  40b720:	48 8b 1d 69 62 26 00 	mov    0x266269(%rip),%rbx        # 671990 <_ZZN11__sanitizer6GetEnvEPKcE7environ>
    uptr environ_size;
    if (!ReadFileToBuffer("/proc/self/environ", &environ, &environ_size, &len))
      environ = nullptr;
  }
  if (!environ || len == 0) return nullptr;
  uptr namelen = internal_strlen(name);
  40b727:	49 89 c4             	mov    %rax,%r12
  const char *p = environ;
  while (*p != '\0') {  // will happen at the \0\0 that terminates the buffer
  40b72a:	80 3b 00             	cmpb   $0x0,(%rbx)
  40b72d:	0f 84 ad 00 00 00    	je     40b7e0 <_ZN11__sanitizer6GetEnvEPKc+0x100>
  40b733:	48 89 da             	mov    %rbx,%rdx
  40b736:	eb 1d                	jmp    40b755 <_ZN11__sanitizer6GetEnvEPKc+0x75>
  40b738:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b73f:	00 
  40b740:	80 7d 01 00          	cmpb   $0x0,0x1(%rbp)
        (char*)internal_memchr(p, '\0', len - (p - environ));
    if (!endp)  // this entry isn't NUL terminated
      return nullptr;
    else if (!internal_memcmp(p, name, namelen) && p[namelen] == '=')  // Match.
      return p + namelen + 1;  // point after =
    p = endp + 1;
  40b744:	48 8d 5d 01          	lea    0x1(%rbp),%rbx
      environ = nullptr;
  }
  if (!environ || len == 0) return nullptr;
  uptr namelen = internal_strlen(name);
  const char *p = environ;
  while (*p != '\0') {  // will happen at the \0\0 that terminates the buffer
  40b748:	0f 84 92 00 00 00    	je     40b7e0 <_ZN11__sanitizer6GetEnvEPKc+0x100>
  40b74e:	48 8b 15 3b 62 26 00 	mov    0x26623b(%rip),%rdx        # 671990 <_ZZN11__sanitizer6GetEnvEPKcE7environ>
    // proc file has the format NAME=value\0NAME=value\0NAME=value\0...
    const char* endp =
        (char*)internal_memchr(p, '\0', len - (p - environ));
  40b755:	48 29 da             	sub    %rbx,%rdx
  40b758:	48 03 15 21 62 26 00 	add    0x266221(%rip),%rdx        # 671980 <_ZZN11__sanitizer6GetEnvEPKcE3len>
  40b75f:	31 f6                	xor    %esi,%esi
  40b761:	48 89 df             	mov    %rbx,%rdi
  40b764:	e8 e7 e6 ff ff       	callq  409e50 <_ZN11__sanitizer15internal_memchrEPKvim>
    if (!endp)  // this entry isn't NUL terminated
  40b769:	48 85 c0             	test   %rax,%rax
  uptr namelen = internal_strlen(name);
  const char *p = environ;
  while (*p != '\0') {  // will happen at the \0\0 that terminates the buffer
    // proc file has the format NAME=value\0NAME=value\0NAME=value\0...
    const char* endp =
        (char*)internal_memchr(p, '\0', len - (p - environ));
  40b76c:	48 89 c5             	mov    %rax,%rbp
    if (!endp)  // this entry isn't NUL terminated
  40b76f:	74 6f                	je     40b7e0 <_ZN11__sanitizer6GetEnvEPKc+0x100>
      return nullptr;
    else if (!internal_memcmp(p, name, namelen) && p[namelen] == '=')  // Match.
  40b771:	4c 89 e2             	mov    %r12,%rdx
  40b774:	4c 89 ee             	mov    %r13,%rsi
  40b777:	48 89 df             	mov    %rbx,%rdi
  40b77a:	e8 41 e7 ff ff       	callq  409ec0 <_ZN11__sanitizer15internal_memcmpEPKvS1_m>
  40b77f:	85 c0                	test   %eax,%eax
  40b781:	75 bd                	jne    40b740 <_ZN11__sanitizer6GetEnvEPKc+0x60>
  40b783:	42 80 3c 23 3d       	cmpb   $0x3d,(%rbx,%r12,1)
  40b788:	75 b6                	jne    40b740 <_ZN11__sanitizer6GetEnvEPKc+0x60>
  }
  return nullptr;  // Not found.
#else
#error "Unsupported platform"
#endif
}
  40b78a:	48 83 c4 18          	add    $0x18,%rsp
    const char* endp =
        (char*)internal_memchr(p, '\0', len - (p - environ));
    if (!endp)  // this entry isn't NUL terminated
      return nullptr;
    else if (!internal_memcmp(p, name, namelen) && p[namelen] == '=')  // Match.
      return p + namelen + 1;  // point after =
  40b78e:	4a 8d 44 23 01       	lea    0x1(%rbx,%r12,1),%rax
  }
  return nullptr;  // Not found.
#else
#error "Unsupported platform"
#endif
}
  40b793:	5b                   	pop    %rbx
  40b794:	5d                   	pop    %rbp
  40b795:	41 5c                	pop    %r12
  40b797:	41 5d                	pop    %r13
  40b799:	c3                   	retq   
  40b79a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  static uptr len;
  static bool inited;
  if (!inited) {
    inited = true;
    uptr environ_size;
    if (!ReadFileToBuffer("/proc/self/environ", &environ, &environ_size, &len))
  40b7a0:	48 8d 0d d9 61 26 00 	lea    0x2661d9(%rip),%rcx        # 671980 <_ZZN11__sanitizer6GetEnvEPKcE3len>
  40b7a7:	48 8d 35 e2 61 26 00 	lea    0x2661e2(%rip),%rsi        # 671990 <_ZZN11__sanitizer6GetEnvEPKcE7environ>
  40b7ae:	48 8d 3d 31 d4 00 00 	lea    0xd431(%rip),%rdi        # 418be6 <.LC3>
  40b7b5:	45 31 c9             	xor    %r9d,%r9d
  40b7b8:	48 89 e2             	mov    %rsp,%rdx
  40b7bb:	41 b8 00 00 00 04    	mov    $0x4000000,%r8d
#elif SANITIZER_LINUX
  static char *environ;
  static uptr len;
  static bool inited;
  if (!inited) {
    inited = true;
  40b7c1:	c6 05 d8 61 26 00 01 	movb   $0x1,0x2661d8(%rip)        # 6719a0 <_ZZN11__sanitizer6GetEnvEPKcE6inited>
    uptr environ_size;
    if (!ReadFileToBuffer("/proc/self/environ", &environ, &environ_size, &len))
  40b7c8:	e8 23 9e ff ff       	callq  4055f0 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi>
  40b7cd:	84 c0                	test   %al,%al
  40b7cf:	0f 85 25 ff ff ff    	jne    40b6fa <_ZN11__sanitizer6GetEnvEPKc+0x1a>
      environ = nullptr;
  40b7d5:	48 c7 05 b0 61 26 00 	movq   $0x0,0x2661b0(%rip)        # 671990 <_ZZN11__sanitizer6GetEnvEPKcE7environ>
  40b7dc:	00 00 00 00 
  }
  return nullptr;  // Not found.
#else
#error "Unsupported platform"
#endif
}
  40b7e0:	48 83 c4 18          	add    $0x18,%rsp
    inited = true;
    uptr environ_size;
    if (!ReadFileToBuffer("/proc/self/environ", &environ, &environ_size, &len))
      environ = nullptr;
  }
  if (!environ || len == 0) return nullptr;
  40b7e4:	31 c0                	xor    %eax,%eax
  }
  return nullptr;  // Not found.
#else
#error "Unsupported platform"
#endif
}
  40b7e6:	5b                   	pop    %rbx
  40b7e7:	5d                   	pop    %rbp
  40b7e8:	41 5c                	pop    %r12
  40b7ea:	41 5d                	pop    %r13
  40b7ec:	c3                   	retq   
  40b7ed:	0f 1f 00             	nopl   (%rax)

000000000040b7f0 <_ZN11__sanitizer6ReExecEv>:
    ReadNullSepFileToArray("/proc/self/environ", envp, kMaxEnvp);
  }
#endif
}

void ReExec() {
  40b7f0:	48 83 ec 28          	sub    $0x28,%rsp
}
#endif

static void GetArgsAndEnv(char*** argv, char*** envp) {
#if !SANITIZER_GO
  if (&__libc_stack_end) {
  40b7f4:	48 8b 05 cd 2a 01 00 	mov    0x12acd(%rip),%rax        # 41e2c8 <_DYNAMIC+0x2c8>
  40b7fb:	48 85 c0             	test   %rax,%rax
  40b7fe:	74 67                	je     40b867 <_ZN11__sanitizer6ReExecEv+0x77>
#endif
    uptr* stack_end = (uptr*)__libc_stack_end;
  40b800:	48 8b 08             	mov    (%rax),%rcx
    int argc = *stack_end;
  40b803:	48 8b 01             	mov    (%rcx),%rax
    *argv = (char**)(stack_end + 1);
  40b806:	48 8d 71 08          	lea    0x8(%rcx),%rsi
  40b80a:	48 89 34 24          	mov    %rsi,(%rsp)
    *envp = (char**)(stack_end + argc + 2);
  40b80e:	48 98                	cltq   
  40b810:	48 8d 54 c1 10       	lea    0x10(%rcx,%rax,8),%rdx
  40b815:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)

template <typename T1, typename T2, typename T3>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3) : "rcx", "r11", "memory", "cc");
  40b81a:	48 8d 3d eb d3 00 00 	lea    0xd3eb(%rip),%rdi        # 418c0c <.LC5>
  40b821:	b8 3b 00 00 00       	mov    $0x3b,%eax
  40b826:	0f 05                	syscall 
               "memory", "cc");
  return retval;
}

bool internal_iserror(uptr retval, int *rverrno) {
  if (retval >= (uptr)-4095) {
  40b828:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
  40b82e:	76 17                	jbe    40b847 <_ZN11__sanitizer6ReExecEv+0x57>
    if (rverrno)
      *rverrno = -retval;
  40b830:	89 c6                	mov    %eax,%esi
  char **argv, **envp;
  GetArgsAndEnv(&argv, &envp);
  uptr rv = internal_execve("/proc/self/exe", argv, envp);
  int rverrno;
  CHECK_EQ(internal_iserror(rv, &rverrno), true);
  Printf("execve failed, errno %d\n", rverrno);
  40b832:	48 8d 3d e2 d3 00 00 	lea    0xd3e2(%rip),%rdi        # 418c1b <.LC6>
  40b839:	31 c0                	xor    %eax,%eax
  40b83b:	f7 de                	neg    %esi
  40b83d:	e8 ae 21 00 00       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  Die();
  40b842:	e8 19 9a ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
void ReExec() {
  char **argv, **envp;
  GetArgsAndEnv(&argv, &envp);
  uptr rv = internal_execve("/proc/self/exe", argv, envp);
  int rverrno;
  CHECK_EQ(internal_iserror(rv, &rverrno), true);
  40b847:	48 8d 15 6a b9 00 00 	lea    0xb96a(%rip),%rdx        # 4171b8 <.LC7>
  40b84e:	48 8d 3d f3 b8 00 00 	lea    0xb8f3(%rip),%rdi        # 417148 <.LC2>
  40b855:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  40b85b:	31 c9                	xor    %ecx,%ecx
  40b85d:	be c0 01 00 00       	mov    $0x1c0,%esi
  40b862:	e8 89 9b ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    *argv = (char**)(stack_end + 1);
    *envp = (char**)(stack_end + argc + 2);
#if !SANITIZER_GO
  } else {
    static const int kMaxArgv = 2000, kMaxEnvp = 2000;
    ReadNullSepFileToArray("/proc/self/cmdline", argv, kMaxArgv);
  40b867:	48 8d 3d 8b d3 00 00 	lea    0xd38b(%rip),%rdi        # 418bf9 <.LC4>
  40b86e:	48 89 e6             	mov    %rsp,%rsi
  40b871:	e8 50 6c ff ff       	callq  4024c6 <_ZN11__sanitizerL22ReadNullSepFileToArrayEPKcPPPci.constprop.6>
    ReadNullSepFileToArray("/proc/self/environ", envp, kMaxEnvp);
  40b876:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
  40b87b:	48 8d 3d 64 d3 00 00 	lea    0xd364(%rip),%rdi        # 418be6 <.LC3>
  40b882:	e8 3f 6c ff ff       	callq  4024c6 <_ZN11__sanitizerL22ReadNullSepFileToArrayEPKcPPPci.constprop.6>
  40b887:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  40b88c:	48 8b 34 24          	mov    (%rsp),%rsi
  40b890:	eb 88                	jmp    40b81a <_ZN11__sanitizer6ReExecEv+0x2a>
  40b892:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40b899:	1f 84 00 00 00 00 00 

000000000040b8a0 <_ZN11__sanitizer13BlockingMutexC1Ev>:
  MtxLocked = 1,
  MtxSleeping = 2
};

BlockingMutex::BlockingMutex() {
  internal_memset(this, 0, sizeof(*this));
  40b8a0:	ba 58 00 00 00       	mov    $0x58,%edx
  40b8a5:	31 f6                	xor    %esi,%esi
  40b8a7:	e9 94 ea ff ff       	jmpq   40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  40b8ac:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040b8b0 <_ZN11__sanitizer13BlockingMutex4LockEv>:
}

void BlockingMutex::Lock() {
  40b8b0:	55                   	push   %rbp
  40b8b1:	53                   	push   %rbx
  40b8b2:	48 83 ec 08          	sub    $0x8,%rsp
  CHECK_EQ(owner_, 0);
  40b8b6:	48 8b 4f 50          	mov    0x50(%rdi),%rcx
  40b8ba:	48 85 c9             	test   %rcx,%rcx
  40b8bd:	75 3e                	jne    40b8fd <_ZN11__sanitizer13BlockingMutex4LockEv+0x4d>
  40b8bf:	b8 01 00 00 00       	mov    $0x1,%eax
  40b8c4:	87 07                	xchg   %eax,(%rdi)
  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);
  if (atomic_exchange(m, MtxLocked, memory_order_acquire) == MtxUnlocked)
  40b8c6:	85 c0                	test   %eax,%eax
  40b8c8:	74 2c                	je     40b8f6 <_ZN11__sanitizer13BlockingMutex4LockEv+0x46>
  40b8ca:	bb 02 00 00 00       	mov    $0x2,%ebx
               "mov %6, %%r8;"
               "mov %7, %%r9;"
               "syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3), "r"((u64)arg4), "r"((u64)arg5),
               "r"((u64)arg6) : "rcx", "r11", "r10", "r8", "r9",
               "memory", "cc");
  40b8cf:	bd ca 00 00 00       	mov    $0xca,%ebp
  40b8d4:	31 f6                	xor    %esi,%esi
  40b8d6:	ba 02 00 00 00       	mov    $0x2,%edx
  40b8db:	eb 11                	jmp    40b8ee <_ZN11__sanitizer13BlockingMutex4LockEv+0x3e>
  40b8dd:	0f 1f 00             	nopl   (%rax)
  40b8e0:	48 89 e8             	mov    %rbp,%rax
  40b8e3:	49 89 f2             	mov    %rsi,%r10
  40b8e6:	49 89 f0             	mov    %rsi,%r8
  40b8e9:	49 89 f1             	mov    %rsi,%r9
  40b8ec:	0f 05                	syscall 
  40b8ee:	89 d9                	mov    %ebx,%ecx
  40b8f0:	87 0f                	xchg   %ecx,(%rdi)
    return;
  while (atomic_exchange(m, MtxSleeping, memory_order_acquire) != MtxUnlocked) {
  40b8f2:	85 c9                	test   %ecx,%ecx
  40b8f4:	75 ea                	jne    40b8e0 <_ZN11__sanitizer13BlockingMutex4LockEv+0x30>
    _umtx_op(m, UMTX_OP_WAIT_UINT, MtxSleeping, 0, 0);
#else
    internal_syscall(SYSCALL(futex), (uptr)m, FUTEX_WAIT, MtxSleeping, 0, 0, 0);
#endif
  }
}
  40b8f6:	48 83 c4 08          	add    $0x8,%rsp
  40b8fa:	5b                   	pop    %rbx
  40b8fb:	5d                   	pop    %rbp
  40b8fc:	c3                   	retq   
BlockingMutex::BlockingMutex() {
  internal_memset(this, 0, sizeof(*this));
}

void BlockingMutex::Lock() {
  CHECK_EQ(owner_, 0);
  40b8fd:	48 8d 15 30 d3 00 00 	lea    0xd330(%rip),%rdx        # 418c34 <.LC8>
  40b904:	48 8d 3d 3d b8 00 00 	lea    0xb83d(%rip),%rdi        # 417148 <.LC2>
  40b90b:	45 31 c0             	xor    %r8d,%r8d
  40b90e:	be d0 01 00 00       	mov    $0x1d0,%esi
  40b913:	e8 d8 9a ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40b918:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b91f:	00 

000000000040b920 <_ZN11__sanitizer13BlockingMutex6UnlockEv>:
    internal_syscall(SYSCALL(futex), (uptr)m, FUTEX_WAIT, MtxSleeping, 0, 0, 0);
#endif
  }
}

void BlockingMutex::Unlock() {
  40b920:	53                   	push   %rbx
  40b921:	31 c0                	xor    %eax,%eax
  40b923:	87 07                	xchg   %eax,(%rdi)
  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);
  u32 v = atomic_exchange(m, MtxUnlocked, memory_order_relaxed);
  CHECK_NE(v, MtxUnlocked);
  40b925:	85 c0                	test   %eax,%eax
  40b927:	74 23                	je     40b94c <_ZN11__sanitizer13BlockingMutex6UnlockEv+0x2c>
  if (v == MtxSleeping) {
  40b929:	83 f8 02             	cmp    $0x2,%eax
  40b92c:	74 02                	je     40b930 <_ZN11__sanitizer13BlockingMutex6UnlockEv+0x10>
    _umtx_op(m, UMTX_OP_WAKE, 1, 0, 0);
#else
    internal_syscall(SYSCALL(futex), (uptr)m, FUTEX_WAKE, 1, 0, 0, 0);
#endif
  }
}
  40b92e:	5b                   	pop    %rbx
  40b92f:	c3                   	retq   
  40b930:	ba 01 00 00 00       	mov    $0x1,%edx
  40b935:	31 db                	xor    %ebx,%ebx
  40b937:	b8 ca 00 00 00       	mov    $0xca,%eax
  40b93c:	48 89 d6             	mov    %rdx,%rsi
  40b93f:	49 89 da             	mov    %rbx,%r10
  40b942:	49 89 d8             	mov    %rbx,%r8
  40b945:	49 89 d9             	mov    %rbx,%r9
  40b948:	0f 05                	syscall 
  40b94a:	5b                   	pop    %rbx
  40b94b:	c3                   	retq   
}

void BlockingMutex::Unlock() {
  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);
  u32 v = atomic_exchange(m, MtxUnlocked, memory_order_relaxed);
  CHECK_NE(v, MtxUnlocked);
  40b94c:	48 8d 15 f5 d2 00 00 	lea    0xd2f5(%rip),%rdx        # 418c48 <.LC9>
  40b953:	48 8d 3d ee b7 00 00 	lea    0xb7ee(%rip),%rdi        # 417148 <.LC2>
  40b95a:	45 31 c0             	xor    %r8d,%r8d
  40b95d:	31 c9                	xor    %ecx,%ecx
  40b95f:	be e0 01 00 00       	mov    $0x1e0,%esi
  40b964:	e8 87 9a ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40b969:	90                   	nop
  40b96a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000040b970 <_ZN11__sanitizer13BlockingMutex11CheckLockedEv>:
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  40b970:	8b 07                	mov    (%rdi),%eax
  }
}

void BlockingMutex::CheckLocked() {
  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);
  CHECK_NE(MtxUnlocked, atomic_load(m, memory_order_relaxed));
  40b972:	85 c0                	test   %eax,%eax
  40b974:	74 02                	je     40b978 <_ZN11__sanitizer13BlockingMutex11CheckLockedEv+0x8>
  40b976:	f3 c3                	repz retq 
  40b978:	48 8d 15 69 b8 00 00 	lea    0xb869(%rip),%rdx        # 4171e8 <.LC10>
    internal_syscall(SYSCALL(futex), (uptr)m, FUTEX_WAKE, 1, 0, 0, 0);
#endif
  }
}

void BlockingMutex::CheckLocked() {
  40b97f:	50                   	push   %rax
  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);
  CHECK_NE(MtxUnlocked, atomic_load(m, memory_order_relaxed));
  40b980:	48 8d 3d c1 b7 00 00 	lea    0xb7c1(%rip),%rdi        # 417148 <.LC2>
  40b987:	45 31 c0             	xor    %r8d,%r8d
  40b98a:	31 c9                	xor    %ecx,%ecx
  40b98c:	be ec 01 00 00       	mov    $0x1ec,%esi
  40b991:	e8 5a 9a ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40b996:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40b99d:	00 00 00 

000000000040b9a0 <_ZN11__sanitizer15internal_ptraceEiiPvS0_>:
#endif
  char               d_name[256];
};

// Syscall wrappers.
uptr internal_ptrace(int request, int pid, void *addr, void *data) {
  40b9a0:	49 89 c8             	mov    %rcx,%r8
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
  u64 retval;
  asm volatile("mov %5, %%r10;"
               "syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3), "r"((u64)arg4) :
               "rcx", "r11", "r10", "memory", "cc");
  40b9a3:	48 63 ff             	movslq %edi,%rdi
  40b9a6:	48 63 f6             	movslq %esi,%rsi
  40b9a9:	b8 65 00 00 00       	mov    $0x65,%eax
  40b9ae:	4d 89 c2             	mov    %r8,%r10
  40b9b1:	0f 05                	syscall 
  return internal_syscall(SYSCALL(ptrace), request, pid, (uptr)addr,
                          (uptr)data);
}
  40b9b3:	c3                   	retq   
  40b9b4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40b9bb:	00 00 00 00 00 

000000000040b9c0 <_ZN11__sanitizer16internal_waitpidEiPii>:
  40b9c0:	48 63 ff             	movslq %edi,%rdi
  40b9c3:	48 63 d2             	movslq %edx,%rdx
  40b9c6:	45 31 c0             	xor    %r8d,%r8d
  40b9c9:	b8 3d 00 00 00       	mov    $0x3d,%eax
  40b9ce:	4d 89 c2             	mov    %r8,%r10
  40b9d1:	0f 05                	syscall 

uptr internal_waitpid(int pid, int *status, int options) {
  return internal_syscall(SYSCALL(wait4), pid, (uptr)status, options,
                          0 /* rusage */);
}
  40b9d3:	c3                   	retq   
  40b9d4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40b9db:	00 00 00 00 00 

000000000040b9e0 <_ZN11__sanitizer15internal_getpidEv>:
#define SYSCALL(name) __NR_ ## name

static uptr internal_syscall(u64 nr) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr) : "rcx", "r11",
               "memory", "cc");
  40b9e0:	b8 27 00 00 00       	mov    $0x27,%eax
  40b9e5:	0f 05                	syscall 

uptr internal_getpid() {
  return internal_syscall(SYSCALL(getpid));
}
  40b9e7:	c3                   	retq   
  40b9e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b9ef:	00 

000000000040b9f0 <_ZN11__sanitizer16internal_getppidEv>:
  40b9f0:	b8 6e 00 00 00       	mov    $0x6e,%eax
  40b9f5:	0f 05                	syscall 

uptr internal_getppid() {
  return internal_syscall(SYSCALL(getppid));
}
  40b9f7:	c3                   	retq   
  40b9f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40b9ff:	00 

000000000040ba00 <_ZN11__sanitizer17internal_getdentsEiPNS_12linux_direntEj>:

template <typename T1, typename T2, typename T3>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3) : "rcx", "r11", "memory", "cc");
  40ba00:	48 63 ff             	movslq %edi,%rdi
  40ba03:	89 d2                	mov    %edx,%edx
  40ba05:	b8 4e 00 00 00       	mov    $0x4e,%eax
  40ba0a:	0f 05                	syscall 
#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS
  return internal_syscall(SYSCALL(getdents64), fd, (uptr)dirp, count);
#else
  return internal_syscall(SYSCALL(getdents), fd, (uptr)dirp, count);
#endif
}
  40ba0c:	c3                   	retq   
  40ba0d:	0f 1f 00             	nopl   (%rax)

000000000040ba10 <_ZN11__sanitizer14internal_lseekEiyi>:
  40ba10:	48 63 ff             	movslq %edi,%rdi
  40ba13:	48 63 d2             	movslq %edx,%rdx
  40ba16:	b8 08 00 00 00       	mov    $0x8,%eax
  40ba1b:	0f 05                	syscall 

uptr internal_lseek(fd_t fd, OFF_T offset, int whence) {
  return internal_syscall(SYSCALL(lseek), fd, offset, whence);
}
  40ba1d:	c3                   	retq   
  40ba1e:	66 90                	xchg   %ax,%ax

000000000040ba20 <_ZN11__sanitizer14internal_prctlEimmmm>:

#if SANITIZER_LINUX
uptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5) {
  40ba20:	53                   	push   %rbx
  40ba21:	49 89 c9             	mov    %rcx,%r9
  40ba24:	4c 89 c3             	mov    %r8,%rbx
  u64 retval;
  asm volatile("mov %5, %%r10;"
               "mov %6, %%r8;"
               "syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3), "r"((u64)arg4), "r"((u64)arg5) :
               "rcx", "r11", "r10", "r8", "memory", "cc");
  40ba27:	48 63 ff             	movslq %edi,%rdi
  40ba2a:	b8 9d 00 00 00       	mov    $0x9d,%eax
  40ba2f:	4d 89 ca             	mov    %r9,%r10
  40ba32:	49 89 d8             	mov    %rbx,%r8
  40ba35:	0f 05                	syscall 
  return internal_syscall(SYSCALL(prctl), option, arg2, arg3, arg4, arg5);
}
  40ba37:	5b                   	pop    %rbx
  40ba38:	c3                   	retq   
  40ba39:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000040ba40 <_ZN11__sanitizer20internal_sigaltstackEPK11sigaltstackPS0_>:

template <typename T1, typename T2>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2) : "rcx", "r11", "memory", "cc");
  40ba40:	b8 83 00 00 00       	mov    $0x83,%eax
  40ba45:	0f 05                	syscall 
#endif

uptr internal_sigaltstack(const struct sigaltstack *ss,
                         struct sigaltstack *oss) {
  return internal_syscall(SYSCALL(sigaltstack), (uptr)ss, (uptr)oss);
}
  40ba47:	c3                   	retq   
  40ba48:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40ba4f:	00 

000000000040ba50 <_ZN11__sanitizer13internal_forkEv>:
#define SYSCALL(name) __NR_ ## name

static uptr internal_syscall(u64 nr) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr) : "rcx", "r11",
               "memory", "cc");
  40ba50:	b8 39 00 00 00       	mov    $0x39,%eax
  40ba55:	0f 05                	syscall 
#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS
  return internal_syscall(SYSCALL(clone), SIGCHLD, 0);
#else
  return internal_syscall(SYSCALL(fork));
#endif
}
  40ba57:	c3                   	retq   
  40ba58:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40ba5f:	00 

000000000040ba60 <_ZN11__sanitizer29internal_sigaction_norestorerEiPKvPv>:

#if SANITIZER_LINUX
#define SA_RESTORER 0x04000000
// Doesn't set sa_restorer, use with caution (see below).
int internal_sigaction_norestorer(int signum, const void *act, void *oldact) {
  40ba60:	41 56                	push   %r14
  40ba62:	41 89 fe             	mov    %edi,%r14d
  40ba65:	41 55                	push   %r13
  40ba67:	41 54                	push   %r12
  40ba69:	55                   	push   %rbp
  40ba6a:	48 89 d5             	mov    %rdx,%rbp
  __sanitizer_kernel_sigaction_t k_act, k_oldact;
  internal_memset(&k_act, 0, sizeof(__sanitizer_kernel_sigaction_t));
  40ba6d:	ba 20 00 00 00       	mov    $0x20,%edx
}

#if SANITIZER_LINUX
#define SA_RESTORER 0x04000000
// Doesn't set sa_restorer, use with caution (see below).
int internal_sigaction_norestorer(int signum, const void *act, void *oldact) {
  40ba72:	53                   	push   %rbx
  40ba73:	48 89 f3             	mov    %rsi,%rbx
  __sanitizer_kernel_sigaction_t k_act, k_oldact;
  internal_memset(&k_act, 0, sizeof(__sanitizer_kernel_sigaction_t));
  40ba76:	31 f6                	xor    %esi,%esi
}

#if SANITIZER_LINUX
#define SA_RESTORER 0x04000000
// Doesn't set sa_restorer, use with caution (see below).
int internal_sigaction_norestorer(int signum, const void *act, void *oldact) {
  40ba78:	48 83 ec 40          	sub    $0x40,%rsp
  __sanitizer_kernel_sigaction_t k_act, k_oldact;
  internal_memset(&k_act, 0, sizeof(__sanitizer_kernel_sigaction_t));
  internal_memset(&k_oldact, 0, sizeof(__sanitizer_kernel_sigaction_t));
  40ba7c:	4c 8d 6c 24 20       	lea    0x20(%rsp),%r13
#if SANITIZER_LINUX
#define SA_RESTORER 0x04000000
// Doesn't set sa_restorer, use with caution (see below).
int internal_sigaction_norestorer(int signum, const void *act, void *oldact) {
  __sanitizer_kernel_sigaction_t k_act, k_oldact;
  internal_memset(&k_act, 0, sizeof(__sanitizer_kernel_sigaction_t));
  40ba81:	48 89 e7             	mov    %rsp,%rdi
  40ba84:	49 89 e4             	mov    %rsp,%r12
  40ba87:	e8 b4 e8 ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  internal_memset(&k_oldact, 0, sizeof(__sanitizer_kernel_sigaction_t));
  40ba8c:	31 f6                	xor    %esi,%esi
  40ba8e:	ba 20 00 00 00       	mov    $0x20,%edx
  40ba93:	4c 89 ef             	mov    %r13,%rdi
  40ba96:	e8 a5 e8 ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  const __sanitizer_sigaction *u_act = (const __sanitizer_sigaction *)act;
  __sanitizer_sigaction *u_oldact = (__sanitizer_sigaction *)oldact;
  if (u_act) {
  40ba9b:	48 85 db             	test   %rbx,%rbx
  40ba9e:	74 38                	je     40bad8 <_ZN11__sanitizer29internal_sigaction_norestorerEiPKvPv+0x78>
    k_act.handler = u_act->handler;
  40baa0:	48 8b 03             	mov    (%rbx),%rax
    k_act.sigaction = u_act->sigaction;
    internal_memcpy(&k_act.sa_mask, &u_act->sa_mask,
                    sizeof(__sanitizer_kernel_sigset_t));
  40baa3:	48 8d 73 08          	lea    0x8(%rbx),%rsi
  40baa7:	48 8d 7c 24 18       	lea    0x18(%rsp),%rdi
  40baac:	ba 08 00 00 00       	mov    $0x8,%edx
  internal_memset(&k_act, 0, sizeof(__sanitizer_kernel_sigaction_t));
  internal_memset(&k_oldact, 0, sizeof(__sanitizer_kernel_sigaction_t));
  const __sanitizer_sigaction *u_act = (const __sanitizer_sigaction *)act;
  __sanitizer_sigaction *u_oldact = (__sanitizer_sigaction *)oldact;
  if (u_act) {
    k_act.handler = u_act->handler;
  40bab1:	48 89 04 24          	mov    %rax,(%rsp)
    k_act.sigaction = u_act->sigaction;
    internal_memcpy(&k_act.sa_mask, &u_act->sa_mask,
                    sizeof(__sanitizer_kernel_sigset_t));
  40bab5:	e8 56 e4 ff ff       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
    // Without SA_RESTORER kernel ignores the calls (probably returns EINVAL).
    k_act.sa_flags = u_act->sa_flags | SA_RESTORER;
  40baba:	8b 83 88 00 00 00    	mov    0x88(%rbx),%eax
  40bac0:	0d 00 00 00 04       	or     $0x4000000,%eax
  40bac5:	48 98                	cltq   
  40bac7:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    // signal delivery or fail to unwind the stack in the signal handler.
    // libc implementation of sigaction() passes its own restorer to
    // rt_sigaction, so we need to do the same (we'll need to reimplement the
    // restorers; for x86_64 the restorer address can be obtained from
    // oldact->sa_restorer upon a call to sigaction(xxx, NULL, oldact).
    k_act.sa_restorer = u_act->sa_restorer;
  40bacc:	48 8b 83 90 00 00 00 	mov    0x90(%rbx),%rax
  40bad3:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  }

  uptr result = internal_syscall(SYSCALL(rt_sigaction), (uptr)signum,
      (uptr)(u_act ? &k_act : nullptr),
      (uptr)(u_oldact ? &k_oldact : nullptr),
      (uptr)sizeof(__sanitizer_kernel_sigset_t));
  40bad8:	31 f6                	xor    %esi,%esi
  40bada:	48 85 ed             	test   %rbp,%rbp
  40badd:	49 63 fe             	movslq %r14d,%rdi
  40bae0:	48 89 f2             	mov    %rsi,%rdx
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
  u64 retval;
  asm volatile("mov %5, %%r10;"
               "syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3), "r"((u64)arg4) :
               "rcx", "r11", "r10", "memory", "cc");
  40bae3:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  40bae9:	b8 0d 00 00 00       	mov    $0xd,%eax
  40baee:	49 0f 45 d5          	cmovne %r13,%rdx
  40baf2:	48 85 db             	test   %rbx,%rbx
  40baf5:	49 0f 45 f4          	cmovne %r12,%rsi
  40baf9:	4d 89 c2             	mov    %r8,%r10
  40bafc:	0f 05                	syscall 

  if ((result == 0) && u_oldact) {
  40bafe:	48 85 c0             	test   %rax,%rax
  40bb01:	49 89 c4             	mov    %rax,%r12
  40bb04:	74 1a                	je     40bb20 <_ZN11__sanitizer29internal_sigaction_norestorerEiPKvPv+0xc0>
                    sizeof(__sanitizer_kernel_sigset_t));
    u_oldact->sa_flags = k_oldact.sa_flags;
    u_oldact->sa_restorer = k_oldact.sa_restorer;
  }
  return result;
}
  40bb06:	48 83 c4 40          	add    $0x40,%rsp
  40bb0a:	44 89 e0             	mov    %r12d,%eax
  40bb0d:	5b                   	pop    %rbx
  40bb0e:	5d                   	pop    %rbp
  40bb0f:	41 5c                	pop    %r12
  40bb11:	41 5d                	pop    %r13
  40bb13:	41 5e                	pop    %r14
  40bb15:	c3                   	retq   
  40bb16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40bb1d:	00 00 00 
  uptr result = internal_syscall(SYSCALL(rt_sigaction), (uptr)signum,
      (uptr)(u_act ? &k_act : nullptr),
      (uptr)(u_oldact ? &k_oldact : nullptr),
      (uptr)sizeof(__sanitizer_kernel_sigset_t));

  if ((result == 0) && u_oldact) {
  40bb20:	48 85 ed             	test   %rbp,%rbp
  40bb23:	74 e1                	je     40bb06 <_ZN11__sanitizer29internal_sigaction_norestorerEiPKvPv+0xa6>
    u_oldact->handler = k_oldact.handler;
  40bb25:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    u_oldact->sigaction = k_oldact.sigaction;
    internal_memcpy(&u_oldact->sa_mask, &k_oldact.sa_mask,
                    sizeof(__sanitizer_kernel_sigset_t));
  40bb2a:	49 8d 75 18          	lea    0x18(%r13),%rsi
  40bb2e:	48 8d 7d 08          	lea    0x8(%rbp),%rdi
  40bb32:	ba 08 00 00 00       	mov    $0x8,%edx
      (uptr)(u_act ? &k_act : nullptr),
      (uptr)(u_oldact ? &k_oldact : nullptr),
      (uptr)sizeof(__sanitizer_kernel_sigset_t));

  if ((result == 0) && u_oldact) {
    u_oldact->handler = k_oldact.handler;
  40bb37:	48 89 45 00          	mov    %rax,0x0(%rbp)
    u_oldact->sigaction = k_oldact.sigaction;
    internal_memcpy(&u_oldact->sa_mask, &k_oldact.sa_mask,
                    sizeof(__sanitizer_kernel_sigset_t));
  40bb3b:	e8 d0 e3 ff ff       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
    u_oldact->sa_flags = k_oldact.sa_flags;
  40bb40:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  40bb45:	89 85 88 00 00 00    	mov    %eax,0x88(%rbp)
    u_oldact->sa_restorer = k_oldact.sa_restorer;
  40bb4b:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  40bb50:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
  }
  return result;
}
  40bb57:	48 83 c4 40          	add    $0x40,%rsp
  40bb5b:	44 89 e0             	mov    %r12d,%eax
  40bb5e:	5b                   	pop    %rbx
  40bb5f:	5d                   	pop    %rbp
  40bb60:	41 5c                	pop    %r12
  40bb62:	41 5d                	pop    %r13
  40bb64:	41 5e                	pop    %r14
  40bb66:	c3                   	retq   
  40bb67:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40bb6e:	00 00 

000000000040bb70 <_ZN11__sanitizer20internal_sigprocmaskEiPNS_20__sanitizer_sigset_tES1_>:
#else
  __sanitizer_kernel_sigset_t *k_set = (__sanitizer_kernel_sigset_t *)set;
  __sanitizer_kernel_sigset_t *k_oldset = (__sanitizer_kernel_sigset_t *)oldset;
  return internal_syscall(SYSCALL(rt_sigprocmask), (uptr)how,
                          (uptr)&k_set->sig[0], (uptr)&k_oldset->sig[0],
                          sizeof(__sanitizer_kernel_sigset_t));
  40bb70:	48 63 ff             	movslq %edi,%rdi
  40bb73:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  40bb79:	b8 0e 00 00 00       	mov    $0xe,%eax
  40bb7e:	4d 89 c2             	mov    %r8,%r10
  40bb81:	0f 05                	syscall 
#endif
}
  40bb83:	c3                   	retq   
  40bb84:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40bb8b:	00 00 00 00 00 

000000000040bb90 <_ZN11__sanitizer19internal_sigfillsetEPNS_20__sanitizer_sigset_tE>:

void internal_sigfillset(__sanitizer_sigset_t *set) {
  internal_memset(set, 0xff, sizeof(*set));
  40bb90:	ba 80 00 00 00       	mov    $0x80,%edx
  40bb95:	be ff 00 00 00       	mov    $0xff,%esi
  40bb9a:	e9 a1 e7 ff ff       	jmpq   40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  40bb9f:	90                   	nop

000000000040bba0 <_ZN11__sanitizer18internal_sigdelsetEPNS_20__sanitizer_sigset_tEi>:
}

#if SANITIZER_LINUX
void internal_sigdelset(__sanitizer_sigset_t *set, int signum) {
  signum -= 1;
  40bba0:	83 ee 01             	sub    $0x1,%esi
  CHECK_GE(signum, 0);
  CHECK_LT(signum, sizeof(*set) * 8);
  40bba3:	48 63 ce             	movslq %esi,%rcx
  40bba6:	48 81 f9 ff 03 00 00 	cmp    $0x3ff,%rcx
  40bbad:	77 19                	ja     40bbc8 <_ZN11__sanitizer18internal_sigdelsetEPNS_20__sanitizer_sigset_tEi+0x28>
  __sanitizer_kernel_sigset_t *k_set = (__sanitizer_kernel_sigset_t *)set;
  const uptr idx = signum / (sizeof(k_set->sig[0]) * 8);
  40bbaf:	48 89 ca             	mov    %rcx,%rdx
  const uptr bit = signum % (sizeof(k_set->sig[0]) * 8);
  40bbb2:	89 f1                	mov    %esi,%ecx
  k_set->sig[idx] &= ~(1 << bit);
  40bbb4:	b8 01 00 00 00       	mov    $0x1,%eax
  signum -= 1;
  CHECK_GE(signum, 0);
  CHECK_LT(signum, sizeof(*set) * 8);
  __sanitizer_kernel_sigset_t *k_set = (__sanitizer_kernel_sigset_t *)set;
  const uptr idx = signum / (sizeof(k_set->sig[0]) * 8);
  const uptr bit = signum % (sizeof(k_set->sig[0]) * 8);
  40bbb9:	83 e1 07             	and    $0x7,%ecx
void internal_sigdelset(__sanitizer_sigset_t *set, int signum) {
  signum -= 1;
  CHECK_GE(signum, 0);
  CHECK_LT(signum, sizeof(*set) * 8);
  __sanitizer_kernel_sigset_t *k_set = (__sanitizer_kernel_sigset_t *)set;
  const uptr idx = signum / (sizeof(k_set->sig[0]) * 8);
  40bbbc:	48 c1 ea 03          	shr    $0x3,%rdx
  const uptr bit = signum % (sizeof(k_set->sig[0]) * 8);
  k_set->sig[idx] &= ~(1 << bit);
  40bbc0:	d3 e0                	shl    %cl,%eax
  40bbc2:	f7 d0                	not    %eax
  40bbc4:	20 04 17             	and    %al,(%rdi,%rdx,1)
  40bbc7:	c3                   	retq   

#if SANITIZER_LINUX
void internal_sigdelset(__sanitizer_sigset_t *set, int signum) {
  signum -= 1;
  CHECK_GE(signum, 0);
  CHECK_LT(signum, sizeof(*set) * 8);
  40bbc8:	48 8d 15 59 b6 00 00 	lea    0xb659(%rip),%rdx        # 417228 <.LC11>
void internal_sigfillset(__sanitizer_sigset_t *set) {
  internal_memset(set, 0xff, sizeof(*set));
}

#if SANITIZER_LINUX
void internal_sigdelset(__sanitizer_sigset_t *set, int signum) {
  40bbcf:	50                   	push   %rax
  signum -= 1;
  CHECK_GE(signum, 0);
  CHECK_LT(signum, sizeof(*set) * 8);
  40bbd0:	48 8d 3d 71 b5 00 00 	lea    0xb571(%rip),%rdi        # 417148 <.LC2>
  40bbd7:	41 b8 00 04 00 00    	mov    $0x400,%r8d
  40bbdd:	be 75 02 00 00       	mov    $0x275,%esi
  40bbe2:	e8 09 98 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40bbe7:	90                   	nop
  40bbe8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40bbef:	00 

000000000040bbf0 <_ZN11__sanitizer12ThreadListerC1Ei>:
  k_set->sig[idx] &= ~(1 << bit);
}
#endif  // SANITIZER_LINUX

// ThreadLister implementation.
ThreadLister::ThreadLister(int pid)
  40bbf0:	41 54                	push   %r12
  40bbf2:	55                   	push   %rbp
  40bbf3:	89 f5                	mov    %esi,%ebp
  40bbf5:	53                   	push   %rbx
  40bbf6:	48 89 fb             	mov    %rdi,%rbx
  40bbf9:	48 83 ec 50          	sub    $0x50,%rsp
  : pid_(pid),
    descriptor_(-1),
    buffer_(4096),
    error_(true),
    entry_((struct linux_dirent *)buffer_.data()),
    bytes_read_(0) {
  40bbfd:	89 33                	mov    %esi,(%rbx)
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  40bbff:	48 8d 35 73 c9 00 00 	lea    0xc973(%rip),%rsi        # 418579 <.LC1>
  40bc06:	c7 47 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rdi)
// InternalAlloc is made libc-free.
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
  40bc0d:	48 c7 47 10 00 10 00 	movq   $0x1000,0x10(%rdi)
  40bc14:	00 
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  40bc15:	bf 00 10 00 00       	mov    $0x1000,%edi
  40bc1a:	e8 81 07 00 00       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  char task_directory_path[80];
  internal_snprintf(task_directory_path, sizeof(task_directory_path),
                    "/proc/%d/task/", pid);
  40bc1f:	48 8d 15 3b d0 00 00 	lea    0xd03b(%rip),%rdx        # 418c61 <.LC13>
  40bc26:	48 89 43 08          	mov    %rax,0x8(%rbx)
  : pid_(pid),
    descriptor_(-1),
    buffer_(4096),
    error_(true),
    entry_((struct linux_dirent *)buffer_.data()),
    bytes_read_(0) {
  40bc2a:	48 89 43 20          	mov    %rax,0x20(%rbx)
  char task_directory_path[80];
  internal_snprintf(task_directory_path, sizeof(task_directory_path),
                    "/proc/%d/task/", pid);
  40bc2e:	48 89 e7             	mov    %rsp,%rdi
  : pid_(pid),
    descriptor_(-1),
    buffer_(4096),
    error_(true),
    entry_((struct linux_dirent *)buffer_.data()),
    bytes_read_(0) {
  40bc31:	c6 43 18 01          	movb   $0x1,0x18(%rbx)
  40bc35:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%rbx)
  char task_directory_path[80];
  internal_snprintf(task_directory_path, sizeof(task_directory_path),
                    "/proc/%d/task/", pid);
  40bc3c:	89 e9                	mov    %ebp,%ecx
  40bc3e:	be 50 00 00 00       	mov    $0x50,%esi
  40bc43:	31 c0                	xor    %eax,%eax
  40bc45:	e8 76 1a 00 00       	callq  40d6c0 <_ZN11__sanitizer17internal_snprintfEPcmPKcz>

template <typename T1, typename T2>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2) : "rcx", "r11", "memory", "cc");
  40bc4a:	be 00 00 01 00       	mov    $0x10000,%esi
  40bc4f:	b8 02 00 00 00       	mov    $0x2,%eax
  40bc54:	48 89 e7             	mov    %rsp,%rdi
  40bc57:	0f 05                	syscall 
               "memory", "cc");
  return retval;
}

bool internal_iserror(uptr retval, int *rverrno) {
  if (retval >= (uptr)-4095) {
  40bc59:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
  40bc5f:	76 1f                	jbe    40bc80 <_ZN11__sanitizer12ThreadListerC1Ei+0x90>
  uptr openrv = internal_open(task_directory_path, O_RDONLY | O_DIRECTORY);
  if (internal_iserror(openrv)) {
    error_ = true;
    Report("Can't open /proc/%d/task for reading.\n", pid);
  40bc61:	48 8d 3d e8 b5 00 00 	lea    0xb5e8(%rip),%rdi        # 417250 <.LC14>
  char task_directory_path[80];
  internal_snprintf(task_directory_path, sizeof(task_directory_path),
                    "/proc/%d/task/", pid);
  uptr openrv = internal_open(task_directory_path, O_RDONLY | O_DIRECTORY);
  if (internal_iserror(openrv)) {
    error_ = true;
  40bc68:	c6 43 18 01          	movb   $0x1,0x18(%rbx)
    Report("Can't open /proc/%d/task for reading.\n", pid);
  40bc6c:	89 ee                	mov    %ebp,%esi
  40bc6e:	31 c0                	xor    %eax,%eax
  40bc70:	e8 1b 1e 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
  } else {
    error_ = false;
    descriptor_ = openrv;
  }
}
  40bc75:	48 83 c4 50          	add    $0x50,%rsp
  40bc79:	5b                   	pop    %rbx
  40bc7a:	5d                   	pop    %rbp
  40bc7b:	41 5c                	pop    %r12
  40bc7d:	c3                   	retq   
  40bc7e:	66 90                	xchg   %ax,%ax
  uptr openrv = internal_open(task_directory_path, O_RDONLY | O_DIRECTORY);
  if (internal_iserror(openrv)) {
    error_ = true;
    Report("Can't open /proc/%d/task for reading.\n", pid);
  } else {
    error_ = false;
  40bc80:	c6 43 18 00          	movb   $0x0,0x18(%rbx)
    descriptor_ = openrv;
  40bc84:	89 43 04             	mov    %eax,0x4(%rbx)
  }
}
  40bc87:	48 83 c4 50          	add    $0x50,%rsp
  40bc8b:	5b                   	pop    %rbx
  40bc8c:	5d                   	pop    %rbp
  40bc8d:	41 5c                	pop    %r12
  40bc8f:	c3                   	retq   

000000000040bc90 <_ZN11__sanitizer12ThreadLister10GetNextTIDEv>:

int ThreadLister::GetNextTID() {
  40bc90:	55                   	push   %rbp
  int tid = -1;
  40bc91:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d

template <typename T1, typename T2, typename T3>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3) : "rcx", "r11", "memory", "cc");
  40bc97:	bd 4e 00 00 00       	mov    $0x4e,%ebp
    error_ = false;
    descriptor_ = openrv;
  }
}

int ThreadLister::GetNextTID() {
  40bc9c:	53                   	push   %rbx
  40bc9d:	48 89 fb             	mov    %rdi,%rbx
  40bca0:	48 83 ec 08          	sub    $0x8,%rsp
  40bca4:	eb 42                	jmp    40bce8 <_ZN11__sanitizer12ThreadLister10GetNextTIDEv+0x58>
  40bca6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40bcad:	00 00 00 
  do {
    if (error_)
      return -1;
    if ((char *)entry_ >= &buffer_[bytes_read_] && !GetDirectoryEntries())
      return -1;
    if (entry_->d_ino != 0 && entry_->d_name[0] >= '0' &&
  40bcb0:	48 83 3f 00          	cmpq   $0x0,(%rdi)
  40bcb4:	74 22                	je     40bcd8 <_ZN11__sanitizer12ThreadLister10GetNextTIDEv+0x48>
  40bcb6:	0f b6 47 12          	movzbl 0x12(%rdi),%eax
  40bcba:	83 e8 30             	sub    $0x30,%eax
  40bcbd:	3c 09                	cmp    $0x9,%al
  40bcbf:	77 17                	ja     40bcd8 <_ZN11__sanitizer12ThreadLister10GetNextTIDEv+0x48>
        entry_->d_name[0] <= '9') {
      // Found a valid tid.
      tid = (int)internal_atoll(entry_->d_name);
  40bcc1:	48 83 c7 12          	add    $0x12,%rdi
  40bcc5:	e8 56 ef ff ff       	callq  40ac20 <_ZN11__sanitizer14internal_atollEPKc>
  40bcca:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
  40bcce:	41 89 c0             	mov    %eax,%r8d
  40bcd1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    }
    entry_ = (struct linux_dirent *)(((char *)entry_) + entry_->d_reclen);
  40bcd8:	0f b7 57 10          	movzwl 0x10(%rdi),%edx
  40bcdc:	48 01 d7             	add    %rdx,%rdi
  }
}

int ThreadLister::GetNextTID() {
  int tid = -1;
  do {
  40bcdf:	45 85 c0             	test   %r8d,%r8d
    if (entry_->d_ino != 0 && entry_->d_name[0] >= '0' &&
        entry_->d_name[0] <= '9') {
      // Found a valid tid.
      tid = (int)internal_atoll(entry_->d_name);
    }
    entry_ = (struct linux_dirent *)(((char *)entry_) + entry_->d_reclen);
  40bce2:	48 89 7b 20          	mov    %rdi,0x20(%rbx)
  }
}

int ThreadLister::GetNextTID() {
  int tid = -1;
  do {
  40bce6:	79 70                	jns    40bd58 <_ZN11__sanitizer12ThreadLister10GetNextTIDEv+0xc8>
    if (error_)
  40bce8:	80 7b 18 00          	cmpb   $0x0,0x18(%rbx)
  40bcec:	75 43                	jne    40bd31 <_ZN11__sanitizer12ThreadLister10GetNextTIDEv+0xa1>
      return -1;
    if ((char *)entry_ >= &buffer_[bytes_read_] && !GetDirectoryEntries())
  40bcee:	48 63 53 28          	movslq 0x28(%rbx),%rdx
  40bcf2:	48 8b 73 08          	mov    0x8(%rbx),%rsi
  40bcf6:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
  }
  ~InternalScopedBuffer() {
    UnmapOrDie(ptr_, cnt_ * sizeof(T));
  }
  T &operator[](uptr i) { return ptr_[i]; }
  40bcfa:	48 01 f2             	add    %rsi,%rdx
  40bcfd:	48 39 d7             	cmp    %rdx,%rdi
  40bd00:	72 ae                	jb     40bcb0 <_ZN11__sanitizer12ThreadLister10GetNextTIDEv+0x20>
  40bd02:	48 63 7b 04          	movslq 0x4(%rbx),%rdi
  40bd06:	8b 53 10             	mov    0x10(%rbx),%edx
  40bd09:	48 89 e8             	mov    %rbp,%rax
  40bd0c:	0f 05                	syscall 
  CHECK_GE(descriptor_, 0);
  CHECK_NE(error_, true);
  bytes_read_ = internal_getdents(descriptor_,
                                  (struct linux_dirent *)buffer_.data(),
                                  buffer_.size());
  if (internal_iserror(bytes_read_)) {
  40bd0e:	48 63 d0             	movslq %eax,%rdx
bool ThreadLister::GetDirectoryEntries() {
  CHECK_GE(descriptor_, 0);
  CHECK_NE(error_, true);
  bytes_read_ = internal_getdents(descriptor_,
                                  (struct linux_dirent *)buffer_.data(),
                                  buffer_.size());
  40bd11:	89 43 28             	mov    %eax,0x28(%rbx)
               "memory", "cc");
  return retval;
}

bool internal_iserror(uptr retval, int *rverrno) {
  if (retval >= (uptr)-4095) {
  40bd14:	48 81 fa 00 f0 ff ff 	cmp    $0xfffffffffffff000,%rdx
  40bd1b:	76 23                	jbe    40bd40 <_ZN11__sanitizer12ThreadLister10GetNextTIDEv+0xb0>
  if (internal_iserror(bytes_read_)) {
    Report("Can't read directory entries from /proc/%d/task.\n", pid_);
  40bd1d:	8b 33                	mov    (%rbx),%esi
  40bd1f:	48 8d 3d 52 b5 00 00 	lea    0xb552(%rip),%rdi        # 417278 <.LC15>
  40bd26:	31 c0                	xor    %eax,%eax
  40bd28:	e8 63 1d 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
    error_ = true;
  40bd2d:	c6 43 18 01          	movb   $0x1,0x18(%rbx)
      tid = (int)internal_atoll(entry_->d_name);
    }
    entry_ = (struct linux_dirent *)(((char *)entry_) + entry_->d_reclen);
  } while (tid < 0);
  return tid;
}
  40bd31:	48 83 c4 08          	add    $0x8,%rsp
  int tid = -1;
  do {
    if (error_)
      return -1;
    if ((char *)entry_ >= &buffer_[bytes_read_] && !GetDirectoryEntries())
      return -1;
  40bd35:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      tid = (int)internal_atoll(entry_->d_name);
    }
    entry_ = (struct linux_dirent *)(((char *)entry_) + entry_->d_reclen);
  } while (tid < 0);
  return tid;
}
  40bd3a:	5b                   	pop    %rbx
  40bd3b:	5d                   	pop    %rbp
  40bd3c:	c3                   	retq   
  40bd3d:	0f 1f 00             	nopl   (%rax)
                                  buffer_.size());
  if (internal_iserror(bytes_read_)) {
    Report("Can't read directory entries from /proc/%d/task.\n", pid_);
    error_ = true;
    return false;
  } else if (bytes_read_ == 0) {
  40bd40:	85 c0                	test   %eax,%eax
  40bd42:	74 ed                	je     40bd31 <_ZN11__sanitizer12ThreadLister10GetNextTIDEv+0xa1>
bool ThreadLister::GetDirectoryEntries() {
  CHECK_GE(descriptor_, 0);
  CHECK_NE(error_, true);
  bytes_read_ = internal_getdents(descriptor_,
                                  (struct linux_dirent *)buffer_.data(),
                                  buffer_.size());
  40bd44:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    error_ = true;
    return false;
  } else if (bytes_read_ == 0) {
    return false;
  }
  entry_ = (struct linux_dirent *)buffer_.data();
  40bd48:	48 89 7b 20          	mov    %rdi,0x20(%rbx)
  40bd4c:	e9 5f ff ff ff       	jmpq   40bcb0 <_ZN11__sanitizer12ThreadLister10GetNextTIDEv+0x20>
  40bd51:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      tid = (int)internal_atoll(entry_->d_name);
    }
    entry_ = (struct linux_dirent *)(((char *)entry_) + entry_->d_reclen);
  } while (tid < 0);
  return tid;
}
  40bd58:	48 83 c4 08          	add    $0x8,%rsp
  40bd5c:	44 89 c0             	mov    %r8d,%eax
  40bd5f:	5b                   	pop    %rbx
  40bd60:	5d                   	pop    %rbp
  40bd61:	c3                   	retq   
  40bd62:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40bd69:	1f 84 00 00 00 00 00 

000000000040bd70 <_ZN11__sanitizer12ThreadLister5ResetEv>:

void ThreadLister::Reset() {
  if (error_ || descriptor_ < 0)
  40bd70:	80 7f 18 00          	cmpb   $0x0,0x18(%rdi)
  40bd74:	75 14                	jne    40bd8a <_ZN11__sanitizer12ThreadLister5ResetEv+0x1a>
  40bd76:	48 63 7f 04          	movslq 0x4(%rdi),%rdi
  40bd7a:	85 ff                	test   %edi,%edi
  40bd7c:	78 0c                	js     40bd8a <_ZN11__sanitizer12ThreadLister5ResetEv+0x1a>

template <typename T1, typename T2, typename T3>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3) : "rcx", "r11", "memory", "cc");
  40bd7e:	31 d2                	xor    %edx,%edx
  40bd80:	b8 08 00 00 00       	mov    $0x8,%eax
  40bd85:	48 89 d6             	mov    %rdx,%rsi
  40bd88:	0f 05                	syscall 
  40bd8a:	f3 c3                	repz retq 
  40bd8c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040bd90 <_ZN11__sanitizer12ThreadListerD1Ev>:
    return;
  internal_lseek(descriptor_, 0, SEEK_SET);
}

ThreadLister::~ThreadLister() {
  40bd90:	48 89 fa             	mov    %rdi,%rdx
  if (descriptor_ >= 0)
  40bd93:	48 63 7f 04          	movslq 0x4(%rdi),%rdi
  40bd97:	85 ff                	test   %edi,%edi
  40bd99:	78 07                	js     40bda2 <_ZN11__sanitizer12ThreadListerD1Ev+0x12>

template <typename T1>
static uptr internal_syscall(u64 nr, T1 arg1) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1) :
               "rcx", "r11", "memory", "cc");
  40bd9b:	b8 03 00 00 00       	mov    $0x3,%eax
  40bda0:	0f 05                	syscall 
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  }
  ~InternalScopedBuffer() {
    UnmapOrDie(ptr_, cnt_ * sizeof(T));
  40bda2:	48 8b 72 10          	mov    0x10(%rdx),%rsi
  40bda6:	48 8b 7a 08          	mov    0x8(%rdx),%rdi
  40bdaa:	e9 91 06 00 00       	jmpq   40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  40bdaf:	90                   	nop

000000000040bdb0 <_ZN11__sanitizer12ThreadLister5errorEv>:
    internal_close(descriptor_);
}

bool ThreadLister::error() { return error_; }
  40bdb0:	0f b6 47 18          	movzbl 0x18(%rdi),%eax
  40bdb4:	c3                   	retq   
  40bdb5:	90                   	nop
  40bdb6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40bdbd:	00 00 00 

000000000040bdc0 <_ZN11__sanitizer12ThreadLister19GetDirectoryEntriesEv>:

bool ThreadLister::GetDirectoryEntries() {
  40bdc0:	55                   	push   %rbp
  40bdc1:	53                   	push   %rbx
  40bdc2:	48 89 fb             	mov    %rdi,%rbx
  40bdc5:	48 83 ec 08          	sub    $0x8,%rsp
  CHECK_GE(descriptor_, 0);
  CHECK_NE(error_, true);
  40bdc9:	0f b6 6f 18          	movzbl 0x18(%rdi),%ebp
}

bool ThreadLister::error() { return error_; }

bool ThreadLister::GetDirectoryEntries() {
  CHECK_GE(descriptor_, 0);
  40bdcd:	8b 47 04             	mov    0x4(%rdi),%eax
  CHECK_NE(error_, true);
  40bdd0:	40 84 ed             	test   %bpl,%bpl
  40bdd3:	75 58                	jne    40be2d <_ZN11__sanitizer12ThreadLister19GetDirectoryEntriesEv+0x6d>

template <typename T1, typename T2, typename T3>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3) : "rcx", "r11", "memory", "cc");
  40bdd5:	48 63 f8             	movslq %eax,%rdi
  40bdd8:	48 8b 73 08          	mov    0x8(%rbx),%rsi
  40bddc:	8b 53 10             	mov    0x10(%rbx),%edx
  40bddf:	b8 4e 00 00 00       	mov    $0x4e,%eax
  40bde4:	0f 05                	syscall 
  bytes_read_ = internal_getdents(descriptor_,
                                  (struct linux_dirent *)buffer_.data(),
                                  buffer_.size());
  if (internal_iserror(bytes_read_)) {
  40bde6:	48 63 d0             	movslq %eax,%rdx
bool ThreadLister::GetDirectoryEntries() {
  CHECK_GE(descriptor_, 0);
  CHECK_NE(error_, true);
  bytes_read_ = internal_getdents(descriptor_,
                                  (struct linux_dirent *)buffer_.data(),
                                  buffer_.size());
  40bde9:	89 43 28             	mov    %eax,0x28(%rbx)
               "memory", "cc");
  return retval;
}

bool internal_iserror(uptr retval, int *rverrno) {
  if (retval >= (uptr)-4095) {
  40bdec:	48 81 fa 00 f0 ff ff 	cmp    $0xfffffffffffff000,%rdx
  40bdf3:	77 1b                	ja     40be10 <_ZN11__sanitizer12ThreadLister19GetDirectoryEntriesEv+0x50>
  if (internal_iserror(bytes_read_)) {
    Report("Can't read directory entries from /proc/%d/task.\n", pid_);
    error_ = true;
    return false;
  } else if (bytes_read_ == 0) {
  40bdf5:	85 c0                	test   %eax,%eax
  40bdf7:	74 0d                	je     40be06 <_ZN11__sanitizer12ThreadLister19GetDirectoryEntriesEv+0x46>
    return false;
  }
  entry_ = (struct linux_dirent *)buffer_.data();
  40bdf9:	48 8b 43 08          	mov    0x8(%rbx),%rax
  return true;
  40bdfd:	bd 01 00 00 00       	mov    $0x1,%ebp
    error_ = true;
    return false;
  } else if (bytes_read_ == 0) {
    return false;
  }
  entry_ = (struct linux_dirent *)buffer_.data();
  40be02:	48 89 43 20          	mov    %rax,0x20(%rbx)
  return true;
}
  40be06:	48 83 c4 08          	add    $0x8,%rsp
  40be0a:	89 e8                	mov    %ebp,%eax
  40be0c:	5b                   	pop    %rbx
  40be0d:	5d                   	pop    %rbp
  40be0e:	c3                   	retq   
  40be0f:	90                   	nop
  CHECK_NE(error_, true);
  bytes_read_ = internal_getdents(descriptor_,
                                  (struct linux_dirent *)buffer_.data(),
                                  buffer_.size());
  if (internal_iserror(bytes_read_)) {
    Report("Can't read directory entries from /proc/%d/task.\n", pid_);
  40be10:	8b 33                	mov    (%rbx),%esi
  40be12:	48 8d 3d 5f b4 00 00 	lea    0xb45f(%rip),%rdi        # 417278 <.LC15>
  40be19:	31 c0                	xor    %eax,%eax
  40be1b:	e8 70 1c 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
    error_ = true;
  40be20:	c6 43 18 01          	movb   $0x1,0x18(%rbx)
  } else if (bytes_read_ == 0) {
    return false;
  }
  entry_ = (struct linux_dirent *)buffer_.data();
  return true;
}
  40be24:	48 83 c4 08          	add    $0x8,%rsp
  40be28:	89 e8                	mov    %ebp,%eax
  40be2a:	5b                   	pop    %rbx
  40be2b:	5d                   	pop    %rbp
  40be2c:	c3                   	retq   

bool ThreadLister::error() { return error_; }

bool ThreadLister::GetDirectoryEntries() {
  CHECK_GE(descriptor_, 0);
  CHECK_NE(error_, true);
  40be2d:	48 8d 15 3c ce 00 00 	lea    0xce3c(%rip),%rdx        # 418c70 <.LC16>
  40be34:	48 8d 3d 0d b3 00 00 	lea    0xb30d(%rip),%rdi        # 417148 <.LC2>
  40be3b:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  40be41:	b9 01 00 00 00       	mov    $0x1,%ecx
  40be46:	be b2 02 00 00       	mov    $0x2b2,%esi
  40be4b:	e8 a0 95 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

000000000040be50 <_ZN11__sanitizer11GetPageSizeEv>:
#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__i386__))
  return EXEC_PAGESIZE;
#else
  return sysconf(_SC_PAGESIZE);  // EXEC_PAGESIZE may not be trustworthy.
#endif
}
  40be50:	b8 00 10 00 00       	mov    $0x1000,%eax
  40be55:	c3                   	retq   
  40be56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40be5d:	00 00 00 

000000000040be60 <_ZN11__sanitizer14ReadBinaryNameEPcm>:

uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {
  40be60:	41 54                	push   %r12

template <typename T1, typename T2, typename T3>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3) : "rcx", "r11", "memory", "cc");
  40be62:	4c 8d 25 a3 cd 00 00 	lea    0xcda3(%rip),%r12        # 418c0c <.LC5>
  40be69:	b8 59 00 00 00       	mov    $0x59,%eax
  40be6e:	55                   	push   %rbp
  40be6f:	48 89 fd             	mov    %rdi,%rbp
  40be72:	4c 89 e7             	mov    %r12,%rdi
  40be75:	53                   	push   %rbx
  40be76:	48 89 f3             	mov    %rsi,%rbx
  40be79:	48 89 ee             	mov    %rbp,%rsi
  40be7c:	48 89 da             	mov    %rbx,%rdx
  40be7f:	0f 05                	syscall 
  40be81:	49 89 c1             	mov    %rax,%r9
               "memory", "cc");
  return retval;
}

bool internal_iserror(uptr retval, int *rverrno) {
  if (retval >= (uptr)-4095) {
  40be84:	49 81 f9 00 f0 ff ff 	cmp    $0xfffffffffffff000,%r9
  40be8b:	76 31                	jbe    40bebe <_ZN11__sanitizer14ReadBinaryNameEPcm+0x5e>
    if (rverrno)
      *rverrno = -retval;
  40be8d:	44 89 ce             	mov    %r9d,%esi
  bool IsErr = internal_iserror(module_name_len, &readlink_error);
#endif
  if (IsErr) {
    // We can't read binary name for some reason, assume it's unknown.
    Report("WARNING: reading executable name failed with errno %d, "
           "some stack frames may not be symbolized\n", readlink_error);
  40be90:	48 8d 3d 19 b4 00 00 	lea    0xb419(%rip),%rdi        # 4172b0 <.LC17>
  40be97:	31 c0                	xor    %eax,%eax
  40be99:	f7 de                	neg    %esi
  40be9b:	e8 f0 1b 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
    module_name_len = internal_snprintf(buf, buf_len, "%s",
                                        default_module_name);
  40bea0:	48 8d 15 6b c6 00 00 	lea    0xc66b(%rip),%rdx        # 418512 <.LC18>
  40bea7:	31 c0                	xor    %eax,%eax
  40bea9:	4c 89 e1             	mov    %r12,%rcx
  40beac:	48 89 de             	mov    %rbx,%rsi
  40beaf:	48 89 ef             	mov    %rbp,%rdi
  40beb2:	e8 09 18 00 00       	callq  40d6c0 <_ZN11__sanitizer17internal_snprintfEPcmPKcz>
  40beb7:	48 98                	cltq   
    CHECK_LT(module_name_len, buf_len);
  40beb9:	48 39 c3             	cmp    %rax,%rbx
  40bebc:	76 05                	jbe    40bec3 <_ZN11__sanitizer14ReadBinaryNameEPcm+0x63>
  }
  return module_name_len;
}
  40bebe:	5b                   	pop    %rbx
  40bebf:	5d                   	pop    %rbp
  40bec0:	41 5c                	pop    %r12
  40bec2:	c3                   	retq   
    // We can't read binary name for some reason, assume it's unknown.
    Report("WARNING: reading executable name failed with errno %d, "
           "some stack frames may not be symbolized\n", readlink_error);
    module_name_len = internal_snprintf(buf, buf_len, "%s",
                                        default_module_name);
    CHECK_LT(module_name_len, buf_len);
  40bec3:	48 8d 15 46 b4 00 00 	lea    0xb446(%rip),%rdx        # 417310 <.LC19>
  40beca:	48 8d 3d 77 b2 00 00 	lea    0xb277(%rip),%rdi        # 417148 <.LC2>
  40bed1:	49 89 d8             	mov    %rbx,%r8
  40bed4:	48 89 c1             	mov    %rax,%rcx
  40bed7:	be de 02 00 00       	mov    $0x2de,%esi
  40bedc:	e8 0f 95 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40bee1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40bee8:	0f 1f 84 00 00 00 00 
  40beef:	00 

000000000040bef0 <_ZN11__sanitizer19ReadLongProcessNameEPcm>:
  }
  return module_name_len;
}

uptr ReadLongProcessName(/*out*/ char *buf, uptr buf_len) {
  40bef0:	41 54                	push   %r12
#if SANITIZER_LINUX
  char *tmpbuf;
  uptr tmpsize;
  uptr tmplen;
  if (ReadFileToBuffer("/proc/self/cmdline", &tmpbuf, &tmpsize, &tmplen,
  40bef2:	45 31 c9             	xor    %r9d,%r9d
  40bef5:	41 b8 00 00 10 00    	mov    $0x100000,%r8d
    CHECK_LT(module_name_len, buf_len);
  }
  return module_name_len;
}

uptr ReadLongProcessName(/*out*/ char *buf, uptr buf_len) {
  40befb:	55                   	push   %rbp
  40befc:	48 89 f5             	mov    %rsi,%rbp
  40beff:	53                   	push   %rbx
  40bf00:	48 89 fb             	mov    %rdi,%rbx
#if SANITIZER_LINUX
  char *tmpbuf;
  uptr tmpsize;
  uptr tmplen;
  if (ReadFileToBuffer("/proc/self/cmdline", &tmpbuf, &tmpsize, &tmplen,
  40bf03:	48 8d 3d ef cc 00 00 	lea    0xccef(%rip),%rdi        # 418bf9 <.LC4>
    CHECK_LT(module_name_len, buf_len);
  }
  return module_name_len;
}

uptr ReadLongProcessName(/*out*/ char *buf, uptr buf_len) {
  40bf0a:	48 83 ec 30          	sub    $0x30,%rsp
#if SANITIZER_LINUX
  char *tmpbuf;
  uptr tmpsize;
  uptr tmplen;
  if (ReadFileToBuffer("/proc/self/cmdline", &tmpbuf, &tmpsize, &tmplen,
  40bf0e:	48 8d 4c 24 20       	lea    0x20(%rsp),%rcx
  40bf13:	48 8d 54 24 10       	lea    0x10(%rsp),%rdx
  40bf18:	48 89 e6             	mov    %rsp,%rsi
  40bf1b:	e8 d0 96 ff ff       	callq  4055f0 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi>
  40bf20:	84 c0                	test   %al,%al
  40bf22:	0f 85 88 00 00 00    	jne    40bfb0 <_ZN11__sanitizer19ReadLongProcessNameEPcm+0xc0>

template <typename T1, typename T2, typename T3>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3) : "rcx", "r11", "memory", "cc");
  40bf28:	4c 8d 25 dd cc 00 00 	lea    0xccdd(%rip),%r12        # 418c0c <.LC5>
  40bf2f:	b8 59 00 00 00       	mov    $0x59,%eax
  40bf34:	48 89 de             	mov    %rbx,%rsi
  40bf37:	48 89 ea             	mov    %rbp,%rdx
  40bf3a:	4c 89 e7             	mov    %r12,%rdi
  40bf3d:	0f 05                	syscall 
               "memory", "cc");
  return retval;
}

bool internal_iserror(uptr retval, int *rverrno) {
  if (retval >= (uptr)-4095) {
  40bf3f:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax

template <typename T1, typename T2, typename T3>
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3) {
  u64 retval;
  asm volatile("syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3) : "rcx", "r11", "memory", "cc");
  40bf45:	48 89 c1             	mov    %rax,%rcx
               "memory", "cc");
  return retval;
}

bool internal_iserror(uptr retval, int *rverrno) {
  if (retval >= (uptr)-4095) {
  40bf48:	77 16                	ja     40bf60 <_ZN11__sanitizer19ReadLongProcessNameEPcm+0x70>
    UnmapOrDie(tmpbuf, tmpsize);
    return internal_strlen(buf);
  }
#endif
  return ReadBinaryName(buf, buf_len);
}
  40bf4a:	48 83 c4 30          	add    $0x30,%rsp
    internal_strncpy(buf, tmpbuf, buf_len);
    UnmapOrDie(tmpbuf, tmpsize);
    return internal_strlen(buf);
  }
#endif
  return ReadBinaryName(buf, buf_len);
  40bf4e:	48 89 c8             	mov    %rcx,%rax
}
  40bf51:	5b                   	pop    %rbx
  40bf52:	5d                   	pop    %rbp
  40bf53:	41 5c                	pop    %r12
  40bf55:	c3                   	retq   
  40bf56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40bf5d:	00 00 00 
    if (rverrno)
      *rverrno = -retval;
  40bf60:	89 c6                	mov    %eax,%esi
  bool IsErr = internal_iserror(module_name_len, &readlink_error);
#endif
  if (IsErr) {
    // We can't read binary name for some reason, assume it's unknown.
    Report("WARNING: reading executable name failed with errno %d, "
           "some stack frames may not be symbolized\n", readlink_error);
  40bf62:	48 8d 3d 47 b3 00 00 	lea    0xb347(%rip),%rdi        # 4172b0 <.LC17>
  40bf69:	31 c0                	xor    %eax,%eax
  40bf6b:	f7 de                	neg    %esi
  40bf6d:	e8 1e 1b 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
    module_name_len = internal_snprintf(buf, buf_len, "%s",
                                        default_module_name);
  40bf72:	48 8d 15 99 c5 00 00 	lea    0xc599(%rip),%rdx        # 418512 <.LC18>
  40bf79:	4c 89 e1             	mov    %r12,%rcx
  40bf7c:	31 c0                	xor    %eax,%eax
  40bf7e:	48 89 ee             	mov    %rbp,%rsi
  40bf81:	48 89 df             	mov    %rbx,%rdi
  40bf84:	e8 37 17 00 00       	callq  40d6c0 <_ZN11__sanitizer17internal_snprintfEPcmPKcz>
  40bf89:	48 63 c8             	movslq %eax,%rcx
    CHECK_LT(module_name_len, buf_len);
  40bf8c:	48 39 cd             	cmp    %rcx,%rbp
  40bf8f:	77 b9                	ja     40bf4a <_ZN11__sanitizer19ReadLongProcessNameEPcm+0x5a>
  40bf91:	48 8d 15 78 b3 00 00 	lea    0xb378(%rip),%rdx        # 417310 <.LC19>
  40bf98:	48 8d 3d a9 b1 00 00 	lea    0xb1a9(%rip),%rdi        # 417148 <.LC2>
  40bf9f:	49 89 e8             	mov    %rbp,%r8
  40bfa2:	be de 02 00 00       	mov    $0x2de,%esi
  40bfa7:	e8 44 94 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40bfac:	0f 1f 40 00          	nopl   0x0(%rax)
  char *tmpbuf;
  uptr tmpsize;
  uptr tmplen;
  if (ReadFileToBuffer("/proc/self/cmdline", &tmpbuf, &tmpsize, &tmplen,
                       1024 * 1024)) {
    internal_strncpy(buf, tmpbuf, buf_len);
  40bfb0:	48 8b 34 24          	mov    (%rsp),%rsi
  40bfb4:	48 89 ea             	mov    %rbp,%rdx
  40bfb7:	48 89 df             	mov    %rbx,%rdi
  40bfba:	e8 f1 e9 ff ff       	callq  40a9b0 <_ZN11__sanitizer16internal_strncpyEPcPKcm>
    UnmapOrDie(tmpbuf, tmpsize);
  40bfbf:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40bfc4:	48 8b 3c 24          	mov    (%rsp),%rdi
  40bfc8:	e8 73 04 00 00       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
    return internal_strlen(buf);
  40bfcd:	48 89 df             	mov    %rbx,%rdi
  40bfd0:	e8 5b e9 ff ff       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  }
#endif
  return ReadBinaryName(buf, buf_len);
}
  40bfd5:	48 83 c4 30          	add    $0x30,%rsp
  40bfd9:	5b                   	pop    %rbx
  40bfda:	5d                   	pop    %rbp
  40bfdb:	41 5c                	pop    %r12
  40bfdd:	c3                   	retq   
  40bfde:	66 90                	xchg   %ax,%ax

000000000040bfe0 <_ZN11__sanitizer13LibraryNameIsEPKcS1_>:

// Match full names of the form /path/to/base_name{-,.}*
bool LibraryNameIs(const char *full_name, const char *base_name) {
  40bfe0:	41 54                	push   %r12
  40bfe2:	55                   	push   %rbp
  40bfe3:	48 89 f5             	mov    %rsi,%rbp
  40bfe6:	53                   	push   %rbx
  const char *name = full_name;
  // Strip path.
  while (*name != '\0') name++;
  40bfe7:	80 3f 00             	cmpb   $0x0,(%rdi)
  40bfea:	74 6d                	je     40c059 <_ZN11__sanitizer13LibraryNameIsEPKcS1_+0x79>
  40bfec:	48 89 f8             	mov    %rdi,%rax
  40bfef:	90                   	nop
  40bff0:	48 83 c0 01          	add    $0x1,%rax
  40bff4:	80 38 00             	cmpb   $0x0,(%rax)
  40bff7:	75 f7                	jne    40bff0 <_ZN11__sanitizer13LibraryNameIsEPKcS1_+0x10>
  while (name > full_name && *name != '/') name--;
  40bff9:	48 39 f8             	cmp    %rdi,%rax
  40bffc:	77 0b                	ja     40c009 <_ZN11__sanitizer13LibraryNameIsEPKcS1_+0x29>
  40bffe:	eb 56                	jmp    40c056 <_ZN11__sanitizer13LibraryNameIsEPKcS1_+0x76>
  40c000:	80 78 ff 2f          	cmpb   $0x2f,-0x1(%rax)
  40c004:	74 4a                	je     40c050 <_ZN11__sanitizer13LibraryNameIsEPKcS1_+0x70>
  40c006:	48 89 d8             	mov    %rbx,%rax
  40c009:	48 8d 58 ff          	lea    -0x1(%rax),%rbx
  40c00d:	48 39 fb             	cmp    %rdi,%rbx
  40c010:	75 ee                	jne    40c000 <_ZN11__sanitizer13LibraryNameIsEPKcS1_+0x20>
  if (*name == '/') name++;
  40c012:	80 78 ff 2f          	cmpb   $0x2f,-0x1(%rax)
  40c016:	74 38                	je     40c050 <_ZN11__sanitizer13LibraryNameIsEPKcS1_+0x70>
  uptr base_name_length = internal_strlen(base_name);
  40c018:	48 89 ef             	mov    %rbp,%rdi
  40c01b:	e8 10 e9 ff ff       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  if (internal_strncmp(name, base_name, base_name_length)) return false;
  40c020:	48 89 ee             	mov    %rbp,%rsi
  40c023:	48 89 c2             	mov    %rax,%rdx
  40c026:	48 89 df             	mov    %rbx,%rdi
  const char *name = full_name;
  // Strip path.
  while (*name != '\0') name++;
  while (name > full_name && *name != '/') name--;
  if (*name == '/') name++;
  uptr base_name_length = internal_strlen(base_name);
  40c029:	49 89 c4             	mov    %rax,%r12
  if (internal_strncmp(name, base_name, base_name_length)) return false;
  40c02c:	e8 ef e7 ff ff       	callq  40a820 <_ZN11__sanitizer16internal_strncmpEPKcS1_m>
  40c031:	31 c9                	xor    %ecx,%ecx
  40c033:	85 c0                	test   %eax,%eax
  40c035:	75 0d                	jne    40c044 <_ZN11__sanitizer13LibraryNameIsEPKcS1_+0x64>
  return (name[base_name_length] == '-' || name[base_name_length] == '.');
  40c037:	42 0f b6 04 23       	movzbl (%rbx,%r12,1),%eax
  40c03c:	83 e8 2d             	sub    $0x2d,%eax
  40c03f:	3c 01                	cmp    $0x1,%al
  40c041:	0f 96 c1             	setbe  %cl
}
  40c044:	5b                   	pop    %rbx
  40c045:	5d                   	pop    %rbp
  40c046:	89 c8                	mov    %ecx,%eax
  40c048:	41 5c                	pop    %r12
  40c04a:	c3                   	retq   
  40c04b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
bool LibraryNameIs(const char *full_name, const char *base_name) {
  const char *name = full_name;
  // Strip path.
  while (*name != '\0') name++;
  while (name > full_name && *name != '/') name--;
  if (*name == '/') name++;
  40c050:	48 83 c3 01          	add    $0x1,%rbx
  40c054:	eb c2                	jmp    40c018 <_ZN11__sanitizer13LibraryNameIsEPKcS1_+0x38>
// Match full names of the form /path/to/base_name{-,.}*
bool LibraryNameIs(const char *full_name, const char *base_name) {
  const char *name = full_name;
  // Strip path.
  while (*name != '\0') name++;
  while (name > full_name && *name != '/') name--;
  40c056:	48 89 c7             	mov    %rax,%rdi
  40c059:	48 89 fb             	mov    %rdi,%rbx
  40c05c:	eb ba                	jmp    40c018 <_ZN11__sanitizer13LibraryNameIsEPKcS1_+0x38>
  40c05e:	66 90                	xchg   %ax,%ax

000000000040c060 <_ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE>:
  return (name[base_name_length] == '-' || name[base_name_length] == '.');
}

#if !SANITIZER_ANDROID
// Call cb for each region mapped by map.
void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr)) {
  40c060:	41 57                	push   %r15
  40c062:	41 56                	push   %r14
  40c064:	41 55                	push   %r13
  40c066:	41 54                	push   %r12
  40c068:	55                   	push   %rbp
  40c069:	53                   	push   %rbx
  40c06a:	48 83 ec 18          	sub    $0x18,%rsp
  CHECK_NE(map, nullptr);
  40c06e:	48 85 ff             	test   %rdi,%rdi
  return (name[base_name_length] == '-' || name[base_name_length] == '.');
}

#if !SANITIZER_ANDROID
// Call cb for each region mapped by map.
void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr)) {
  40c071:	48 89 34 24          	mov    %rsi,(%rsp)
  CHECK_NE(map, nullptr);
  40c075:	0f 84 e4 00 00 00    	je     40c15f <_ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE+0xff>
#if !SANITIZER_FREEBSD
  typedef ElfW(Phdr) Elf_Phdr;
  typedef ElfW(Ehdr) Elf_Ehdr;
#endif  // !SANITIZER_FREEBSD
  char *base = (char *)map->l_addr;
  40c07b:	4c 8b 2f             	mov    (%rdi),%r13
  char *phdrs_end = phdrs + ehdr->e_phnum * ehdr->e_phentsize;

  // Find the segment with the minimum base so we can "relocate" the p_vaddr
  // fields.  Typically ET_DYN objects (DSOs) have base of zero and ET_EXEC
  // objects have a non-zero base.
  uptr preferred_base = (uptr)-1;
  40c07e:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
  typedef ElfW(Ehdr) Elf_Ehdr;
#endif  // !SANITIZER_FREEBSD
  char *base = (char *)map->l_addr;
  Elf_Ehdr *ehdr = (Elf_Ehdr *)base;
  char *phdrs = base + ehdr->e_phoff;
  char *phdrs_end = phdrs + ehdr->e_phnum * ehdr->e_phentsize;
  40c085:	41 0f b7 55 36       	movzwl 0x36(%r13),%edx
  40c08a:	41 0f b7 6d 38       	movzwl 0x38(%r13),%ebp
  typedef ElfW(Phdr) Elf_Phdr;
  typedef ElfW(Ehdr) Elf_Ehdr;
#endif  // !SANITIZER_FREEBSD
  char *base = (char *)map->l_addr;
  Elf_Ehdr *ehdr = (Elf_Ehdr *)base;
  char *phdrs = base + ehdr->e_phoff;
  40c08f:	4c 89 eb             	mov    %r13,%rbx
  40c092:	49 03 5d 20          	add    0x20(%r13),%rbx
  char *phdrs_end = phdrs + ehdr->e_phnum * ehdr->e_phentsize;
  40c096:	0f b7 c2             	movzwl %dx,%eax
  40c099:	0f b7 ca             	movzwl %dx,%ecx
  40c09c:	0f af e8             	imul   %eax,%ebp

  // Find the segment with the minimum base so we can "relocate" the p_vaddr
  // fields.  Typically ET_DYN objects (DSOs) have base of zero and ET_EXEC
  // objects have a non-zero base.
  uptr preferred_base = (uptr)-1;
  for (char *iter = phdrs; iter != phdrs_end; iter += ehdr->e_phentsize) {
  40c09f:	48 89 d8             	mov    %rbx,%rax
  typedef ElfW(Ehdr) Elf_Ehdr;
#endif  // !SANITIZER_FREEBSD
  char *base = (char *)map->l_addr;
  Elf_Ehdr *ehdr = (Elf_Ehdr *)base;
  char *phdrs = base + ehdr->e_phoff;
  char *phdrs_end = phdrs + ehdr->e_phnum * ehdr->e_phentsize;
  40c0a2:	48 63 ed             	movslq %ebp,%rbp
  40c0a5:	48 01 dd             	add    %rbx,%rbp

  // Find the segment with the minimum base so we can "relocate" the p_vaddr
  // fields.  Typically ET_DYN objects (DSOs) have base of zero and ET_EXEC
  // objects have a non-zero base.
  uptr preferred_base = (uptr)-1;
  for (char *iter = phdrs; iter != phdrs_end; iter += ehdr->e_phentsize) {
  40c0a8:	48 39 eb             	cmp    %rbp,%rbx
  40c0ab:	75 13                	jne    40c0c0 <_ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE+0x60>
  40c0ad:	e9 9e 00 00 00       	jmpq   40c150 <_ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE+0xf0>
  40c0b2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40c0b8:	48 01 c8             	add    %rcx,%rax
  40c0bb:	48 39 c5             	cmp    %rax,%rbp
  40c0be:	74 18                	je     40c0d8 <_ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE+0x78>
    Elf_Phdr *phdr = (Elf_Phdr *)iter;
    if (phdr->p_type == PT_LOAD && preferred_base > (uptr)phdr->p_vaddr)
  40c0c0:	83 38 01             	cmpl   $0x1,(%rax)
  40c0c3:	75 f3                	jne    40c0b8 <_ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE+0x58>
  40c0c5:	48 8b 78 10          	mov    0x10(%rax),%rdi
  40c0c9:	48 39 fe             	cmp    %rdi,%rsi
  40c0cc:	48 0f 47 f7          	cmova  %rdi,%rsi

  // Find the segment with the minimum base so we can "relocate" the p_vaddr
  // fields.  Typically ET_DYN objects (DSOs) have base of zero and ET_EXEC
  // objects have a non-zero base.
  uptr preferred_base = (uptr)-1;
  for (char *iter = phdrs; iter != phdrs_end; iter += ehdr->e_phentsize) {
  40c0d0:	48 01 c8             	add    %rcx,%rax
  40c0d3:	48 39 c5             	cmp    %rax,%rbp
  40c0d6:	75 e8                	jne    40c0c0 <_ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE+0x60>
    if (phdr->p_type == PT_LOAD && preferred_base > (uptr)phdr->p_vaddr)
      preferred_base = (uptr)phdr->p_vaddr;
  }

  // Compute the delta from the real base to get a relocation delta.
  sptr delta = (uptr)base - preferred_base;
  40c0d8:	4c 89 e8             	mov    %r13,%rax
  40c0db:	48 29 f0             	sub    %rsi,%rax
  40c0de:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40c0e3:	eb 0e                	jmp    40c0f3 <_ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE+0x93>
  40c0e5:	0f 1f 00             	nopl   (%rax)
  // Now we can figure out what the loader really mapped.
  for (char *iter = phdrs; iter != phdrs_end; iter += ehdr->e_phentsize) {
  40c0e8:	0f b7 c2             	movzwl %dx,%eax
  40c0eb:	48 01 c3             	add    %rax,%rbx
  40c0ee:	48 39 dd             	cmp    %rbx,%rbp
  40c0f1:	74 5d                	je     40c150 <_ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE+0xf0>
    Elf_Phdr *phdr = (Elf_Phdr *)iter;
    if (phdr->p_type == PT_LOAD) {
  40c0f3:	83 3b 01             	cmpl   $0x1,(%rbx)
  40c0f6:	75 f0                	jne    40c0e8 <_ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE+0x88>
      uptr seg_start = phdr->p_vaddr + delta;
  40c0f8:	4c 8b 7c 24 08       	mov    0x8(%rsp),%r15
  40c0fd:	4c 03 7b 10          	add    0x10(%rbx),%r15
      uptr seg_end = seg_start + phdr->p_memsz;
  40c101:	4c 8b 63 28          	mov    0x28(%rbx),%r12
      // None of these values are aligned.  We consider the ragged edges of the
      // load command as defined, since they are mapped from the file.
      seg_start = RoundDownTo(seg_start, GetPageSizeCached());
  40c105:	e8 a6 8f ff ff       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
  40c10a:	49 89 c6             	mov    %rax,%r14
      seg_end = RoundUpTo(seg_end, GetPageSizeCached());
  40c10d:	e8 9e 8f ff ff       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
#endif
  return up;
}

INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
  40c112:	48 8d 48 ff          	lea    -0x1(%rax),%rcx
  CHECK(IsPowerOfTwo(boundary));
  return (size + boundary - 1) & ~(boundary - 1);
}

INLINE uptr RoundDownTo(uptr x, uptr boundary) {
  return x & ~(boundary - 1);
  40c116:	49 f7 de             	neg    %r14
  40c119:	4d 21 fe             	and    %r15,%r14
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40c11c:	48 85 c1             	test   %rax,%rcx
  40c11f:	75 5b                	jne    40c17c <_ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE+0x11c>
  return (size + boundary - 1) & ~(boundary - 1);
  40c121:	4b 8d 54 27 ff       	lea    -0x1(%r15,%r12,1),%rdx
  40c126:	48 89 c6             	mov    %rax,%rsi
      cb((void *)seg_start, seg_end - seg_start);
  40c129:	4c 89 f7             	mov    %r14,%rdi
  40c12c:	48 f7 de             	neg    %rsi
  40c12f:	48 01 d0             	add    %rdx,%rax
  40c132:	48 21 c6             	and    %rax,%rsi
  40c135:	48 8b 04 24          	mov    (%rsp),%rax
  40c139:	4c 29 f6             	sub    %r14,%rsi
  40c13c:	ff d0                	callq  *%rax
  40c13e:	41 0f b7 55 36       	movzwl 0x36(%r13),%edx
  }

  // Compute the delta from the real base to get a relocation delta.
  sptr delta = (uptr)base - preferred_base;
  // Now we can figure out what the loader really mapped.
  for (char *iter = phdrs; iter != phdrs_end; iter += ehdr->e_phentsize) {
  40c143:	0f b7 c2             	movzwl %dx,%eax
  40c146:	48 01 c3             	add    %rax,%rbx
  40c149:	48 39 dd             	cmp    %rbx,%rbp
  40c14c:	75 a5                	jne    40c0f3 <_ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE+0x93>
  40c14e:	66 90                	xchg   %ax,%ax
      seg_start = RoundDownTo(seg_start, GetPageSizeCached());
      seg_end = RoundUpTo(seg_end, GetPageSizeCached());
      cb((void *)seg_start, seg_end - seg_start);
    }
  }
}
  40c150:	48 83 c4 18          	add    $0x18,%rsp
  40c154:	5b                   	pop    %rbx
  40c155:	5d                   	pop    %rbp
  40c156:	41 5c                	pop    %r12
  40c158:	41 5d                	pop    %r13
  40c15a:	41 5e                	pop    %r14
  40c15c:	41 5f                	pop    %r15
  40c15e:	c3                   	retq   
}

#if !SANITIZER_ANDROID
// Call cb for each region mapped by map.
void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr)) {
  CHECK_NE(map, nullptr);
  40c15f:	48 8d 15 21 cb 00 00 	lea    0xcb21(%rip),%rdx        # 418c87 <.LC20>
  40c166:	48 8d 3d db af 00 00 	lea    0xafdb(%rip),%rdi        # 417148 <.LC2>
  40c16d:	45 31 c0             	xor    %r8d,%r8d
  40c170:	31 c9                	xor    %ecx,%ecx
  40c172:	be 01 03 00 00       	mov    $0x301,%esi
  40c177:	e8 74 92 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40c17c:	48 8d 15 7d 91 00 00 	lea    0x917d(%rip),%rdx        # 415300 <.LC19>
  40c183:	48 8d 3d 86 8e 00 00 	lea    0x8e86(%rip),%rdi        # 415010 <.LC1>
  40c18a:	45 31 c0             	xor    %r8d,%r8d
  40c18d:	31 c9                	xor    %ecx,%ecx
  40c18f:	be a9 01 00 00       	mov    $0x1a9,%esi
  40c194:	e8 57 92 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40c199:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000040c1a0 <_ZN11__sanitizer14internal_cloneEPFiPvES0_iS0_PiS0_S3_>:
// descriptor to keep glibc happy). So the stock version of clone(), when
// used with CLONE_VM, would end up corrupting the parent's thread descriptor.
uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,
                    int *parent_tidptr, void *newtls, int *child_tidptr) {
  long long res;
  if (!fn || !child_stack)
  40c1a0:	48 85 ff             	test   %rdi,%rdi
  40c1a3:	75 0b                	jne    40c1b0 <_ZN11__sanitizer14internal_cloneEPFiPvES0_iS0_PiS0_S3_+0x10>
    return -EINVAL;
  40c1a5:	48 c7 c0 ea ff ff ff 	mov    $0xffffffffffffffea,%rax
  40c1ac:	c3                   	retq   
  40c1ad:	0f 1f 00             	nopl   (%rax)
// descriptor to keep glibc happy). So the stock version of clone(), when
// used with CLONE_VM, would end up corrupting the parent's thread descriptor.
uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,
                    int *parent_tidptr, void *newtls, int *child_tidptr) {
  long long res;
  if (!fn || !child_stack)
  40c1b0:	48 85 f6             	test   %rsi,%rsi
  40c1b3:	74 f0                	je     40c1a5 <_ZN11__sanitizer14internal_cloneEPFiPvES0_iS0_PiS0_S3_+0x5>
// descriptor, but in our case the child task shares the thread descriptor with
// the parent (because we don't know how to allocate a new thread
// descriptor to keep glibc happy). So the stock version of clone(), when
// used with CLONE_VM, would end up corrupting the parent's thread descriptor.
uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,
                    int *parent_tidptr, void *newtls, int *child_tidptr) {
  40c1b5:	53                   	push   %rbx
  40c1b6:	89 d3                	mov    %edx,%ebx
  40c1b8:	4c 89 c2             	mov    %r8,%rdx
  long long res;
  if (!fn || !child_stack)
    return -EINVAL;
  CHECK_EQ(0, (uptr)child_stack % 16);
  40c1bb:	49 89 f0             	mov    %rsi,%r8
  40c1be:	41 83 e0 0f          	and    $0xf,%r8d
  40c1c2:	75 37                	jne    40c1fb <_ZN11__sanitizer14internal_cloneEPFiPvES0_iS0_PiS0_S3_+0x5b>
  child_stack = (char *)child_stack - 2 * sizeof(unsigned long long);
  ((unsigned long long *)child_stack)[0] = (uptr)fn;
  40c1c4:	48 89 7e f0          	mov    %rdi,-0x10(%rsi)
  ((unsigned long long *)child_stack)[1] = (uptr)arg;
  40c1c8:	48 89 4e f8          	mov    %rcx,-0x8(%rsi)
  register void *r8 __asm__("r8") = newtls;
  40c1cc:	4d 89 c8             	mov    %r9,%r8
  register int *r10 __asm__("r10") = child_tidptr;
  40c1cf:	4c 8b 54 24 10       	mov    0x10(%rsp),%r10
                    int *parent_tidptr, void *newtls, int *child_tidptr) {
  long long res;
  if (!fn || !child_stack)
    return -EINVAL;
  CHECK_EQ(0, (uptr)child_stack % 16);
  child_stack = (char *)child_stack - 2 * sizeof(unsigned long long);
  40c1d4:	48 83 ee 10          	sub    $0x10,%rsi
                         "D"(flags),
                         "d"(parent_tidptr),
                         "r"(r8),
                         "r"(r10)
                       : "rsp", "memory", "r11", "rcx");
  return res;
  40c1d8:	b8 38 00 00 00       	mov    $0x38,%eax
  40c1dd:	89 df                	mov    %ebx,%edi
  40c1df:	0f 05                	syscall 
  40c1e1:	48 85 c0             	test   %rax,%rax
  40c1e4:	75 13                	jne    40c1f9 <_ZN11__sanitizer14internal_cloneEPFiPvES0_iS0_PiS0_S3_+0x59>
  40c1e6:	48 31 ed             	xor    %rbp,%rbp
  40c1e9:	58                   	pop    %rax
  40c1ea:	5f                   	pop    %rdi
  40c1eb:	ff d0                	callq  *%rax
  40c1ed:	48 89 c7             	mov    %rax,%rdi
  40c1f0:	48 c7 c0 3c 00 00 00 	mov    $0x3c,%rax
  40c1f7:	0f 05                	syscall 
}
  40c1f9:	5b                   	pop    %rbx
  40c1fa:	c3                   	retq   
uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,
                    int *parent_tidptr, void *newtls, int *child_tidptr) {
  long long res;
  if (!fn || !child_stack)
    return -EINVAL;
  CHECK_EQ(0, (uptr)child_stack % 16);
  40c1fb:	48 8d 15 36 b1 00 00 	lea    0xb136(%rip),%rdx        # 417338 <.LC23>
  40c202:	48 8d 3d 3f af 00 00 	lea    0xaf3f(%rip),%rdi        # 417148 <.LC2>
  40c209:	31 c9                	xor    %ecx,%ecx
  40c20b:	be 33 03 00 00       	mov    $0x333,%esi
  40c210:	e8 db 91 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40c215:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  40c21c:	00 00 00 00 

000000000040c220 <_ZN11__sanitizer14IsDeadlySignalEi>:
}

#endif

bool IsDeadlySignal(int signum) {
  if (common_flags()->handle_abort && signum == SIGABRT)
  40c220:	48 8b 15 91 20 01 00 	mov    0x12091(%rip),%rdx        # 41e2b8 <_DYNAMIC+0x2b8>
  40c227:	0f b6 42 3e          	movzbl 0x3e(%rdx),%eax
  40c22b:	84 c0                	test   %al,%al
  40c22d:	74 05                	je     40c234 <_ZN11__sanitizer14IsDeadlySignalEi+0x14>
  40c22f:	83 ff 06             	cmp    $0x6,%edi
  40c232:	74 34                	je     40c268 <_ZN11__sanitizer14IsDeadlySignalEi+0x48>
    return true;
  if (common_flags()->handle_sigfpe && signum == SIGFPE)
  40c234:	0f b6 42 3f          	movzbl 0x3f(%rdx),%eax
  40c238:	84 c0                	test   %al,%al
  40c23a:	74 05                	je     40c241 <_ZN11__sanitizer14IsDeadlySignalEi+0x21>
  40c23c:	83 ff 08             	cmp    $0x8,%edi
  40c23f:	74 2f                	je     40c270 <_ZN11__sanitizer14IsDeadlySignalEi+0x50>
    return true;
  return (signum == SIGSEGV || signum == SIGBUS) && common_flags()->handle_segv;
  40c241:	83 ff 07             	cmp    $0x7,%edi
  40c244:	0f 94 c1             	sete   %cl
  40c247:	83 ff 0b             	cmp    $0xb,%edi
  40c24a:	0f 94 c0             	sete   %al
  40c24d:	08 c8                	or     %cl,%al
  40c24f:	74 0f                	je     40c260 <_ZN11__sanitizer14IsDeadlySignalEi+0x40>
  40c251:	0f b6 42 3d          	movzbl 0x3d(%rdx),%eax
  40c255:	c3                   	retq   
  40c256:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40c25d:	00 00 00 
}
  40c260:	f3 c3                	repz retq 
  40c262:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40c268:	f3 c3                	repz retq 
  40c26a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40c270:	f3 c3                	repz retq 
  40c272:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40c279:	1f 84 00 00 00 00 00 

000000000040c280 <_ZN11__sanitizer21internal_start_threadEPFvPvES0_>:

#ifndef SANITIZER_GO
void *internal_start_thread(void(*func)(void *arg), void *arg) {
  40c280:	41 57                	push   %r15
                          sizeof(__sanitizer_kernel_sigset_t));
#endif
}

void internal_sigfillset(__sanitizer_sigset_t *set) {
  internal_memset(set, 0xff, sizeof(*set));
  40c282:	ba 80 00 00 00       	mov    $0x80,%edx
    return true;
  return (signum == SIGSEGV || signum == SIGBUS) && common_flags()->handle_segv;
}

#ifndef SANITIZER_GO
void *internal_start_thread(void(*func)(void *arg), void *arg) {
  40c287:	49 89 f7             	mov    %rsi,%r15
                          sizeof(__sanitizer_kernel_sigset_t));
#endif
}

void internal_sigfillset(__sanitizer_sigset_t *set) {
  internal_memset(set, 0xff, sizeof(*set));
  40c28a:	be ff 00 00 00       	mov    $0xff,%esi
    return true;
  return (signum == SIGSEGV || signum == SIGBUS) && common_flags()->handle_segv;
}

#ifndef SANITIZER_GO
void *internal_start_thread(void(*func)(void *arg), void *arg) {
  40c28f:	41 56                	push   %r14
  40c291:	41 55                	push   %r13
static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
  u64 retval;
  asm volatile("mov %5, %%r10;"
               "syscall" : "=a"(retval) : "a"(nr), "D"((u64)arg1),
               "S"((u64)arg2), "d"((u64)arg3), "r"((u64)arg4) :
               "rcx", "r11", "r10", "memory", "cc");
  40c293:	41 bd 08 00 00 00    	mov    $0x8,%r13d
  40c299:	41 54                	push   %r12
  40c29b:	55                   	push   %rbp
  40c29c:	bd 02 00 00 00       	mov    $0x2,%ebp
  40c2a1:	53                   	push   %rbx
  40c2a2:	bb 0e 00 00 00       	mov    $0xe,%ebx
  40c2a7:	48 81 ec 28 01 00 00 	sub    $0x128,%rsp
                          sizeof(__sanitizer_kernel_sigset_t));
#endif
}

void internal_sigfillset(__sanitizer_sigset_t *set) {
  internal_memset(set, 0xff, sizeof(*set));
  40c2ae:	4c 8d 74 24 20       	lea    0x20(%rsp),%r14
#else
  __sanitizer_kernel_sigset_t *k_set = (__sanitizer_kernel_sigset_t *)set;
  __sanitizer_kernel_sigset_t *k_oldset = (__sanitizer_kernel_sigset_t *)oldset;
  return internal_syscall(SYSCALL(rt_sigprocmask), (uptr)how,
                          (uptr)&k_set->sig[0], (uptr)&k_oldset->sig[0],
                          sizeof(__sanitizer_kernel_sigset_t));
  40c2b3:	4c 8d a4 24 a0 00 00 	lea    0xa0(%rsp),%r12
  40c2ba:	00 
    return true;
  return (signum == SIGSEGV || signum == SIGBUS) && common_flags()->handle_segv;
}

#ifndef SANITIZER_GO
void *internal_start_thread(void(*func)(void *arg), void *arg) {
  40c2bb:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
                          sizeof(__sanitizer_kernel_sigset_t));
#endif
}

void internal_sigfillset(__sanitizer_sigset_t *set) {
  internal_memset(set, 0xff, sizeof(*set));
  40c2c0:	4c 89 f7             	mov    %r14,%rdi
  40c2c3:	e8 78 e0 ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  CHECK_GE(signum, 0);
  CHECK_LT(signum, sizeof(*set) * 8);
  __sanitizer_kernel_sigset_t *k_set = (__sanitizer_kernel_sigset_t *)set;
  const uptr idx = signum / (sizeof(k_set->sig[0]) * 8);
  const uptr bit = signum % (sizeof(k_set->sig[0]) * 8);
  k_set->sig[idx] &= ~(1 << bit);
  40c2c8:	80 64 24 24 fe       	andb   $0xfe,0x24(%rsp)
  40c2cd:	48 89 d8             	mov    %rbx,%rax
  40c2d0:	48 89 ef             	mov    %rbp,%rdi
  40c2d3:	4c 89 f6             	mov    %r14,%rsi
  40c2d6:	4c 89 e2             	mov    %r12,%rdx
  40c2d9:	4d 89 ea             	mov    %r13,%r10
  40c2dc:	0f 05                	syscall 
  // on any thread, setuid call hangs (see test/tsan/setuid.c).
  internal_sigdelset(&set, 33);
#endif
  internal_sigprocmask(SIG_SETMASK, &set, &old);
  void *th;
  real_pthread_create(&th, nullptr, (void*(*)(void *arg))func, arg);
  40c2de:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  40c2e3:	48 8d 7c 24 18       	lea    0x18(%rsp),%rdi
  40c2e8:	31 f6                	xor    %esi,%esi
  40c2ea:	4c 89 f9             	mov    %r15,%rcx
  40c2ed:	e8 6e 5f ff ff       	callq  402260 <_ZN11__sanitizer19real_pthread_createEPvS0_PFS0_S0_ES0_@plt>
  40c2f2:	31 d2                	xor    %edx,%edx
  40c2f4:	48 89 d8             	mov    %rbx,%rax
  40c2f7:	48 89 ef             	mov    %rbp,%rdi
  40c2fa:	4c 89 e6             	mov    %r12,%rsi
  40c2fd:	4d 89 ea             	mov    %r13,%r10
  40c300:	0f 05                	syscall 
  internal_sigprocmask(SIG_SETMASK, &old, nullptr);
  return th;
}
  40c302:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  40c307:	48 81 c4 28 01 00 00 	add    $0x128,%rsp
  40c30e:	5b                   	pop    %rbx
  40c30f:	5d                   	pop    %rbp
  40c310:	41 5c                	pop    %r12
  40c312:	41 5d                	pop    %r13
  40c314:	41 5e                	pop    %r14
  40c316:	41 5f                	pop    %r15
  40c318:	c3                   	retq   
  40c319:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000040c320 <_ZN11__sanitizer20internal_join_threadEPv>:

void internal_join_thread(void *th) {
  real_pthread_join(th, nullptr);
  40c320:	31 f6                	xor    %esi,%esi
  40c322:	e9 49 5f ff ff       	jmpq   402270 <_ZN11__sanitizer17real_pthread_joinEPvPS0_@plt>
  40c327:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40c32e:	00 00 

000000000040c330 <_ZN11__sanitizer9GetPcSpBpEPvPmS1_S1_>:
  *pc = ucontext->uc_mcontext.mc_rip;
  *bp = ucontext->uc_mcontext.mc_rbp;
  *sp = ucontext->uc_mcontext.mc_rsp;
# else
  ucontext_t *ucontext = (ucontext_t*)context;
  *pc = ucontext->uc_mcontext.gregs[REG_RIP];
  40c330:	48 8b 87 a8 00 00 00 	mov    0xa8(%rdi),%rax
  40c337:	48 89 06             	mov    %rax,(%rsi)
  *bp = ucontext->uc_mcontext.gregs[REG_RBP];
  40c33a:	48 8b 47 78          	mov    0x78(%rdi),%rax
  40c33e:	48 89 01             	mov    %rax,(%rcx)
  *sp = ucontext->uc_mcontext.gregs[REG_RSP];
  40c341:	48 8b 87 a0 00 00 00 	mov    0xa0(%rdi),%rax
  40c348:	48 89 02             	mov    %rax,(%rdx)
  40c34b:	c3                   	retq   
  40c34c:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  40c353:	00 00 00 00 
	...

000000000040c360 <_ZN11__sanitizer22__sanitizer_in_addr_szEi>:

  int af_inet = (int)AF_INET;
  int af_inet6 = (int)AF_INET6;

  uptr __sanitizer_in_addr_sz(int af) {
    if (af == AF_INET)
  40c360:	83 ff 02             	cmp    $0x2,%edi
      return sizeof(struct in_addr);
  40c363:	b8 04 00 00 00       	mov    $0x4,%eax

  int af_inet = (int)AF_INET;
  int af_inet6 = (int)AF_INET6;

  uptr __sanitizer_in_addr_sz(int af) {
    if (af == AF_INET)
  40c368:	74 0e                	je     40c378 <_ZN11__sanitizer22__sanitizer_in_addr_szEi+0x18>
      return sizeof(struct in_addr);
    else if (af == AF_INET6)
      return sizeof(struct in6_addr);
  40c36a:	b0 10                	mov    $0x10,%al
  40c36c:	83 ff 0a             	cmp    $0xa,%edi
  40c36f:	ba 00 00 00 00       	mov    $0x0,%edx
  40c374:	48 0f 45 c2          	cmovne %rdx,%rax
    else
      return 0;
  }
  40c378:	f3 c3                	repz retq 
  40c37a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000040c380 <_ZN11__sanitizer18GetMmapGranularityEv>:

namespace __sanitizer {

// ------------- sanitizer_common.h
uptr GetMmapGranularity() {
  return GetPageSize();
  40c380:	e9 cb fa ff ff       	jmpq   40be50 <_ZN11__sanitizer11GetPageSizeEv>
  40c385:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  40c38c:	00 00 00 00 

000000000040c390 <_ZN11__sanitizer20GetMaxVirtualAddressEv>:
  if (!common_flags()->full_address_space)
    res -= GetKernelAreaSize();
  CHECK_LT(reinterpret_cast<uptr>(&res), res);
  return res;
#endif  // SANITIZER_WORDSIZE
}
  40c390:	48 b8 ff ff ff ff ff 	movabs $0x7fffffffffff,%rax
  40c397:	7f 00 00 
  40c39a:	c3                   	retq   
  40c39b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000040c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>:

void *MmapOrDie(uptr size, const char *mem_type) {
  40c3a0:	41 54                	push   %r12
  40c3a2:	49 89 f4             	mov    %rsi,%r12
  40c3a5:	55                   	push   %rbp
  40c3a6:	48 89 fd             	mov    %rdi,%rbp
  40c3a9:	53                   	push   %rbx
  40c3aa:	48 83 ec 10          	sub    $0x10,%rsp
  size = RoundUpTo(size, GetPageSizeCached());
  40c3ae:	e8 fd 8c ff ff       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
#endif
  return up;
}

INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
  40c3b3:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40c3b7:	48 85 c2             	test   %rax,%rdx
  40c3ba:	75 51                	jne    40c40d <_ZN11__sanitizer9MmapOrDieEmPKc+0x6d>
  return (size + boundary - 1) & ~(boundary - 1);
  40c3bc:	48 89 c3             	mov    %rax,%rbx
  40c3bf:	48 8d 44 28 ff       	lea    -0x1(%rax,%rbp,1),%rax
  uptr res = internal_mmap(nullptr, size,
                           PROT_READ | PROT_WRITE,
                           MAP_PRIVATE | MAP_ANON, -1, 0);
  40c3c4:	45 31 c9             	xor    %r9d,%r9d
  40c3c7:	48 f7 db             	neg    %rbx
  40c3ca:	31 ff                	xor    %edi,%edi
  40c3cc:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
  40c3d2:	48 21 c3             	and    %rax,%rbx
  40c3d5:	b9 22 00 00 00       	mov    $0x22,%ecx
  40c3da:	ba 03 00 00 00       	mov    $0x3,%edx
  40c3df:	48 89 de             	mov    %rbx,%rsi
  40c3e2:	e8 b9 f0 ff ff       	callq  40b4a0 <_ZN11__sanitizer13internal_mmapEPvmiiiy>
  int reserrno;
  if (internal_iserror(res, &reserrno))
  40c3e7:	48 89 e6             	mov    %rsp,%rsi
  40c3ea:	48 89 c7             	mov    %rax,%rdi

void *MmapOrDie(uptr size, const char *mem_type) {
  size = RoundUpTo(size, GetPageSizeCached());
  uptr res = internal_mmap(nullptr, size,
                           PROT_READ | PROT_WRITE,
                           MAP_PRIVATE | MAP_ANON, -1, 0);
  40c3ed:	48 89 c5             	mov    %rax,%rbp
  int reserrno;
  if (internal_iserror(res, &reserrno))
  40c3f0:	e8 7b f0 ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
  40c3f5:	84 c0                	test   %al,%al
  40c3f7:	75 31                	jne    40c42a <_ZN11__sanitizer9MmapOrDieEmPKc+0x8a>
    ReportMmapFailureAndDie(size, mem_type, reserrno);
  IncreaseTotalMmap(size);
  40c3f9:	48 89 df             	mov    %rbx,%rdi
  40c3fc:	e8 4f 97 ff ff       	callq  405b50 <_ZN11__sanitizer17IncreaseTotalMmapEm>
  return (void *)res;
}
  40c401:	48 83 c4 10          	add    $0x10,%rsp
  40c405:	48 89 e8             	mov    %rbp,%rax
  40c408:	5b                   	pop    %rbx
  40c409:	5d                   	pop    %rbp
  40c40a:	41 5c                	pop    %r12
  40c40c:	c3                   	retq   
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40c40d:	48 8d 15 ec 8e 00 00 	lea    0x8eec(%rip),%rdx        # 415300 <.LC19>
  40c414:	48 8d 3d f5 8b 00 00 	lea    0x8bf5(%rip),%rdi        # 415010 <.LC1>
  40c41b:	45 31 c0             	xor    %r8d,%r8d
  40c41e:	31 c9                	xor    %ecx,%ecx
  40c420:	be a9 01 00 00       	mov    $0x1a9,%esi
  40c425:	e8 c6 8f ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  uptr res = internal_mmap(nullptr, size,
                           PROT_READ | PROT_WRITE,
                           MAP_PRIVATE | MAP_ANON, -1, 0);
  int reserrno;
  if (internal_iserror(res, &reserrno))
    ReportMmapFailureAndDie(size, mem_type, reserrno);
  40c42a:	8b 14 24             	mov    (%rsp),%edx
  40c42d:	4c 89 e6             	mov    %r12,%rsi
  40c430:	48 89 df             	mov    %rbx,%rdi
  40c433:	e8 48 91 ff ff       	callq  405580 <_ZN11__sanitizer23ReportMmapFailureAndDieEmPKci>
  40c438:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40c43f:	00 

000000000040c440 <_ZN11__sanitizer10UnmapOrDieEPvm>:
  IncreaseTotalMmap(size);
  return (void *)res;
}

void UnmapOrDie(void *addr, uptr size) {
  40c440:	55                   	push   %rbp
  40c441:	53                   	push   %rbx
  40c442:	48 89 fb             	mov    %rdi,%rbx
  40c445:	48 83 ec 08          	sub    $0x8,%rsp
  if (!addr || !size) return;
  40c449:	48 85 ff             	test   %rdi,%rdi
  40c44c:	75 0a                	jne    40c458 <_ZN11__sanitizer10UnmapOrDieEPvm+0x18>
    Report("ERROR: %s failed to deallocate 0x%zx (%zd) bytes at address %p\n",
           SanitizerToolName, size, size, addr);
    CHECK("unable to unmap" && 0);
  }
  DecreaseTotalMmap(size);
}
  40c44e:	48 83 c4 08          	add    $0x8,%rsp
  40c452:	5b                   	pop    %rbx
  40c453:	5d                   	pop    %rbp
  40c454:	c3                   	retq   
  40c455:	0f 1f 00             	nopl   (%rax)
  IncreaseTotalMmap(size);
  return (void *)res;
}

void UnmapOrDie(void *addr, uptr size) {
  if (!addr || !size) return;
  40c458:	48 85 f6             	test   %rsi,%rsi
  40c45b:	48 89 f5             	mov    %rsi,%rbp
  40c45e:	74 ee                	je     40c44e <_ZN11__sanitizer10UnmapOrDieEPvm+0xe>
  uptr res = internal_munmap(addr, size);
  40c460:	e8 6b f0 ff ff       	callq  40b4d0 <_ZN11__sanitizer15internal_munmapEPvm>
  if (internal_iserror(res)) {
  40c465:	31 f6                	xor    %esi,%esi
  40c467:	48 89 c7             	mov    %rax,%rdi
  40c46a:	e8 01 f0 ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
  40c46f:	84 c0                	test   %al,%al
  40c471:	75 0e                	jne    40c481 <_ZN11__sanitizer10UnmapOrDieEPvm+0x41>
    Report("ERROR: %s failed to deallocate 0x%zx (%zd) bytes at address %p\n",
           SanitizerToolName, size, size, addr);
    CHECK("unable to unmap" && 0);
  }
  DecreaseTotalMmap(size);
}
  40c473:	48 83 c4 08          	add    $0x8,%rsp
  if (internal_iserror(res)) {
    Report("ERROR: %s failed to deallocate 0x%zx (%zd) bytes at address %p\n",
           SanitizerToolName, size, size, addr);
    CHECK("unable to unmap" && 0);
  }
  DecreaseTotalMmap(size);
  40c477:	48 89 ef             	mov    %rbp,%rdi
}
  40c47a:	5b                   	pop    %rbx
  40c47b:	5d                   	pop    %rbp
  if (internal_iserror(res)) {
    Report("ERROR: %s failed to deallocate 0x%zx (%zd) bytes at address %p\n",
           SanitizerToolName, size, size, addr);
    CHECK("unable to unmap" && 0);
  }
  DecreaseTotalMmap(size);
  40c47c:	e9 0f 97 ff ff       	jmpq   405b90 <_ZN11__sanitizer17DecreaseTotalMmapEm>
  40c481:	48 89 ee             	mov    %rbp,%rsi
  40c484:	48 89 df             	mov    %rbx,%rdi
  40c487:	e8 f3 60 ff ff       	callq  40257f <_ZN11__sanitizer10UnmapOrDieEPvm.part.0>
  40c48c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040c490 <_ZN11__sanitizer18MmapNoReserveOrDieEmPKc>:
}

void *MmapNoReserveOrDie(uptr size, const char *mem_type) {
  40c490:	41 54                	push   %r12
  40c492:	49 89 f4             	mov    %rsi,%r12
  40c495:	55                   	push   %rbp
  40c496:	53                   	push   %rbx
  40c497:	48 89 fb             	mov    %rdi,%rbx
  40c49a:	48 83 ec 10          	sub    $0x10,%rsp
  uptr PageSize = GetPageSizeCached();
  40c49e:	e8 0d 8c ff ff       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
#endif
  return up;
}

INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
  40c4a3:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40c4a7:	48 85 c2             	test   %rax,%rdx
  40c4aa:	75 4e                	jne    40c4fa <_ZN11__sanitizer18MmapNoReserveOrDieEmPKc+0x6a>
  return (size + boundary - 1) & ~(boundary - 1);
  40c4ac:	48 89 c6             	mov    %rax,%rsi
  40c4af:	48 8d 44 18 ff       	lea    -0x1(%rax,%rbx,1),%rax
  uptr p = internal_mmap(nullptr,
                         RoundUpTo(size, PageSize),
                         PROT_READ | PROT_WRITE,
                         MAP_PRIVATE | MAP_ANON | MAP_NORESERVE,
                         -1, 0);
  40c4b4:	45 31 c9             	xor    %r9d,%r9d
  40c4b7:	48 f7 de             	neg    %rsi
  40c4ba:	31 ff                	xor    %edi,%edi
  40c4bc:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
  40c4c2:	48 21 c6             	and    %rax,%rsi
  40c4c5:	b9 22 40 00 00       	mov    $0x4022,%ecx
  40c4ca:	ba 03 00 00 00       	mov    $0x3,%edx
  40c4cf:	e8 cc ef ff ff       	callq  40b4a0 <_ZN11__sanitizer13internal_mmapEPvmiiiy>
  int reserrno;
  if (internal_iserror(p, &reserrno)) {
  40c4d4:	48 89 e6             	mov    %rsp,%rsi
  40c4d7:	48 89 c7             	mov    %rax,%rdi
  uptr PageSize = GetPageSizeCached();
  uptr p = internal_mmap(nullptr,
                         RoundUpTo(size, PageSize),
                         PROT_READ | PROT_WRITE,
                         MAP_PRIVATE | MAP_ANON | MAP_NORESERVE,
                         -1, 0);
  40c4da:	48 89 c5             	mov    %rax,%rbp
  int reserrno;
  if (internal_iserror(p, &reserrno)) {
  40c4dd:	e8 8e ef ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
  40c4e2:	84 c0                	test   %al,%al
  40c4e4:	75 31                	jne    40c517 <_ZN11__sanitizer18MmapNoReserveOrDieEmPKc+0x87>
    Report("ERROR: %s failed to "
           "allocate noreserve 0x%zx (%zd) bytes for '%s' (errno: %d)\n",
           SanitizerToolName, size, size, mem_type, reserrno);
    CHECK("unable to mmap" && 0);
  }
  IncreaseTotalMmap(size);
  40c4e6:	48 89 df             	mov    %rbx,%rdi
  40c4e9:	e8 62 96 ff ff       	callq  405b50 <_ZN11__sanitizer17IncreaseTotalMmapEm>
  return (void *)p;
}
  40c4ee:	48 83 c4 10          	add    $0x10,%rsp
  40c4f2:	48 89 e8             	mov    %rbp,%rax
  40c4f5:	5b                   	pop    %rbx
  40c4f6:	5d                   	pop    %rbp
  40c4f7:	41 5c                	pop    %r12
  40c4f9:	c3                   	retq   
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40c4fa:	48 8d 15 ff 8d 00 00 	lea    0x8dff(%rip),%rdx        # 415300 <.LC19>
  40c501:	48 8d 3d 08 8b 00 00 	lea    0x8b08(%rip),%rdi        # 415010 <.LC1>
  40c508:	45 31 c0             	xor    %r8d,%r8d
  40c50b:	31 c9                	xor    %ecx,%ecx
  40c50d:	be a9 01 00 00       	mov    $0x1a9,%esi
  40c512:	e8 d9 8e ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
                         -1, 0);
  int reserrno;
  if (internal_iserror(p, &reserrno)) {
    Report("ERROR: %s failed to "
           "allocate noreserve 0x%zx (%zd) bytes for '%s' (errno: %d)\n",
           SanitizerToolName, size, size, mem_type, reserrno);
  40c517:	48 8b 05 92 1d 01 00 	mov    0x11d92(%rip),%rax        # 41e2b0 <_DYNAMIC+0x2b0>
  40c51e:	44 8b 0c 24          	mov    (%rsp),%r9d
  40c522:	48 8d 3d 0f af 00 00 	lea    0xaf0f(%rip),%rdi        # 417438 <.LC5>
  40c529:	4d 89 e0             	mov    %r12,%r8
  40c52c:	48 89 d9             	mov    %rbx,%rcx
  40c52f:	48 89 da             	mov    %rbx,%rdx
  40c532:	48 8b 30             	mov    (%rax),%rsi
  40c535:	31 c0                	xor    %eax,%eax
  40c537:	e8 54 15 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
    CHECK("unable to mmap" && 0);
  40c53c:	48 8d 15 45 af 00 00 	lea    0xaf45(%rip),%rdx        # 417488 <.LC6>
  40c543:	48 8d 3d 7e ae 00 00 	lea    0xae7e(%rip),%rdi        # 4173c8 <.LC2>
  40c54a:	45 31 c0             	xor    %r8d,%r8d
  40c54d:	31 c9                	xor    %ecx,%ecx
  40c54f:	be 96 00 00 00       	mov    $0x96,%esi
  40c554:	e8 97 8e ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40c559:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000040c560 <_ZN11__sanitizer14MmapFixedOrDieEmm>:
  }
  IncreaseTotalMmap(size);
  return (void *)p;
}

void *MmapFixedOrDie(uptr fixed_addr, uptr size) {
  40c560:	41 54                	push   %r12
  40c562:	49 89 fc             	mov    %rdi,%r12
  40c565:	55                   	push   %rbp
  40c566:	53                   	push   %rbx
  40c567:	48 89 f3             	mov    %rsi,%rbx
  40c56a:	48 83 ec 10          	sub    $0x10,%rsp
  uptr PageSize = GetPageSizeCached();
  40c56e:	e8 3d 8b ff ff       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
#endif
  return up;
}

INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
  40c573:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40c577:	48 85 c2             	test   %rax,%rdx
  40c57a:	75 52                	jne    40c5ce <_ZN11__sanitizer14MmapFixedOrDieEmm+0x6e>
  return (size + boundary - 1) & ~(boundary - 1);
  40c57c:	48 89 c2             	mov    %rax,%rdx
  40c57f:	48 8d 74 18 ff       	lea    -0x1(%rax,%rbx,1),%rsi
  uptr p = internal_mmap((void*)(fixed_addr & ~(PageSize - 1)),
      RoundUpTo(size, PageSize),
      PROT_READ | PROT_WRITE,
      MAP_PRIVATE | MAP_ANON | MAP_FIXED,
      -1, 0);
  40c584:	45 31 c9             	xor    %r9d,%r9d
  40c587:	48 f7 da             	neg    %rdx
  40c58a:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
  40c590:	b9 32 00 00 00       	mov    $0x32,%ecx
  return (void *)p;
}

void *MmapFixedOrDie(uptr fixed_addr, uptr size) {
  uptr PageSize = GetPageSizeCached();
  uptr p = internal_mmap((void*)(fixed_addr & ~(PageSize - 1)),
  40c595:	48 89 d7             	mov    %rdx,%rdi
  40c598:	48 21 d6             	and    %rdx,%rsi
      RoundUpTo(size, PageSize),
      PROT_READ | PROT_WRITE,
      MAP_PRIVATE | MAP_ANON | MAP_FIXED,
      -1, 0);
  40c59b:	ba 03 00 00 00       	mov    $0x3,%edx
  return (void *)p;
}

void *MmapFixedOrDie(uptr fixed_addr, uptr size) {
  uptr PageSize = GetPageSizeCached();
  uptr p = internal_mmap((void*)(fixed_addr & ~(PageSize - 1)),
  40c5a0:	4c 21 e7             	and    %r12,%rdi
      RoundUpTo(size, PageSize),
      PROT_READ | PROT_WRITE,
      MAP_PRIVATE | MAP_ANON | MAP_FIXED,
      -1, 0);
  40c5a3:	e8 f8 ee ff ff       	callq  40b4a0 <_ZN11__sanitizer13internal_mmapEPvmiiiy>
  int reserrno;
  if (internal_iserror(p, &reserrno)) {
  40c5a8:	48 89 e6             	mov    %rsp,%rsi
  40c5ab:	48 89 c7             	mov    %rax,%rdi
  uptr PageSize = GetPageSizeCached();
  uptr p = internal_mmap((void*)(fixed_addr & ~(PageSize - 1)),
      RoundUpTo(size, PageSize),
      PROT_READ | PROT_WRITE,
      MAP_PRIVATE | MAP_ANON | MAP_FIXED,
      -1, 0);
  40c5ae:	48 89 c5             	mov    %rax,%rbp
  int reserrno;
  if (internal_iserror(p, &reserrno)) {
  40c5b1:	e8 ba ee ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
  40c5b6:	84 c0                	test   %al,%al
  40c5b8:	75 31                	jne    40c5eb <_ZN11__sanitizer14MmapFixedOrDieEmm+0x8b>
    Report("ERROR: %s failed to "
           "allocate 0x%zx (%zd) bytes at address %zx (errno: %d)\n",
           SanitizerToolName, size, size, fixed_addr, reserrno);
    CHECK("unable to mmap" && 0);
  }
  IncreaseTotalMmap(size);
  40c5ba:	48 89 df             	mov    %rbx,%rdi
  40c5bd:	e8 8e 95 ff ff       	callq  405b50 <_ZN11__sanitizer17IncreaseTotalMmapEm>
  return (void *)p;
}
  40c5c2:	48 83 c4 10          	add    $0x10,%rsp
  40c5c6:	48 89 e8             	mov    %rbp,%rax
  40c5c9:	5b                   	pop    %rbx
  40c5ca:	5d                   	pop    %rbp
  40c5cb:	41 5c                	pop    %r12
  40c5cd:	c3                   	retq   
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40c5ce:	48 8d 15 2b 8d 00 00 	lea    0x8d2b(%rip),%rdx        # 415300 <.LC19>
  40c5d5:	48 8d 3d 34 8a 00 00 	lea    0x8a34(%rip),%rdi        # 415010 <.LC1>
  40c5dc:	45 31 c0             	xor    %r8d,%r8d
  40c5df:	31 c9                	xor    %ecx,%ecx
  40c5e1:	be a9 01 00 00       	mov    $0x1a9,%esi
  40c5e6:	e8 05 8e ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
      -1, 0);
  int reserrno;
  if (internal_iserror(p, &reserrno)) {
    Report("ERROR: %s failed to "
           "allocate 0x%zx (%zd) bytes at address %zx (errno: %d)\n",
           SanitizerToolName, size, size, fixed_addr, reserrno);
  40c5eb:	48 8b 05 be 1c 01 00 	mov    0x11cbe(%rip),%rax        # 41e2b0 <_DYNAMIC+0x2b0>
  40c5f2:	44 8b 0c 24          	mov    (%rsp),%r9d
  40c5f6:	48 8d 3d b3 ae 00 00 	lea    0xaeb3(%rip),%rdi        # 4174b0 <.LC7>
  40c5fd:	4d 89 e0             	mov    %r12,%r8
  40c600:	48 89 d9             	mov    %rbx,%rcx
  40c603:	48 89 da             	mov    %rbx,%rdx
  40c606:	48 8b 30             	mov    (%rax),%rsi
  40c609:	31 c0                	xor    %eax,%eax
  40c60b:	e8 80 14 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
    CHECK("unable to mmap" && 0);
  40c610:	48 8d 15 71 ae 00 00 	lea    0xae71(%rip),%rdx        # 417488 <.LC6>
  40c617:	48 8d 3d aa ad 00 00 	lea    0xadaa(%rip),%rdi        # 4173c8 <.LC2>
  40c61e:	45 31 c0             	xor    %r8d,%r8d
  40c621:	31 c9                	xor    %ecx,%ecx
  40c623:	be a8 00 00 00       	mov    $0xa8,%esi
  40c628:	e8 c3 8d ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40c62d:	0f 1f 00             	nopl   (%rax)

000000000040c630 <_ZN11__sanitizer16MprotectNoAccessEmm>:
  }
  IncreaseTotalMmap(size);
  return (void *)p;
}

bool MprotectNoAccess(uptr addr, uptr size) {
  40c630:	48 83 ec 08          	sub    $0x8,%rsp
  return 0 == internal_mprotect((void*)addr, size, PROT_NONE);
  40c634:	31 d2                	xor    %edx,%edx
  40c636:	e8 a5 ee ff ff       	callq  40b4e0 <_ZN11__sanitizer17internal_mprotectEPvmi>
  40c63b:	85 c0                	test   %eax,%eax
  40c63d:	0f 94 c0             	sete   %al
}
  40c640:	48 83 c4 08          	add    $0x8,%rsp
  40c644:	c3                   	retq   
  40c645:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  40c64c:	00 00 00 00 

000000000040c650 <_ZN11__sanitizer8OpenFileEPKcNS_14FileAccessModeEPi>:

fd_t OpenFile(const char *filename, FileAccessMode mode, error_t *errno_p) {
  40c650:	55                   	push   %rbp
  int flags;
  switch (mode) {
    case RdOnly: flags = O_RDONLY; break;
    case WrOnly: flags = O_WRONLY | O_CREAT; break;
  40c651:	b8 41 00 00 00       	mov    $0x41,%eax

bool MprotectNoAccess(uptr addr, uptr size) {
  return 0 == internal_mprotect((void*)addr, size, PROT_NONE);
}

fd_t OpenFile(const char *filename, FileAccessMode mode, error_t *errno_p) {
  40c656:	48 89 d5             	mov    %rdx,%rbp
  40c659:	53                   	push   %rbx
  40c65a:	48 83 ec 08          	sub    $0x8,%rsp
  int flags;
  switch (mode) {
  40c65e:	83 fe 01             	cmp    $0x1,%esi
  40c661:	74 0f                	je     40c672 <_ZN11__sanitizer8OpenFileEPKcNS_14FileAccessModeEPi+0x22>
  40c663:	83 fe 02             	cmp    $0x2,%esi
  40c666:	74 38                	je     40c6a0 <_ZN11__sanitizer8OpenFileEPKcNS_14FileAccessModeEPi+0x50>
    case RdOnly: flags = O_RDONLY; break;
  40c668:	85 f6                	test   %esi,%esi
  40c66a:	ba 00 00 00 00       	mov    $0x0,%edx
  40c66f:	0f 44 c2             	cmove  %edx,%eax
    case WrOnly: flags = O_WRONLY | O_CREAT; break;
    case RdWr: flags = O_RDWR | O_CREAT; break;
  }
  fd_t res = internal_open(filename, flags, 0660);
  40c672:	ba b0 01 00 00       	mov    $0x1b0,%edx
  40c677:	89 c6                	mov    %eax,%esi
  40c679:	e8 92 ee ff ff       	callq  40b510 <_ZN11__sanitizer13internal_openEPKcij>
  if (internal_iserror(res, errno_p))
  40c67e:	48 89 ee             	mov    %rbp,%rsi
  40c681:	48 63 f8             	movslq %eax,%rdi
  switch (mode) {
    case RdOnly: flags = O_RDONLY; break;
    case WrOnly: flags = O_WRONLY | O_CREAT; break;
    case RdWr: flags = O_RDWR | O_CREAT; break;
  }
  fd_t res = internal_open(filename, flags, 0660);
  40c684:	48 89 c3             	mov    %rax,%rbx
  if (internal_iserror(res, errno_p))
  40c687:	e8 e4 ed ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
    return kInvalidFd;
  40c68c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40c691:	84 c0                	test   %al,%al
  40c693:	0f 44 d3             	cmove  %ebx,%edx
  return res;
}
  40c696:	48 83 c4 08          	add    $0x8,%rsp
  40c69a:	5b                   	pop    %rbx
  40c69b:	89 d0                	mov    %edx,%eax
  40c69d:	5d                   	pop    %rbp
  40c69e:	c3                   	retq   
  40c69f:	90                   	nop
fd_t OpenFile(const char *filename, FileAccessMode mode, error_t *errno_p) {
  int flags;
  switch (mode) {
    case RdOnly: flags = O_RDONLY; break;
    case WrOnly: flags = O_WRONLY | O_CREAT; break;
    case RdWr: flags = O_RDWR | O_CREAT; break;
  40c6a0:	b8 42 00 00 00       	mov    $0x42,%eax
  40c6a5:	eb cb                	jmp    40c672 <_ZN11__sanitizer8OpenFileEPKcNS_14FileAccessModeEPi+0x22>
  40c6a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40c6ae:	00 00 

000000000040c6b0 <_ZN11__sanitizer9CloseFileEi>:
    return kInvalidFd;
  return res;
}

void CloseFile(fd_t fd) {
  internal_close(fd);
  40c6b0:	e9 3b ee ff ff       	jmpq   40b4f0 <_ZN11__sanitizer14internal_closeEi>
  40c6b5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  40c6bc:	00 00 00 00 

000000000040c6c0 <_ZN11__sanitizer12ReadFromFileEiPvmPmPi>:
}

bool ReadFromFile(fd_t fd, void *buff, uptr buff_size, uptr *bytes_read,
                  error_t *error_p) {
  40c6c0:	41 54                	push   %r12
  40c6c2:	4d 89 c4             	mov    %r8,%r12
  40c6c5:	55                   	push   %rbp
  40c6c6:	48 89 cd             	mov    %rcx,%rbp
  40c6c9:	53                   	push   %rbx
  uptr res = internal_read(fd, buff, buff_size);
  40c6ca:	e8 51 ee ff ff       	callq  40b520 <_ZN11__sanitizer13internal_readEiPvm>
  if (internal_iserror(res, error_p))
  40c6cf:	4c 89 e6             	mov    %r12,%rsi
  40c6d2:	48 89 c7             	mov    %rax,%rdi
  internal_close(fd);
}

bool ReadFromFile(fd_t fd, void *buff, uptr buff_size, uptr *bytes_read,
                  error_t *error_p) {
  uptr res = internal_read(fd, buff, buff_size);
  40c6d5:	48 89 c3             	mov    %rax,%rbx
  if (internal_iserror(res, error_p))
  40c6d8:	e8 93 ed ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
    return false;
  40c6dd:	31 d2                	xor    %edx,%edx
}

bool ReadFromFile(fd_t fd, void *buff, uptr buff_size, uptr *bytes_read,
                  error_t *error_p) {
  uptr res = internal_read(fd, buff, buff_size);
  if (internal_iserror(res, error_p))
  40c6df:	84 c0                	test   %al,%al
  40c6e1:	75 0e                	jne    40c6f1 <_ZN11__sanitizer12ReadFromFileEiPvmPmPi+0x31>
    return false;
  if (bytes_read)
  40c6e3:	48 85 ed             	test   %rbp,%rbp
  40c6e6:	74 18                	je     40c700 <_ZN11__sanitizer12ReadFromFileEiPvmPmPi+0x40>
    *bytes_read = res;
  40c6e8:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
  return true;
  40c6ec:	ba 01 00 00 00       	mov    $0x1,%edx
}
  40c6f1:	5b                   	pop    %rbx
  40c6f2:	5d                   	pop    %rbp
  40c6f3:	89 d0                	mov    %edx,%eax
  40c6f5:	41 5c                	pop    %r12
  40c6f7:	c3                   	retq   
  40c6f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40c6ff:	00 
  uptr res = internal_read(fd, buff, buff_size);
  if (internal_iserror(res, error_p))
    return false;
  if (bytes_read)
    *bytes_read = res;
  return true;
  40c700:	ba 01 00 00 00       	mov    $0x1,%edx
  40c705:	eb ea                	jmp    40c6f1 <_ZN11__sanitizer12ReadFromFileEiPvmPmPi+0x31>
  40c707:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40c70e:	00 00 

000000000040c710 <_ZN11__sanitizer11WriteToFileEiPKvmPmPi>:
}

bool WriteToFile(fd_t fd, const void *buff, uptr buff_size, uptr *bytes_written,
                 error_t *error_p) {
  40c710:	41 54                	push   %r12
  40c712:	4d 89 c4             	mov    %r8,%r12
  40c715:	55                   	push   %rbp
  40c716:	48 89 cd             	mov    %rcx,%rbp
  40c719:	53                   	push   %rbx
  uptr res = internal_write(fd, buff, buff_size);
  40c71a:	e8 21 ee ff ff       	callq  40b540 <_ZN11__sanitizer14internal_writeEiPKvm>
  if (internal_iserror(res, error_p))
  40c71f:	4c 89 e6             	mov    %r12,%rsi
  40c722:	48 89 c7             	mov    %rax,%rdi
  return true;
}

bool WriteToFile(fd_t fd, const void *buff, uptr buff_size, uptr *bytes_written,
                 error_t *error_p) {
  uptr res = internal_write(fd, buff, buff_size);
  40c725:	48 89 c3             	mov    %rax,%rbx
  if (internal_iserror(res, error_p))
  40c728:	e8 43 ed ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
    return false;
  40c72d:	31 d2                	xor    %edx,%edx
}

bool WriteToFile(fd_t fd, const void *buff, uptr buff_size, uptr *bytes_written,
                 error_t *error_p) {
  uptr res = internal_write(fd, buff, buff_size);
  if (internal_iserror(res, error_p))
  40c72f:	84 c0                	test   %al,%al
  40c731:	75 0e                	jne    40c741 <_ZN11__sanitizer11WriteToFileEiPKvmPmPi+0x31>
    return false;
  if (bytes_written)
  40c733:	48 85 ed             	test   %rbp,%rbp
  40c736:	74 18                	je     40c750 <_ZN11__sanitizer11WriteToFileEiPKvmPmPi+0x40>
    *bytes_written = res;
  40c738:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
  return true;
  40c73c:	ba 01 00 00 00       	mov    $0x1,%edx
}
  40c741:	5b                   	pop    %rbx
  40c742:	5d                   	pop    %rbp
  40c743:	89 d0                	mov    %edx,%eax
  40c745:	41 5c                	pop    %r12
  40c747:	c3                   	retq   
  40c748:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40c74f:	00 
  uptr res = internal_write(fd, buff, buff_size);
  if (internal_iserror(res, error_p))
    return false;
  if (bytes_written)
    *bytes_written = res;
  return true;
  40c750:	ba 01 00 00 00       	mov    $0x1,%edx
  40c755:	eb ea                	jmp    40c741 <_ZN11__sanitizer11WriteToFileEiPKvmPmPi+0x31>
  40c757:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40c75e:	00 00 

000000000040c760 <_ZN11__sanitizer10RenameFileEPKcS1_Pi>:
}

bool RenameFile(const char *oldpath, const char *newpath, error_t *error_p) {
  40c760:	53                   	push   %rbx
  40c761:	48 89 d3             	mov    %rdx,%rbx
  uptr res = internal_rename(oldpath, newpath);
  40c764:	e8 a7 ee ff ff       	callq  40b610 <_ZN11__sanitizer15internal_renameEPKcS1_>
  return !internal_iserror(res, error_p);
  40c769:	48 89 de             	mov    %rbx,%rsi
  40c76c:	48 89 c7             	mov    %rax,%rdi
  40c76f:	e8 fc ec ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
}
  40c774:	5b                   	pop    %rbx
  return true;
}

bool RenameFile(const char *oldpath, const char *newpath, error_t *error_p) {
  uptr res = internal_rename(oldpath, newpath);
  return !internal_iserror(res, error_p);
  40c775:	83 f0 01             	xor    $0x1,%eax
}
  40c778:	c3                   	retq   
  40c779:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000040c780 <_ZN11__sanitizer15MapFileToMemoryEPKcPm>:

void *MapFileToMemory(const char *file_name, uptr *buff_size) {
  40c780:	41 55                	push   %r13
  switch (mode) {
    case RdOnly: flags = O_RDONLY; break;
    case WrOnly: flags = O_WRONLY | O_CREAT; break;
    case RdWr: flags = O_RDWR | O_CREAT; break;
  }
  fd_t res = internal_open(filename, flags, 0660);
  40c782:	ba b0 01 00 00       	mov    $0x1b0,%edx
bool RenameFile(const char *oldpath, const char *newpath, error_t *error_p) {
  uptr res = internal_rename(oldpath, newpath);
  return !internal_iserror(res, error_p);
}

void *MapFileToMemory(const char *file_name, uptr *buff_size) {
  40c787:	49 89 f5             	mov    %rsi,%r13
  switch (mode) {
    case RdOnly: flags = O_RDONLY; break;
    case WrOnly: flags = O_WRONLY | O_CREAT; break;
    case RdWr: flags = O_RDWR | O_CREAT; break;
  }
  fd_t res = internal_open(filename, flags, 0660);
  40c78a:	31 f6                	xor    %esi,%esi
bool RenameFile(const char *oldpath, const char *newpath, error_t *error_p) {
  uptr res = internal_rename(oldpath, newpath);
  return !internal_iserror(res, error_p);
}

void *MapFileToMemory(const char *file_name, uptr *buff_size) {
  40c78c:	41 54                	push   %r12
  40c78e:	55                   	push   %rbp
  40c78f:	53                   	push   %rbx
  40c790:	48 83 ec 08          	sub    $0x8,%rsp
  switch (mode) {
    case RdOnly: flags = O_RDONLY; break;
    case WrOnly: flags = O_WRONLY | O_CREAT; break;
    case RdWr: flags = O_RDWR | O_CREAT; break;
  }
  fd_t res = internal_open(filename, flags, 0660);
  40c794:	e8 77 ed ff ff       	callq  40b510 <_ZN11__sanitizer13internal_openEPKcij>
  if (internal_iserror(res, errno_p))
  40c799:	31 f6                	xor    %esi,%esi
  40c79b:	48 63 f8             	movslq %eax,%rdi
  switch (mode) {
    case RdOnly: flags = O_RDONLY; break;
    case WrOnly: flags = O_WRONLY | O_CREAT; break;
    case RdWr: flags = O_RDWR | O_CREAT; break;
  }
  fd_t res = internal_open(filename, flags, 0660);
  40c79e:	48 89 c3             	mov    %rax,%rbx
  if (internal_iserror(res, errno_p))
  40c7a1:	e8 ca ec ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
  40c7a6:	84 c0                	test   %al,%al
  40c7a8:	75 7a                	jne    40c824 <_ZN11__sanitizer15MapFileToMemoryEPKcPm+0xa4>
  return !internal_iserror(res, error_p);
}

void *MapFileToMemory(const char *file_name, uptr *buff_size) {
  fd_t fd = OpenFile(file_name, RdOnly);
  CHECK(fd != kInvalidFd);
  40c7aa:	83 fb ff             	cmp    $0xffffffff,%ebx
  40c7ad:	74 75                	je     40c824 <_ZN11__sanitizer15MapFileToMemoryEPKcPm+0xa4>
  uptr fsize = internal_filesize(fd);
  40c7af:	89 df                	mov    %ebx,%edi
  40c7b1:	e8 fa ed ff ff       	callq  40b5b0 <_ZN11__sanitizer17internal_filesizeEi>
  CHECK_NE(fsize, (uptr)-1);
  40c7b6:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
}

void *MapFileToMemory(const char *file_name, uptr *buff_size) {
  fd_t fd = OpenFile(file_name, RdOnly);
  CHECK(fd != kInvalidFd);
  uptr fsize = internal_filesize(fd);
  40c7ba:	48 89 c5             	mov    %rax,%rbp
  CHECK_NE(fsize, (uptr)-1);
  40c7bd:	0f 84 b8 00 00 00    	je     40c87b <_ZN11__sanitizer15MapFileToMemoryEPKcPm+0xfb>
  CHECK_GT(fsize, 0);
  40c7c3:	48 85 c0             	test   %rax,%rax
  40c7c6:	0f 84 92 00 00 00    	je     40c85e <_ZN11__sanitizer15MapFileToMemoryEPKcPm+0xde>
  *buff_size = RoundUpTo(fsize, GetPageSizeCached());
  40c7cc:	e8 df 88 ff ff       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
#endif
  return up;
}

INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
  40c7d1:	4c 8d 60 ff          	lea    -0x1(%rax),%r12
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40c7d5:	49 21 c4             	and    %rax,%r12
  40c7d8:	75 67                	jne    40c841 <_ZN11__sanitizer15MapFileToMemoryEPKcPm+0xc1>
  return (size + boundary - 1) & ~(boundary - 1);
  40c7da:	48 89 c6             	mov    %rax,%rsi
  40c7dd:	48 8d 44 05 ff       	lea    -0x1(%rbp,%rax,1),%rax
  uptr map = internal_mmap(nullptr, *buff_size, PROT_READ, MAP_PRIVATE, fd, 0);
  40c7e2:	45 31 c9             	xor    %r9d,%r9d
  40c7e5:	48 f7 de             	neg    %rsi
  40c7e8:	41 89 d8             	mov    %ebx,%r8d
  40c7eb:	31 ff                	xor    %edi,%edi
  40c7ed:	48 21 c6             	and    %rax,%rsi
  40c7f0:	b9 02 00 00 00       	mov    $0x2,%ecx
  40c7f5:	ba 01 00 00 00       	mov    $0x1,%edx
  fd_t fd = OpenFile(file_name, RdOnly);
  CHECK(fd != kInvalidFd);
  uptr fsize = internal_filesize(fd);
  CHECK_NE(fsize, (uptr)-1);
  CHECK_GT(fsize, 0);
  *buff_size = RoundUpTo(fsize, GetPageSizeCached());
  40c7fa:	49 89 75 00          	mov    %rsi,0x0(%r13)
  uptr map = internal_mmap(nullptr, *buff_size, PROT_READ, MAP_PRIVATE, fd, 0);
  40c7fe:	e8 9d ec ff ff       	callq  40b4a0 <_ZN11__sanitizer13internal_mmapEPvmiiiy>
  return internal_iserror(map) ? nullptr : (void *)map;
  40c803:	31 f6                	xor    %esi,%esi
  40c805:	48 89 c7             	mov    %rax,%rdi
  CHECK(fd != kInvalidFd);
  uptr fsize = internal_filesize(fd);
  CHECK_NE(fsize, (uptr)-1);
  CHECK_GT(fsize, 0);
  *buff_size = RoundUpTo(fsize, GetPageSizeCached());
  uptr map = internal_mmap(nullptr, *buff_size, PROT_READ, MAP_PRIVATE, fd, 0);
  40c808:	48 89 c3             	mov    %rax,%rbx
  return internal_iserror(map) ? nullptr : (void *)map;
  40c80b:	e8 60 ec ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
  40c810:	84 c0                	test   %al,%al
  40c812:	4c 89 e0             	mov    %r12,%rax
  40c815:	48 0f 44 c3          	cmove  %rbx,%rax
}
  40c819:	48 83 c4 08          	add    $0x8,%rsp
  40c81d:	5b                   	pop    %rbx
  40c81e:	5d                   	pop    %rbp
  40c81f:	41 5c                	pop    %r12
  40c821:	41 5d                	pop    %r13
  40c823:	c3                   	retq   
  return !internal_iserror(res, error_p);
}

void *MapFileToMemory(const char *file_name, uptr *buff_size) {
  fd_t fd = OpenFile(file_name, RdOnly);
  CHECK(fd != kInvalidFd);
  40c824:	48 8d 15 73 c4 00 00 	lea    0xc473(%rip),%rdx        # 418c9e <.LC8>
  40c82b:	48 8d 3d 96 ab 00 00 	lea    0xab96(%rip),%rdi        # 4173c8 <.LC2>
  40c832:	45 31 c0             	xor    %r8d,%r8d
  40c835:	31 c9                	xor    %ecx,%ecx
  40c837:	be de 00 00 00       	mov    $0xde,%esi
  40c83c:	e8 af 8b ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40c841:	48 8d 15 b8 8a 00 00 	lea    0x8ab8(%rip),%rdx        # 415300 <.LC19>
  40c848:	48 8d 3d c1 87 00 00 	lea    0x87c1(%rip),%rdi        # 415010 <.LC1>
  40c84f:	45 31 c0             	xor    %r8d,%r8d
  40c852:	31 c9                	xor    %ecx,%ecx
  40c854:	be a9 01 00 00       	mov    $0x1a9,%esi
  40c859:	e8 92 8b ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  uptr fsize = internal_filesize(fd);
  CHECK_NE(fsize, (uptr)-1);
  CHECK_GT(fsize, 0);
  40c85e:	48 8d 15 6f c4 00 00 	lea    0xc46f(%rip),%rdx        # 418cd4 <.LC10>
  40c865:	48 8d 3d 5c ab 00 00 	lea    0xab5c(%rip),%rdi        # 4173c8 <.LC2>
  40c86c:	45 31 c0             	xor    %r8d,%r8d
  40c86f:	31 c9                	xor    %ecx,%ecx
  40c871:	be e1 00 00 00       	mov    $0xe1,%esi
  40c876:	e8 75 8b ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

void *MapFileToMemory(const char *file_name, uptr *buff_size) {
  fd_t fd = OpenFile(file_name, RdOnly);
  CHECK(fd != kInvalidFd);
  uptr fsize = internal_filesize(fd);
  CHECK_NE(fsize, (uptr)-1);
  40c87b:	48 8d 15 38 c4 00 00 	lea    0xc438(%rip),%rdx        # 418cba <.LC9>
  40c882:	48 8d 3d 3f ab 00 00 	lea    0xab3f(%rip),%rdi        # 4173c8 <.LC2>
  40c889:	49 89 c0             	mov    %rax,%r8
  40c88c:	48 89 c1             	mov    %rax,%rcx
  40c88f:	be e0 00 00 00       	mov    $0xe0,%esi
  40c894:	e8 57 8b ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40c899:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000040c8a0 <_ZN11__sanitizer23MapWritableFileToMemoryEPvmiy>:
  *buff_size = RoundUpTo(fsize, GetPageSizeCached());
  uptr map = internal_mmap(nullptr, *buff_size, PROT_READ, MAP_PRIVATE, fd, 0);
  return internal_iserror(map) ? nullptr : (void *)map;
}

void *MapWritableFileToMemory(void *addr, uptr size, fd_t fd, OFF_T offset) {
  40c8a0:	41 55                	push   %r13
  uptr flags = MAP_SHARED;
  if (addr) flags |= MAP_FIXED;
  uptr p = internal_mmap(addr, size, PROT_READ | PROT_WRITE, flags, fd, offset);
  40c8a2:	41 89 d0             	mov    %edx,%r8d
  *buff_size = RoundUpTo(fsize, GetPageSizeCached());
  uptr map = internal_mmap(nullptr, *buff_size, PROT_READ, MAP_PRIVATE, fd, 0);
  return internal_iserror(map) ? nullptr : (void *)map;
}

void *MapWritableFileToMemory(void *addr, uptr size, fd_t fd, OFF_T offset) {
  40c8a5:	49 89 f5             	mov    %rsi,%r13
  40c8a8:	41 54                	push   %r12
  40c8aa:	49 89 cc             	mov    %rcx,%r12
  uptr flags = MAP_SHARED;
  if (addr) flags |= MAP_FIXED;
  uptr p = internal_mmap(addr, size, PROT_READ | PROT_WRITE, flags, fd, offset);
  40c8ad:	4d 89 e1             	mov    %r12,%r9
  *buff_size = RoundUpTo(fsize, GetPageSizeCached());
  uptr map = internal_mmap(nullptr, *buff_size, PROT_READ, MAP_PRIVATE, fd, 0);
  return internal_iserror(map) ? nullptr : (void *)map;
}

void *MapWritableFileToMemory(void *addr, uptr size, fd_t fd, OFF_T offset) {
  40c8b0:	55                   	push   %rbp
  40c8b1:	89 d5                	mov    %edx,%ebp
  uptr flags = MAP_SHARED;
  if (addr) flags |= MAP_FIXED;
  uptr p = internal_mmap(addr, size, PROT_READ | PROT_WRITE, flags, fd, offset);
  40c8b3:	ba 03 00 00 00       	mov    $0x3,%edx
  *buff_size = RoundUpTo(fsize, GetPageSizeCached());
  uptr map = internal_mmap(nullptr, *buff_size, PROT_READ, MAP_PRIVATE, fd, 0);
  return internal_iserror(map) ? nullptr : (void *)map;
}

void *MapWritableFileToMemory(void *addr, uptr size, fd_t fd, OFF_T offset) {
  40c8b8:	53                   	push   %rbx
  40c8b9:	48 83 ec 18          	sub    $0x18,%rsp
  uptr flags = MAP_SHARED;
  if (addr) flags |= MAP_FIXED;
  40c8bd:	48 83 ff 01          	cmp    $0x1,%rdi
  40c8c1:	19 c9                	sbb    %ecx,%ecx
  40c8c3:	83 e1 f0             	and    $0xfffffff0,%ecx
  40c8c6:	83 c1 11             	add    $0x11,%ecx
  uptr p = internal_mmap(addr, size, PROT_READ | PROT_WRITE, flags, fd, offset);
  40c8c9:	e8 d2 eb ff ff       	callq  40b4a0 <_ZN11__sanitizer13internal_mmapEPvmiiiy>
  int mmap_errno = 0;
  if (internal_iserror(p, &mmap_errno)) {
  40c8ce:	48 89 e6             	mov    %rsp,%rsi
  40c8d1:	48 89 c7             	mov    %rax,%rdi
}

void *MapWritableFileToMemory(void *addr, uptr size, fd_t fd, OFF_T offset) {
  uptr flags = MAP_SHARED;
  if (addr) flags |= MAP_FIXED;
  uptr p = internal_mmap(addr, size, PROT_READ | PROT_WRITE, flags, fd, offset);
  40c8d4:	48 89 c3             	mov    %rax,%rbx
  int mmap_errno = 0;
  40c8d7:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  if (internal_iserror(p, &mmap_errno)) {
  40c8de:	e8 8d eb ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
  40c8e3:	84 c0                	test   %al,%al
    Printf("could not map writable file (%d, %lld, %zu): %zd, errno: %d\n",
           fd, (long long)offset, size, p, mmap_errno);
    return nullptr;
  }
  return (void *)p;
  40c8e5:	49 89 d8             	mov    %rbx,%r8
void *MapWritableFileToMemory(void *addr, uptr size, fd_t fd, OFF_T offset) {
  uptr flags = MAP_SHARED;
  if (addr) flags |= MAP_FIXED;
  uptr p = internal_mmap(addr, size, PROT_READ | PROT_WRITE, flags, fd, offset);
  int mmap_errno = 0;
  if (internal_iserror(p, &mmap_errno)) {
  40c8e8:	75 16                	jne    40c900 <_ZN11__sanitizer23MapWritableFileToMemoryEPvmiy+0x60>
    Printf("could not map writable file (%d, %lld, %zu): %zd, errno: %d\n",
           fd, (long long)offset, size, p, mmap_errno);
    return nullptr;
  }
  return (void *)p;
}
  40c8ea:	48 83 c4 18          	add    $0x18,%rsp
  40c8ee:	4c 89 c0             	mov    %r8,%rax
  40c8f1:	5b                   	pop    %rbx
  40c8f2:	5d                   	pop    %rbp
  40c8f3:	41 5c                	pop    %r12
  40c8f5:	41 5d                	pop    %r13
  40c8f7:	c3                   	retq   
  40c8f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40c8ff:	00 
  if (addr) flags |= MAP_FIXED;
  uptr p = internal_mmap(addr, size, PROT_READ | PROT_WRITE, flags, fd, offset);
  int mmap_errno = 0;
  if (internal_iserror(p, &mmap_errno)) {
    Printf("could not map writable file (%d, %lld, %zu): %zd, errno: %d\n",
           fd, (long long)offset, size, p, mmap_errno);
  40c900:	44 8b 0c 24          	mov    (%rsp),%r9d
  40c904:	48 8d 3d f5 ab 00 00 	lea    0xabf5(%rip),%rdi        # 417500 <.LC11>
  40c90b:	4c 89 e9             	mov    %r13,%rcx
  40c90e:	4c 89 e2             	mov    %r12,%rdx
  40c911:	89 ee                	mov    %ebp,%esi
  40c913:	31 c0                	xor    %eax,%eax
  40c915:	e8 d6 10 00 00       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
    return nullptr;
  40c91a:	45 31 c0             	xor    %r8d,%r8d
  40c91d:	eb cb                	jmp    40c8ea <_ZN11__sanitizer23MapWritableFileToMemoryEPvmiy+0x4a>
  40c91f:	90                   	nop

000000000040c920 <_ZN11__sanitizer22MemoryRangeIsAvailableEmm>:

// FIXME: this is thread-unsafe, but should not cause problems most of the time.
// When the shadow is mapped only a single thread usually exists (plus maybe
// several worker threads on Mac, which aren't expected to map big chunks of
// memory).
bool MemoryRangeIsAvailable(uptr range_start, uptr range_end) {
  40c920:	41 57                	push   %r15
  40c922:	41 56                	push   %r14
  40c924:	49 89 f6             	mov    %rsi,%r14
  MemoryMappingLayout proc_maps(/*cache_enabled*/true);
  40c927:	be 01 00 00 00       	mov    $0x1,%esi

// FIXME: this is thread-unsafe, but should not cause problems most of the time.
// When the shadow is mapped only a single thread usually exists (plus maybe
// several worker threads on Mac, which aren't expected to map big chunks of
// memory).
bool MemoryRangeIsAvailable(uptr range_start, uptr range_end) {
  40c92c:	41 55                	push   %r13
  40c92e:	49 89 fd             	mov    %rdi,%r13
  40c931:	41 54                	push   %r12
  40c933:	55                   	push   %rbp
  40c934:	53                   	push   %rbx
  40c935:	48 83 ec 58          	sub    $0x58,%rsp
  MemoryMappingLayout proc_maps(/*cache_enabled*/true);
  40c939:	48 8d 5c 24 30       	lea    0x30(%rsp),%rbx
  40c93e:	4c 8d 64 24 20       	lea    0x20(%rsp),%r12
  40c943:	48 8d 6c 24 10       	lea    0x10(%rsp),%rbp
  40c948:	48 89 df             	mov    %rbx,%rdi
  40c94b:	e8 c0 13 00 00       	callq  40dd10 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb>
  40c950:	4d 39 f5             	cmp    %r14,%r13
  40c953:	0f 87 b9 00 00 00    	ja     40ca12 <_ZN11__sanitizer22MemoryRangeIsAvailableEmm+0xf2>
  40c959:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  uptr start, end;
  while (proc_maps.Next(&start, &end,
  40c960:	45 31 c9             	xor    %r9d,%r9d
  40c963:	45 31 c0             	xor    %r8d,%r8d
  40c966:	31 c9                	xor    %ecx,%ecx
  40c968:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  40c96f:	00 
  40c970:	4c 89 e2             	mov    %r12,%rdx
  40c973:	48 89 ee             	mov    %rbp,%rsi
  40c976:	48 89 df             	mov    %rbx,%rdi
  40c979:	e8 e2 1a 00 00       	callq  40e460 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_>
  40c97e:	84 c0                	test   %al,%al
  40c980:	74 4e                	je     40c9d0 <_ZN11__sanitizer22MemoryRangeIsAvailableEmm+0xb0>
                        /*offset*/nullptr, /*filename*/nullptr,
                        /*filename_size*/0, /*protection*/nullptr)) {
    if (start == end) continue;  // Empty range.
  40c982:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  40c987:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  40c98c:	48 39 c2             	cmp    %rax,%rdx
  40c98f:	74 cf                	je     40c960 <_ZN11__sanitizer22MemoryRangeIsAvailableEmm+0x40>
    CHECK_NE(0, end);
  40c991:	48 85 c0             	test   %rax,%rax
  40c994:	74 42                	je     40c9d8 <_ZN11__sanitizer22MemoryRangeIsAvailableEmm+0xb8>
    if (!IntervalsAreSeparate(start, end - 1, range_start, range_end))
  40c996:	48 83 e8 01          	sub    $0x1,%rax
  return (void *)p;
}

static inline bool IntervalsAreSeparate(uptr start1, uptr end1,
                                        uptr start2, uptr end2) {
  CHECK(start1 <= end1);
  40c99a:	48 39 c2             	cmp    %rax,%rdx
  40c99d:	77 56                	ja     40c9f5 <_ZN11__sanitizer22MemoryRangeIsAvailableEmm+0xd5>
  CHECK(start2 <= end2);
  return (end1 < start2) || (end2 < start1);
  40c99f:	4c 39 e8             	cmp    %r13,%rax
  40c9a2:	0f 92 c1             	setb   %cl
  40c9a5:	4c 39 f2             	cmp    %r14,%rdx
  40c9a8:	0f 97 c0             	seta   %al
  while (proc_maps.Next(&start, &end,
                        /*offset*/nullptr, /*filename*/nullptr,
                        /*filename_size*/0, /*protection*/nullptr)) {
    if (start == end) continue;  // Empty range.
    CHECK_NE(0, end);
    if (!IntervalsAreSeparate(start, end - 1, range_start, range_end))
  40c9ab:	08 c1                	or     %al,%cl
  40c9ad:	41 89 cf             	mov    %ecx,%r15d
  40c9b0:	75 ae                	jne    40c960 <_ZN11__sanitizer22MemoryRangeIsAvailableEmm+0x40>
      return false;
  }
  return true;
  40c9b2:	48 89 df             	mov    %rbx,%rdi
  40c9b5:	e8 e6 14 00 00       	callq  40dea0 <_ZN11__sanitizer19MemoryMappingLayoutD1Ev>
}
  40c9ba:	48 83 c4 58          	add    $0x58,%rsp
  40c9be:	44 89 f8             	mov    %r15d,%eax
  40c9c1:	5b                   	pop    %rbx
  40c9c2:	5d                   	pop    %rbp
  40c9c3:	41 5c                	pop    %r12
  40c9c5:	41 5d                	pop    %r13
  40c9c7:	41 5e                	pop    %r14
  40c9c9:	41 5f                	pop    %r15
  40c9cb:	c3                   	retq   
  40c9cc:	0f 1f 40 00          	nopl   0x0(%rax)
    if (start == end) continue;  // Empty range.
    CHECK_NE(0, end);
    if (!IntervalsAreSeparate(start, end - 1, range_start, range_end))
      return false;
  }
  return true;
  40c9d0:	41 bf 01 00 00 00    	mov    $0x1,%r15d
  40c9d6:	eb da                	jmp    40c9b2 <_ZN11__sanitizer22MemoryRangeIsAvailableEmm+0x92>
  uptr start, end;
  while (proc_maps.Next(&start, &end,
                        /*offset*/nullptr, /*filename*/nullptr,
                        /*filename_size*/0, /*protection*/nullptr)) {
    if (start == end) continue;  // Empty range.
    CHECK_NE(0, end);
  40c9d8:	48 8d 15 07 c3 00 00 	lea    0xc307(%rip),%rdx        # 418ce6 <.LC12>
  40c9df:	48 8d 3d e2 a9 00 00 	lea    0xa9e2(%rip),%rdi        # 4173c8 <.LC2>
  40c9e6:	45 31 c0             	xor    %r8d,%r8d
  40c9e9:	31 c9                	xor    %ecx,%ecx
  40c9eb:	be 06 01 00 00       	mov    $0x106,%esi
  40c9f0:	e8 fb 89 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  return (void *)p;
}

static inline bool IntervalsAreSeparate(uptr start1, uptr end1,
                                        uptr start2, uptr end2) {
  CHECK(start1 <= end1);
  40c9f5:	48 8d 15 fb c2 00 00 	lea    0xc2fb(%rip),%rdx        # 418cf7 <.LC13>
  40c9fc:	48 8d 3d c5 a9 00 00 	lea    0xa9c5(%rip),%rdi        # 4173c8 <.LC2>
  40ca03:	45 31 c0             	xor    %r8d,%r8d
  40ca06:	31 c9                	xor    %ecx,%ecx
  40ca08:	be f6 00 00 00       	mov    $0xf6,%esi
  40ca0d:	e8 de 89 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
// several worker threads on Mac, which aren't expected to map big chunks of
// memory).
bool MemoryRangeIsAvailable(uptr range_start, uptr range_end) {
  MemoryMappingLayout proc_maps(/*cache_enabled*/true);
  uptr start, end;
  while (proc_maps.Next(&start, &end,
  40ca12:	45 31 c9             	xor    %r9d,%r9d
  40ca15:	45 31 c0             	xor    %r8d,%r8d
  40ca18:	31 c9                	xor    %ecx,%ecx
  40ca1a:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  40ca21:	00 
  40ca22:	4c 89 e2             	mov    %r12,%rdx
  40ca25:	48 89 ee             	mov    %rbp,%rsi
  40ca28:	48 89 df             	mov    %rbx,%rdi
  40ca2b:	e8 30 1a 00 00       	callq  40e460 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_>
  40ca30:	84 c0                	test   %al,%al
  40ca32:	74 9c                	je     40c9d0 <_ZN11__sanitizer22MemoryRangeIsAvailableEmm+0xb0>
                        /*offset*/nullptr, /*filename*/nullptr,
                        /*filename_size*/0, /*protection*/nullptr)) {
    if (start == end) continue;  // Empty range.
  40ca34:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  40ca39:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  40ca3e:	48 39 c2             	cmp    %rax,%rdx
  40ca41:	74 cf                	je     40ca12 <_ZN11__sanitizer22MemoryRangeIsAvailableEmm+0xf2>
    CHECK_NE(0, end);
  40ca43:	48 85 c0             	test   %rax,%rax
  40ca46:	74 90                	je     40c9d8 <_ZN11__sanitizer22MemoryRangeIsAvailableEmm+0xb8>
    if (!IntervalsAreSeparate(start, end - 1, range_start, range_end))
  40ca48:	48 83 e8 01          	sub    $0x1,%rax
  return (void *)p;
}

static inline bool IntervalsAreSeparate(uptr start1, uptr end1,
                                        uptr start2, uptr end2) {
  CHECK(start1 <= end1);
  40ca4c:	48 39 d0             	cmp    %rdx,%rax
  40ca4f:	72 a4                	jb     40c9f5 <_ZN11__sanitizer22MemoryRangeIsAvailableEmm+0xd5>
  CHECK(start2 <= end2);
  40ca51:	48 8d 15 b9 c2 00 00 	lea    0xc2b9(%rip),%rdx        # 418d11 <.LC14>
  40ca58:	48 8d 3d 69 a9 00 00 	lea    0xa969(%rip),%rdi        # 4173c8 <.LC2>
  40ca5f:	45 31 c0             	xor    %r8d,%r8d
  40ca62:	31 c9                	xor    %ecx,%ecx
  40ca64:	be f7 00 00 00       	mov    $0xf7,%esi
  40ca69:	e8 82 89 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40ca6e:	66 90                	xchg   %ax,%ax

000000000040ca70 <_ZN11__sanitizer14DumpProcessMapEv>:
      return false;
  }
  return true;
}

void DumpProcessMap() {
  40ca70:	41 55                	push   %r13
  MemoryMappingLayout proc_maps(/*cache_enabled*/true);
  40ca72:	be 01 00 00 00       	mov    $0x1,%esi
      return false;
  }
  return true;
}

void DumpProcessMap() {
  40ca77:	41 54                	push   %r12
  40ca79:	55                   	push   %rbp
  40ca7a:	53                   	push   %rbx
  40ca7b:	48 83 ec 58          	sub    $0x58,%rsp
  MemoryMappingLayout proc_maps(/*cache_enabled*/true);
  40ca7f:	48 8d 6c 24 30       	lea    0x30(%rsp),%rbp
  40ca84:	48 89 ef             	mov    %rbp,%rdi
  40ca87:	e8 84 12 00 00       	callq  40dd10 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb>
  return res;
#endif  // SANITIZER_WORDSIZE
}

void *MmapOrDie(uptr size, const char *mem_type) {
  size = RoundUpTo(size, GetPageSizeCached());
  40ca8c:	e8 1f 86 ff ff       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
#endif
  return up;
}

INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
  40ca91:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40ca95:	48 85 c2             	test   %rax,%rdx
  40ca98:	0f 85 19 01 00 00    	jne    40cbb7 <_ZN11__sanitizer14DumpProcessMapEv+0x147>
  return (size + boundary - 1) & ~(boundary - 1);
  40ca9e:	49 89 c5             	mov    %rax,%r13
  40caa1:	48 05 fe 0f 00 00    	add    $0xffe,%rax
  uptr res = internal_mmap(nullptr, size,
                           PROT_READ | PROT_WRITE,
                           MAP_PRIVATE | MAP_ANON, -1, 0);
  int reserrno;
  if (internal_iserror(res, &reserrno))
  40caa7:	4c 8d 64 24 20       	lea    0x20(%rsp),%r12
  40caac:	49 f7 dd             	neg    %r13

void *MmapOrDie(uptr size, const char *mem_type) {
  size = RoundUpTo(size, GetPageSizeCached());
  uptr res = internal_mmap(nullptr, size,
                           PROT_READ | PROT_WRITE,
                           MAP_PRIVATE | MAP_ANON, -1, 0);
  40caaf:	45 31 c9             	xor    %r9d,%r9d
  40cab2:	31 ff                	xor    %edi,%edi
  40cab4:	49 21 c5             	and    %rax,%r13
  40cab7:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
  40cabd:	b9 22 00 00 00       	mov    $0x22,%ecx
  40cac2:	ba 03 00 00 00       	mov    $0x3,%edx
  40cac7:	4c 89 ee             	mov    %r13,%rsi
  40caca:	e8 d1 e9 ff ff       	callq  40b4a0 <_ZN11__sanitizer13internal_mmapEPvmiiiy>
  int reserrno;
  if (internal_iserror(res, &reserrno))
  40cacf:	4c 89 e6             	mov    %r12,%rsi
  40cad2:	48 89 c7             	mov    %rax,%rdi

void *MmapOrDie(uptr size, const char *mem_type) {
  size = RoundUpTo(size, GetPageSizeCached());
  uptr res = internal_mmap(nullptr, size,
                           PROT_READ | PROT_WRITE,
                           MAP_PRIVATE | MAP_ANON, -1, 0);
  40cad5:	48 89 c3             	mov    %rax,%rbx
  int reserrno;
  if (internal_iserror(res, &reserrno))
  40cad8:	e8 93 e9 ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
  40cadd:	84 c0                	test   %al,%al
  40cadf:	0f 85 bf 00 00 00    	jne    40cba4 <_ZN11__sanitizer14DumpProcessMapEv+0x134>
    ReportMmapFailureAndDie(size, mem_type, reserrno);
  IncreaseTotalMmap(size);
  40cae5:	4c 89 ef             	mov    %r13,%rdi
  40cae8:	4c 8d 6c 24 10       	lea    0x10(%rsp),%r13
  40caed:	e8 5e 90 ff ff       	callq  405b50 <_ZN11__sanitizer17IncreaseTotalMmapEm>
void DumpProcessMap() {
  MemoryMappingLayout proc_maps(/*cache_enabled*/true);
  uptr start, end;
  const sptr kBufSize = 4095;
  char *filename = (char*)MmapOrDie(kBufSize, __func__);
  Report("Process memory map follows:\n");
  40caf2:	48 8d 3d 32 c2 00 00 	lea    0xc232(%rip),%rdi        # 418d2b <.LC15>
  40caf9:	31 c0                	xor    %eax,%eax
  40cafb:	e8 90 0f 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
  while (proc_maps.Next(&start, &end, /* file_offset */nullptr,
  40cb00:	eb 21                	jmp    40cb23 <_ZN11__sanitizer14DumpProcessMapEv+0xb3>
  40cb02:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                        filename, kBufSize, /* protection */nullptr)) {
    Printf("\t%p-%p\t%s\n", (void*)start, (void*)end, filename);
  40cb08:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
  40cb0d:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40cb12:	48 8d 3d 2f c2 00 00 	lea    0xc22f(%rip),%rdi        # 418d48 <.LC16>
  40cb19:	48 89 d9             	mov    %rbx,%rcx
  40cb1c:	31 c0                	xor    %eax,%eax
  40cb1e:	e8 cd 0e 00 00       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  MemoryMappingLayout proc_maps(/*cache_enabled*/true);
  uptr start, end;
  const sptr kBufSize = 4095;
  char *filename = (char*)MmapOrDie(kBufSize, __func__);
  Report("Process memory map follows:\n");
  while (proc_maps.Next(&start, &end, /* file_offset */nullptr,
  40cb23:	31 c9                	xor    %ecx,%ecx
  40cb25:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  40cb2c:	00 
  40cb2d:	41 b9 ff 0f 00 00    	mov    $0xfff,%r9d
  40cb33:	49 89 d8             	mov    %rbx,%r8
  40cb36:	4c 89 e2             	mov    %r12,%rdx
  40cb39:	4c 89 ee             	mov    %r13,%rsi
  40cb3c:	48 89 ef             	mov    %rbp,%rdi
  40cb3f:	e8 1c 19 00 00       	callq  40e460 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_>
  40cb44:	84 c0                	test   %al,%al
  40cb46:	75 c0                	jne    40cb08 <_ZN11__sanitizer14DumpProcessMapEv+0x98>
                        filename, kBufSize, /* protection */nullptr)) {
    Printf("\t%p-%p\t%s\n", (void*)start, (void*)end, filename);
  }
  Report("End of process memory map.\n");
  40cb48:	48 8d 3d 04 c2 00 00 	lea    0xc204(%rip),%rdi        # 418d53 <.LC17>
  40cb4f:	e8 3c 0f 00 00       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
  IncreaseTotalMmap(size);
  return (void *)res;
}

void UnmapOrDie(void *addr, uptr size) {
  if (!addr || !size) return;
  40cb54:	48 85 db             	test   %rbx,%rbx
  40cb57:	75 17                	jne    40cb70 <_ZN11__sanitizer14DumpProcessMapEv+0x100>
  while (proc_maps.Next(&start, &end, /* file_offset */nullptr,
                        filename, kBufSize, /* protection */nullptr)) {
    Printf("\t%p-%p\t%s\n", (void*)start, (void*)end, filename);
  }
  Report("End of process memory map.\n");
  UnmapOrDie(filename, kBufSize);
  40cb59:	48 89 ef             	mov    %rbp,%rdi
  40cb5c:	e8 3f 13 00 00       	callq  40dea0 <_ZN11__sanitizer19MemoryMappingLayoutD1Ev>
}
  40cb61:	48 83 c4 58          	add    $0x58,%rsp
  40cb65:	5b                   	pop    %rbx
  40cb66:	5d                   	pop    %rbp
  40cb67:	41 5c                	pop    %r12
  40cb69:	41 5d                	pop    %r13
  40cb6b:	c3                   	retq   
  40cb6c:	0f 1f 40 00          	nopl   0x0(%rax)
  return (void *)res;
}

void UnmapOrDie(void *addr, uptr size) {
  if (!addr || !size) return;
  uptr res = internal_munmap(addr, size);
  40cb70:	be ff 0f 00 00       	mov    $0xfff,%esi
  40cb75:	48 89 df             	mov    %rbx,%rdi
  40cb78:	e8 53 e9 ff ff       	callq  40b4d0 <_ZN11__sanitizer15internal_munmapEPvm>
  if (internal_iserror(res)) {
  40cb7d:	31 f6                	xor    %esi,%esi
  40cb7f:	48 89 c7             	mov    %rax,%rdi
  40cb82:	e8 e9 e8 ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
  40cb87:	84 c0                	test   %al,%al
  40cb89:	75 0c                	jne    40cb97 <_ZN11__sanitizer14DumpProcessMapEv+0x127>
    Report("ERROR: %s failed to deallocate 0x%zx (%zd) bytes at address %p\n",
           SanitizerToolName, size, size, addr);
    CHECK("unable to unmap" && 0);
  }
  DecreaseTotalMmap(size);
  40cb8b:	bf ff 0f 00 00       	mov    $0xfff,%edi
  40cb90:	e8 fb 8f ff ff       	callq  405b90 <_ZN11__sanitizer17DecreaseTotalMmapEm>
  40cb95:	eb c2                	jmp    40cb59 <_ZN11__sanitizer14DumpProcessMapEv+0xe9>
  40cb97:	be ff 0f 00 00       	mov    $0xfff,%esi
  40cb9c:	48 89 df             	mov    %rbx,%rdi
  40cb9f:	e8 db 59 ff ff       	callq  40257f <_ZN11__sanitizer10UnmapOrDieEPvm.part.0>
  uptr res = internal_mmap(nullptr, size,
                           PROT_READ | PROT_WRITE,
                           MAP_PRIVATE | MAP_ANON, -1, 0);
  int reserrno;
  if (internal_iserror(res, &reserrno))
    ReportMmapFailureAndDie(size, mem_type, reserrno);
  40cba4:	8b 54 24 20          	mov    0x20(%rsp),%edx
  40cba8:	48 8d 35 a9 c5 00 00 	lea    0xc5a9(%rip),%rsi        # 419158 <_ZZN11__sanitizer14DumpProcessMapEvE8__func__>
  40cbaf:	4c 89 ef             	mov    %r13,%rdi
  40cbb2:	e8 c9 89 ff ff       	callq  405580 <_ZN11__sanitizer23ReportMmapFailureAndDieEmPKci>
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40cbb7:	48 8d 15 42 87 00 00 	lea    0x8742(%rip),%rdx        # 415300 <.LC19>
  40cbbe:	48 8d 3d 4b 84 00 00 	lea    0x844b(%rip),%rdi        # 415010 <.LC1>
  40cbc5:	45 31 c0             	xor    %r8d,%r8d
  40cbc8:	31 c9                	xor    %ecx,%ecx
  40cbca:	be a9 01 00 00       	mov    $0x1a9,%esi
  40cbcf:	e8 1c 88 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40cbd4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40cbdb:	00 00 00 00 00 

000000000040cbe0 <_ZN11__sanitizer6GetPwdEv>:
  Report("End of process memory map.\n");
  UnmapOrDie(filename, kBufSize);
}

const char *GetPwd() {
  return GetEnv("PWD");
  40cbe0:	48 8d 3d 88 c1 00 00 	lea    0xc188(%rip),%rdi        # 418d6f <.LC18>
  40cbe7:	e9 f4 ea ff ff       	jmpq   40b6e0 <_ZN11__sanitizer6GetEnvEPKc>
  40cbec:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040cbf0 <_ZN11__sanitizer15IsPathSeparatorEc>:
}

bool IsPathSeparator(const char c) {
  return c == '/';
  40cbf0:	40 80 ff 2f          	cmp    $0x2f,%dil
  40cbf4:	0f 94 c0             	sete   %al
}
  40cbf7:	c3                   	retq   
  40cbf8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40cbff:	00 

000000000040cc00 <_ZN11__sanitizer14IsAbsolutePathEPKc>:

bool IsAbsolutePath(const char *path) {
  return path != nullptr && IsPathSeparator(path[0]);
  40cc00:	48 85 ff             	test   %rdi,%rdi
  40cc03:	74 0b                	je     40cc10 <_ZN11__sanitizer14IsAbsolutePathEPKc+0x10>
  40cc05:	80 3f 2f             	cmpb   $0x2f,(%rdi)
  40cc08:	0f 94 c0             	sete   %al
  40cc0b:	c3                   	retq   
  40cc0c:	0f 1f 40 00          	nopl   0x0(%rax)
  40cc10:	31 c0                	xor    %eax,%eax
}
  40cc12:	c3                   	retq   
  40cc13:	90                   	nop
  40cc14:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40cc1b:	00 00 00 00 00 

000000000040cc20 <_ZN11__sanitizer10ReportFile5WriteEPKcm>:

void ReportFile::Write(const char *buffer, uptr length) {
  40cc20:	41 55                	push   %r13
  40cc22:	b8 01 00 00 00       	mov    $0x1,%eax
  40cc27:	49 89 f5             	mov    %rsi,%r13
  40cc2a:	41 54                	push   %r12
  40cc2c:	49 89 d4             	mov    %rdx,%r12
  40cc2f:	55                   	push   %rbp
  40cc30:	48 89 fd             	mov    %rdi,%rbp
  40cc33:	53                   	push   %rbx
  40cc34:	48 83 ec 08          	sub    $0x8,%rsp
  SpinMutexLock l(mu);
  40cc38:	48 8b 1f             	mov    (%rdi),%rbx
  40cc3b:	86 03                	xchg   %al,(%rbx)
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  40cc3d:	84 c0                	test   %al,%al
  40cc3f:	74 08                	je     40cc49 <_ZN11__sanitizer10ReportFile5WriteEPKcm+0x29>
      return;
    LockSlow();
  40cc41:	48 89 df             	mov    %rbx,%rdi
  40cc44:	e8 07 79 ff ff       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  static const char *kWriteError =
      "ReportFile::Write() can't output requested buffer!\n";
  ReopenIfNecessary();
  40cc49:	48 89 ef             	mov    %rbp,%rdi
  40cc4c:	e8 ef 87 ff ff       	callq  405440 <_ZN11__sanitizer10ReportFile17ReopenIfNecessaryEv>
  if (length != internal_write(fd, buffer, length)) {
  40cc51:	8b 7d 08             	mov    0x8(%rbp),%edi
  40cc54:	4c 89 e2             	mov    %r12,%rdx
  40cc57:	4c 89 ee             	mov    %r13,%rsi
  40cc5a:	e8 e1 e8 ff ff       	callq  40b540 <_ZN11__sanitizer14internal_writeEiPKvm>
  40cc5f:	49 39 c4             	cmp    %rax,%r12
  40cc62:	75 0e                	jne    40cc72 <_ZN11__sanitizer10ReportFile5WriteEPKcm+0x52>
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  40cc64:	c6 03 00             	movb   $0x0,(%rbx)
    internal_write(fd, kWriteError, internal_strlen(kWriteError));
    Die();
  }
}
  40cc67:	48 83 c4 08          	add    $0x8,%rsp
  40cc6b:	5b                   	pop    %rbx
  40cc6c:	5d                   	pop    %rbp
  40cc6d:	41 5c                	pop    %r12
  40cc6f:	41 5d                	pop    %r13
  40cc71:	c3                   	retq   
  SpinMutexLock l(mu);
  static const char *kWriteError =
      "ReportFile::Write() can't output requested buffer!\n";
  ReopenIfNecessary();
  if (length != internal_write(fd, buffer, length)) {
    internal_write(fd, kWriteError, internal_strlen(kWriteError));
  40cc72:	48 8d 3d c7 a8 00 00 	lea    0xa8c7(%rip),%rdi        # 417540 <.LC19>
  40cc79:	e8 b2 dc ff ff       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  40cc7e:	8b 7d 08             	mov    0x8(%rbp),%edi
  40cc81:	48 8d 35 b8 a8 00 00 	lea    0xa8b8(%rip),%rsi        # 417540 <.LC19>
  40cc88:	48 89 c2             	mov    %rax,%rdx
  40cc8b:	e8 b0 e8 ff ff       	callq  40b540 <_ZN11__sanitizer14internal_writeEiPKvm>
    Die();
  40cc90:	e8 cb 85 ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  40cc95:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  40cc9c:	00 00 00 00 

000000000040cca0 <_ZN11__sanitizer19GetCodeRangeForFileEPKcPmS2_>:
  }
}

bool GetCodeRangeForFile(const char *module, uptr *start, uptr *end) {
  40cca0:	41 57                	push   %r15
  40cca2:	41 56                	push   %r14
  40cca4:	41 55                	push   %r13
  40cca6:	41 54                	push   %r12
  40cca8:	55                   	push   %rbp
  40cca9:	53                   	push   %rbx
  40ccaa:	48 83 ec 68          	sub    $0x68,%rsp
  40ccae:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  40ccb3:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  40ccb8:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  return res;
#endif  // SANITIZER_WORDSIZE
}

void *MmapOrDie(uptr size, const char *mem_type) {
  size = RoundUpTo(size, GetPageSizeCached());
  40ccbd:	e8 ee 83 ff ff       	callq  4050b0 <_ZN11__sanitizer17GetPageSizeCachedEv>
#endif
  return up;
}

INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
  40ccc2:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40ccc6:	48 85 c2             	test   %rax,%rdx
  40ccc9:	0f 85 26 01 00 00    	jne    40cdf5 <_ZN11__sanitizer19GetCodeRangeForFileEPKcPmS2_+0x155>
  return (size + boundary - 1) & ~(boundary - 1);
  40cccf:	49 89 c4             	mov    %rax,%r12
  40ccd2:	48 05 ff 0f 00 00    	add    $0xfff,%rax
  uptr res = internal_mmap(nullptr, size,
                           PROT_READ | PROT_WRITE,
                           MAP_PRIVATE | MAP_ANON, -1, 0);
  int reserrno;
  if (internal_iserror(res, &reserrno))
  40ccd8:	48 8d 6c 24 40       	lea    0x40(%rsp),%rbp
  40ccdd:	49 f7 dc             	neg    %r12

void *MmapOrDie(uptr size, const char *mem_type) {
  size = RoundUpTo(size, GetPageSizeCached());
  uptr res = internal_mmap(nullptr, size,
                           PROT_READ | PROT_WRITE,
                           MAP_PRIVATE | MAP_ANON, -1, 0);
  40cce0:	45 31 c9             	xor    %r9d,%r9d
  40cce3:	31 ff                	xor    %edi,%edi
  40cce5:	49 21 c4             	and    %rax,%r12
  40cce8:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
  40ccee:	b9 22 00 00 00       	mov    $0x22,%ecx
  40ccf3:	ba 03 00 00 00       	mov    $0x3,%edx
  40ccf8:	4c 89 e6             	mov    %r12,%rsi
  40ccfb:	e8 a0 e7 ff ff       	callq  40b4a0 <_ZN11__sanitizer13internal_mmapEPvmiiiy>
  int reserrno;
  if (internal_iserror(res, &reserrno))
  40cd00:	48 89 ee             	mov    %rbp,%rsi
  40cd03:	48 89 c7             	mov    %rax,%rdi

void *MmapOrDie(uptr size, const char *mem_type) {
  size = RoundUpTo(size, GetPageSizeCached());
  uptr res = internal_mmap(nullptr, size,
                           PROT_READ | PROT_WRITE,
                           MAP_PRIVATE | MAP_ANON, -1, 0);
  40cd06:	48 89 c3             	mov    %rax,%rbx
  int reserrno;
  if (internal_iserror(res, &reserrno))
  40cd09:	e8 62 e7 ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
  40cd0e:	84 c0                	test   %al,%al
  40cd10:	0f 85 cc 00 00 00    	jne    40cde2 <_ZN11__sanitizer19GetCodeRangeForFileEPKcPmS2_+0x142>
    ReportMmapFailureAndDie(size, mem_type, reserrno);
  IncreaseTotalMmap(size);
  40cd16:	4c 89 e7             	mov    %r12,%rdi
  40cd19:	4c 8d 7c 24 38       	lea    0x38(%rsp),%r15
  40cd1e:	4c 8d 74 24 30       	lea    0x30(%rsp),%r14
  40cd23:	4c 8d 6c 24 28       	lea    0x28(%rsp),%r13
  40cd28:	4c 8d 64 24 20       	lea    0x20(%rsp),%r12
  40cd2d:	e8 1e 8e ff ff       	callq  405b50 <_ZN11__sanitizer17IncreaseTotalMmapEm>

class InternalScopedString : public InternalScopedBuffer<char> {
 public:
  explicit InternalScopedString(uptr max_length)
      : InternalScopedBuffer<char>(max_length), length_(0) {
    (*this)[0] = '\0';
  40cd32:	c6 03 00             	movb   $0x0,(%rbx)
}

bool GetCodeRangeForFile(const char *module, uptr *start, uptr *end) {
  uptr s, e, off, prot;
  InternalScopedString buff(kMaxPathLength);
  MemoryMappingLayout proc_maps(/*cache_enabled*/false);
  40cd35:	31 f6                	xor    %esi,%esi
  40cd37:	48 89 ef             	mov    %rbp,%rdi
  40cd3a:	e8 d1 0f 00 00       	callq  40dd10 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb>
  40cd3f:	90                   	nop
  while (proc_maps.Next(&s, &e, &off, buff.data(), buff.size(), &prot)) {
  40cd40:	4c 89 24 24          	mov    %r12,(%rsp)
  40cd44:	41 b9 00 10 00 00    	mov    $0x1000,%r9d
  40cd4a:	49 89 d8             	mov    %rbx,%r8
  40cd4d:	4c 89 f9             	mov    %r15,%rcx
  40cd50:	4c 89 f2             	mov    %r14,%rdx
  40cd53:	4c 89 ee             	mov    %r13,%rsi
  40cd56:	48 89 ef             	mov    %rbp,%rdi
  40cd59:	e8 02 17 00 00       	callq  40e460 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_>
  40cd5e:	84 c0                	test   %al,%al
  40cd60:	74 3e                	je     40cda0 <_ZN11__sanitizer19GetCodeRangeForFileEPKcPmS2_+0x100>
    if ((prot & MemoryMappingLayout::kProtectionExecute) != 0
        && internal_strcmp(module, buff.data()) == 0) {
  40cd62:	f6 44 24 20 04       	testb  $0x4,0x20(%rsp)
  40cd67:	74 d7                	je     40cd40 <_ZN11__sanitizer19GetCodeRangeForFileEPKcPmS2_+0xa0>
  40cd69:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  40cd6e:	48 89 de             	mov    %rbx,%rsi
  40cd71:	e8 6a da ff ff       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
  40cd76:	85 c0                	test   %eax,%eax
  40cd78:	75 c6                	jne    40cd40 <_ZN11__sanitizer19GetCodeRangeForFileEPKcPmS2_+0xa0>
      *start = s;
  40cd7a:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  40cd7f:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
      *end = e;
      return true;
  40cd84:	41 bc 01 00 00 00    	mov    $0x1,%r12d
  InternalScopedString buff(kMaxPathLength);
  MemoryMappingLayout proc_maps(/*cache_enabled*/false);
  while (proc_maps.Next(&s, &e, &off, buff.data(), buff.size(), &prot)) {
    if ((prot & MemoryMappingLayout::kProtectionExecute) != 0
        && internal_strcmp(module, buff.data()) == 0) {
      *start = s;
  40cd8a:	48 89 01             	mov    %rax,(%rcx)
      *end = e;
  40cd8d:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  40cd92:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  40cd97:	48 89 01             	mov    %rax,(%rcx)
      return true;
  40cd9a:	eb 07                	jmp    40cda3 <_ZN11__sanitizer19GetCodeRangeForFileEPKcPmS2_+0x103>
  40cd9c:	0f 1f 40 00          	nopl   0x0(%rax)
    }
  }
  return false;
  40cda0:	45 31 e4             	xor    %r12d,%r12d
}

bool GetCodeRangeForFile(const char *module, uptr *start, uptr *end) {
  uptr s, e, off, prot;
  InternalScopedString buff(kMaxPathLength);
  MemoryMappingLayout proc_maps(/*cache_enabled*/false);
  40cda3:	48 89 ef             	mov    %rbp,%rdi
  40cda6:	e8 f5 10 00 00       	callq  40dea0 <_ZN11__sanitizer19MemoryMappingLayoutD1Ev>
  return (void *)res;
}

void UnmapOrDie(void *addr, uptr size) {
  if (!addr || !size) return;
  uptr res = internal_munmap(addr, size);
  40cdab:	be 00 10 00 00       	mov    $0x1000,%esi
  40cdb0:	48 89 df             	mov    %rbx,%rdi
  40cdb3:	e8 18 e7 ff ff       	callq  40b4d0 <_ZN11__sanitizer15internal_munmapEPvm>
  if (internal_iserror(res)) {
  40cdb8:	31 f6                	xor    %esi,%esi
  40cdba:	48 89 c7             	mov    %rax,%rdi
  40cdbd:	e8 ae e6 ff ff       	callq  40b470 <_ZN11__sanitizer16internal_iserrorEmPi>
  40cdc2:	84 c0                	test   %al,%al
  40cdc4:	75 4c                	jne    40ce12 <_ZN11__sanitizer19GetCodeRangeForFileEPKcPmS2_+0x172>
    Report("ERROR: %s failed to deallocate 0x%zx (%zd) bytes at address %p\n",
           SanitizerToolName, size, size, addr);
    CHECK("unable to unmap" && 0);
  }
  DecreaseTotalMmap(size);
  40cdc6:	bf 00 10 00 00       	mov    $0x1000,%edi
  40cdcb:	e8 c0 8d ff ff       	callq  405b90 <_ZN11__sanitizer17DecreaseTotalMmapEm>
      *end = e;
      return true;
    }
  }
  return false;
}
  40cdd0:	48 83 c4 68          	add    $0x68,%rsp
  40cdd4:	44 89 e0             	mov    %r12d,%eax
  40cdd7:	5b                   	pop    %rbx
  40cdd8:	5d                   	pop    %rbp
  40cdd9:	41 5c                	pop    %r12
  40cddb:	41 5d                	pop    %r13
  40cddd:	41 5e                	pop    %r14
  40cddf:	41 5f                	pop    %r15
  40cde1:	c3                   	retq   
  uptr res = internal_mmap(nullptr, size,
                           PROT_READ | PROT_WRITE,
                           MAP_PRIVATE | MAP_ANON, -1, 0);
  int reserrno;
  if (internal_iserror(res, &reserrno))
    ReportMmapFailureAndDie(size, mem_type, reserrno);
  40cde2:	8b 54 24 40          	mov    0x40(%rsp),%edx
  40cde6:	48 8d 35 8c b7 00 00 	lea    0xb78c(%rip),%rsi        # 418579 <.LC1>
  40cded:	4c 89 e7             	mov    %r12,%rdi
  40cdf0:	e8 8b 87 ff ff       	callq  405580 <_ZN11__sanitizer23ReportMmapFailureAndDieEmPKci>
  CHECK(size > (1ULL << up));
  return 1ULL << (up + 1);
}

INLINE uptr RoundUpTo(uptr size, uptr boundary) {
  CHECK(IsPowerOfTwo(boundary));
  40cdf5:	48 8d 15 04 85 00 00 	lea    0x8504(%rip),%rdx        # 415300 <.LC19>
  40cdfc:	48 8d 3d 0d 82 00 00 	lea    0x820d(%rip),%rdi        # 415010 <.LC1>
  40ce03:	45 31 c0             	xor    %r8d,%r8d
  40ce06:	31 c9                	xor    %ecx,%ecx
  40ce08:	be a9 01 00 00       	mov    $0x1a9,%esi
  40ce0d:	e8 de 85 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40ce12:	be 00 10 00 00       	mov    $0x1000,%esi
  40ce17:	48 89 df             	mov    %rbx,%rdi
  40ce1a:	e8 60 57 ff ff       	callq  40257f <_ZN11__sanitizer10UnmapOrDieEPvm.part.0>
  40ce1f:	90                   	nop

000000000040ce20 <_ZN11__sanitizer13SignalContext6CreateEPvS1_>:
    }
  }
  return false;
}

SignalContext SignalContext::Create(void *siginfo, void *context) {
  40ce20:	41 54                	push   %r12
  40ce22:	55                   	push   %rbp
  40ce23:	48 89 d5             	mov    %rdx,%rbp
  40ce26:	53                   	push   %rbx
  40ce27:	48 89 fb             	mov    %rdi,%rbx
  uptr addr = (uptr)((siginfo_t*)siginfo)->si_addr;
  uptr pc, sp, bp;
  GetPcSpBp(context, &pc, &sp, &bp);
  40ce2a:	48 89 ef             	mov    %rbp,%rdi
    }
  }
  return false;
}

SignalContext SignalContext::Create(void *siginfo, void *context) {
  40ce2d:	48 83 ec 20          	sub    $0x20,%rsp
  uptr addr = (uptr)((siginfo_t*)siginfo)->si_addr;
  40ce31:	4c 8b 66 10          	mov    0x10(%rsi),%r12
  uptr pc, sp, bp;
  GetPcSpBp(context, &pc, &sp, &bp);
  40ce35:	48 8d 4c 24 18       	lea    0x18(%rsp),%rcx
  40ce3a:	48 8d 54 24 10       	lea    0x10(%rsp),%rdx
  40ce3f:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
  40ce44:	e8 e7 f4 ff ff       	callq  40c330 <_ZN11__sanitizer9GetPcSpBpEPvPmS1_S1_>
  uptr pc;
  uptr sp;
  uptr bp;

  SignalContext(void *context, uptr addr, uptr pc, uptr sp, uptr bp) :
      context(context), addr(addr), pc(pc), sp(sp), bp(bp) {
  40ce49:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  40ce4e:	4c 89 63 08          	mov    %r12,0x8(%rbx)
  40ce52:	48 89 2b             	mov    %rbp,(%rbx)
  40ce55:	48 89 43 10          	mov    %rax,0x10(%rbx)
  40ce59:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  40ce5e:	48 89 43 18          	mov    %rax,0x18(%rbx)
  40ce62:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  40ce67:	48 89 43 20          	mov    %rax,0x20(%rbx)
  return SignalContext(context, addr, pc, sp, bp);
}
  40ce6b:	48 83 c4 20          	add    $0x20,%rsp
  40ce6f:	48 89 d8             	mov    %rbx,%rax
  40ce72:	5b                   	pop    %rbx
  40ce73:	5d                   	pop    %rbp
  40ce74:	41 5c                	pop    %r12
  40ce76:	c3                   	retq   
  40ce77:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40ce7e:	00 00 

000000000040ce80 <_ZN11__sanitizer12CheckVMASizeEv>:

// This function check is the built VMA matches the runtime one for
// architectures with multiple VMA size.
void CheckVMASize() {
  40ce80:	f3 c3                	repz retq 
  40ce82:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40ce89:	0f 1f 84 00 00 00 00 
  40ce90:	00 
	...

000000000040cea0 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb>:
// Appends number in a given base to buffer. If its length is less than
// |minimal_num_length|, it is padded with leading zeroes or spaces, depending
// on the value of |pad_with_zero|.
static int AppendNumber(char **buff, const char *buff_end, u64 absolute_value,
                        u8 base, u8 minimal_num_length, bool pad_with_zero,
                        bool negative) {
  40cea0:	41 57                	push   %r15
  40cea2:	48 89 d0             	mov    %rdx,%rax
  40cea5:	41 56                	push   %r14
  40cea7:	41 55                	push   %r13
  40cea9:	45 89 cd             	mov    %r9d,%r13d
  40ceac:	41 54                	push   %r12
  40ceae:	55                   	push   %rbp
  40ceaf:	48 89 f5             	mov    %rsi,%rbp
  40ceb2:	0f b6 f1             	movzbl %cl,%esi
  40ceb5:	53                   	push   %rbx
  40ceb6:	48 89 fb             	mov    %rdi,%rbx
  40ceb9:	44 89 c7             	mov    %r8d,%edi
  40cebc:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  uptr const kMaxLen = 30;
  RAW_CHECK(base == 10 || base == 16);
  40cec3:	80 f9 0a             	cmp    $0xa,%cl
  40cec6:	0f 95 c2             	setne  %dl
  40cec9:	80 f9 10             	cmp    $0x10,%cl
// Appends number in a given base to buffer. If its length is less than
// |minimal_num_length|, it is padded with leading zeroes or spaces, depending
// on the value of |pad_with_zero|.
static int AppendNumber(char **buff, const char *buff_end, u64 absolute_value,
                        u8 base, u8 minimal_num_length, bool pad_with_zero,
                        bool negative) {
  40cecc:	44 8b b4 24 40 01 00 	mov    0x140(%rsp),%r14d
  40ced3:	00 
  uptr const kMaxLen = 30;
  RAW_CHECK(base == 10 || base == 16);
  40ced4:	0f 85 ad 01 00 00    	jne    40d087 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x1e7>
  RAW_CHECK(base == 10 || !negative);
  40ceda:	84 d2                	test   %dl,%dl
  40cedc:	0f 85 e9 01 00 00    	jne    40d0cb <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x22b>
  RAW_CHECK(absolute_value || !negative);
  40cee2:	48 85 c0             	test   %rax,%rax
  40cee5:	0f 84 c6 01 00 00    	je     40d0b1 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x211>
  RAW_CHECK(minimal_num_length < kMaxLen);
  40ceeb:	41 80 f8 1d          	cmp    $0x1d,%r8b
  40ceef:	90                   	nop
  40cef0:	0f 87 aa 01 00 00    	ja     40d0a0 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x200>
  int result = 0;
  if (negative && minimal_num_length)
  40cef6:	45 84 f6             	test   %r14b,%r14b
  40cef9:	74 1e                	je     40cf19 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x79>
  40cefb:	45 84 c0             	test   %r8b,%r8b
  40cefe:	0f 95 c2             	setne  %dl
    --minimal_num_length;
  40cf01:	41 83 e8 01          	sub    $0x1,%r8d
  40cf05:	84 d2                	test   %dl,%dl
  40cf07:	41 0f 45 f8          	cmovne %r8d,%edi
  if (negative && pad_with_zero)
  40cf0b:	45 84 f6             	test   %r14b,%r14b
  40cf0e:	74 09                	je     40cf19 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x79>
  40cf10:	45 84 c9             	test   %r9b,%r9b
  40cf13:	0f 85 cc 00 00 00    	jne    40cfe5 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x145>
  uptr const kMaxLen = 30;
  RAW_CHECK(base == 10 || base == 16);
  RAW_CHECK(base == 10 || !negative);
  RAW_CHECK(absolute_value || !negative);
  RAW_CHECK(minimal_num_length < kMaxLen);
  int result = 0;
  40cf19:	45 31 e4             	xor    %r12d,%r12d
  40cf1c:	4c 8d 54 24 10       	lea    0x10(%rsp),%r10
  if (negative && minimal_num_length)
    --minimal_num_length;
  if (negative && pad_with_zero)
    result += AppendChar(buff, buff_end, '-');
  uptr num_buffer[kMaxLen];
  int pos = 0;
  40cf21:	31 c9                	xor    %ecx,%ecx
  40cf23:	4d 89 d0             	mov    %r10,%r8
  40cf26:	eb 15                	jmp    40cf3d <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x9d>
  40cf28:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40cf2f:	00 
  40cf30:	49 83 c0 08          	add    $0x8,%r8
  do {
    RAW_CHECK_MSG((uptr)pos < kMaxLen, "AppendNumber buffer overflow");
  40cf34:	83 f9 1e             	cmp    $0x1e,%ecx
  40cf37:	0f 84 39 01 00 00    	je     40d076 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x1d6>
    num_buffer[pos++] = absolute_value % base;
  40cf3d:	31 d2                	xor    %edx,%edx
  40cf3f:	83 c1 01             	add    $0x1,%ecx
  40cf42:	48 f7 f6             	div    %rsi
    --minimal_num_length;
  if (negative && pad_with_zero)
    result += AppendChar(buff, buff_end, '-');
  uptr num_buffer[kMaxLen];
  int pos = 0;
  do {
  40cf45:	48 85 c0             	test   %rax,%rax
    RAW_CHECK_MSG((uptr)pos < kMaxLen, "AppendNumber buffer overflow");
    num_buffer[pos++] = absolute_value % base;
  40cf48:	49 89 10             	mov    %rdx,(%r8)
    --minimal_num_length;
  if (negative && pad_with_zero)
    result += AppendChar(buff, buff_end, '-');
  uptr num_buffer[kMaxLen];
  int pos = 0;
  do {
  40cf4b:	75 e3                	jne    40cf30 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x90>
    RAW_CHECK_MSG((uptr)pos < kMaxLen, "AppendNumber buffer overflow");
    num_buffer[pos++] = absolute_value % base;
    absolute_value /= base;
  } while (absolute_value > 0);
  if (pos < minimal_num_length) {
  40cf4d:	44 0f b6 ff          	movzbl %dil,%r15d
  40cf51:	41 39 cf             	cmp    %ecx,%r15d
  40cf54:	0f 8f f0 00 00 00    	jg     40d04a <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x1aa>
    internal_memset(&num_buffer[pos], 0,
                    sizeof(num_buffer[0]) * (minimal_num_length - pos));
    pos = minimal_num_length;
  }
  RAW_CHECK(pos > 0);
  pos--;
  40cf5a:	8d 79 ff             	lea    -0x1(%rcx),%edi
  40cf5d:	0f 1f 00             	nopl   (%rax)
  for (; pos >= 0 && num_buffer[pos] == 0; pos--) {
  40cf60:	48 63 c7             	movslq %edi,%rax
  40cf63:	48 83 7c c4 10 00    	cmpq   $0x0,0x10(%rsp,%rax,8)
  40cf69:	75 2d                	jne    40cf98 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0xf8>
    char c = (pad_with_zero || pos == 0) ? '0' : ' ';
  40cf6b:	85 ff                	test   %edi,%edi
  40cf6d:	74 0a                	je     40cf79 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0xd9>
  40cf6f:	45 84 ed             	test   %r13b,%r13b
  40cf72:	ba 20 00 00 00       	mov    $0x20,%edx
  40cf77:	74 05                	je     40cf7e <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0xde>
  40cf79:	ba 30 00 00 00       	mov    $0x30,%edx
namespace __sanitizer {

StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
  40cf7e:	48 8b 03             	mov    (%rbx),%rax
  40cf81:	48 39 c5             	cmp    %rax,%rbp
  40cf84:	76 06                	jbe    40cf8c <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0xec>
    **buff = c;
  40cf86:	88 10                	mov    %dl,(%rax)
    (*buff)++;
  40cf88:	48 83 03 01          	addq   $0x1,(%rbx)
                    sizeof(num_buffer[0]) * (minimal_num_length - pos));
    pos = minimal_num_length;
  }
  RAW_CHECK(pos > 0);
  pos--;
  for (; pos >= 0 && num_buffer[pos] == 0; pos--) {
  40cf8c:	83 ef 01             	sub    $0x1,%edi
    char c = (pad_with_zero || pos == 0) ? '0' : ' ';
    result += AppendChar(buff, buff_end, c);
  40cf8f:	41 83 c4 01          	add    $0x1,%r12d
                    sizeof(num_buffer[0]) * (minimal_num_length - pos));
    pos = minimal_num_length;
  }
  RAW_CHECK(pos > 0);
  pos--;
  for (; pos >= 0 && num_buffer[pos] == 0; pos--) {
  40cf93:	83 ff ff             	cmp    $0xffffffff,%edi
  40cf96:	75 c8                	jne    40cf60 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0xc0>
    char c = (pad_with_zero || pos == 0) ? '0' : ' ';
    result += AppendChar(buff, buff_end, c);
  }
  if (negative && !pad_with_zero) result += AppendChar(buff, buff_end, '-');
  40cf98:	45 84 f6             	test   %r14b,%r14b
  40cf9b:	0f 85 87 00 00 00    	jne    40d028 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x188>
  for (; pos >= 0; pos--) {
  40cfa1:	83 ff ff             	cmp    $0xffffffff,%edi
  40cfa4:	74 67                	je     40d00d <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x16d>
  40cfa6:	4c 8b 03             	mov    (%rbx),%r8
  40cfa9:	89 fa                	mov    %edi,%edx
  40cfab:	eb 23                	jmp    40cfd0 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x130>
  40cfad:	0f 1f 00             	nopl   (%rax)
    char digit = static_cast<char>(num_buffer[pos]);
    result += AppendChar(buff, buff_end, (digit < 10) ? '0' + digit
                                                      : 'a' + digit - 10);
  40cfb0:	83 c1 30             	add    $0x30,%ecx
  40cfb3:	0f be c9             	movsbl %cl,%ecx
namespace __sanitizer {

StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
  40cfb6:	4c 39 c5             	cmp    %r8,%rbp
  40cfb9:	76 0d                	jbe    40cfc8 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x128>
  40cfbb:	41 88 08             	mov    %cl,(%r8)
    **buff = c;
    (*buff)++;
  40cfbe:	48 8b 03             	mov    (%rbx),%rax
  40cfc1:	4c 8d 40 01          	lea    0x1(%rax),%r8
  40cfc5:	4c 89 03             	mov    %r8,(%rbx)
  for (; pos >= 0 && num_buffer[pos] == 0; pos--) {
    char c = (pad_with_zero || pos == 0) ? '0' : ' ';
    result += AppendChar(buff, buff_end, c);
  }
  if (negative && !pad_with_zero) result += AppendChar(buff, buff_end, '-');
  for (; pos >= 0; pos--) {
  40cfc8:	83 ea 01             	sub    $0x1,%edx
  40cfcb:	83 fa ff             	cmp    $0xffffffff,%edx
  40cfce:	74 38                	je     40d008 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x168>
    char digit = static_cast<char>(num_buffer[pos]);
  40cfd0:	48 63 f2             	movslq %edx,%rsi
  40cfd3:	48 8b 4c f4 10       	mov    0x10(%rsp,%rsi,8),%rcx
    result += AppendChar(buff, buff_end, (digit < 10) ? '0' + digit
                                                      : 'a' + digit - 10);
  40cfd8:	80 f9 09             	cmp    $0x9,%cl
  40cfdb:	7e d3                	jle    40cfb0 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x110>
  40cfdd:	83 c1 57             	add    $0x57,%ecx
  40cfe0:	0f be c9             	movsbl %cl,%ecx
  40cfe3:	eb d1                	jmp    40cfb6 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x116>
namespace __sanitizer {

StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
  40cfe5:	48 8b 13             	mov    (%rbx),%rdx
  RAW_CHECK(minimal_num_length < kMaxLen);
  int result = 0;
  if (negative && minimal_num_length)
    --minimal_num_length;
  if (negative && pad_with_zero)
    result += AppendChar(buff, buff_end, '-');
  40cfe8:	41 bc 01 00 00 00    	mov    $0x1,%r12d
namespace __sanitizer {

StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
  40cfee:	48 39 d5             	cmp    %rdx,%rbp
  40cff1:	0f 86 25 ff ff ff    	jbe    40cf1c <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x7c>
    **buff = c;
  40cff7:	c6 02 2d             	movb   $0x2d,(%rdx)
    (*buff)++;
  40cffa:	48 83 03 01          	addq   $0x1,(%rbx)
  40cffe:	e9 19 ff ff ff       	jmpq   40cf1c <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x7c>
  40d003:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  40d008:	45 8d 64 3c 01       	lea    0x1(%r12,%rdi,1),%r12d
    char digit = static_cast<char>(num_buffer[pos]);
    result += AppendChar(buff, buff_end, (digit < 10) ? '0' + digit
                                                      : 'a' + digit - 10);
  }
  return result;
}
  40d00d:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  40d014:	44 89 e0             	mov    %r12d,%eax
  40d017:	5b                   	pop    %rbx
  40d018:	5d                   	pop    %rbp
  40d019:	41 5c                	pop    %r12
  40d01b:	41 5d                	pop    %r13
  40d01d:	41 5e                	pop    %r14
  40d01f:	41 5f                	pop    %r15
  40d021:	c3                   	retq   
  40d022:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  pos--;
  for (; pos >= 0 && num_buffer[pos] == 0; pos--) {
    char c = (pad_with_zero || pos == 0) ? '0' : ' ';
    result += AppendChar(buff, buff_end, c);
  }
  if (negative && !pad_with_zero) result += AppendChar(buff, buff_end, '-');
  40d028:	41 80 f9 01          	cmp    $0x1,%r9b
  40d02c:	0f 84 6f ff ff ff    	je     40cfa1 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x101>
namespace __sanitizer {

StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
  40d032:	48 8b 03             	mov    (%rbx),%rax
  40d035:	48 39 c5             	cmp    %rax,%rbp
  40d038:	76 07                	jbe    40d041 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x1a1>
    **buff = c;
  40d03a:	c6 00 2d             	movb   $0x2d,(%rax)
    (*buff)++;
  40d03d:	48 83 03 01          	addq   $0x1,(%rbx)
  pos--;
  for (; pos >= 0 && num_buffer[pos] == 0; pos--) {
    char c = (pad_with_zero || pos == 0) ? '0' : ' ';
    result += AppendChar(buff, buff_end, c);
  }
  if (negative && !pad_with_zero) result += AppendChar(buff, buff_end, '-');
  40d041:	41 83 c4 01          	add    $0x1,%r12d
  40d045:	e9 57 ff ff ff       	jmpq   40cfa1 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x101>
    absolute_value /= base;
  } while (absolute_value > 0);
  if (pos < minimal_num_length) {
    // Make sure compiler doesn't insert call to memset here.
    internal_memset(&num_buffer[pos], 0,
                    sizeof(num_buffer[0]) * (minimal_num_length - pos));
  40d04a:	44 89 fa             	mov    %r15d,%edx
  40d04d:	31 f6                	xor    %esi,%esi
  40d04f:	44 89 4c 24 0c       	mov    %r9d,0xc(%rsp)
  40d054:	29 ca                	sub    %ecx,%edx
  40d056:	48 63 c9             	movslq %ecx,%rcx
  40d059:	49 8d 3c ca          	lea    (%r10,%rcx,8),%rdi
  40d05d:	48 63 d2             	movslq %edx,%rdx
  40d060:	48 c1 e2 03          	shl    $0x3,%rdx
  40d064:	e8 d7 d2 ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  40d069:	44 89 f9             	mov    %r15d,%ecx
  40d06c:	44 8b 4c 24 0c       	mov    0xc(%rsp),%r9d
  40d071:	e9 e4 fe ff ff       	jmpq   40cf5a <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0xba>
  if (negative && pad_with_zero)
    result += AppendChar(buff, buff_end, '-');
  uptr num_buffer[kMaxLen];
  int pos = 0;
  do {
    RAW_CHECK_MSG((uptr)pos < kMaxLen, "AppendNumber buffer overflow");
  40d076:	48 8d 3d 60 bd 00 00 	lea    0xbd60(%rip),%rdi        # 418ddd <.LC4>
  40d07d:	e8 5e 80 ff ff       	callq  4050e0 <_ZN11__sanitizer8RawWriteEPKc>
  40d082:	e8 d9 81 ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
// on the value of |pad_with_zero|.
static int AppendNumber(char **buff, const char *buff_end, u64 absolute_value,
                        u8 base, u8 minimal_num_length, bool pad_with_zero,
                        bool negative) {
  uptr const kMaxLen = 30;
  RAW_CHECK(base == 10 || base == 16);
  40d087:	84 d2                	test   %dl,%dl
  40d089:	0f 84 53 fe ff ff    	je     40cee2 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x42>
  40d08f:	48 8d 3d dd bc 00 00 	lea    0xbcdd(%rip),%rdi        # 418d73 <.LC0>
  40d096:	e8 45 80 ff ff       	callq  4050e0 <_ZN11__sanitizer8RawWriteEPKc>
  40d09b:	e8 c0 81 ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  RAW_CHECK(base == 10 || !negative);
  RAW_CHECK(absolute_value || !negative);
  RAW_CHECK(minimal_num_length < kMaxLen);
  40d0a0:	48 8d 3d 19 bd 00 00 	lea    0xbd19(%rip),%rdi        # 418dc0 <.LC3>
  40d0a7:	e8 34 80 ff ff       	callq  4050e0 <_ZN11__sanitizer8RawWriteEPKc>
  40d0ac:	e8 af 81 ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
                        u8 base, u8 minimal_num_length, bool pad_with_zero,
                        bool negative) {
  uptr const kMaxLen = 30;
  RAW_CHECK(base == 10 || base == 16);
  RAW_CHECK(base == 10 || !negative);
  RAW_CHECK(absolute_value || !negative);
  40d0b1:	45 84 f6             	test   %r14b,%r14b
  40d0b4:	0f 84 31 fe ff ff    	je     40ceeb <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x4b>
  40d0ba:	48 8d 3d e3 bc 00 00 	lea    0xbce3(%rip),%rdi        # 418da4 <.LC2>
  40d0c1:	e8 1a 80 ff ff       	callq  4050e0 <_ZN11__sanitizer8RawWriteEPKc>
  40d0c6:	e8 95 81 ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
static int AppendNumber(char **buff, const char *buff_end, u64 absolute_value,
                        u8 base, u8 minimal_num_length, bool pad_with_zero,
                        bool negative) {
  uptr const kMaxLen = 30;
  RAW_CHECK(base == 10 || base == 16);
  RAW_CHECK(base == 10 || !negative);
  40d0cb:	45 84 f6             	test   %r14b,%r14b
  40d0ce:	0f 84 0e fe ff ff    	je     40cee2 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb+0x42>
  40d0d4:	48 8d 3d b1 bc 00 00 	lea    0xbcb1(%rip),%rdi        # 418d8c <.LC1>
  40d0db:	e8 00 80 ff ff       	callq  4050e0 <_ZN11__sanitizer8RawWriteEPKc>
  40d0e0:	e8 7b 81 ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  40d0e5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  40d0ec:	00 00 00 00 

000000000040d0f0 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag>:
                           SANITIZER_POINTER_FORMAT_LENGTH, true);
  return result;
}

int VSNPrintf(char *buff, int buff_length,
              const char *format, va_list args) {
  40d0f0:	41 57                	push   %r15
  40d0f2:	41 56                	push   %r14
  40d0f4:	41 55                	push   %r13
  40d0f6:	41 54                	push   %r12
  40d0f8:	55                   	push   %rbp
  40d0f9:	53                   	push   %rbx
  40d0fa:	48 83 ec 28          	sub    $0x28,%rsp
  static const char *kPrintfFormatsHelp =
    "Supported Printf formats: %([0-9]*)?(z|ll)?{d,u,x}; %p; %(\\.\\*)?s; %c\n";
  RAW_CHECK(format);
  40d0fe:	48 85 d2             	test   %rdx,%rdx
                           SANITIZER_POINTER_FORMAT_LENGTH, true);
  return result;
}

int VSNPrintf(char *buff, int buff_length,
              const char *format, va_list args) {
  40d101:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  static const char *kPrintfFormatsHelp =
    "Supported Printf formats: %([0-9]*)?(z|ll)?{d,u,x}; %p; %(\\.\\*)?s; %c\n";
  RAW_CHECK(format);
  40d106:	0f 84 7f 05 00 00    	je     40d68b <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x59b>
  RAW_CHECK(buff_length > 0);
  40d10c:	85 f6                	test   %esi,%esi
  40d10e:	0f 8e 66 05 00 00    	jle    40d67a <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x58a>
  const char *buff_end = &buff[buff_length - 1];
  const char *cur = format;
  int result = 0;
  for (; *cur; cur++) {
  40d114:	0f b6 02             	movzbl (%rdx),%eax
  40d117:	49 89 ce             	mov    %rcx,%r14
              const char *format, va_list args) {
  static const char *kPrintfFormatsHelp =
    "Supported Printf formats: %([0-9]*)?(z|ll)?{d,u,x}; %p; %(\\.\\*)?s; %c\n";
  RAW_CHECK(format);
  RAW_CHECK(buff_length > 0);
  const char *buff_end = &buff[buff_length - 1];
  40d11a:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  40d11f:	48 63 f6             	movslq %esi,%rsi
  const char *cur = format;
  int result = 0;
  40d122:	31 ed                	xor    %ebp,%ebp
              const char *format, va_list args) {
  static const char *kPrintfFormatsHelp =
    "Supported Printf formats: %([0-9]*)?(z|ll)?{d,u,x}; %p; %(\\.\\*)?s; %c\n";
  RAW_CHECK(format);
  RAW_CHECK(buff_length > 0);
  const char *buff_end = &buff[buff_length - 1];
  40d124:	4c 8d 64 31 ff       	lea    -0x1(%rcx,%rsi,1),%r12
  const char *cur = format;
  int result = 0;
  for (; *cur; cur++) {
  40d129:	84 c0                	test   %al,%al
  40d12b:	0f 84 ac 01 00 00    	je     40d2dd <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x1ed>
      case 'x': {
        uval = have_ll ? va_arg(args, u64)
             : have_z ? va_arg(args, uptr)
             : va_arg(args, unsigned);
        result += AppendUnsigned(&buff, buff_end, uval,
                                 (*cur == 'u') ? 10 : 16, width, pad_with_zero);
  40d131:	41 bf 10 00 00 00    	mov    $0x10,%r15d
}

static int AppendUnsigned(char **buff, const char *buff_end, u64 num, u8 base,
                          u8 minimal_num_length, bool pad_with_zero) {
  return AppendNumber(buff, buff_end, num, base, minimal_num_length,
                      pad_with_zero, false /* negative */);
  40d137:	4c 8d 6c 24 18       	lea    0x18(%rsp),%r13
  40d13c:	eb 2a                	jmp    40d168 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x78>
  40d13e:	66 90                	xchg   %ax,%ax
namespace __sanitizer {

StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
  40d140:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  40d145:	49 39 cc             	cmp    %rcx,%r12
  40d148:	76 08                	jbe    40d152 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x62>
    **buff = c;
  40d14a:	88 01                	mov    %al,(%rcx)
    (*buff)++;
  40d14c:	48 83 44 24 18 01    	addq   $0x1,0x18(%rsp)
  const char *buff_end = &buff[buff_length - 1];
  const char *cur = format;
  int result = 0;
  for (; *cur; cur++) {
    if (*cur != '%') {
      result += AppendChar(&buff, buff_end, *cur);
  40d152:	83 c5 01             	add    $0x1,%ebp
      continue;
  40d155:	48 89 d3             	mov    %rdx,%rbx
  RAW_CHECK(format);
  RAW_CHECK(buff_length > 0);
  const char *buff_end = &buff[buff_length - 1];
  const char *cur = format;
  int result = 0;
  for (; *cur; cur++) {
  40d158:	0f b6 43 01          	movzbl 0x1(%rbx),%eax
  40d15c:	48 8d 53 01          	lea    0x1(%rbx),%rdx
  40d160:	84 c0                	test   %al,%al
  40d162:	0f 84 70 01 00 00    	je     40d2d8 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x1e8>
    if (*cur != '%') {
  40d168:	3c 25                	cmp    $0x25,%al
  40d16a:	75 d4                	jne    40d140 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x50>
      result += AppendChar(&buff, buff_end, *cur);
      continue;
    }
    cur++;
    bool have_width = (*cur >= '0' && *cur <= '9');
  40d16c:	0f b6 72 01          	movzbl 0x1(%rdx),%esi
  for (; *cur; cur++) {
    if (*cur != '%') {
      result += AppendChar(&buff, buff_end, *cur);
      continue;
    }
    cur++;
  40d170:	48 8d 42 01          	lea    0x1(%rdx),%rax
    bool have_width = (*cur >= '0' && *cur <= '9');
  40d174:	8d 56 d0             	lea    -0x30(%rsi),%edx
  40d177:	80 fa 09             	cmp    $0x9,%dl
    bool pad_with_zero = (*cur == '0');
    int width = 0;
    if (have_width) {
      while (*cur >= '0' && *cur <= '9') {
  40d17a:	40 0f 96 c7          	setbe  %dil
  40d17e:	0f 87 34 04 00 00    	ja     40d5b8 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x4c8>
  40d184:	40 0f be d6          	movsbl %sil,%edx
  40d188:	45 31 c0             	xor    %r8d,%r8d
  40d18b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        width = width * 10 + *cur++ - '0';
  40d190:	43 8d 0c 80          	lea    (%r8,%r8,4),%ecx
  40d194:	48 83 c0 01          	add    $0x1,%rax
  40d198:	44 8d 44 4a d0       	lea    -0x30(%rdx,%rcx,2),%r8d
    cur++;
    bool have_width = (*cur >= '0' && *cur <= '9');
    bool pad_with_zero = (*cur == '0');
    int width = 0;
    if (have_width) {
      while (*cur >= '0' && *cur <= '9') {
  40d19d:	0f be 10             	movsbl (%rax),%edx
  40d1a0:	8d 4a d0             	lea    -0x30(%rdx),%ecx
  40d1a3:	80 f9 09             	cmp    $0x9,%cl
  40d1a6:	76 e8                	jbe    40d190 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0xa0>
        width = width * 10 + *cur++ - '0';
      }
    }
    bool have_precision = (cur[0] == '.' && cur[1] == '*');
  40d1a8:	80 fa 2e             	cmp    $0x2e,%dl
    int precision = -1;
  40d1ab:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    if (have_width) {
      while (*cur >= '0' && *cur <= '9') {
        width = width * 10 + *cur++ - '0';
      }
    }
    bool have_precision = (cur[0] == '.' && cur[1] == '*');
  40d1b0:	74 4e                	je     40d200 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x110>
    int precision = -1;
    if (have_precision) {
      cur += 2;
      precision = va_arg(args, int);
    }
    bool have_z = (*cur == 'z');
  40d1b2:	80 fa 7a             	cmp    $0x7a,%dl
  40d1b5:	0f 94 c2             	sete   %dl
    cur += have_z;
  40d1b8:	44 0f b6 ca          	movzbl %dl,%r9d
  40d1bc:	4c 01 c8             	add    %r9,%rax
    bool have_ll = !have_z && (cur[0] == 'l' && cur[1] == 'l');
  40d1bf:	84 d2                	test   %dl,%dl
  40d1c1:	74 47                	je     40d20a <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x11a>
  40d1c3:	31 db                	xor    %ebx,%ebx
  40d1c5:	09 d7                	or     %edx,%edi
  40d1c7:	45 31 db             	xor    %r11d,%r11d
    cur += have_ll * 2;
  40d1ca:	48 01 c3             	add    %rax,%rbx
    s64 dval;
    u64 uval;
    bool have_flags = have_width | have_z | have_ll;
    // Only %s supports precision for now
    CHECK(!(precision >= 0 && *cur != 's'));
  40d1cd:	85 c9                	test   %ecx,%ecx
  40d1cf:	78 5f                	js     40d230 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x140>
  40d1d1:	80 3b 73             	cmpb   $0x73,(%rbx)
  40d1d4:	0f 84 26 02 00 00    	je     40d400 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x310>
  40d1da:	48 8d 15 df a3 00 00 	lea    0xa3df(%rip),%rdx        # 4175c0 <.LC11>
  40d1e1:	48 8d 3d 08 a4 00 00 	lea    0xa408(%rip),%rdi        # 4175f0 <.LC12>
  40d1e8:	45 31 c0             	xor    %r8d,%r8d
  40d1eb:	31 c9                	xor    %ecx,%ecx
  40d1ed:	be 9c 00 00 00       	mov    $0x9c,%esi
  40d1f2:	e8 f9 81 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40d1f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40d1fe:	00 00 
    if (have_width) {
      while (*cur >= '0' && *cur <= '9') {
        width = width * 10 + *cur++ - '0';
      }
    }
    bool have_precision = (cur[0] == '.' && cur[1] == '*');
  40d200:	80 78 01 2a          	cmpb   $0x2a,0x1(%rax)
  40d204:	0f 84 86 02 00 00    	je     40d490 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x3a0>
  40d20a:	31 d2                	xor    %edx,%edx
      cur += 2;
      precision = va_arg(args, int);
    }
    bool have_z = (*cur == 'z');
    cur += have_z;
    bool have_ll = !have_z && (cur[0] == 'l' && cur[1] == 'l');
  40d20c:	80 38 6c             	cmpb   $0x6c,(%rax)
  40d20f:	75 b2                	jne    40d1c3 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0xd3>
  40d211:	80 78 01 6c          	cmpb   $0x6c,0x1(%rax)
  40d215:	75 ac                	jne    40d1c3 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0xd3>
  40d217:	bb 02 00 00 00       	mov    $0x2,%ebx
  40d21c:	bf 01 00 00 00       	mov    $0x1,%edi
  40d221:	41 bb 01 00 00 00    	mov    $0x1,%r11d
    cur += have_ll * 2;
  40d227:	48 01 c3             	add    %rax,%rbx
    s64 dval;
    u64 uval;
    bool have_flags = have_width | have_z | have_ll;
    // Only %s supports precision for now
    CHECK(!(precision >= 0 && *cur != 's'));
  40d22a:	85 c9                	test   %ecx,%ecx
  40d22c:	79 a3                	jns    40d1d1 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0xe1>
  40d22e:	66 90                	xchg   %ax,%ax
    switch (*cur) {
  40d230:	0f b6 03             	movzbl (%rbx),%eax
      result += AppendChar(&buff, buff_end, *cur);
      continue;
    }
    cur++;
    bool have_width = (*cur >= '0' && *cur <= '9');
    bool pad_with_zero = (*cur == '0');
  40d233:	40 80 fe 30          	cmp    $0x30,%sil
  40d237:	41 0f 94 c1          	sete   %r9b
    s64 dval;
    u64 uval;
    bool have_flags = have_width | have_z | have_ll;
    // Only %s supports precision for now
    CHECK(!(precision >= 0 && *cur != 's'));
    switch (*cur) {
  40d23b:	3c 70                	cmp    $0x70,%al
  40d23d:	0f 84 fd 00 00 00    	je     40d340 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x250>
  40d243:	0f 8f 97 01 00 00    	jg     40d3e0 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x2f0>
  40d249:	3c 63                	cmp    $0x63,%al
  40d24b:	0f 84 b2 00 00 00    	je     40d303 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x213>
  40d251:	3c 64                	cmp    $0x64,%al
  40d253:	74 19                	je     40d26e <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x17e>
  40d255:	3c 25                	cmp    $0x25,%al
  40d257:	0f 84 30 03 00 00    	je     40d58d <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x49d>
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendChar(&buff, buff_end, '%');
        break;
      }
      default: {
        RAW_CHECK_MSG(false, kPrintfFormatsHelp);
  40d25d:	48 8d 3d 14 a3 00 00 	lea    0xa314(%rip),%rdi        # 417578 <.LC9>
  40d264:	e8 77 7e ff ff       	callq  4050e0 <_ZN11__sanitizer8RawWriteEPKc>
  40d269:	e8 f2 7f ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
    CHECK(!(precision >= 0 && *cur != 's'));
    switch (*cur) {
      case 'd': {
        dval = have_ll ? va_arg(args, s64)
             : have_z ? va_arg(args, sptr)
             : va_arg(args, int);
  40d26e:	45 84 db             	test   %r11b,%r11b
  40d271:	0f 84 91 02 00 00    	je     40d508 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x418>
    bool have_flags = have_width | have_z | have_ll;
    // Only %s supports precision for now
    CHECK(!(precision >= 0 && *cur != 's'));
    switch (*cur) {
      case 'd': {
        dval = have_ll ? va_arg(args, s64)
  40d277:	41 8b 16             	mov    (%r14),%edx
  40d27a:	83 fa 30             	cmp    $0x30,%edx
  40d27d:	0f 83 f9 02 00 00    	jae    40d57c <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x48c>
             : have_z ? va_arg(args, sptr)
             : va_arg(args, int);
  40d283:	89 d0                	mov    %edx,%eax
  40d285:	49 03 46 10          	add    0x10(%r14),%rax
  40d289:	83 c2 08             	add    $0x8,%edx
  40d28c:	41 89 16             	mov    %edx,(%r14)
  40d28f:	48 8b 00             	mov    (%rax),%rax
                      pad_with_zero, false /* negative */);
}

static int AppendSignedDecimal(char **buff, const char *buff_end, s64 num,
                               u8 minimal_num_length, bool pad_with_zero) {
  bool negative = (num < 0);
  40d292:	48 89 c1             	mov    %rax,%rcx
  return AppendNumber(buff, buff_end, (u64)(negative ? -num : num), 10,
                      minimal_num_length, pad_with_zero, negative);
  40d295:	48 89 c2             	mov    %rax,%rdx
  40d298:	45 0f b6 c0          	movzbl %r8b,%r8d
                      pad_with_zero, false /* negative */);
}

static int AppendSignedDecimal(char **buff, const char *buff_end, s64 num,
                               u8 minimal_num_length, bool pad_with_zero) {
  bool negative = (num < 0);
  40d29c:	48 c1 e9 3f          	shr    $0x3f,%rcx
  return AppendNumber(buff, buff_end, (u64)(negative ? -num : num), 10,
                      minimal_num_length, pad_with_zero, negative);
  40d2a0:	48 f7 da             	neg    %rdx
  40d2a3:	4c 89 e6             	mov    %r12,%rsi
  40d2a6:	84 c9                	test   %cl,%cl
  40d2a8:	89 0c 24             	mov    %ecx,(%rsp)
  40d2ab:	4c 89 ef             	mov    %r13,%rdi
  40d2ae:	48 0f 44 d0          	cmove  %rax,%rdx
  40d2b2:	b9 0a 00 00 00       	mov    $0xa,%ecx
  40d2b7:	41 83 e1 01          	and    $0x1,%r9d
  40d2bb:	e8 e0 fb ff ff       	callq  40cea0 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb>
      case 'd': {
        dval = have_ll ? va_arg(args, s64)
             : have_z ? va_arg(args, sptr)
             : va_arg(args, int);
        result += AppendSignedDecimal(&buff, buff_end, dval, width,
                                      pad_with_zero);
  40d2c0:	01 c5                	add    %eax,%ebp
  RAW_CHECK(format);
  RAW_CHECK(buff_length > 0);
  const char *buff_end = &buff[buff_length - 1];
  const char *cur = format;
  int result = 0;
  for (; *cur; cur++) {
  40d2c2:	0f b6 43 01          	movzbl 0x1(%rbx),%eax
  40d2c6:	48 8d 53 01          	lea    0x1(%rbx),%rdx
  40d2ca:	84 c0                	test   %al,%al
  40d2cc:	0f 85 96 fe ff ff    	jne    40d168 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x78>
  40d2d2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40d2d8:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
      default: {
        RAW_CHECK_MSG(false, kPrintfFormatsHelp);
      }
    }
  }
  RAW_CHECK(buff <= buff_end);
  40d2dd:	49 39 cc             	cmp    %rcx,%r12
  40d2e0:	0f 82 83 03 00 00    	jb     40d669 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x579>
  AppendChar(&buff, buff_end + 1, '\0');
  40d2e6:	49 83 c4 01          	add    $0x1,%r12
namespace __sanitizer {

StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
  40d2ea:	4c 39 e1             	cmp    %r12,%rcx
  40d2ed:	73 03                	jae    40d2f2 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x202>
    **buff = c;
  40d2ef:	c6 01 00             	movb   $0x0,(%rcx)
    }
  }
  RAW_CHECK(buff <= buff_end);
  AppendChar(&buff, buff_end + 1, '\0');
  return result;
}
  40d2f2:	48 83 c4 28          	add    $0x28,%rsp
  40d2f6:	89 e8                	mov    %ebp,%eax
  40d2f8:	5b                   	pop    %rbx
  40d2f9:	5d                   	pop    %rbp
  40d2fa:	41 5c                	pop    %r12
  40d2fc:	41 5d                	pop    %r13
  40d2fe:	41 5e                	pop    %r14
  40d300:	41 5f                	pop    %r15
  40d302:	c3                   	retq   
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendString(&buff, buff_end, precision, va_arg(args, char*));
        break;
      }
      case 'c': {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
  40d303:	40 84 ff             	test   %dil,%dil
  40d306:	0f 85 51 ff ff ff    	jne    40d25d <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x16d>
        result += AppendChar(&buff, buff_end, va_arg(args, int));
  40d30c:	41 8b 06             	mov    (%r14),%eax
  40d30f:	83 f8 30             	cmp    $0x30,%eax
  40d312:	0f 83 d8 01 00 00    	jae    40d4f0 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x400>
  40d318:	89 c2                	mov    %eax,%edx
  40d31a:	49 03 56 10          	add    0x10(%r14),%rdx
  40d31e:	83 c0 08             	add    $0x8,%eax
  40d321:	41 89 06             	mov    %eax,(%r14)
namespace __sanitizer {

StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
  40d324:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
        result += AppendString(&buff, buff_end, precision, va_arg(args, char*));
        break;
      }
      case 'c': {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendChar(&buff, buff_end, va_arg(args, int));
  40d329:	8b 12                	mov    (%rdx),%edx
namespace __sanitizer {

StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
  40d32b:	49 39 c4             	cmp    %rax,%r12
  40d32e:	76 08                	jbe    40d338 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x248>
        result += AppendString(&buff, buff_end, precision, va_arg(args, char*));
        break;
      }
      case 'c': {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendChar(&buff, buff_end, va_arg(args, int));
  40d330:	88 10                	mov    %dl,(%rax)
StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
    **buff = c;
    (*buff)++;
  40d332:	48 83 44 24 18 01    	addq   $0x1,0x18(%rsp)
        result += AppendChar(&buff, buff_end, va_arg(args, int));
        break;
      }
      case '%' : {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendChar(&buff, buff_end, '%');
  40d338:	83 c5 01             	add    $0x1,%ebp
        break;
  40d33b:	e9 18 fe ff ff       	jmpq   40d158 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x68>
        result += AppendUnsigned(&buff, buff_end, uval,
                                 (*cur == 'u') ? 10 : 16, width, pad_with_zero);
        break;
      }
      case 'p': {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
  40d340:	40 84 ff             	test   %dil,%dil
  40d343:	0f 85 14 ff ff ff    	jne    40d25d <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x16d>
        result += AppendPointer(&buff, buff_end, va_arg(args, uptr));
  40d349:	41 8b 06             	mov    (%r14),%eax
  40d34c:	83 f8 30             	cmp    $0x30,%eax
  40d34f:	0f 83 83 01 00 00    	jae    40d4d8 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x3e8>
  40d355:	89 c2                	mov    %eax,%edx
  40d357:	49 03 56 10          	add    0x10(%r14),%rdx
  40d35b:	83 c0 08             	add    $0x8,%eax
  40d35e:	41 89 06             	mov    %eax,(%r14)
  40d361:	48 8b 12             	mov    (%rdx),%rdx
  40d364:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
  40d369:	48 8d 05 8a ba 00 00 	lea    0xba8a(%rip),%rax        # 418dfa <.LC5>
static int AppendString(char **buff, const char *buff_end, int precision,
                        const char *s) {
  if (!s)
    s = "<null>";
  int result = 0;
  for (; *s; s++) {
  40d370:	b9 30 00 00 00       	mov    $0x30,%ecx
                                 (*cur == 'u') ? 10 : 16, width, pad_with_zero);
        break;
      }
      case 'p': {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendPointer(&buff, buff_end, va_arg(args, uptr));
  40d375:	45 31 db             	xor    %r11d,%r11d
  40d378:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40d37f:	00 
namespace __sanitizer {

StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
  40d380:	49 39 f4             	cmp    %rsi,%r12
  40d383:	76 10                	jbe    40d395 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x2a5>
    **buff = c;
  40d385:	88 0e                	mov    %cl,(%rsi)
    (*buff)++;
  40d387:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  40d38c:	48 8d 77 01          	lea    0x1(%rdi),%rsi
  40d390:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
static int AppendString(char **buff, const char *buff_end, int precision,
                        const char *s) {
  if (!s)
    s = "<null>";
  int result = 0;
  for (; *s; s++) {
  40d395:	48 83 c0 01          	add    $0x1,%rax
  40d399:	0f b6 08             	movzbl (%rax),%ecx
    if (precision >= 0 && result >= precision)
      break;
    result += AppendChar(buff, buff_end, *s);
  40d39c:	41 83 c3 01          	add    $0x1,%r11d
static int AppendString(char **buff, const char *buff_end, int precision,
                        const char *s) {
  if (!s)
    s = "<null>";
  int result = 0;
  for (; *s; s++) {
  40d3a0:	84 c9                	test   %cl,%cl
  40d3a2:	75 dc                	jne    40d380 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x290>
}

static int AppendUnsigned(char **buff, const char *buff_end, u64 num, u8 base,
                          u8 minimal_num_length, bool pad_with_zero) {
  return AppendNumber(buff, buff_end, num, base, minimal_num_length,
                      pad_with_zero, false /* negative */);
  40d3a4:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  40d3ab:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  40d3b1:	41 b8 0c 00 00 00    	mov    $0xc,%r8d
  40d3b7:	b9 10 00 00 00       	mov    $0x10,%ecx
  40d3bc:	4c 89 e6             	mov    %r12,%rsi
  40d3bf:	4c 89 ef             	mov    %r13,%rdi
  40d3c2:	44 89 5c 24 14       	mov    %r11d,0x14(%rsp)
  40d3c7:	e8 d4 fa ff ff       	callq  40cea0 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb>

static int AppendPointer(char **buff, const char *buff_end, u64 ptr_value) {
  int result = 0;
  result += AppendString(buff, buff_end, -1, "0x");
  result += AppendUnsigned(buff, buff_end, ptr_value, 16,
                           SANITIZER_POINTER_FORMAT_LENGTH, true);
  40d3cc:	44 8b 5c 24 14       	mov    0x14(%rsp),%r11d
  40d3d1:	41 01 c3             	add    %eax,%r11d
                                 (*cur == 'u') ? 10 : 16, width, pad_with_zero);
        break;
      }
      case 'p': {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendPointer(&buff, buff_end, va_arg(args, uptr));
  40d3d4:	44 01 dd             	add    %r11d,%ebp
        break;
  40d3d7:	e9 7c fd ff ff       	jmpq   40d158 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x68>
  40d3dc:	0f 1f 40 00          	nopl   0x0(%rax)
    s64 dval;
    u64 uval;
    bool have_flags = have_width | have_z | have_ll;
    // Only %s supports precision for now
    CHECK(!(precision >= 0 && *cur != 's'));
    switch (*cur) {
  40d3e0:	3c 75                	cmp    $0x75,%al
  40d3e2:	0f 84 da 01 00 00    	je     40d5c2 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x4d2>
  40d3e8:	3c 78                	cmp    $0x78,%al
  40d3ea:	0f 84 d2 01 00 00    	je     40d5c2 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x4d2>
  40d3f0:	3c 73                	cmp    $0x73,%al
  40d3f2:	0f 85 65 fe ff ff    	jne    40d25d <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x16d>
  40d3f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40d3ff:	00 
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendPointer(&buff, buff_end, va_arg(args, uptr));
        break;
      }
      case 's': {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
  40d400:	40 84 ff             	test   %dil,%dil
  40d403:	0f 85 54 fe ff ff    	jne    40d25d <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x16d>
        result += AppendString(&buff, buff_end, precision, va_arg(args, char*));
  40d409:	41 8b 06             	mov    (%r14),%eax
  40d40c:	83 f8 30             	cmp    $0x30,%eax
  40d40f:	0f 83 ab 00 00 00    	jae    40d4c0 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x3d0>
  40d415:	89 c2                	mov    %eax,%edx
  40d417:	49 03 56 10          	add    0x10(%r14),%rdx
  40d41b:	83 c0 08             	add    $0x8,%eax
  40d41e:	41 89 06             	mov    %eax,(%r14)
  40d421:	48 8b 02             	mov    (%rdx),%rax
}

static int AppendString(char **buff, const char *buff_end, int precision,
                        const char *s) {
  if (!s)
    s = "<null>";
  40d424:	48 8d 3d d2 b9 00 00 	lea    0xb9d2(%rip),%rdi        # 418dfd <.LC6>
  40d42b:	48 85 c0             	test   %rax,%rax
  40d42e:	48 0f 44 c7          	cmove  %rdi,%rax
  int result = 0;
  for (; *s; s++) {
  40d432:	0f b6 10             	movzbl (%rax),%edx
  40d435:	84 d2                	test   %dl,%dl
  40d437:	0f 84 23 02 00 00    	je     40d660 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x570>
    if (precision >= 0 && result >= precision)
  40d43d:	89 ce                	mov    %ecx,%esi
  40d43f:	f7 d6                	not    %esi
  40d441:	c1 ee 1f             	shr    $0x1f,%esi
  40d444:	85 c9                	test   %ecx,%ecx
  40d446:	41 89 f0             	mov    %esi,%r8d
  40d449:	0f 84 11 02 00 00    	je     40d660 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x570>
  40d44f:	31 ff                	xor    %edi,%edi
  40d451:	45 84 c0             	test   %r8b,%r8b
  40d454:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
  40d459:	0f 85 f7 00 00 00    	jne    40d556 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x466>
  40d45f:	90                   	nop
namespace __sanitizer {

StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
  40d460:	49 39 f4             	cmp    %rsi,%r12
  40d463:	76 10                	jbe    40d475 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x385>
    **buff = c;
  40d465:	88 16                	mov    %dl,(%rsi)
    (*buff)++;
  40d467:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
  40d46c:	48 83 c6 01          	add    $0x1,%rsi
  40d470:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
static int AppendString(char **buff, const char *buff_end, int precision,
                        const char *s) {
  if (!s)
    s = "<null>";
  int result = 0;
  for (; *s; s++) {
  40d475:	48 83 c0 01          	add    $0x1,%rax
  40d479:	0f b6 10             	movzbl (%rax),%edx
    if (precision >= 0 && result >= precision)
      break;
    result += AppendChar(buff, buff_end, *s);
  40d47c:	83 c7 01             	add    $0x1,%edi
static int AppendString(char **buff, const char *buff_end, int precision,
                        const char *s) {
  if (!s)
    s = "<null>";
  int result = 0;
  for (; *s; s++) {
  40d47f:	84 d2                	test   %dl,%dl
  40d481:	75 dd                	jne    40d460 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x370>
        result += AppendPointer(&buff, buff_end, va_arg(args, uptr));
        break;
      }
      case 's': {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendString(&buff, buff_end, precision, va_arg(args, char*));
  40d483:	01 fd                	add    %edi,%ebp
        break;
  40d485:	e9 ce fc ff ff       	jmpq   40d158 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x68>
  40d48a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    }
    bool have_precision = (cur[0] == '.' && cur[1] == '*');
    int precision = -1;
    if (have_precision) {
      cur += 2;
      precision = va_arg(args, int);
  40d490:	41 8b 0e             	mov    (%r14),%ecx
      }
    }
    bool have_precision = (cur[0] == '.' && cur[1] == '*');
    int precision = -1;
    if (have_precision) {
      cur += 2;
  40d493:	4c 8d 48 02          	lea    0x2(%rax),%r9
      precision = va_arg(args, int);
  40d497:	83 f9 30             	cmp    $0x30,%ecx
  40d49a:	0f 83 c2 00 00 00    	jae    40d562 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x472>
  40d4a0:	89 ca                	mov    %ecx,%edx
  40d4a2:	49 03 56 10          	add    0x10(%r14),%rdx
  40d4a6:	83 c1 08             	add    $0x8,%ecx
  40d4a9:	41 89 0e             	mov    %ecx,(%r14)
  40d4ac:	8b 0a                	mov    (%rdx),%ecx
  40d4ae:	0f b6 50 02          	movzbl 0x2(%rax),%edx
      }
    }
    bool have_precision = (cur[0] == '.' && cur[1] == '*');
    int precision = -1;
    if (have_precision) {
      cur += 2;
  40d4b2:	4c 89 c8             	mov    %r9,%rax
  40d4b5:	e9 f8 fc ff ff       	jmpq   40d1b2 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0xc2>
  40d4ba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        result += AppendPointer(&buff, buff_end, va_arg(args, uptr));
        break;
      }
      case 's': {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendString(&buff, buff_end, precision, va_arg(args, char*));
  40d4c0:	49 8b 56 08          	mov    0x8(%r14),%rdx
  40d4c4:	48 8d 42 08          	lea    0x8(%rdx),%rax
  40d4c8:	49 89 46 08          	mov    %rax,0x8(%r14)
  40d4cc:	e9 50 ff ff ff       	jmpq   40d421 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x331>
  40d4d1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                                 (*cur == 'u') ? 10 : 16, width, pad_with_zero);
        break;
      }
      case 'p': {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendPointer(&buff, buff_end, va_arg(args, uptr));
  40d4d8:	49 8b 56 08          	mov    0x8(%r14),%rdx
  40d4dc:	48 8d 42 08          	lea    0x8(%rdx),%rax
  40d4e0:	49 89 46 08          	mov    %rax,0x8(%r14)
  40d4e4:	e9 78 fe ff ff       	jmpq   40d361 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x271>
  40d4e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        result += AppendString(&buff, buff_end, precision, va_arg(args, char*));
        break;
      }
      case 'c': {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendChar(&buff, buff_end, va_arg(args, int));
  40d4f0:	49 8b 56 08          	mov    0x8(%r14),%rdx
  40d4f4:	48 8d 42 08          	lea    0x8(%rdx),%rax
  40d4f8:	49 89 46 08          	mov    %rax,0x8(%r14)
  40d4fc:	e9 23 fe ff ff       	jmpq   40d324 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x234>
  40d501:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    CHECK(!(precision >= 0 && *cur != 's'));
    switch (*cur) {
      case 'd': {
        dval = have_ll ? va_arg(args, s64)
             : have_z ? va_arg(args, sptr)
             : va_arg(args, int);
  40d508:	84 d2                	test   %dl,%dl
  40d50a:	41 8b 16             	mov    (%r14),%edx
  40d50d:	75 64                	jne    40d573 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x483>
  40d50f:	83 fa 30             	cmp    $0x30,%edx
  40d512:	0f 83 37 01 00 00    	jae    40d64f <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x55f>
  40d518:	89 d0                	mov    %edx,%eax
  40d51a:	49 03 46 10          	add    0x10(%r14),%rax
  40d51e:	83 c2 08             	add    $0x8,%edx
  40d521:	41 89 16             	mov    %edx,(%r14)
  40d524:	48 63 00             	movslq (%rax),%rax
  40d527:	e9 66 fd ff ff       	jmpq   40d292 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x1a2>

StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
    **buff = c;
  40d52c:	88 16                	mov    %dl,(%rsi)
    (*buff)++;
  40d52e:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
  40d533:	48 83 c6 01          	add    $0x1,%rsi
  40d537:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
static int AppendString(char **buff, const char *buff_end, int precision,
                        const char *s) {
  if (!s)
    s = "<null>";
  int result = 0;
  for (; *s; s++) {
  40d53c:	48 83 c0 01          	add    $0x1,%rax
  40d540:	0f b6 10             	movzbl (%rax),%edx
    if (precision >= 0 && result >= precision)
      break;
    result += AppendChar(buff, buff_end, *s);
  40d543:	83 c7 01             	add    $0x1,%edi
static int AppendString(char **buff, const char *buff_end, int precision,
                        const char *s) {
  if (!s)
    s = "<null>";
  int result = 0;
  for (; *s; s++) {
  40d546:	84 d2                	test   %dl,%dl
  40d548:	0f 84 35 ff ff ff    	je     40d483 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x393>
    if (precision >= 0 && result >= precision)
  40d54e:	39 f9                	cmp    %edi,%ecx
  40d550:	0f 8e 2d ff ff ff    	jle    40d483 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x393>
namespace __sanitizer {

StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
  40d556:	49 39 f4             	cmp    %rsi,%r12
  40d559:	76 e1                	jbe    40d53c <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x44c>
  40d55b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  40d560:	eb ca                	jmp    40d52c <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x43c>
    }
    bool have_precision = (cur[0] == '.' && cur[1] == '*');
    int precision = -1;
    if (have_precision) {
      cur += 2;
      precision = va_arg(args, int);
  40d562:	49 8b 56 08          	mov    0x8(%r14),%rdx
  40d566:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  40d56a:	49 89 4e 08          	mov    %rcx,0x8(%r14)
  40d56e:	e9 39 ff ff ff       	jmpq   40d4ac <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x3bc>
    CHECK(!(precision >= 0 && *cur != 's'));
    switch (*cur) {
      case 'd': {
        dval = have_ll ? va_arg(args, s64)
             : have_z ? va_arg(args, sptr)
             : va_arg(args, int);
  40d573:	83 fa 30             	cmp    $0x30,%edx
  40d576:	0f 82 07 fd ff ff    	jb     40d283 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x193>
  40d57c:	49 8b 46 08          	mov    0x8(%r14),%rax
  40d580:	48 8d 50 08          	lea    0x8(%rax),%rdx
  40d584:	49 89 56 08          	mov    %rdx,0x8(%r14)
  40d588:	e9 02 fd ff ff       	jmpq   40d28f <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x19f>
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendChar(&buff, buff_end, va_arg(args, int));
        break;
      }
      case '%' : {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
  40d58d:	40 84 ff             	test   %dil,%dil
  40d590:	0f 85 c7 fc ff ff    	jne    40d25d <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x16d>
namespace __sanitizer {

StaticSpinMutex CommonSanitizerReportMutex;

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff < buff_end) {
  40d596:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  40d59b:	49 39 c4             	cmp    %rax,%r12
  40d59e:	0f 86 94 fd ff ff    	jbe    40d338 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x248>
    **buff = c;
  40d5a4:	c6 00 25             	movb   $0x25,(%rax)
    (*buff)++;
  40d5a7:	48 83 44 24 18 01    	addq   $0x1,0x18(%rsp)
  40d5ad:	e9 86 fd ff ff       	jmpq   40d338 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x248>
  40d5b2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    cur++;
    bool have_width = (*cur >= '0' && *cur <= '9');
    bool pad_with_zero = (*cur == '0');
    int width = 0;
    if (have_width) {
      while (*cur >= '0' && *cur <= '9') {
  40d5b8:	89 f2                	mov    %esi,%edx
  40d5ba:	45 31 c0             	xor    %r8d,%r8d
  40d5bd:	e9 e6 fb ff ff       	jmpq   40d1a8 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0xb8>
      }
      case 'u':
      case 'x': {
        uval = have_ll ? va_arg(args, u64)
             : have_z ? va_arg(args, uptr)
             : va_arg(args, unsigned);
  40d5c2:	45 84 db             	test   %r11b,%r11b
  40d5c5:	74 49                	je     40d610 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x520>
                                      pad_with_zero);
        break;
      }
      case 'u':
      case 'x': {
        uval = have_ll ? va_arg(args, u64)
  40d5c7:	41 8b 16             	mov    (%r14),%edx
  40d5ca:	83 fa 30             	cmp    $0x30,%edx
  40d5cd:	73 4d                	jae    40d61c <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x52c>
             : have_z ? va_arg(args, uptr)
             : va_arg(args, unsigned);
  40d5cf:	89 d0                	mov    %edx,%eax
  40d5d1:	49 03 46 10          	add    0x10(%r14),%rax
  40d5d5:	83 c2 08             	add    $0x8,%edx
  40d5d8:	41 89 16             	mov    %edx,(%r14)
  40d5db:	48 8b 10             	mov    (%rax),%rdx
        result += AppendUnsigned(&buff, buff_end, uval,
                                 (*cur == 'u') ? 10 : 16, width, pad_with_zero);
  40d5de:	80 3b 75             	cmpb   $0x75,(%rbx)
  40d5e1:	b9 0a 00 00 00       	mov    $0xa,%ecx
}

static int AppendUnsigned(char **buff, const char *buff_end, u64 num, u8 base,
                          u8 minimal_num_length, bool pad_with_zero) {
  return AppendNumber(buff, buff_end, num, base, minimal_num_length,
                      pad_with_zero, false /* negative */);
  40d5e6:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  40d5ed:	45 0f b6 c0          	movzbl %r8b,%r8d
  40d5f1:	4c 89 e6             	mov    %r12,%rsi
  40d5f4:	4c 89 ef             	mov    %r13,%rdi
      case 'x': {
        uval = have_ll ? va_arg(args, u64)
             : have_z ? va_arg(args, uptr)
             : va_arg(args, unsigned);
        result += AppendUnsigned(&buff, buff_end, uval,
                                 (*cur == 'u') ? 10 : 16, width, pad_with_zero);
  40d5f7:	41 0f 45 cf          	cmovne %r15d,%ecx
}

static int AppendUnsigned(char **buff, const char *buff_end, u64 num, u8 base,
                          u8 minimal_num_length, bool pad_with_zero) {
  return AppendNumber(buff, buff_end, num, base, minimal_num_length,
                      pad_with_zero, false /* negative */);
  40d5fb:	41 83 e1 01          	and    $0x1,%r9d
  40d5ff:	e8 9c f8 ff ff       	callq  40cea0 <_ZN11__sanitizerL12AppendNumberEPPcPKcyhhbb>
      case 'x': {
        uval = have_ll ? va_arg(args, u64)
             : have_z ? va_arg(args, uptr)
             : va_arg(args, unsigned);
        result += AppendUnsigned(&buff, buff_end, uval,
                                 (*cur == 'u') ? 10 : 16, width, pad_with_zero);
  40d604:	01 c5                	add    %eax,%ebp
        break;
  40d606:	e9 4d fb ff ff       	jmpq   40d158 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x68>
  40d60b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
      }
      case 'u':
      case 'x': {
        uval = have_ll ? va_arg(args, u64)
             : have_z ? va_arg(args, uptr)
             : va_arg(args, unsigned);
  40d610:	84 d2                	test   %dl,%dl
  40d612:	41 8b 16             	mov    (%r14),%edx
  40d615:	74 13                	je     40d62a <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x53a>
  40d617:	83 fa 30             	cmp    $0x30,%edx
  40d61a:	72 b3                	jb     40d5cf <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x4df>
  40d61c:	49 8b 46 08          	mov    0x8(%r14),%rax
  40d620:	48 8d 50 08          	lea    0x8(%rax),%rdx
  40d624:	49 89 56 08          	mov    %rdx,0x8(%r14)
  40d628:	eb b1                	jmp    40d5db <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x4eb>
  40d62a:	83 fa 30             	cmp    $0x30,%edx
  40d62d:	73 10                	jae    40d63f <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x54f>
  40d62f:	89 d0                	mov    %edx,%eax
  40d631:	49 03 46 10          	add    0x10(%r14),%rax
  40d635:	83 c2 08             	add    $0x8,%edx
  40d638:	41 89 16             	mov    %edx,(%r14)
  40d63b:	8b 10                	mov    (%rax),%edx
  40d63d:	eb 9f                	jmp    40d5de <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x4ee>
  40d63f:	49 8b 46 08          	mov    0x8(%r14),%rax
  40d643:	48 8d 50 08          	lea    0x8(%rax),%rdx
  40d647:	49 89 56 08          	mov    %rdx,0x8(%r14)
  40d64b:	8b 10                	mov    (%rax),%edx
  40d64d:	eb 8f                	jmp    40d5de <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x4ee>
    CHECK(!(precision >= 0 && *cur != 's'));
    switch (*cur) {
      case 'd': {
        dval = have_ll ? va_arg(args, s64)
             : have_z ? va_arg(args, sptr)
             : va_arg(args, int);
  40d64f:	49 8b 46 08          	mov    0x8(%r14),%rax
  40d653:	48 8d 50 08          	lea    0x8(%rax),%rdx
  40d657:	49 89 56 08          	mov    %rdx,0x8(%r14)
  40d65b:	e9 c4 fe ff ff       	jmpq   40d524 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x434>
                        const char *s) {
  if (!s)
    s = "<null>";
  int result = 0;
  for (; *s; s++) {
    if (precision >= 0 && result >= precision)
  40d660:	31 ff                	xor    %edi,%edi
        result += AppendPointer(&buff, buff_end, va_arg(args, uptr));
        break;
      }
      case 's': {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendString(&buff, buff_end, precision, va_arg(args, char*));
  40d662:	01 fd                	add    %edi,%ebp
  40d664:	e9 ef fa ff ff       	jmpq   40d158 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag+0x68>
      default: {
        RAW_CHECK_MSG(false, kPrintfFormatsHelp);
      }
    }
  }
  RAW_CHECK(buff <= buff_end);
  40d669:	48 8d 3d ab b7 00 00 	lea    0xb7ab(%rip),%rdi        # 418e1b <.LC10>
  40d670:	e8 6b 7a ff ff       	callq  4050e0 <_ZN11__sanitizer8RawWriteEPKc>
  40d675:	e8 e6 7b ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
int VSNPrintf(char *buff, int buff_length,
              const char *format, va_list args) {
  static const char *kPrintfFormatsHelp =
    "Supported Printf formats: %([0-9]*)?(z|ll)?{d,u,x}; %p; %(\\.\\*)?s; %c\n";
  RAW_CHECK(format);
  RAW_CHECK(buff_length > 0);
  40d67a:	48 8d 3d 8a b7 00 00 	lea    0xb78a(%rip),%rdi        # 418e0b <.LC8>
  40d681:	e8 5a 7a ff ff       	callq  4050e0 <_ZN11__sanitizer8RawWriteEPKc>
  40d686:	e8 d5 7b ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>

int VSNPrintf(char *buff, int buff_length,
              const char *format, va_list args) {
  static const char *kPrintfFormatsHelp =
    "Supported Printf formats: %([0-9]*)?(z|ll)?{d,u,x}; %p; %(\\.\\*)?s; %c\n";
  RAW_CHECK(format);
  40d68b:	48 8d 3d 72 b7 00 00 	lea    0xb772(%rip),%rdi        # 418e04 <.LC7>
  40d692:	e8 49 7a ff ff       	callq  4050e0 <_ZN11__sanitizer8RawWriteEPKc>
  40d697:	e8 c4 7b ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  40d69c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040d6a0 <_ZN11__sanitizer26SetPrintfAndReportCallbackEPFvPKcE>:
  return result;
}

static void (*PrintfAndReportCallback)(const char *);
void SetPrintfAndReportCallback(void (*callback)(const char *)) {
  PrintfAndReportCallback = callback;
  40d6a0:	48 89 3d 39 43 26 00 	mov    %rdi,0x264339(%rip)        # 6719e0 <_ZN11__sanitizerL23PrintfAndReportCallbackE>
  40d6a7:	c3                   	retq   
  40d6a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40d6af:	00 

000000000040d6b0 <_ZN11__sanitizer7OnPrintEPKc>:
}

// Can be overriden in frontend.
#if SANITIZER_SUPPORTS_WEAK_HOOKS
SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE
void OnPrint(const char *str) {
  40d6b0:	f3 c3                	repz retq 
  40d6b2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40d6b9:	1f 84 00 00 00 00 00 

000000000040d6c0 <_ZN11__sanitizer17internal_snprintfEPcmPKcz>:
// Writes at most "length" symbols to "buffer" (including trailing '\0').
// Returns the number of symbols that should have been written to buffer
// (not including trailing '\0'). Thus, the string is truncated
// iff return value is not less than "length".
FORMAT(3, 4)
int internal_snprintf(char *buffer, uptr length, const char *format, ...) {
  40d6c0:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
  40d6c7:	84 c0                	test   %al,%al
  40d6c9:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  40d6ce:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
  40d6d3:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
  40d6d8:	74 37                	je     40d711 <_ZN11__sanitizer17internal_snprintfEPcmPKcz+0x51>
  40d6da:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
  40d6df:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
  40d6e4:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
  40d6e9:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
  40d6f0:	00 
  40d6f1:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
  40d6f8:	00 
  40d6f9:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
  40d700:	00 
  40d701:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
  40d708:	00 
  40d709:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
  40d710:	00 
  va_list args;
  va_start(args, format);
  40d711:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
  40d718:	00 
  int needed_length = VSNPrintf(buffer, length, format, args);
  40d719:	48 8d 4c 24 08       	lea    0x8(%rsp),%rcx
// (not including trailing '\0'). Thus, the string is truncated
// iff return value is not less than "length".
FORMAT(3, 4)
int internal_snprintf(char *buffer, uptr length, const char *format, ...) {
  va_list args;
  va_start(args, format);
  40d71e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40d723:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
  40d728:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%rsp)
  40d72f:	00 
  40d730:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
  40d737:	00 
  40d738:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  int needed_length = VSNPrintf(buffer, length, format, args);
  40d73d:	e8 ae f9 ff ff       	callq  40d0f0 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag>
  va_end(args);
  return needed_length;
}
  40d742:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
  40d749:	c3                   	retq   
  40d74a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000040d750 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag>:
  if (PrintfAndReportCallback)
    PrintfAndReportCallback(str);
}

static void SharedPrintfCode(bool append_pid, const char *format,
                             va_list args) {
  40d750:	41 57                	push   %r15
  40d752:	49 89 d7             	mov    %rdx,%r15
  40d755:	41 56                	push   %r14
  40d757:	41 55                	push   %r13
  int needed_length;
  char *buffer = local_buffer;
  int buffer_size = ARRAY_SIZE(local_buffer);
  // First try to print a message using a local buffer, and then fall back to
  // mmaped buffer.
  for (int use_mmap = 0; use_mmap < 2; use_mmap++) {
  40d759:	45 31 ed             	xor    %r13d,%r13d
  if (PrintfAndReportCallback)
    PrintfAndReportCallback(str);
}

static void SharedPrintfCode(bool append_pid, const char *format,
                             va_list args) {
  40d75c:	41 54                	push   %r12
  40d75e:	55                   	push   %rbp
  // hand, the bigger the buffer is, the more the chance the error report will
  // fit into it.
  char local_buffer[400];
  int needed_length;
  char *buffer = local_buffer;
  int buffer_size = ARRAY_SIZE(local_buffer);
  40d75f:	bd 90 01 00 00       	mov    $0x190,%ebp
  if (PrintfAndReportCallback)
    PrintfAndReportCallback(str);
}

static void SharedPrintfCode(bool append_pid, const char *format,
                             va_list args) {
  40d764:	53                   	push   %rbx
  40d765:	48 81 ec d8 01 00 00 	sub    $0x1d8,%rsp
  va_list args2;
  va_copy(args2, args);
  40d76c:	48 8b 02             	mov    (%rdx),%rax
  // the stack limit enforced by TSan (-Wframe-larger-than=512). On the other
  // hand, the bigger the buffer is, the more the chance the error report will
  // fit into it.
  char local_buffer[400];
  int needed_length;
  char *buffer = local_buffer;
  40d76f:	4c 8d 64 24 40       	lea    0x40(%rsp),%r12
  if (PrintfAndReportCallback)
    PrintfAndReportCallback(str);
}

static void SharedPrintfCode(bool append_pid, const char *format,
                             va_list args) {
  40d774:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  40d779:	40 88 7c 24 18       	mov    %dil,0x18(%rsp)
  va_list args2;
  va_copy(args2, args);
  40d77e:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  40d783:	48 8b 42 08          	mov    0x8(%rdx),%rax
  // the stack limit enforced by TSan (-Wframe-larger-than=512). On the other
  // hand, the bigger the buffer is, the more the chance the error report will
  // fit into it.
  char local_buffer[400];
  int needed_length;
  char *buffer = local_buffer;
  40d787:	4c 89 e3             	mov    %r12,%rbx
}

static void SharedPrintfCode(bool append_pid, const char *format,
                             va_list args) {
  va_list args2;
  va_copy(args2, args);
  40d78a:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  40d78f:	48 8b 42 10          	mov    0x10(%rdx),%rax
  40d793:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
      if (needed_length >= buffer_size) { \
        if (!use_mmap) continue; \
        RAW_CHECK_MSG(needed_length < kLen, \
                      "Buffer in Report is too short!\n"); \
      }
    if (append_pid) {
  40d798:	80 7c 24 18 00       	cmpb   $0x0,0x18(%rsp)
  40d79d:	0f 85 9d 00 00 00    	jne    40d840 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0xf0>
  40d7a3:	31 ff                	xor    %edi,%edi
      va_end(args);
      va_copy(args, args2);
      buffer = (char*)MmapOrDie(kLen, "Report");
      buffer_size = kLen;
    }
    needed_length = 0;
  40d7a5:	45 31 c9             	xor    %r9d,%r9d
                                         buffer_size - needed_length,
                                         "==%d==", pid);
      CHECK_NEEDED_LENGTH
    }
    needed_length += VSNPrintf(buffer + needed_length,
                               buffer_size - needed_length, format, args);
  40d7a8:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  40d7ad:	89 ee                	mov    %ebp,%esi
  40d7af:	48 01 df             	add    %rbx,%rdi
  40d7b2:	44 29 ce             	sub    %r9d,%esi
  40d7b5:	4c 89 f9             	mov    %r15,%rcx
  40d7b8:	44 89 4c 24 10       	mov    %r9d,0x10(%rsp)
  40d7bd:	e8 2e f9 ff ff       	callq  40d0f0 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag>
  40d7c2:	44 8b 4c 24 10       	mov    0x10(%rsp),%r9d
  40d7c7:	41 01 c1             	add    %eax,%r9d
    CHECK_NEEDED_LENGTH
  40d7ca:	44 39 cd             	cmp    %r9d,%ebp
  40d7cd:	7f 16                	jg     40d7e5 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x95>
  40d7cf:	45 85 ed             	test   %r13d,%r13d
  40d7d2:	0f 84 38 01 00 00    	je     40d910 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x1c0>
  40d7d8:	41 81 f9 ff 3f 00 00 	cmp    $0x3fff,%r9d
  40d7df:	0f 8f f2 01 00 00    	jg     40d9d7 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x287>
  40d7e5:	4c 8b 35 cc 0a 01 00 	mov    0x10acc(%rip),%r14        # 41e2b8 <_DYNAMIC+0x2b8>
    // If the message fit into the buffer, print it and exit.
    break;
#   undef CHECK_NEEDED_LENGTH
  }
  RawWrite(buffer);
  40d7ec:	48 89 df             	mov    %rbx,%rdi
  40d7ef:	e8 ec 78 ff ff       	callq  4050e0 <_ZN11__sanitizer8RawWriteEPKc>
  if (common_flags()->log_to_syslog)
  40d7f4:	41 80 7e 31 00       	cmpb   $0x0,0x31(%r14)
  40d7f9:	74 08                	je     40d803 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0xb3>
    WriteToSyslog(buffer);
  40d7fb:	48 89 df             	mov    %rbx,%rdi
  40d7fe:	e8 cd 4c 00 00       	callq  4124d0 <_ZN11__sanitizer13WriteToSyslogEPKc>
  (void)str;
}
#endif

static void CallPrintfAndReportCallback(const char *str) {
  OnPrint(str);
  40d803:	48 89 df             	mov    %rbx,%rdi
  40d806:	e8 a5 fe ff ff       	callq  40d6b0 <_ZN11__sanitizer7OnPrintEPKc>
  if (PrintfAndReportCallback)
  40d80b:	48 8b 05 ce 41 26 00 	mov    0x2641ce(%rip),%rax        # 6719e0 <_ZN11__sanitizerL23PrintfAndReportCallbackE>
  40d812:	48 85 c0             	test   %rax,%rax
  40d815:	74 05                	je     40d81c <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0xcc>
    PrintfAndReportCallback(str);
  40d817:	48 89 df             	mov    %rbx,%rdi
  40d81a:	ff d0                	callq  *%rax
  RawWrite(buffer);
  if (common_flags()->log_to_syslog)
    WriteToSyslog(buffer);
  CallPrintfAndReportCallback(buffer);
  // If we had mapped any memory, clean up.
  if (buffer != local_buffer)
  40d81c:	4c 39 e3             	cmp    %r12,%rbx
  40d81f:	74 0b                	je     40d82c <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0xdc>
    UnmapOrDie((void *)buffer, buffer_size);
  40d821:	48 63 f5             	movslq %ebp,%rsi
  40d824:	48 89 df             	mov    %rbx,%rdi
  40d827:	e8 14 ec ff ff       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  va_end(args2);
}
  40d82c:	48 81 c4 d8 01 00 00 	add    $0x1d8,%rsp
  40d833:	5b                   	pop    %rbx
  40d834:	5d                   	pop    %rbp
  40d835:	41 5c                	pop    %r12
  40d837:	41 5d                	pop    %r13
  40d839:	41 5e                	pop    %r14
  40d83b:	41 5f                	pop    %r15
  40d83d:	c3                   	retq   
  40d83e:	66 90                	xchg   %ax,%ax
        if (!use_mmap) continue; \
        RAW_CHECK_MSG(needed_length < kLen, \
                      "Buffer in Report is too short!\n"); \
      }
    if (append_pid) {
      int pid = internal_getpid();
  40d840:	e8 9b e1 ff ff       	callq  40b9e0 <_ZN11__sanitizer15internal_getpidEv>
  40d845:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
      const char *exe_name = GetProcessName();
  40d84a:	e8 31 86 ff ff       	callq  405e80 <_ZN11__sanitizer14GetProcessNameEv>
      if (common_flags()->log_exe_name && exe_name) {
  40d84f:	4c 8b 35 62 0a 01 00 	mov    0x10a62(%rip),%r14        # 41e2b8 <_DYNAMIC+0x2b8>
  40d856:	41 80 7e 30 00       	cmpb   $0x0,0x30(%r14)
  40d85b:	0f 84 ef 00 00 00    	je     40d950 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x200>
  40d861:	48 85 c0             	test   %rax,%rax
  40d864:	0f 84 e6 00 00 00    	je     40d950 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x200>
        needed_length += internal_snprintf(buffer, buffer_size,
                                           "==%s", exe_name);
  40d86a:	48 8d 15 c2 b5 00 00 	lea    0xb5c2(%rip),%rdx        # 418e33 <.LC15>
  40d871:	48 89 c1             	mov    %rax,%rcx
  40d874:	48 89 df             	mov    %rbx,%rdi
  40d877:	31 c0                	xor    %eax,%eax
  40d879:	48 63 f5             	movslq %ebp,%rsi
  40d87c:	e8 3f fe ff ff       	callq  40d6c0 <_ZN11__sanitizer17internal_snprintfEPcmPKcz>
        CHECK_NEEDED_LENGTH
  40d881:	39 c5                	cmp    %eax,%ebp
    if (append_pid) {
      int pid = internal_getpid();
      const char *exe_name = GetProcessName();
      if (common_flags()->log_exe_name && exe_name) {
        needed_length += internal_snprintf(buffer, buffer_size,
                                           "==%s", exe_name);
  40d883:	41 89 c1             	mov    %eax,%r9d
  40d886:	48 63 f8             	movslq %eax,%rdi
        CHECK_NEEDED_LENGTH
  40d889:	0f 8e d1 00 00 00    	jle    40d960 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x210>
      }
      needed_length += internal_snprintf(buffer + needed_length,
                                         buffer_size - needed_length,
  40d88f:	89 ee                	mov    %ebp,%esi
                                         "==%d==", pid);
  40d891:	8b 4c 24 10          	mov    0x10(%rsp),%ecx
  40d895:	48 8d 15 90 b5 00 00 	lea    0xb590(%rip),%rdx        # 418e2c <.LC14>
        needed_length += internal_snprintf(buffer, buffer_size,
                                           "==%s", exe_name);
        CHECK_NEEDED_LENGTH
      }
      needed_length += internal_snprintf(buffer + needed_length,
                                         buffer_size - needed_length,
  40d89c:	44 29 ce             	sub    %r9d,%esi
                                         "==%d==", pid);
  40d89f:	48 01 df             	add    %rbx,%rdi
  40d8a2:	31 c0                	xor    %eax,%eax
  40d8a4:	48 63 f6             	movslq %esi,%rsi
        needed_length += internal_snprintf(buffer, buffer_size,
                                           "==%s", exe_name);
        CHECK_NEEDED_LENGTH
      }
      needed_length += internal_snprintf(buffer + needed_length,
                                         buffer_size - needed_length,
  40d8a7:	44 89 4c 24 1c       	mov    %r9d,0x1c(%rsp)
                                         "==%d==", pid);
  40d8ac:	e8 0f fe ff ff       	callq  40d6c0 <_ZN11__sanitizer17internal_snprintfEPcmPKcz>
  40d8b1:	44 8b 4c 24 1c       	mov    0x1c(%rsp),%r9d
  40d8b6:	41 01 c1             	add    %eax,%r9d
      CHECK_NEEDED_LENGTH
  40d8b9:	44 39 cd             	cmp    %r9d,%ebp
  40d8bc:	49 63 f9             	movslq %r9d,%rdi
  40d8bf:	0f 8f e3 fe ff ff    	jg     40d7a8 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x58>
  40d8c5:	45 85 ed             	test   %r13d,%r13d
  40d8c8:	74 46                	je     40d910 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x1c0>
  40d8ca:	41 81 f9 ff 3f 00 00 	cmp    $0x3fff,%r9d
  40d8d1:	0f 8f 00 01 00 00    	jg     40d9d7 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x287>
    }
    needed_length += VSNPrintf(buffer + needed_length,
                               buffer_size - needed_length, format, args);
  40d8d7:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  40d8dc:	49 63 f9             	movslq %r9d,%rdi
  40d8df:	89 ee                	mov    %ebp,%esi
  40d8e1:	44 29 ce             	sub    %r9d,%esi
  40d8e4:	48 01 df             	add    %rbx,%rdi
  40d8e7:	4c 89 f9             	mov    %r15,%rcx
  40d8ea:	44 89 4c 24 18       	mov    %r9d,0x18(%rsp)
  40d8ef:	e8 fc f7 ff ff       	callq  40d0f0 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag>
  40d8f4:	44 8b 4c 24 18       	mov    0x18(%rsp),%r9d
  40d8f9:	41 01 c1             	add    %eax,%r9d
    CHECK_NEEDED_LENGTH
  40d8fc:	41 39 e9             	cmp    %ebp,%r9d
  40d8ff:	0f 8d d3 fe ff ff    	jge    40d7d8 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x88>
  40d905:	e9 e2 fe ff ff       	jmpq   40d7ec <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x9c>
  40d90a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  // First try to print a message using a local buffer, and then fall back to
  // mmaped buffer.
  for (int use_mmap = 0; use_mmap < 2; use_mmap++) {
    if (use_mmap) {
      va_end(args);
      va_copy(args, args2);
  40d910:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
      buffer = (char*)MmapOrDie(kLen, "Report");
  40d915:	48 8d 35 1c b5 00 00 	lea    0xb51c(%rip),%rsi        # 418e38 <.LC16>
  40d91c:	bf 00 40 00 00       	mov    $0x4000,%edi
  int needed_length;
  char *buffer = local_buffer;
  int buffer_size = ARRAY_SIZE(local_buffer);
  // First try to print a message using a local buffer, and then fall back to
  // mmaped buffer.
  for (int use_mmap = 0; use_mmap < 2; use_mmap++) {
  40d921:	41 bd 01 00 00 00    	mov    $0x1,%r13d
  40d927:	bd 00 40 00 00       	mov    $0x4000,%ebp
    if (use_mmap) {
      va_end(args);
      va_copy(args, args2);
  40d92c:	49 89 07             	mov    %rax,(%r15)
  40d92f:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  40d934:	49 89 47 08          	mov    %rax,0x8(%r15)
  40d938:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
  40d93d:	49 89 47 10          	mov    %rax,0x10(%r15)
      buffer = (char*)MmapOrDie(kLen, "Report");
  40d941:	e8 5a ea ff ff       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  40d946:	48 89 c3             	mov    %rax,%rbx
  40d949:	e9 4a fe ff ff       	jmpq   40d798 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x48>
  40d94e:	66 90                	xchg   %ax,%ax
  40d950:	31 ff                	xor    %edi,%edi
      buffer_size = kLen;
    }
    needed_length = 0;
  40d952:	45 31 c9             	xor    %r9d,%r9d
  40d955:	e9 35 ff ff ff       	jmpq   40d88f <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x13f>
  40d95a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      int pid = internal_getpid();
      const char *exe_name = GetProcessName();
      if (common_flags()->log_exe_name && exe_name) {
        needed_length += internal_snprintf(buffer, buffer_size,
                                           "==%s", exe_name);
        CHECK_NEEDED_LENGTH
  40d960:	45 85 ed             	test   %r13d,%r13d
  40d963:	74 ab                	je     40d910 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x1c0>
  40d965:	41 81 f9 ff 3f 00 00 	cmp    $0x3fff,%r9d
  40d96c:	7f 69                	jg     40d9d7 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x287>
      }
      needed_length += internal_snprintf(buffer + needed_length,
                                         buffer_size - needed_length,
  40d96e:	89 ee                	mov    %ebp,%esi
                                         "==%d==", pid);
  40d970:	8b 4c 24 10          	mov    0x10(%rsp),%ecx
  40d974:	49 63 f9             	movslq %r9d,%rdi
        needed_length += internal_snprintf(buffer, buffer_size,
                                           "==%s", exe_name);
        CHECK_NEEDED_LENGTH
      }
      needed_length += internal_snprintf(buffer + needed_length,
                                         buffer_size - needed_length,
  40d977:	44 29 ce             	sub    %r9d,%esi
                                         "==%d==", pid);
  40d97a:	48 8d 15 ab b4 00 00 	lea    0xb4ab(%rip),%rdx        # 418e2c <.LC14>
  40d981:	48 01 df             	add    %rbx,%rdi
  40d984:	31 c0                	xor    %eax,%eax
  40d986:	48 63 f6             	movslq %esi,%rsi
  40d989:	44 89 4c 24 18       	mov    %r9d,0x18(%rsp)
  40d98e:	e8 2d fd ff ff       	callq  40d6c0 <_ZN11__sanitizer17internal_snprintfEPcmPKcz>
  40d993:	44 8b 4c 24 18       	mov    0x18(%rsp),%r9d
  40d998:	41 01 c1             	add    %eax,%r9d
      CHECK_NEEDED_LENGTH
  40d99b:	44 39 cd             	cmp    %r9d,%ebp
  40d99e:	0f 8e 26 ff ff ff    	jle    40d8ca <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x17a>
    }
    needed_length += VSNPrintf(buffer + needed_length,
                               buffer_size - needed_length, format, args);
  40d9a4:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  40d9a9:	49 63 f9             	movslq %r9d,%rdi
  40d9ac:	89 ee                	mov    %ebp,%esi
  40d9ae:	44 29 ce             	sub    %r9d,%esi
  40d9b1:	48 01 df             	add    %rbx,%rdi
  40d9b4:	4c 89 f9             	mov    %r15,%rcx
  40d9b7:	44 89 4c 24 18       	mov    %r9d,0x18(%rsp)
  40d9bc:	e8 2f f7 ff ff       	callq  40d0f0 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag>
  40d9c1:	44 8b 4c 24 18       	mov    0x18(%rsp),%r9d
  40d9c6:	41 01 c1             	add    %eax,%r9d
    CHECK_NEEDED_LENGTH
  40d9c9:	44 39 cd             	cmp    %r9d,%ebp
  40d9cc:	0f 8e 06 fe ff ff    	jle    40d7d8 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x88>
  40d9d2:	e9 15 fe ff ff       	jmpq   40d7ec <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag+0x9c>
      int pid = internal_getpid();
      const char *exe_name = GetProcessName();
      if (common_flags()->log_exe_name && exe_name) {
        needed_length += internal_snprintf(buffer, buffer_size,
                                           "==%s", exe_name);
        CHECK_NEEDED_LENGTH
  40d9d7:	48 8d 3d 82 9c 00 00 	lea    0x9c82(%rip),%rdi        # 417660 <.LC13>
  40d9de:	e8 fd 76 ff ff       	callq  4050e0 <_ZN11__sanitizer8RawWriteEPKc>
  40d9e3:	e8 78 78 ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  40d9e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40d9ef:	00 

000000000040d9f0 <_ZN11__sanitizer6PrintfEPKcz>:
    UnmapOrDie((void *)buffer, buffer_size);
  va_end(args2);
}

FORMAT(1, 2)
void Printf(const char *format, ...) {
  40d9f0:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
  40d9f7:	84 c0                	test   %al,%al
  40d9f9:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  40d9fe:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
  40da03:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  40da08:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
  40da0d:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
  40da12:	74 37                	je     40da4b <_ZN11__sanitizer6PrintfEPKcz+0x5b>
  40da14:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
  40da19:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
  40da1e:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
  40da23:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
  40da2a:	00 
  40da2b:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
  40da32:	00 
  40da33:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
  40da3a:	00 
  40da3b:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
  40da42:	00 
  40da43:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
  40da4a:	00 
  va_list args;
  va_start(args, format);
  40da4b:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
  40da52:	00 
  SharedPrintfCode(false, format, args);
  40da53:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
    UnmapOrDie((void *)buffer, buffer_size);
  va_end(args2);
}

FORMAT(1, 2)
void Printf(const char *format, ...) {
  40da58:	48 89 fe             	mov    %rdi,%rsi
  va_list args;
  va_start(args, format);
  SharedPrintfCode(false, format, args);
  40da5b:	31 ff                	xor    %edi,%edi
}

FORMAT(1, 2)
void Printf(const char *format, ...) {
  va_list args;
  va_start(args, format);
  40da5d:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40da62:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
  40da67:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%rsp)
  40da6e:	00 
  40da6f:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
  40da76:	00 
  40da77:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  SharedPrintfCode(false, format, args);
  40da7c:	e8 cf fc ff ff       	callq  40d750 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag>
  va_end(args);
}
  40da81:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
  40da88:	c3                   	retq   
  40da89:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000040da90 <_ZN11__sanitizer6ReportEPKcz>:

// Like Printf, but prints the current PID before the output string.
FORMAT(1, 2)
void Report(const char *format, ...) {
  40da90:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
  40da97:	84 c0                	test   %al,%al
  40da99:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  40da9e:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
  40daa3:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  40daa8:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
  40daad:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
  40dab2:	74 37                	je     40daeb <_ZN11__sanitizer6ReportEPKcz+0x5b>
  40dab4:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
  40dab9:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
  40dabe:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
  40dac3:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
  40daca:	00 
  40dacb:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
  40dad2:	00 
  40dad3:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
  40dada:	00 
  40dadb:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
  40dae2:	00 
  40dae3:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
  40daea:	00 
  va_list args;
  va_start(args, format);
  40daeb:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
  40daf2:	00 
  SharedPrintfCode(true, format, args);
  40daf3:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
  va_end(args);
}

// Like Printf, but prints the current PID before the output string.
FORMAT(1, 2)
void Report(const char *format, ...) {
  40daf8:	48 89 fe             	mov    %rdi,%rsi
  va_list args;
  va_start(args, format);
  SharedPrintfCode(true, format, args);
  40dafb:	bf 01 00 00 00       	mov    $0x1,%edi

// Like Printf, but prints the current PID before the output string.
FORMAT(1, 2)
void Report(const char *format, ...) {
  va_list args;
  va_start(args, format);
  40db00:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40db05:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
  40db0a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%rsp)
  40db11:	00 
  40db12:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
  40db19:	00 
  40db1a:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  SharedPrintfCode(true, format, args);
  40db1f:	e8 2c fc ff ff       	callq  40d750 <_ZN11__sanitizerL16SharedPrintfCodeEbPKcP13__va_list_tag>
  va_end(args);
}
  40db24:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
  40db2b:	c3                   	retq   
  40db2c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>:
  va_end(args);
  return needed_length;
}

FORMAT(2, 3)
void InternalScopedString::append(const char *format, ...) {
  40db30:	53                   	push   %rbx
  40db31:	48 89 fb             	mov    %rdi,%rbx
  40db34:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  40db3b:	84 c0                	test   %al,%al
  40db3d:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
  40db42:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  40db47:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
  40db4c:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
  40db51:	74 37                	je     40db8a <_ZN11__sanitizer20InternalScopedString6appendEPKcz+0x5a>
  40db53:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
  40db58:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
  40db5d:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
  40db62:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
  40db69:	00 
  40db6a:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
  40db71:	00 
  40db72:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
  40db79:	00 
  40db7a:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
  40db81:	00 
  40db82:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
  40db89:	00 
  40db8a:	48 89 f2             	mov    %rsi,%rdx
  CHECK_LT(length_, size());
  40db8d:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  40db91:	4c 8b 43 08          	mov    0x8(%rbx),%r8
  40db95:	4c 39 c7             	cmp    %r8,%rdi
  40db98:	73 5f                	jae    40dbf9 <_ZN11__sanitizer20InternalScopedString6appendEPKcz+0xc9>
  va_list args;
  va_start(args, format);
  VSNPrintf(data() + length_, size() - length_, format, args);
  40db9a:	44 89 c6             	mov    %r8d,%esi

FORMAT(2, 3)
void InternalScopedString::append(const char *format, ...) {
  CHECK_LT(length_, size());
  va_list args;
  va_start(args, format);
  40db9d:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
  40dba4:	00 
  VSNPrintf(data() + length_, size() - length_, format, args);
  40dba5:	48 8d 4c 24 08       	lea    0x8(%rsp),%rcx
  40dbaa:	29 fe                	sub    %edi,%esi
  40dbac:	48 03 3b             	add    (%rbx),%rdi

FORMAT(2, 3)
void InternalScopedString::append(const char *format, ...) {
  CHECK_LT(length_, size());
  va_list args;
  va_start(args, format);
  40dbaf:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%rsp)
  40dbb6:	00 
  40dbb7:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40dbbc:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
  40dbc1:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
  40dbc8:	00 
  40dbc9:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  VSNPrintf(data() + length_, size() - length_, format, args);
  40dbce:	e8 1d f5 ff ff       	callq  40d0f0 <_ZN11__sanitizer9VSNPrintfEPciPKcP13__va_list_tag>
  va_end(args);
  length_ += internal_strlen(data() + length_);
  40dbd3:	48 8b 3b             	mov    (%rbx),%rdi
  40dbd6:	48 03 7b 10          	add    0x10(%rbx),%rdi
  40dbda:	e8 51 cd ff ff       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  40dbdf:	48 03 43 10          	add    0x10(%rbx),%rax
  return needed_length;
}

FORMAT(2, 3)
void InternalScopedString::append(const char *format, ...) {
  CHECK_LT(length_, size());
  40dbe3:	4c 8b 43 08          	mov    0x8(%rbx),%r8
  va_list args;
  va_start(args, format);
  VSNPrintf(data() + length_, size() - length_, format, args);
  va_end(args);
  length_ += internal_strlen(data() + length_);
  CHECK_LT(length_, size());
  40dbe7:	4c 39 c0             	cmp    %r8,%rax
  CHECK_LT(length_, size());
  va_list args;
  va_start(args, format);
  VSNPrintf(data() + length_, size() - length_, format, args);
  va_end(args);
  length_ += internal_strlen(data() + length_);
  40dbea:	48 89 43 10          	mov    %rax,0x10(%rbx)
  CHECK_LT(length_, size());
  40dbee:	73 24                	jae    40dc14 <_ZN11__sanitizer20InternalScopedString6appendEPKcz+0xe4>
}
  40dbf0:	48 81 c4 d0 00 00 00 	add    $0xd0,%rsp
  40dbf7:	5b                   	pop    %rbx
  40dbf8:	c3                   	retq   
  return needed_length;
}

FORMAT(2, 3)
void InternalScopedString::append(const char *format, ...) {
  CHECK_LT(length_, size());
  40dbf9:	48 89 f9             	mov    %rdi,%rcx
  40dbfc:	48 8d 15 3c b2 00 00 	lea    0xb23c(%rip),%rdx        # 418e3f <.LC17>
  40dc03:	48 8d 3d e6 99 00 00 	lea    0x99e6(%rip),%rdi        # 4175f0 <.LC12>
  40dc0a:	be 42 01 00 00       	mov    $0x142,%esi
  40dc0f:	e8 dc 77 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  va_list args;
  va_start(args, format);
  VSNPrintf(data() + length_, size() - length_, format, args);
  va_end(args);
  length_ += internal_strlen(data() + length_);
  CHECK_LT(length_, size());
  40dc14:	48 8d 15 24 b2 00 00 	lea    0xb224(%rip),%rdx        # 418e3f <.LC17>
  40dc1b:	48 8d 3d ce 99 00 00 	lea    0x99ce(%rip),%rdi        # 4175f0 <.LC12>
  40dc22:	48 89 c1             	mov    %rax,%rcx
  40dc25:	be 48 01 00 00       	mov    $0x148,%esi
  40dc2a:	e8 c1 77 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40dc2f:	90                   	nop

000000000040dc30 <_ZN11__sanitizer9IsDecimalEc>:
// Linker initialized.
ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;
StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.

static int TranslateDigit(char c) {
  if (c >= '0' && c <= '9')
  40dc30:	83 ef 30             	sub    $0x30,%edi
    return c - '0';
  if (c >= 'a' && c <= 'f')
  40dc33:	40 80 ff 0a          	cmp    $0xa,%dil
  40dc37:	0f 92 c0             	setb   %al
}

bool IsDecimal(char c) {
  int d = TranslateDigit(c);
  return d >= 0 && d < 10;
}
  40dc3a:	c3                   	retq   
  40dc3b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000040dc40 <_ZN11__sanitizer12ParseDecimalEPPKc>:

uptr ParseDecimal(const char **p) {
  40dc40:	48 8b 17             	mov    (%rdi),%rdx
  40dc43:	31 c0                	xor    %eax,%eax
// Parse a number and promote 'p' up to the first non-digit character.
static uptr ParseNumber(const char **p, int base) {
  uptr n = 0;
  int d;
  CHECK(base >= 2 && base <= 16);
  while ((d = TranslateDigit(**p)) >= 0 && d < base) {
  40dc45:	0f be 0a             	movsbl (%rdx),%ecx
// Linker initialized.
ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;
StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.

static int TranslateDigit(char c) {
  if (c >= '0' && c <= '9')
  40dc48:	8d 71 d0             	lea    -0x30(%rcx),%esi
  40dc4b:	40 80 fe 09          	cmp    $0x9,%sil
  40dc4f:	77 28                	ja     40dc79 <_ZN11__sanitizer12ParseDecimalEPPKc+0x39>
  40dc51:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    return c - '0';
  40dc58:	83 e9 30             	sub    $0x30,%ecx
static uptr ParseNumber(const char **p, int base) {
  uptr n = 0;
  int d;
  CHECK(base >= 2 && base <= 16);
  while ((d = TranslateDigit(**p)) >= 0 && d < base) {
    n = n * base + d;
  40dc5b:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
  40dc5f:	48 83 c2 01          	add    $0x1,%rdx
  40dc63:	48 63 c9             	movslq %ecx,%rcx
    (*p)++;
  40dc66:	48 89 17             	mov    %rdx,(%rdi)
static uptr ParseNumber(const char **p, int base) {
  uptr n = 0;
  int d;
  CHECK(base >= 2 && base <= 16);
  while ((d = TranslateDigit(**p)) >= 0 && d < base) {
    n = n * base + d;
  40dc69:	48 8d 04 41          	lea    (%rcx,%rax,2),%rax
// Parse a number and promote 'p' up to the first non-digit character.
static uptr ParseNumber(const char **p, int base) {
  uptr n = 0;
  int d;
  CHECK(base >= 2 && base <= 16);
  while ((d = TranslateDigit(**p)) >= 0 && d < base) {
  40dc6d:	0f be 0a             	movsbl (%rdx),%ecx
// Linker initialized.
ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;
StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.

static int TranslateDigit(char c) {
  if (c >= '0' && c <= '9')
  40dc70:	8d 71 d0             	lea    -0x30(%rcx),%esi
  40dc73:	40 80 fe 09          	cmp    $0x9,%sil
  40dc77:	76 df                	jbe    40dc58 <_ZN11__sanitizer12ParseDecimalEPPKc+0x18>
  return d >= 0 && d < 10;
}

uptr ParseDecimal(const char **p) {
  return ParseNumber(p, 10);
}
  40dc79:	f3 c3                	repz retq 
  40dc7b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000040dc80 <_ZN11__sanitizer5IsHexEc>:
// Linker initialized.
ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;
StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.

static int TranslateDigit(char c) {
  if (c >= '0' && c <= '9')
  40dc80:	8d 57 d0             	lea    -0x30(%rdi),%edx
  40dc83:	b8 01 00 00 00       	mov    $0x1,%eax
  40dc88:	80 fa 09             	cmp    $0x9,%dl
  40dc8b:	76 12                	jbe    40dc9f <_ZN11__sanitizer5IsHexEc+0x1f>
    return c - '0';
  if (c >= 'a' && c <= 'f')
  40dc8d:	8d 57 9f             	lea    -0x61(%rdi),%edx
  40dc90:	80 fa 05             	cmp    $0x5,%dl
  40dc93:	76 0a                	jbe    40dc9f <_ZN11__sanitizer5IsHexEc+0x1f>
    return c - 'a' + 10;
  if (c >= 'A' && c <= 'F')
  40dc95:	83 ef 41             	sub    $0x41,%edi
  40dc98:	40 80 ff 05          	cmp    $0x5,%dil
  40dc9c:	0f 96 c0             	setbe  %al
}

bool IsHex(char c) {
  int d = TranslateDigit(c);
  return d >= 0 && d < 16;
}
  40dc9f:	f3 c3                	repz retq 
  40dca1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40dca8:	0f 1f 84 00 00 00 00 
  40dcaf:	00 

000000000040dcb0 <_ZN11__sanitizer8ParseHexEPPKc>:

uptr ParseHex(const char **p) {
  40dcb0:	48 8b 17             	mov    (%rdi),%rdx
  40dcb3:	31 c0                	xor    %eax,%eax
  40dcb5:	eb 1d                	jmp    40dcd4 <_ZN11__sanitizer8ParseHexEPPKc+0x24>
  40dcb7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40dcbe:	00 00 
ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;
StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.

static int TranslateDigit(char c) {
  if (c >= '0' && c <= '9')
    return c - '0';
  40dcc0:	83 e9 30             	sub    $0x30,%ecx
static uptr ParseNumber(const char **p, int base) {
  uptr n = 0;
  int d;
  CHECK(base >= 2 && base <= 16);
  while ((d = TranslateDigit(**p)) >= 0 && d < base) {
    n = n * base + d;
  40dcc3:	48 c1 e0 04          	shl    $0x4,%rax
  40dcc7:	48 63 c9             	movslq %ecx,%rcx
    (*p)++;
  40dcca:	48 83 c2 01          	add    $0x1,%rdx
static uptr ParseNumber(const char **p, int base) {
  uptr n = 0;
  int d;
  CHECK(base >= 2 && base <= 16);
  while ((d = TranslateDigit(**p)) >= 0 && d < base) {
    n = n * base + d;
  40dcce:	48 01 c8             	add    %rcx,%rax
    (*p)++;
  40dcd1:	48 89 17             	mov    %rdx,(%rdi)
// Parse a number and promote 'p' up to the first non-digit character.
static uptr ParseNumber(const char **p, int base) {
  uptr n = 0;
  int d;
  CHECK(base >= 2 && base <= 16);
  while ((d = TranslateDigit(**p)) >= 0 && d < base) {
  40dcd4:	0f be 0a             	movsbl (%rdx),%ecx
// Linker initialized.
ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;
StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.

static int TranslateDigit(char c) {
  if (c >= '0' && c <= '9')
  40dcd7:	8d 71 d0             	lea    -0x30(%rcx),%esi
  40dcda:	40 80 fe 09          	cmp    $0x9,%sil
  40dcde:	76 e0                	jbe    40dcc0 <_ZN11__sanitizer8ParseHexEPPKc+0x10>
    return c - '0';
  if (c >= 'a' && c <= 'f')
  40dce0:	8d 71 9f             	lea    -0x61(%rcx),%esi
  40dce3:	40 80 fe 05          	cmp    $0x5,%sil
  40dce7:	77 07                	ja     40dcf0 <_ZN11__sanitizer8ParseHexEPPKc+0x40>
    return c - 'a' + 10;
  40dce9:	83 e9 57             	sub    $0x57,%ecx
  40dcec:	eb d5                	jmp    40dcc3 <_ZN11__sanitizer8ParseHexEPPKc+0x13>
  40dcee:	66 90                	xchg   %ax,%ax
  if (c >= 'A' && c <= 'F')
  40dcf0:	8d 71 bf             	lea    -0x41(%rcx),%esi
  40dcf3:	40 80 fe 05          	cmp    $0x5,%sil
  40dcf7:	77 07                	ja     40dd00 <_ZN11__sanitizer8ParseHexEPPKc+0x50>
    return c - 'A' + 10;
  40dcf9:	83 e9 37             	sub    $0x37,%ecx
  40dcfc:	eb c5                	jmp    40dcc3 <_ZN11__sanitizer8ParseHexEPPKc+0x13>
  40dcfe:	66 90                	xchg   %ax,%ax
  return d >= 0 && d < 16;
}

uptr ParseHex(const char **p) {
  return ParseNumber(p, 16);
}
  40dd00:	f3 c3                	repz retq 
  40dd02:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40dd09:	1f 84 00 00 00 00 00 

000000000040dd10 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb>:

MemoryMappingLayout::MemoryMappingLayout(bool cache_enabled) {
  40dd10:	41 54                	push   %r12
  40dd12:	55                   	push   %rbp
  40dd13:	89 f5                	mov    %esi,%ebp
  40dd15:	53                   	push   %rbx
  40dd16:	48 89 fb             	mov    %rdi,%rbx
  ReadProcMaps(&proc_self_maps_);
  40dd19:	e8 f2 06 00 00       	callq  40e410 <_ZN11__sanitizer12ReadProcMapsEPNS_16ProcSelfMapsBuffE>
  if (cache_enabled) {
  40dd1e:	40 84 ed             	test   %bpl,%bpl
  40dd21:	74 6d                	je     40dd90 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb+0x80>
    if (proc_self_maps_.mmaped_size == 0) {
  40dd23:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
  40dd28:	0f 84 82 00 00 00    	je     40ddb0 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb+0xa0>
    UnmapOrDie(proc_self_maps_.data, proc_self_maps_.mmaped_size);
  }
}

void MemoryMappingLayout::Reset() {
  current_ = proc_self_maps_.data;
  40dd2e:	48 8b 03             	mov    (%rbx),%rax
  40dd31:	48 89 43 18          	mov    %rax,0x18(%rbx)
  40dd35:	b8 01 00 00 00       	mov    $0x1,%eax
  40dd3a:	86 05 a9 3c 26 00    	xchg   %al,0x263ca9(%rip)        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  40dd40:	84 c0                	test   %al,%al
  40dd42:	0f 85 20 01 00 00    	jne    40de68 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb+0x158>
void MemoryMappingLayout::CacheMemoryMappings() {
  SpinMutexLock l(&cache_lock_);
  // Don't invalidate the cache if the mappings are unavailable.
  ProcSelfMapsBuff old_proc_self_maps;
  old_proc_self_maps = cached_proc_self_maps_;
  ReadProcMaps(&cached_proc_self_maps_);
  40dd48:	48 8d 3d a1 3c 26 00 	lea    0x263ca1(%rip),%rdi        # 6719f0 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E>
// static
void MemoryMappingLayout::CacheMemoryMappings() {
  SpinMutexLock l(&cache_lock_);
  // Don't invalidate the cache if the mappings are unavailable.
  ProcSelfMapsBuff old_proc_self_maps;
  old_proc_self_maps = cached_proc_self_maps_;
  40dd4f:	48 8b 2d 9a 3c 26 00 	mov    0x263c9a(%rip),%rbp        # 6719f0 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E>
  40dd56:	48 8b 1d 9b 3c 26 00 	mov    0x263c9b(%rip),%rbx        # 6719f8 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E+0x8>
  40dd5d:	4c 8b 25 9c 3c 26 00 	mov    0x263c9c(%rip),%r12        # 671a00 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E+0x10>
  ReadProcMaps(&cached_proc_self_maps_);
  40dd64:	e8 a7 06 00 00       	callq  40e410 <_ZN11__sanitizer12ReadProcMapsEPNS_16ProcSelfMapsBuffE>
  if (cached_proc_self_maps_.mmaped_size == 0) {
  40dd69:	48 83 3d 87 3c 26 00 	cmpq   $0x0,0x263c87(%rip)        # 6719f8 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E+0x8>
  40dd70:	00 
  40dd71:	0f 84 c9 00 00 00    	je     40de40 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb+0x130>
    cached_proc_self_maps_ = old_proc_self_maps;
  } else {
    if (old_proc_self_maps.mmaped_size) {
  40dd77:	48 85 db             	test   %rbx,%rbx
  40dd7a:	0f 85 a8 00 00 00    	jne    40de28 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb+0x118>
  40dd80:	c6 05 62 3c 26 00 00 	movb   $0x0,0x263c62(%rip)        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
  }
  Reset();
  // FIXME: in the future we may want to cache the mappings on demand only.
  if (cache_enabled)
    CacheMemoryMappings();
}
  40dd87:	5b                   	pop    %rbx
  40dd88:	5d                   	pop    %rbp
  40dd89:	41 5c                	pop    %r12
  40dd8b:	c3                   	retq   
  40dd8c:	0f 1f 40 00          	nopl   0x0(%rax)
    if (proc_self_maps_.mmaped_size == 0) {
      LoadFromCache();
      CHECK_GT(proc_self_maps_.len, 0);
    }
  } else {
    CHECK_GT(proc_self_maps_.mmaped_size, 0);
  40dd90:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
  40dd95:	0f 84 de 00 00 00    	je     40de79 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb+0x169>
    UnmapOrDie(proc_self_maps_.data, proc_self_maps_.mmaped_size);
  }
}

void MemoryMappingLayout::Reset() {
  current_ = proc_self_maps_.data;
  40dd9b:	48 8b 03             	mov    (%rbx),%rax
  40dd9e:	48 89 43 18          	mov    %rax,0x18(%rbx)
  }
  Reset();
  // FIXME: in the future we may want to cache the mappings on demand only.
  if (cache_enabled)
    CacheMemoryMappings();
}
  40dda2:	5b                   	pop    %rbx
  40dda3:	5d                   	pop    %rbp
  40dda4:	41 5c                	pop    %r12
  40dda6:	c3                   	retq   
  40dda7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40ddae:	00 00 
  40ddb0:	b8 01 00 00 00       	mov    $0x1,%eax
  40ddb5:	86 05 2e 3c 26 00    	xchg   %al,0x263c2e(%rip)        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
  40ddbb:	84 c0                	test   %al,%al
  40ddbd:	74 0c                	je     40ddcb <_ZN11__sanitizer19MemoryMappingLayoutC1Eb+0xbb>
      return;
    LockSlow();
  40ddbf:	48 8d 3d 23 3c 26 00 	lea    0x263c23(%rip),%rdi        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
  40ddc6:	e8 85 67 ff ff       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  }
}

void MemoryMappingLayout::LoadFromCache() {
  SpinMutexLock l(&cache_lock_);
  if (cached_proc_self_maps_.data) {
  40ddcb:	48 83 3d 1d 3c 26 00 	cmpq   $0x0,0x263c1d(%rip)        # 6719f0 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E>
  40ddd2:	00 
  40ddd3:	74 20                	je     40ddf5 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb+0xe5>
    proc_self_maps_ = cached_proc_self_maps_;
  40ddd5:	48 8b 05 14 3c 26 00 	mov    0x263c14(%rip),%rax        # 6719f0 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E>
  40dddc:	48 89 03             	mov    %rax,(%rbx)
  40dddf:	48 8b 05 12 3c 26 00 	mov    0x263c12(%rip),%rax        # 6719f8 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E+0x8>
  40dde6:	48 89 43 08          	mov    %rax,0x8(%rbx)
  40ddea:	48 8b 05 0f 3c 26 00 	mov    0x263c0f(%rip),%rax        # 671a00 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E+0x10>
  40ddf1:	48 89 43 10          	mov    %rax,0x10(%rbx)
  40ddf5:	c6 05 ed 3b 26 00 00 	movb   $0x0,0x263bed(%rip)        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
MemoryMappingLayout::MemoryMappingLayout(bool cache_enabled) {
  ReadProcMaps(&proc_self_maps_);
  if (cache_enabled) {
    if (proc_self_maps_.mmaped_size == 0) {
      LoadFromCache();
      CHECK_GT(proc_self_maps_.len, 0);
  40ddfc:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  40de01:	0f 85 27 ff ff ff    	jne    40dd2e <_ZN11__sanitizer19MemoryMappingLayoutC1Eb+0x1e>
  40de07:	48 8d 15 72 98 00 00 	lea    0x9872(%rip),%rdx        # 417680 <.LC0>
  40de0e:	48 8d 3d 8b 98 00 00 	lea    0x988b(%rip),%rdi        # 4176a0 <.LC1>
  40de15:	45 31 c0             	xor    %r8d,%r8d
  40de18:	31 c9                	xor    %ecx,%ecx
  40de1a:	be 48 00 00 00       	mov    $0x48,%esi
  40de1f:	e8 cc 75 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40de24:	0f 1f 40 00          	nopl   0x0(%rax)
  if (cached_proc_self_maps_.mmaped_size == 0) {
    cached_proc_self_maps_ = old_proc_self_maps;
  } else {
    if (old_proc_self_maps.mmaped_size) {
      UnmapOrDie(old_proc_self_maps.data,
                 old_proc_self_maps.mmaped_size);
  40de28:	48 89 de             	mov    %rbx,%rsi
  40de2b:	48 89 ef             	mov    %rbp,%rdi
  40de2e:	e8 0d e6 ff ff       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  40de33:	e9 48 ff ff ff       	jmpq   40dd80 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb+0x70>
  40de38:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40de3f:	00 
  // Don't invalidate the cache if the mappings are unavailable.
  ProcSelfMapsBuff old_proc_self_maps;
  old_proc_self_maps = cached_proc_self_maps_;
  ReadProcMaps(&cached_proc_self_maps_);
  if (cached_proc_self_maps_.mmaped_size == 0) {
    cached_proc_self_maps_ = old_proc_self_maps;
  40de40:	48 89 2d a9 3b 26 00 	mov    %rbp,0x263ba9(%rip)        # 6719f0 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E>
  40de47:	48 89 1d aa 3b 26 00 	mov    %rbx,0x263baa(%rip)        # 6719f8 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E+0x8>
  40de4e:	4c 89 25 ab 3b 26 00 	mov    %r12,0x263bab(%rip)        # 671a00 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E+0x10>
  40de55:	c6 05 8d 3b 26 00 00 	movb   $0x0,0x263b8d(%rip)        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
      __asm__ __volatile__("" ::: "memory");
  40de5c:	e9 26 ff ff ff       	jmpq   40dd87 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb+0x77>
  40de61:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40de68:	48 8d 3d 7a 3b 26 00 	lea    0x263b7a(%rip),%rdi        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
  40de6f:	e8 dc 66 ff ff       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  40de74:	e9 cf fe ff ff       	jmpq   40dd48 <_ZN11__sanitizer19MemoryMappingLayoutC1Eb+0x38>
    if (proc_self_maps_.mmaped_size == 0) {
      LoadFromCache();
      CHECK_GT(proc_self_maps_.len, 0);
    }
  } else {
    CHECK_GT(proc_self_maps_.mmaped_size, 0);
  40de79:	48 8d 15 98 98 00 00 	lea    0x9898(%rip),%rdx        # 417718 <.LC2>
  40de80:	48 8d 3d 19 98 00 00 	lea    0x9819(%rip),%rdi        # 4176a0 <.LC1>
  40de87:	45 31 c0             	xor    %r8d,%r8d
  40de8a:	31 c9                	xor    %ecx,%ecx
  40de8c:	be 4b 00 00 00       	mov    $0x4b,%esi
  40de91:	e8 5a 75 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40de96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40de9d:	00 00 00 

000000000040dea0 <_ZN11__sanitizer19MemoryMappingLayoutD1Ev>:
}

MemoryMappingLayout::~MemoryMappingLayout() {
  // Only unmap the buffer if it is different from the cached one. Otherwise
  // it will be unmapped when the cache is refreshed.
  if (proc_self_maps_.data != cached_proc_self_maps_.data) {
  40dea0:	48 8b 07             	mov    (%rdi),%rax
  40dea3:	48 3b 05 46 3b 26 00 	cmp    0x263b46(%rip),%rax        # 6719f0 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E>
  40deaa:	74 14                	je     40dec0 <_ZN11__sanitizer19MemoryMappingLayoutD1Ev+0x20>
    UnmapOrDie(proc_self_maps_.data, proc_self_maps_.mmaped_size);
  40deac:	48 8b 77 08          	mov    0x8(%rdi),%rsi
  40deb0:	48 89 c7             	mov    %rax,%rdi
  40deb3:	e9 88 e5 ff ff       	jmpq   40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  40deb8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40debf:	00 
  40dec0:	f3 c3                	repz retq 
  40dec2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40dec9:	1f 84 00 00 00 00 00 

000000000040ded0 <_ZN11__sanitizer19MemoryMappingLayout5ResetEv>:
  }
}

void MemoryMappingLayout::Reset() {
  current_ = proc_self_maps_.data;
  40ded0:	48 8b 07             	mov    (%rdi),%rax
  40ded3:	48 89 47 18          	mov    %rax,0x18(%rdi)
  40ded7:	c3                   	retq   
  40ded8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40dedf:	00 

000000000040dee0 <_ZN11__sanitizer19MemoryMappingLayout19CacheMemoryMappingsEv>:
}

// static
void MemoryMappingLayout::CacheMemoryMappings() {
  40dee0:	41 54                	push   %r12
  40dee2:	b8 01 00 00 00       	mov    $0x1,%eax
  40dee7:	55                   	push   %rbp
  40dee8:	53                   	push   %rbx
  40dee9:	86 05 fa 3a 26 00    	xchg   %al,0x263afa(%rip)        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  40deef:	84 c0                	test   %al,%al
  40def1:	74 0c                	je     40deff <_ZN11__sanitizer19MemoryMappingLayout19CacheMemoryMappingsEv+0x1f>
      return;
    LockSlow();
  40def3:	48 8d 3d ef 3a 26 00 	lea    0x263aef(%rip),%rdi        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
  40defa:	e8 51 66 ff ff       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  SpinMutexLock l(&cache_lock_);
  // Don't invalidate the cache if the mappings are unavailable.
  ProcSelfMapsBuff old_proc_self_maps;
  old_proc_self_maps = cached_proc_self_maps_;
  ReadProcMaps(&cached_proc_self_maps_);
  40deff:	48 8d 3d ea 3a 26 00 	lea    0x263aea(%rip),%rdi        # 6719f0 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E>
// static
void MemoryMappingLayout::CacheMemoryMappings() {
  SpinMutexLock l(&cache_lock_);
  // Don't invalidate the cache if the mappings are unavailable.
  ProcSelfMapsBuff old_proc_self_maps;
  old_proc_self_maps = cached_proc_self_maps_;
  40df06:	48 8b 2d e3 3a 26 00 	mov    0x263ae3(%rip),%rbp        # 6719f0 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E>
  40df0d:	48 8b 1d e4 3a 26 00 	mov    0x263ae4(%rip),%rbx        # 6719f8 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E+0x8>
  40df14:	4c 8b 25 e5 3a 26 00 	mov    0x263ae5(%rip),%r12        # 671a00 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E+0x10>
  ReadProcMaps(&cached_proc_self_maps_);
  40df1b:	e8 f0 04 00 00       	callq  40e410 <_ZN11__sanitizer12ReadProcMapsEPNS_16ProcSelfMapsBuffE>
  if (cached_proc_self_maps_.mmaped_size == 0) {
  40df20:	48 83 3d d0 3a 26 00 	cmpq   $0x0,0x263ad0(%rip)        # 6719f8 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E+0x8>
  40df27:	00 
  40df28:	74 36                	je     40df60 <_ZN11__sanitizer19MemoryMappingLayout19CacheMemoryMappingsEv+0x80>
    cached_proc_self_maps_ = old_proc_self_maps;
  } else {
    if (old_proc_self_maps.mmaped_size) {
  40df2a:	48 85 db             	test   %rbx,%rbx
  40df2d:	75 11                	jne    40df40 <_ZN11__sanitizer19MemoryMappingLayout19CacheMemoryMappingsEv+0x60>
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  40df2f:	c6 05 b3 3a 26 00 00 	movb   $0x0,0x263ab3(%rip)        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
      UnmapOrDie(old_proc_self_maps.data,
                 old_proc_self_maps.mmaped_size);
    }
  }
}
  40df36:	5b                   	pop    %rbx
  40df37:	5d                   	pop    %rbp
  40df38:	41 5c                	pop    %r12
  40df3a:	c3                   	retq   
  40df3b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  if (cached_proc_self_maps_.mmaped_size == 0) {
    cached_proc_self_maps_ = old_proc_self_maps;
  } else {
    if (old_proc_self_maps.mmaped_size) {
      UnmapOrDie(old_proc_self_maps.data,
                 old_proc_self_maps.mmaped_size);
  40df40:	48 89 de             	mov    %rbx,%rsi
  40df43:	48 89 ef             	mov    %rbp,%rdi
  40df46:	e8 f5 e4 ff ff       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  40df4b:	c6 05 97 3a 26 00 00 	movb   $0x0,0x263a97(%rip)        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
    }
  }
}
  40df52:	5b                   	pop    %rbx
  40df53:	5d                   	pop    %rbp
  40df54:	41 5c                	pop    %r12
  40df56:	c3                   	retq   
  40df57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40df5e:	00 00 
  // Don't invalidate the cache if the mappings are unavailable.
  ProcSelfMapsBuff old_proc_self_maps;
  old_proc_self_maps = cached_proc_self_maps_;
  ReadProcMaps(&cached_proc_self_maps_);
  if (cached_proc_self_maps_.mmaped_size == 0) {
    cached_proc_self_maps_ = old_proc_self_maps;
  40df60:	48 89 2d 89 3a 26 00 	mov    %rbp,0x263a89(%rip)        # 6719f0 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E>
  40df67:	48 89 1d 8a 3a 26 00 	mov    %rbx,0x263a8a(%rip)        # 6719f8 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E+0x8>
  40df6e:	4c 89 25 8b 3a 26 00 	mov    %r12,0x263a8b(%rip)        # 671a00 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E+0x10>
  40df75:	c6 05 6d 3a 26 00 00 	movb   $0x0,0x263a6d(%rip)        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
    if (old_proc_self_maps.mmaped_size) {
      UnmapOrDie(old_proc_self_maps.data,
                 old_proc_self_maps.mmaped_size);
    }
  }
}
  40df7c:	5b                   	pop    %rbx
  40df7d:	5d                   	pop    %rbp
  40df7e:	41 5c                	pop    %r12
  40df80:	c3                   	retq   
  40df81:	90                   	nop
  40df82:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40df89:	1f 84 00 00 00 00 00 

000000000040df90 <_ZN11__sanitizer19MemoryMappingLayout13LoadFromCacheEv>:

void MemoryMappingLayout::LoadFromCache() {
  40df90:	53                   	push   %rbx
  40df91:	b8 01 00 00 00       	mov    $0x1,%eax
  40df96:	48 89 fb             	mov    %rdi,%rbx
  40df99:	86 05 4a 3a 26 00    	xchg   %al,0x263a4a(%rip)        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  40df9f:	84 c0                	test   %al,%al
  40dfa1:	74 0c                	je     40dfaf <_ZN11__sanitizer19MemoryMappingLayout13LoadFromCacheEv+0x1f>
      return;
    LockSlow();
  40dfa3:	48 8d 3d 3f 3a 26 00 	lea    0x263a3f(%rip),%rdi        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
  40dfaa:	e8 a1 65 ff ff       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  SpinMutexLock l(&cache_lock_);
  if (cached_proc_self_maps_.data) {
  40dfaf:	48 83 3d 39 3a 26 00 	cmpq   $0x0,0x263a39(%rip)        # 6719f0 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E>
  40dfb6:	00 
  40dfb7:	74 20                	je     40dfd9 <_ZN11__sanitizer19MemoryMappingLayout13LoadFromCacheEv+0x49>
    proc_self_maps_ = cached_proc_self_maps_;
  40dfb9:	48 8b 05 30 3a 26 00 	mov    0x263a30(%rip),%rax        # 6719f0 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E>
  40dfc0:	48 89 03             	mov    %rax,(%rbx)
  40dfc3:	48 8b 05 2e 3a 26 00 	mov    0x263a2e(%rip),%rax        # 6719f8 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E+0x8>
  40dfca:	48 89 43 08          	mov    %rax,0x8(%rbx)
  40dfce:	48 8b 05 2b 3a 26 00 	mov    0x263a2b(%rip),%rax        # 671a00 <_ZN11__sanitizer19MemoryMappingLayout22cached_proc_self_maps_E+0x10>
  40dfd5:	48 89 43 10          	mov    %rax,0x10(%rbx)
  40dfd9:	c6 05 09 3a 26 00 00 	movb   $0x0,0x263a09(%rip)        # 6719e9 <_ZN11__sanitizer19MemoryMappingLayout11cache_lock_E>
  }
}
  40dfe0:	5b                   	pop    %rbx
  40dfe1:	c3                   	retq   
  40dfe2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40dfe9:	1f 84 00 00 00 00 00 

000000000040dff0 <_ZN11__sanitizer19MemoryMappingLayout17DumpListOfModulesEPNS_12LoadedModuleEmPFbPKcE>:

uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,
                                            uptr max_modules,
                                            string_predicate_t filter) {
  40dff0:	41 57                	push   %r15
  40dff2:	41 56                	push   %r14
  40dff4:	49 89 ce             	mov    %rcx,%r14
  40dff7:	41 55                	push   %r13
  40dff9:	41 54                	push   %r12
  40dffb:	49 89 fc             	mov    %rdi,%r12
  40dffe:	55                   	push   %rbp
  40dfff:	48 89 d5             	mov    %rdx,%rbp
  40e002:	53                   	push   %rbx
  Reset();
  uptr cur_beg, cur_end, cur_offset, prot;
  InternalScopedString module_name(kMaxPathLength);
  uptr n_modules = 0;
  40e003:	31 db                	xor    %ebx,%ebx
  }
}

uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,
                                            uptr max_modules,
                                            string_predicate_t filter) {
  40e005:	48 83 ec 78          	sub    $0x78,%rsp
    UnmapOrDie(proc_self_maps_.data, proc_self_maps_.mmaped_size);
  }
}

void MemoryMappingLayout::Reset() {
  current_ = proc_self_maps_.data;
  40e009:	48 8b 07             	mov    (%rdi),%rax
  }
}

uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,
                                            uptr max_modules,
                                            string_predicate_t filter) {
  40e00c:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  40e011:	48 8d 35 61 a5 00 00 	lea    0xa561(%rip),%rsi        # 418579 <.LC1>
    UnmapOrDie(proc_self_maps_.data, proc_self_maps_.mmaped_size);
  }
}

void MemoryMappingLayout::Reset() {
  current_ = proc_self_maps_.data;
  40e018:	48 89 47 18          	mov    %rax,0x18(%rdi)
  40e01c:	bf 00 10 00 00       	mov    $0x1000,%edi
  40e021:	e8 7a e3 ff ff       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
                                            string_predicate_t filter) {
  Reset();
  uptr cur_beg, cur_end, cur_offset, prot;
  InternalScopedString module_name(kMaxPathLength);
  uptr n_modules = 0;
  for (uptr i = 0; n_modules < max_modules &&
  40e026:	48 85 ed             	test   %rbp,%rbp
  40e029:	49 89 c7             	mov    %rax,%r15

class InternalScopedString : public InternalScopedBuffer<char> {
 public:
  explicit InternalScopedString(uptr max_length)
      : InternalScopedBuffer<char>(max_length), length_(0) {
    (*this)[0] = '\0';
  40e02c:	c6 00 00             	movb   $0x0,(%rax)
  40e02f:	75 2f                	jne    40e060 <_ZN11__sanitizer19MemoryMappingLayout17DumpListOfModulesEPNS_12LoadedModuleEmPFbPKcE+0x70>
  40e031:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  }
  ~InternalScopedBuffer() {
    UnmapOrDie(ptr_, cnt_ * sizeof(T));
  40e038:	4c 89 ff             	mov    %r15,%rdi
  40e03b:	be 00 10 00 00       	mov    $0x1000,%esi
  40e040:	e8 fb e3 ff ff       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
    cur_module->set(cur_name, base_address);
    cur_module->addAddressRange(cur_beg, cur_end, prot & kProtectionExecute);
    n_modules++;
  }
  return n_modules;
}
  40e045:	48 83 c4 78          	add    $0x78,%rsp
  40e049:	48 89 d8             	mov    %rbx,%rax
  40e04c:	5b                   	pop    %rbx
  40e04d:	5d                   	pop    %rbp
  40e04e:	41 5c                	pop    %r12
  40e050:	41 5d                	pop    %r13
  40e052:	41 5e                	pop    %r14
  40e054:	41 5f                	pop    %r15
  40e056:	c3                   	retq   
  40e057:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40e05e:	00 00 
  40e060:	4d 85 f6             	test   %r14,%r14
  40e063:	0f 84 d6 00 00 00    	je     40e13f <_ZN11__sanitizer19MemoryMappingLayout17DumpListOfModulesEPNS_12LoadedModuleEmPFbPKcE+0x14f>
  40e069:	48 8d 44 24 50       	lea    0x50(%rsp),%rax
  40e06e:	4c 89 64 24 38       	mov    %r12,0x38(%rsp)
  40e073:	49 89 dc             	mov    %rbx,%r12
  40e076:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  40e07b:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
  40e080:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  40e085:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
  40e08a:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40e08f:	48 8d 44 24 68       	lea    0x68(%rsp),%rax
  40e094:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  40e099:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  uptr cur_beg, cur_end, cur_offset, prot;
  InternalScopedString module_name(kMaxPathLength);
  uptr n_modules = 0;
  for (uptr i = 0; n_modules < max_modules &&
                       Next(&cur_beg, &cur_end, &cur_offset, module_name.data(),
                            module_name.size(), &prot);
  40e0a0:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  40e0a5:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  40e0aa:	41 b9 00 10 00 00    	mov    $0x1000,%r9d
  40e0b0:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
  40e0b5:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40e0ba:	4d 89 f8             	mov    %r15,%r8
  40e0bd:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
  40e0c2:	48 89 04 24          	mov    %rax,(%rsp)
  40e0c6:	e8 95 03 00 00       	callq  40e460 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_>
                                            string_predicate_t filter) {
  Reset();
  uptr cur_beg, cur_end, cur_offset, prot;
  InternalScopedString module_name(kMaxPathLength);
  uptr n_modules = 0;
  for (uptr i = 0; n_modules < max_modules &&
  40e0cb:	84 c0                	test   %al,%al
  40e0cd:	74 68                	je     40e137 <_ZN11__sanitizer19MemoryMappingLayout17DumpListOfModulesEPNS_12LoadedModuleEmPFbPKcE+0x147>
                       Next(&cur_beg, &cur_end, &cur_offset, module_name.data(),
                            module_name.size(), &prot);
       i++) {
    const char *cur_name = module_name.data();
    if (cur_name[0] == '\0')
  40e0cf:	41 80 3f 00          	cmpb   $0x0,(%r15)
  40e0d3:	74 55                	je     40e12a <_ZN11__sanitizer19MemoryMappingLayout17DumpListOfModulesEPNS_12LoadedModuleEmPFbPKcE+0x13a>
      continue;
    if (filter && !filter(cur_name))
  40e0d5:	4c 89 ff             	mov    %r15,%rdi
  40e0d8:	41 ff d6             	callq  *%r14
  40e0db:	84 c0                	test   %al,%al
  40e0dd:	74 4b                	je     40e12a <_ZN11__sanitizer19MemoryMappingLayout17DumpListOfModulesEPNS_12LoadedModuleEmPFbPKcE+0x13a>
    //   is mapped to a fixed memory range).
    // * If a binary is compiled with -pie, all the modules are
    //   mapped high at address space (in particular, higher than
    //   shadow memory of the tool), so the module can't be the
    //   first entry.
    uptr base_address = (i ? cur_beg : 0) - cur_offset;
  40e0df:	31 d2                	xor    %edx,%edx
  40e0e1:	48 85 db             	test   %rbx,%rbx
  40e0e4:	74 05                	je     40e0eb <_ZN11__sanitizer19MemoryMappingLayout17DumpListOfModulesEPNS_12LoadedModuleEmPFbPKcE+0xfb>
  40e0e6:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
    LoadedModule *cur_module = &modules[n_modules];
  40e0eb:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
  40e0f0:	4b 8d 04 a4          	lea    (%r12,%r12,4),%rax
    //   is mapped to a fixed memory range).
    // * If a binary is compiled with -pie, all the modules are
    //   mapped high at address space (in particular, higher than
    //   shadow memory of the tool), so the module can't be the
    //   first entry.
    uptr base_address = (i ? cur_beg : 0) - cur_offset;
  40e0f4:	48 2b 54 24 50       	sub    0x50(%rsp),%rdx
    LoadedModule *cur_module = &modules[n_modules];
    cur_module->set(cur_name, base_address);
    cur_module->addAddressRange(cur_beg, cur_end, prot & kProtectionExecute);
    n_modules++;
  40e0f9:	49 83 c4 01          	add    $0x1,%r12
    // * If a binary is compiled with -pie, all the modules are
    //   mapped high at address space (in particular, higher than
    //   shadow memory of the tool), so the module can't be the
    //   first entry.
    uptr base_address = (i ? cur_beg : 0) - cur_offset;
    LoadedModule *cur_module = &modules[n_modules];
  40e0fd:	4c 8d 2c c6          	lea    (%rsi,%rax,8),%r13
    cur_module->set(cur_name, base_address);
  40e101:	4c 89 fe             	mov    %r15,%rsi
  40e104:	4c 89 ef             	mov    %r13,%rdi
  40e107:	e8 a4 78 ff ff       	callq  4059b0 <_ZN11__sanitizer12LoadedModule3setEPKcm>
    cur_module->addAddressRange(cur_beg, cur_end, prot & kProtectionExecute);
  40e10c:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
  40e111:	48 8b 54 24 60       	mov    0x60(%rsp),%rdx
  40e116:	4c 89 ef             	mov    %r13,%rdi
  40e119:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  40e11e:	48 c1 e9 02          	shr    $0x2,%rcx
  40e122:	83 e1 01             	and    $0x1,%ecx
  40e125:	e8 66 79 ff ff       	callq  405a90 <_ZN11__sanitizer12LoadedModule15addAddressRangeEmmb>
                                            string_predicate_t filter) {
  Reset();
  uptr cur_beg, cur_end, cur_offset, prot;
  InternalScopedString module_name(kMaxPathLength);
  uptr n_modules = 0;
  for (uptr i = 0; n_modules < max_modules &&
  40e12a:	48 83 c3 01          	add    $0x1,%rbx
  40e12e:	49 39 ec             	cmp    %rbp,%r12
  40e131:	0f 82 69 ff ff ff    	jb     40e0a0 <_ZN11__sanitizer19MemoryMappingLayout17DumpListOfModulesEPNS_12LoadedModuleEmPFbPKcE+0xb0>
  40e137:	4c 89 e3             	mov    %r12,%rbx
  40e13a:	e9 f9 fe ff ff       	jmpq   40e038 <_ZN11__sanitizer19MemoryMappingLayout17DumpListOfModulesEPNS_12LoadedModuleEmPFbPKcE+0x48>
  40e13f:	48 8d 44 24 50       	lea    0x50(%rsp),%rax
  40e144:	45 31 f6             	xor    %r14d,%r14d
    //   is mapped to a fixed memory range).
    // * If a binary is compiled with -pie, all the modules are
    //   mapped high at address space (in particular, higher than
    //   shadow memory of the tool), so the module can't be the
    //   first entry.
    uptr base_address = (i ? cur_beg : 0) - cur_offset;
  40e147:	4c 89 64 24 38       	mov    %r12,0x38(%rsp)
  40e14c:	4c 8b 6c 24 30       	mov    0x30(%rsp),%r13
  40e151:	4c 89 e7             	mov    %r12,%rdi
  40e154:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  40e159:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
  40e15e:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  40e163:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
  40e168:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40e16d:	48 8d 44 24 68       	lea    0x68(%rsp),%rax
  40e172:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  40e177:	eb 0a                	jmp    40e183 <_ZN11__sanitizer19MemoryMappingLayout17DumpListOfModulesEPNS_12LoadedModuleEmPFbPKcE+0x193>
  40e179:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  40e17e:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
  uptr cur_beg, cur_end, cur_offset, prot;
  InternalScopedString module_name(kMaxPathLength);
  uptr n_modules = 0;
  for (uptr i = 0; n_modules < max_modules &&
                       Next(&cur_beg, &cur_end, &cur_offset, module_name.data(),
                            module_name.size(), &prot);
  40e183:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  40e188:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
  40e18d:	41 b9 00 10 00 00    	mov    $0x1000,%r9d
  40e193:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40e198:	48 89 04 24          	mov    %rax,(%rsp)
  40e19c:	4d 89 f8             	mov    %r15,%r8
  40e19f:	e8 bc 02 00 00       	callq  40e460 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_>
                                            string_predicate_t filter) {
  Reset();
  uptr cur_beg, cur_end, cur_offset, prot;
  InternalScopedString module_name(kMaxPathLength);
  uptr n_modules = 0;
  for (uptr i = 0; n_modules < max_modules &&
  40e1a4:	84 c0                	test   %al,%al
  40e1a6:	0f 84 8c fe ff ff    	je     40e038 <_ZN11__sanitizer19MemoryMappingLayout17DumpListOfModulesEPNS_12LoadedModuleEmPFbPKcE+0x48>
                       Next(&cur_beg, &cur_end, &cur_offset, module_name.data(),
                            module_name.size(), &prot);
       i++) {
    const char *cur_name = module_name.data();
    if (cur_name[0] == '\0')
  40e1ac:	41 80 3f 00          	cmpb   $0x0,(%r15)
  40e1b0:	74 49                	je     40e1fb <_ZN11__sanitizer19MemoryMappingLayout17DumpListOfModulesEPNS_12LoadedModuleEmPFbPKcE+0x20b>
    //   is mapped to a fixed memory range).
    // * If a binary is compiled with -pie, all the modules are
    //   mapped high at address space (in particular, higher than
    //   shadow memory of the tool), so the module can't be the
    //   first entry.
    uptr base_address = (i ? cur_beg : 0) - cur_offset;
  40e1b2:	4d 85 f6             	test   %r14,%r14
    LoadedModule *cur_module = &modules[n_modules];
  40e1b5:	48 8d 04 9b          	lea    (%rbx,%rbx,4),%rax
    //   is mapped to a fixed memory range).
    // * If a binary is compiled with -pie, all the modules are
    //   mapped high at address space (in particular, higher than
    //   shadow memory of the tool), so the module can't be the
    //   first entry.
    uptr base_address = (i ? cur_beg : 0) - cur_offset;
  40e1b9:	ba 00 00 00 00       	mov    $0x0,%edx
  40e1be:	48 0f 45 54 24 40    	cmovne 0x40(%rsp),%rdx
    LoadedModule *cur_module = &modules[n_modules];
    cur_module->set(cur_name, base_address);
  40e1c4:	4c 89 fe             	mov    %r15,%rsi
    cur_module->addAddressRange(cur_beg, cur_end, prot & kProtectionExecute);
    n_modules++;
  40e1c7:	48 83 c3 01          	add    $0x1,%rbx
    //   is mapped to a fixed memory range).
    // * If a binary is compiled with -pie, all the modules are
    //   mapped high at address space (in particular, higher than
    //   shadow memory of the tool), so the module can't be the
    //   first entry.
    uptr base_address = (i ? cur_beg : 0) - cur_offset;
  40e1cb:	48 2b 54 24 50       	sub    0x50(%rsp),%rdx
    LoadedModule *cur_module = &modules[n_modules];
  40e1d0:	4d 8d 64 c5 00       	lea    0x0(%r13,%rax,8),%r12
    cur_module->set(cur_name, base_address);
  40e1d5:	4c 89 e7             	mov    %r12,%rdi
  40e1d8:	e8 d3 77 ff ff       	callq  4059b0 <_ZN11__sanitizer12LoadedModule3setEPKcm>
    cur_module->addAddressRange(cur_beg, cur_end, prot & kProtectionExecute);
  40e1dd:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
  40e1e2:	48 8b 54 24 60       	mov    0x60(%rsp),%rdx
  40e1e7:	4c 89 e7             	mov    %r12,%rdi
  40e1ea:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  40e1ef:	48 c1 e9 02          	shr    $0x2,%rcx
  40e1f3:	83 e1 01             	and    $0x1,%ecx
  40e1f6:	e8 95 78 ff ff       	callq  405a90 <_ZN11__sanitizer12LoadedModule15addAddressRangeEmmb>
                                            string_predicate_t filter) {
  Reset();
  uptr cur_beg, cur_end, cur_offset, prot;
  InternalScopedString module_name(kMaxPathLength);
  uptr n_modules = 0;
  for (uptr i = 0; n_modules < max_modules &&
  40e1fb:	49 83 c6 01          	add    $0x1,%r14
  40e1ff:	48 39 dd             	cmp    %rbx,%rbp
  40e202:	0f 86 30 fe ff ff    	jbe    40e038 <_ZN11__sanitizer19MemoryMappingLayout17DumpListOfModulesEPNS_12LoadedModuleEmPFbPKcE+0x48>
  40e208:	e9 6c ff ff ff       	jmpq   40e179 <_ZN11__sanitizer19MemoryMappingLayout17DumpListOfModulesEPNS_12LoadedModuleEmPFbPKcE+0x189>
  40e20d:	0f 1f 00             	nopl   (%rax)

000000000040e210 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m>:
    n_modules++;
  }
  return n_modules;
}

void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) {
  40e210:	41 57                	push   %r15
  char *smaps = nullptr;
  uptr smaps_cap = 0;
  uptr smaps_len = 0;
  if (!ReadFileToBuffer("/proc/self/smaps", &smaps, &smaps_cap, &smaps_len))
  40e212:	45 31 c9             	xor    %r9d,%r9d
  40e215:	41 b8 00 00 00 04    	mov    $0x4000000,%r8d
    n_modules++;
  }
  return n_modules;
}

void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) {
  40e21b:	41 56                	push   %r14
  40e21d:	41 55                	push   %r13
  40e21f:	49 89 d5             	mov    %rdx,%r13
  40e222:	41 54                	push   %r12
  40e224:	49 89 f4             	mov    %rsi,%r12
  40e227:	55                   	push   %rbp
  40e228:	48 89 fd             	mov    %rdi,%rbp
  char *smaps = nullptr;
  uptr smaps_cap = 0;
  uptr smaps_len = 0;
  if (!ReadFileToBuffer("/proc/self/smaps", &smaps, &smaps_cap, &smaps_len))
  40e22b:	48 8d 3d 26 ac 00 00 	lea    0xac26(%rip),%rdi        # 418e58 <.LC4>
    n_modules++;
  }
  return n_modules;
}

void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) {
  40e232:	53                   	push   %rbx
  40e233:	48 83 ec 38          	sub    $0x38,%rsp
  char *smaps = nullptr;
  uptr smaps_cap = 0;
  uptr smaps_len = 0;
  if (!ReadFileToBuffer("/proc/self/smaps", &smaps, &smaps_cap, &smaps_len))
  40e237:	48 8d 4c 24 20       	lea    0x20(%rsp),%rcx
  40e23c:	48 8d 54 24 10       	lea    0x10(%rsp),%rdx
  40e241:	48 89 e6             	mov    %rsp,%rsi
  }
  return n_modules;
}

void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) {
  char *smaps = nullptr;
  40e244:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  40e24b:	00 
  uptr smaps_cap = 0;
  40e24c:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
  40e253:	00 00 
  uptr smaps_len = 0;
  40e255:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
  40e25c:	00 00 
  if (!ReadFileToBuffer("/proc/self/smaps", &smaps, &smaps_cap, &smaps_len))
  40e25e:	e8 8d 73 ff ff       	callq  4055f0 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi>
  40e263:	84 c0                	test   %al,%al
  40e265:	0f 84 86 00 00 00    	je     40e2f1 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0xe1>
    return;
  uptr start = 0;
  bool file = false;
  const char *pos = smaps;
  40e26b:	48 8b 1c 24          	mov    (%rsp),%rbx
  uptr smaps_cap = 0;
  uptr smaps_len = 0;
  if (!ReadFileToBuffer("/proc/self/smaps", &smaps, &smaps_cap, &smaps_len))
    return;
  uptr start = 0;
  bool file = false;
  40e26f:	45 31 f6             	xor    %r14d,%r14d
  char *smaps = nullptr;
  uptr smaps_cap = 0;
  uptr smaps_len = 0;
  if (!ReadFileToBuffer("/proc/self/smaps", &smaps, &smaps_cap, &smaps_len))
    return;
  uptr start = 0;
  40e272:	45 31 ff             	xor    %r15d,%r15d
  40e275:	48 89 d9             	mov    %rbx,%rcx
  40e278:	48 03 4c 24 20       	add    0x20(%rsp),%rcx
  bool file = false;
  const char *pos = smaps;
  while (pos < smaps + smaps_len) {
  40e27d:	48 89 df             	mov    %rbx,%rdi
  40e280:	48 39 cb             	cmp    %rcx,%rbx
  40e283:	73 62                	jae    40e2e7 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0xd7>
  40e285:	0f 1f 00             	nopl   (%rax)
// Linker initialized.
ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;
StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.

static int TranslateDigit(char c) {
  if (c >= '0' && c <= '9')
  40e288:	0f b6 03             	movzbl (%rbx),%eax
  40e28b:	8d 50 d0             	lea    -0x30(%rax),%edx
  40e28e:	80 fa 09             	cmp    $0x9,%dl
  40e291:	0f 86 e9 00 00 00    	jbe    40e380 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x170>
    return c - '0';
  if (c >= 'a' && c <= 'f')
  40e297:	8d 50 9f             	lea    -0x61(%rax),%edx
  40e29a:	80 fa 05             	cmp    $0x5,%dl
  40e29d:	0f 86 dd 00 00 00    	jbe    40e380 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x170>
    return c - 'a' + 10;
  if (c >= 'A' && c <= 'F')
  40e2a3:	83 e8 41             	sub    $0x41,%eax
  40e2a6:	3c 05                	cmp    $0x5,%al
  40e2a8:	0f 86 d2 00 00 00    	jbe    40e380 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x170>
  while (pos < smaps + smaps_len) {
    if (IsHex(pos[0])) {
      start = ParseHex(&pos);
      for (; *pos != '/' && *pos > '\n'; pos++) {}
      file = *pos == '/';
    } else if (internal_strncmp(pos, "Rss:", 4) == 0) {
  40e2ae:	48 8d 35 b4 ab 00 00 	lea    0xabb4(%rip),%rsi        # 418e69 <.LC5>
  40e2b5:	ba 04 00 00 00       	mov    $0x4,%edx
  40e2ba:	48 89 df             	mov    %rbx,%rdi
  40e2bd:	e8 5e c5 ff ff       	callq  40a820 <_ZN11__sanitizer16internal_strncmpEPKcS1_m>
  40e2c2:	85 c0                	test   %eax,%eax
  40e2c4:	74 46                	je     40e30c <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0xfc>
  40e2c6:	48 8b 3c 24          	mov    (%rsp),%rdi
  40e2ca:	48 89 f9             	mov    %rdi,%rcx
  40e2cd:	48 03 4c 24 20       	add    0x20(%rsp),%rcx
  40e2d2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40e2d8:	48 83 c3 01          	add    $0x1,%rbx
      while (!IsDecimal(*pos)) pos++;
      uptr rss = ParseDecimal(&pos) * 1024;
      cb(start, rss, file, stats, stats_size);
    }
    while (*pos++ != '\n') {}
  40e2dc:	80 7b ff 0a          	cmpb   $0xa,-0x1(%rbx)
  40e2e0:	75 f6                	jne    40e2d8 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0xc8>
  if (!ReadFileToBuffer("/proc/self/smaps", &smaps, &smaps_cap, &smaps_len))
    return;
  uptr start = 0;
  bool file = false;
  const char *pos = smaps;
  while (pos < smaps + smaps_len) {
  40e2e2:	48 39 cb             	cmp    %rcx,%rbx
  40e2e5:	72 a1                	jb     40e288 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x78>
      uptr rss = ParseDecimal(&pos) * 1024;
      cb(start, rss, file, stats, stats_size);
    }
    while (*pos++ != '\n') {}
  }
  UnmapOrDie(smaps, smaps_cap);
  40e2e7:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40e2ec:	e8 4f e1 ff ff       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
}
  40e2f1:	48 83 c4 38          	add    $0x38,%rsp
  40e2f5:	5b                   	pop    %rbx
  40e2f6:	5d                   	pop    %rbp
  40e2f7:	41 5c                	pop    %r12
  40e2f9:	41 5d                	pop    %r13
  40e2fb:	41 5e                	pop    %r14
  40e2fd:	41 5f                	pop    %r15
  40e2ff:	c3                   	retq   
ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;
StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.

static int TranslateDigit(char c) {
  if (c >= '0' && c <= '9')
    return c - '0';
  40e300:	83 e8 30             	sub    $0x30,%eax
    if (IsHex(pos[0])) {
      start = ParseHex(&pos);
      for (; *pos != '/' && *pos > '\n'; pos++) {}
      file = *pos == '/';
    } else if (internal_strncmp(pos, "Rss:", 4) == 0) {
      while (!IsDecimal(*pos)) pos++;
  40e303:	83 f8 09             	cmp    $0x9,%eax
  40e306:	76 23                	jbe    40e32b <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x11b>
  40e308:	48 83 c3 01          	add    $0x1,%rbx
  40e30c:	0f be 03             	movsbl (%rbx),%eax
// Linker initialized.
ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;
StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.

static int TranslateDigit(char c) {
  if (c >= '0' && c <= '9')
  40e30f:	8d 50 d0             	lea    -0x30(%rax),%edx
  40e312:	80 fa 09             	cmp    $0x9,%dl
  40e315:	76 e9                	jbe    40e300 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0xf0>
    return c - '0';
  if (c >= 'a' && c <= 'f')
  40e317:	8d 50 9f             	lea    -0x61(%rax),%edx
  40e31a:	80 fa 05             	cmp    $0x5,%dl
  40e31d:	0f 87 cd 00 00 00    	ja     40e3f0 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x1e0>
    return c - 'a' + 10;
  40e323:	83 e8 57             	sub    $0x57,%eax
    if (IsHex(pos[0])) {
      start = ParseHex(&pos);
      for (; *pos != '/' && *pos > '\n'; pos++) {}
      file = *pos == '/';
    } else if (internal_strncmp(pos, "Rss:", 4) == 0) {
      while (!IsDecimal(*pos)) pos++;
  40e326:	83 f8 09             	cmp    $0x9,%eax
  40e329:	77 dd                	ja     40e308 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0xf8>
// Parse a number and promote 'p' up to the first non-digit character.
static uptr ParseNumber(const char **p, int base) {
  uptr n = 0;
  int d;
  CHECK(base >= 2 && base <= 16);
  while ((d = TranslateDigit(**p)) >= 0 && d < base) {
  40e32b:	0f be 03             	movsbl (%rbx),%eax
    if (IsHex(pos[0])) {
      start = ParseHex(&pos);
      for (; *pos != '/' && *pos > '\n'; pos++) {}
      file = *pos == '/';
    } else if (internal_strncmp(pos, "Rss:", 4) == 0) {
      while (!IsDecimal(*pos)) pos++;
  40e32e:	31 f6                	xor    %esi,%esi
// Linker initialized.
ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;
StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.

static int TranslateDigit(char c) {
  if (c >= '0' && c <= '9')
  40e330:	8d 50 d0             	lea    -0x30(%rax),%edx
  40e333:	80 fa 09             	cmp    $0x9,%dl
  40e336:	77 24                	ja     40e35c <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x14c>
  40e338:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40e33f:	00 
    return c - '0';
  40e340:	83 e8 30             	sub    $0x30,%eax
static uptr ParseNumber(const char **p, int base) {
  uptr n = 0;
  int d;
  CHECK(base >= 2 && base <= 16);
  while ((d = TranslateDigit(**p)) >= 0 && d < base) {
    n = n * base + d;
  40e343:	48 8d 14 b6          	lea    (%rsi,%rsi,4),%rdx
  40e347:	48 83 c3 01          	add    $0x1,%rbx
  40e34b:	48 98                	cltq   
  40e34d:	48 8d 34 50          	lea    (%rax,%rdx,2),%rsi
// Parse a number and promote 'p' up to the first non-digit character.
static uptr ParseNumber(const char **p, int base) {
  uptr n = 0;
  int d;
  CHECK(base >= 2 && base <= 16);
  while ((d = TranslateDigit(**p)) >= 0 && d < base) {
  40e351:	0f be 03             	movsbl (%rbx),%eax
// Linker initialized.
ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;
StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.

static int TranslateDigit(char c) {
  if (c >= '0' && c <= '9')
  40e354:	8d 50 d0             	lea    -0x30(%rax),%edx
  40e357:	80 fa 09             	cmp    $0x9,%dl
  40e35a:	76 e4                	jbe    40e340 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x130>
      for (; *pos != '/' && *pos > '\n'; pos++) {}
      file = *pos == '/';
    } else if (internal_strncmp(pos, "Rss:", 4) == 0) {
      while (!IsDecimal(*pos)) pos++;
      uptr rss = ParseDecimal(&pos) * 1024;
      cb(start, rss, file, stats, stats_size);
  40e35c:	4c 89 e1             	mov    %r12,%rcx
  40e35f:	4c 89 ff             	mov    %r15,%rdi
  40e362:	41 0f b6 d6          	movzbl %r14b,%edx
      start = ParseHex(&pos);
      for (; *pos != '/' && *pos > '\n'; pos++) {}
      file = *pos == '/';
    } else if (internal_strncmp(pos, "Rss:", 4) == 0) {
      while (!IsDecimal(*pos)) pos++;
      uptr rss = ParseDecimal(&pos) * 1024;
  40e366:	48 c1 e6 0a          	shl    $0xa,%rsi
      cb(start, rss, file, stats, stats_size);
  40e36a:	4d 89 e8             	mov    %r13,%r8
  40e36d:	ff d5                	callq  *%rbp
  40e36f:	48 8b 3c 24          	mov    (%rsp),%rdi
  40e373:	48 89 f9             	mov    %rdi,%rcx
  40e376:	48 03 4c 24 20       	add    0x20(%rsp),%rcx
  40e37b:	e9 58 ff ff ff       	jmpq   40e2d8 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0xc8>
    n_modules++;
  }
  return n_modules;
}

void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) {
  40e380:	45 31 ff             	xor    %r15d,%r15d
  40e383:	eb 13                	jmp    40e398 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x188>
  40e385:	0f 1f 00             	nopl   (%rax)
ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;
StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.

static int TranslateDigit(char c) {
  if (c >= '0' && c <= '9')
    return c - '0';
  40e388:	83 e8 30             	sub    $0x30,%eax
static uptr ParseNumber(const char **p, int base) {
  uptr n = 0;
  int d;
  CHECK(base >= 2 && base <= 16);
  while ((d = TranslateDigit(**p)) >= 0 && d < base) {
    n = n * base + d;
  40e38b:	49 c1 e7 04          	shl    $0x4,%r15
  40e38f:	48 98                	cltq   
  40e391:	48 83 c3 01          	add    $0x1,%rbx
  40e395:	49 01 c7             	add    %rax,%r15
// Parse a number and promote 'p' up to the first non-digit character.
static uptr ParseNumber(const char **p, int base) {
  uptr n = 0;
  int d;
  CHECK(base >= 2 && base <= 16);
  while ((d = TranslateDigit(**p)) >= 0 && d < base) {
  40e398:	0f be 03             	movsbl (%rbx),%eax
// Linker initialized.
ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;
StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.

static int TranslateDigit(char c) {
  if (c >= '0' && c <= '9')
  40e39b:	8d 50 d0             	lea    -0x30(%rax),%edx
  40e39e:	80 fa 09             	cmp    $0x9,%dl
  40e3a1:	76 e5                	jbe    40e388 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x178>
    return c - '0';
  if (c >= 'a' && c <= 'f')
  40e3a3:	8d 50 9f             	lea    -0x61(%rax),%edx
  40e3a6:	80 fa 05             	cmp    $0x5,%dl
  40e3a9:	77 05                	ja     40e3b0 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x1a0>
    return c - 'a' + 10;
  40e3ab:	83 e8 57             	sub    $0x57,%eax
  40e3ae:	eb db                	jmp    40e38b <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x17b>
  if (c >= 'A' && c <= 'F')
  40e3b0:	8d 50 bf             	lea    -0x41(%rax),%edx
  40e3b3:	80 fa 05             	cmp    $0x5,%dl
  40e3b6:	76 30                	jbe    40e3e8 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x1d8>
  bool file = false;
  const char *pos = smaps;
  while (pos < smaps + smaps_len) {
    if (IsHex(pos[0])) {
      start = ParseHex(&pos);
      for (; *pos != '/' && *pos > '\n'; pos++) {}
  40e3b8:	3c 2f                	cmp    $0x2f,%al
  40e3ba:	74 1b                	je     40e3d7 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x1c7>
  40e3bc:	3c 0a                	cmp    $0xa,%al
  40e3be:	7f 0c                	jg     40e3cc <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x1bc>
  40e3c0:	eb 15                	jmp    40e3d7 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x1c7>
  40e3c2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40e3c8:	3c 2f                	cmp    $0x2f,%al
  40e3ca:	74 0b                	je     40e3d7 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x1c7>
  40e3cc:	48 83 c3 01          	add    $0x1,%rbx
  40e3d0:	0f b6 03             	movzbl (%rbx),%eax
  40e3d3:	3c 0a                	cmp    $0xa,%al
  40e3d5:	7f f1                	jg     40e3c8 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x1b8>
      file = *pos == '/';
  40e3d7:	3c 2f                	cmp    $0x2f,%al
  40e3d9:	41 0f 94 c6          	sete   %r14b
  40e3dd:	e9 f6 fe ff ff       	jmpq   40e2d8 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0xc8>
  40e3e2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  if (c >= '0' && c <= '9')
    return c - '0';
  if (c >= 'a' && c <= 'f')
    return c - 'a' + 10;
  if (c >= 'A' && c <= 'F')
    return c - 'A' + 10;
  40e3e8:	83 e8 37             	sub    $0x37,%eax
  40e3eb:	eb 9e                	jmp    40e38b <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0x17b>
  40e3ed:	0f 1f 00             	nopl   (%rax)
static int TranslateDigit(char c) {
  if (c >= '0' && c <= '9')
    return c - '0';
  if (c >= 'a' && c <= 'f')
    return c - 'a' + 10;
  if (c >= 'A' && c <= 'F')
  40e3f0:	8d 50 bf             	lea    -0x41(%rax),%edx
  40e3f3:	80 fa 05             	cmp    $0x5,%dl
  40e3f6:	0f 87 0c ff ff ff    	ja     40e308 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0xf8>
    return c - 'A' + 10;
  40e3fc:	83 e8 37             	sub    $0x37,%eax
  40e3ff:	e9 ff fe ff ff       	jmpq   40e303 <_ZN11__sanitizer16GetMemoryProfileEPFvmmbPmmES0_m+0xf3>
  40e404:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40e40b:	00 00 00 00 00 

000000000040e410 <_ZN11__sanitizer12ReadProcMapsEPNS_16ProcSelfMapsBuffE>:
#include "sanitizer_common.h"
#include "sanitizer_procmaps.h"

namespace __sanitizer {

void ReadProcMaps(ProcSelfMapsBuff *proc_maps) {
  40e410:	48 89 fe             	mov    %rdi,%rsi
  CHECK(ReadFileToBuffer("/proc/self/maps", &proc_maps->data,
  40e413:	48 8d 4f 10          	lea    0x10(%rdi),%rcx
  40e417:	48 8d 57 08          	lea    0x8(%rdi),%rdx
  40e41b:	48 8d 3d 4c aa 00 00 	lea    0xaa4c(%rip),%rdi        # 418e6e <.LC0>
#include "sanitizer_common.h"
#include "sanitizer_procmaps.h"

namespace __sanitizer {

void ReadProcMaps(ProcSelfMapsBuff *proc_maps) {
  40e422:	48 83 ec 08          	sub    $0x8,%rsp
  CHECK(ReadFileToBuffer("/proc/self/maps", &proc_maps->data,
  40e426:	45 31 c9             	xor    %r9d,%r9d
  40e429:	41 b8 00 00 00 04    	mov    $0x4000000,%r8d
  40e42f:	e8 bc 71 ff ff       	callq  4055f0 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi>
  40e434:	84 c0                	test   %al,%al
  40e436:	74 05                	je     40e43d <_ZN11__sanitizer12ReadProcMapsEPNS_16ProcSelfMapsBuffE+0x2d>
                         &proc_maps->mmaped_size, &proc_maps->len));
}
  40e438:	48 83 c4 08          	add    $0x8,%rsp
  40e43c:	c3                   	retq   
#include "sanitizer_procmaps.h"

namespace __sanitizer {

void ReadProcMaps(ProcSelfMapsBuff *proc_maps) {
  CHECK(ReadFileToBuffer("/proc/self/maps", &proc_maps->data,
  40e43d:	48 8d 15 fc 92 00 00 	lea    0x92fc(%rip),%rdx        # 417740 <.LC1>
  40e444:	48 8d 3d 65 93 00 00 	lea    0x9365(%rip),%rdi        # 4177b0 <.LC2>
  40e44b:	45 31 c0             	xor    %r8d,%r8d
  40e44e:	31 c9                	xor    %ecx,%ecx
  40e450:	be 16 00 00 00       	mov    $0x16,%esi
  40e455:	e8 96 6f ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40e45a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000040e460 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_>:
  return c == c1 || c == c2;
}

bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,
                               char filename[], uptr filename_size,
                               uptr *protection) {
  40e460:	41 57                	push   %r15
  40e462:	49 89 ff             	mov    %rdi,%r15
  40e465:	41 56                	push   %r14
  40e467:	41 55                	push   %r13
  40e469:	41 54                	push   %r12
  40e46b:	55                   	push   %rbp
  40e46c:	53                   	push   %rbx
  40e46d:	48 83 ec 28          	sub    $0x28,%rsp
  char *last = proc_self_maps_.data + proc_self_maps_.len;
  40e471:	4c 8b 2f             	mov    (%rdi),%r13
  40e474:	4c 03 6f 10          	add    0x10(%rdi),%r13
  if (current_ >= last) return false;
  40e478:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
  return c == c1 || c == c2;
}

bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,
                               char filename[], uptr filename_size,
                               uptr *protection) {
  40e47c:	4c 89 0c 24          	mov    %r9,(%rsp)
  char *last = proc_self_maps_.data + proc_self_maps_.len;
  if (current_ >= last) return false;
  40e480:	49 39 fd             	cmp    %rdi,%r13
  40e483:	0f 86 f7 02 00 00    	jbe    40e780 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x320>
  uptr dummy;
  if (!start) start = &dummy;
  40e489:	48 8d 44 24 10       	lea    0x10(%rsp),%rax
  40e48e:	48 85 f6             	test   %rsi,%rsi
  40e491:	49 89 f3             	mov    %rsi,%r11
  40e494:	49 89 d6             	mov    %rdx,%r14
  40e497:	48 89 cd             	mov    %rcx,%rbp
  if (!end) end = &dummy;
  if (!offset) offset = &dummy;
  if (!protection) protection = &dummy;
  char *next_line = (char*)internal_memchr(current_, '\n', last - current_);
  40e49a:	be 0a 00 00 00       	mov    $0xa,%esi
                               char filename[], uptr filename_size,
                               uptr *protection) {
  char *last = proc_self_maps_.data + proc_self_maps_.len;
  if (current_ >= last) return false;
  uptr dummy;
  if (!start) start = &dummy;
  40e49f:	4c 0f 44 d8          	cmove  %rax,%r11
  if (!end) end = &dummy;
  40e4a3:	48 85 d2             	test   %rdx,%rdx
  if (!offset) offset = &dummy;
  if (!protection) protection = &dummy;
  char *next_line = (char*)internal_memchr(current_, '\n', last - current_);
  40e4a6:	4c 89 ea             	mov    %r13,%rdx
                               uptr *protection) {
  char *last = proc_self_maps_.data + proc_self_maps_.len;
  if (current_ >= last) return false;
  uptr dummy;
  if (!start) start = &dummy;
  if (!end) end = &dummy;
  40e4a9:	4c 0f 44 f0          	cmove  %rax,%r14
  if (!offset) offset = &dummy;
  40e4ad:	48 85 c9             	test   %rcx,%rcx
                               char filename[], uptr filename_size,
                               uptr *protection) {
  char *last = proc_self_maps_.data + proc_self_maps_.len;
  if (current_ >= last) return false;
  uptr dummy;
  if (!start) start = &dummy;
  40e4b0:	4c 89 5c 24 08       	mov    %r11,0x8(%rsp)
  if (!end) end = &dummy;
  if (!offset) offset = &dummy;
  40e4b5:	48 0f 44 e8          	cmove  %rax,%rbp
  if (!protection) protection = &dummy;
  40e4b9:	48 83 7c 24 60 00    	cmpq   $0x0,0x60(%rsp)
  40e4bf:	4d 89 c4             	mov    %r8,%r12
  40e4c2:	48 0f 45 44 24 60    	cmovne 0x60(%rsp),%rax
  char *next_line = (char*)internal_memchr(current_, '\n', last - current_);
  40e4c8:	48 29 fa             	sub    %rdi,%rdx
  if (current_ >= last) return false;
  uptr dummy;
  if (!start) start = &dummy;
  if (!end) end = &dummy;
  if (!offset) offset = &dummy;
  if (!protection) protection = &dummy;
  40e4cb:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
  char *next_line = (char*)internal_memchr(current_, '\n', last - current_);
  40e4d0:	e8 7b b9 ff ff       	callq  409e50 <_ZN11__sanitizer15internal_memchrEPKvim>
  40e4d5:	48 85 c0             	test   %rax,%rax
  40e4d8:	48 89 c3             	mov    %rax,%rbx
  40e4db:	49 0f 44 dd          	cmove  %r13,%rbx
  if (next_line == 0)
    next_line = last;
  // Example: 08048000-08056000 r-xp 00000000 03:0c 64593   /foo/bar
  *start = ParseHex(&current_);
  40e4df:	4d 8d 6f 18          	lea    0x18(%r15),%r13
  40e4e3:	4c 89 ef             	mov    %r13,%rdi
  40e4e6:	e8 c5 f7 ff ff       	callq  40dcb0 <_ZN11__sanitizer8ParseHexEPPKc>
  40e4eb:	4c 8b 5c 24 08       	mov    0x8(%rsp),%r11
  40e4f0:	49 89 03             	mov    %rax,(%r11)
  CHECK_EQ(*current_++, '-');
  40e4f3:	49 8b 47 18          	mov    0x18(%r15),%rax
  40e4f7:	48 8d 50 01          	lea    0x1(%rax),%rdx
  40e4fb:	49 89 57 18          	mov    %rdx,0x18(%r15)
  40e4ff:	48 0f be 08          	movsbq (%rax),%rcx
  40e503:	48 83 f9 2d          	cmp    $0x2d,%rcx
  40e507:	0f 85 43 03 00 00    	jne    40e850 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x3f0>
  *end = ParseHex(&current_);
  40e50d:	4c 89 ef             	mov    %r13,%rdi
  40e510:	e8 9b f7 ff ff       	callq  40dcb0 <_ZN11__sanitizer8ParseHexEPPKc>
  40e515:	49 89 06             	mov    %rax,(%r14)
  CHECK_EQ(*current_++, ' ');
  40e518:	49 8b 47 18          	mov    0x18(%r15),%rax
  40e51c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  40e520:	49 89 57 18          	mov    %rdx,0x18(%r15)
  40e524:	48 0f be 08          	movsbq (%rax),%rcx
  40e528:	48 83 f9 20          	cmp    $0x20,%rcx
  40e52c:	0f 85 62 03 00 00    	jne    40e894 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x434>
  CHECK(IsOneOf(*current_, '-', 'r'));
  40e532:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  40e536:	80 fa 72             	cmp    $0x72,%dl
  40e539:	0f 85 2f 03 00 00    	jne    40e86e <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x40e>
  *protection = 0;
  40e53f:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  if (*current_++ == 'r')
  40e544:	48 8d 50 02          	lea    0x2(%rax),%rdx
  40e548:	4c 8b 54 24 60       	mov    0x60(%rsp),%r10
  *start = ParseHex(&current_);
  CHECK_EQ(*current_++, '-');
  *end = ParseHex(&current_);
  CHECK_EQ(*current_++, ' ');
  CHECK(IsOneOf(*current_, '-', 'r'));
  *protection = 0;
  40e54d:	48 c7 01 00 00 00 00 	movq   $0x0,(%rcx)
  if (*current_++ == 'r')
  40e554:	49 89 57 18          	mov    %rdx,0x18(%r15)
  40e558:	31 d2                	xor    %edx,%edx
  40e55a:	80 78 01 72          	cmpb   $0x72,0x1(%rax)
  40e55e:	0f 94 c2             	sete   %dl
  40e561:	31 f6                	xor    %esi,%esi
  40e563:	48 83 c2 08          	add    $0x8,%rdx
  40e567:	80 78 01 72          	cmpb   $0x72,0x1(%rax)
  40e56b:	40 0f 94 c6          	sete   %sil
  40e56f:	31 ff                	xor    %edi,%edi
  40e571:	48 83 c6 0c          	add    $0xc,%rsi
  40e575:	80 78 01 72          	cmpb   $0x72,0x1(%rax)
  40e579:	40 0f 94 c7          	sete   %dil
  40e57d:	45 31 c9             	xor    %r9d,%r9d
  40e580:	48 83 c7 04          	add    $0x4,%rdi
  40e584:	80 78 01 72          	cmpb   $0x72,0x1(%rax)
  40e588:	41 0f 94 c1          	sete   %r9b
  40e58c:	45 31 c0             	xor    %r8d,%r8d
  40e58f:	49 83 c1 0a          	add    $0xa,%r9
  40e593:	80 78 01 72          	cmpb   $0x72,0x1(%rax)
  40e597:	41 0f 94 c0          	sete   %r8b
  40e59b:	31 c9                	xor    %ecx,%ecx
  40e59d:	49 83 c0 0e          	add    $0xe,%r8
  40e5a1:	80 78 01 72          	cmpb   $0x72,0x1(%rax)
  40e5a5:	0f 94 c1             	sete   %cl
  40e5a8:	45 31 db             	xor    %r11d,%r11d
  40e5ab:	48 83 c1 06          	add    $0x6,%rcx
  40e5af:	80 78 01 72          	cmpb   $0x72,0x1(%rax)
  40e5b3:	41 0f 94 c3          	sete   %r11b
  40e5b7:	45 31 f6             	xor    %r14d,%r14d
  40e5ba:	49 83 c3 02          	add    $0x2,%r11
  40e5be:	80 78 01 72          	cmpb   $0x72,0x1(%rax)
  40e5c2:	41 0f 94 c6          	sete   %r14b
  40e5c6:	4d 89 32             	mov    %r14,(%r10)
    *protection |= kProtectionRead;
  CHECK(IsOneOf(*current_, '-', 'w'));
  40e5c9:	44 0f b6 70 02       	movzbl 0x2(%rax),%r14d
  40e5ce:	41 80 fe 77          	cmp    $0x77,%r14b
  40e5d2:	0f 85 01 03 00 00    	jne    40e8d9 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x479>
  if (*current_++ == 'w')
  40e5d8:	4c 8d 70 03          	lea    0x3(%rax),%r14
  40e5dc:	4d 89 77 18          	mov    %r14,0x18(%r15)
  40e5e0:	80 78 02 77          	cmpb   $0x77,0x2(%rax)
  40e5e4:	0f 84 c6 01 00 00    	je     40e7b0 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x350>
    *protection |= kProtectionWrite;
  CHECK(IsOneOf(*current_, '-', 'x'));
  40e5ea:	44 0f b6 40 03       	movzbl 0x3(%rax),%r8d
  40e5ef:	41 80 f8 78          	cmp    $0x78,%r8b
  40e5f3:	0f 85 b9 02 00 00    	jne    40e8b2 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x452>
  if (*current_++ == 'x')
  40e5f9:	4c 8d 40 04          	lea    0x4(%rax),%r8
  40e5fd:	4d 89 47 18          	mov    %r8,0x18(%r15)
  40e601:	80 78 03 78          	cmpb   $0x78,0x3(%rax)
  40e605:	0f 84 7d 01 00 00    	je     40e788 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x328>
    *protection |= kProtectionExecute;
  CHECK(IsOneOf(*current_, 's', 'p'));
  40e60b:	0f b6 70 04          	movzbl 0x4(%rax),%esi
  CHECK(ReadFileToBuffer("/proc/self/maps", &proc_maps->data,
                         &proc_maps->mmaped_size, &proc_maps->len));
}

static bool IsOneOf(char c, char c1, char c2) {
  return c == c1 || c == c2;
  40e60f:	40 80 fe 70          	cmp    $0x70,%sil
  40e613:	41 0f 94 c6          	sete   %r14b
  40e617:	40 80 fe 73          	cmp    $0x73,%sil
  40e61b:	40 0f 94 c6          	sete   %sil
  if (*current_++ == 'w')
    *protection |= kProtectionWrite;
  CHECK(IsOneOf(*current_, '-', 'x'));
  if (*current_++ == 'x')
    *protection |= kProtectionExecute;
  CHECK(IsOneOf(*current_, 's', 'p'));
  40e61f:	41 08 f6             	or     %sil,%r14b
  40e622:	0f 84 0b 02 00 00    	je     40e833 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x3d3>
  if (*current_++ == 's')
  40e628:	48 8d 70 05          	lea    0x5(%rax),%rsi
  40e62c:	49 89 77 18          	mov    %rsi,0x18(%r15)
  40e630:	80 78 04 73          	cmpb   $0x73,0x4(%rax)
  40e634:	0f 84 66 01 00 00    	je     40e7a0 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x340>
    *protection |= kProtectionShared;
  CHECK_EQ(*current_++, ' ');
  40e63a:	48 8d 50 06          	lea    0x6(%rax),%rdx
  40e63e:	49 89 57 18          	mov    %rdx,0x18(%r15)
  40e642:	48 0f be 48 05       	movsbq 0x5(%rax),%rcx
  40e647:	48 83 f9 20          	cmp    $0x20,%rcx
  40e64b:	0f 85 a6 01 00 00    	jne    40e7f7 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x397>
  *offset = ParseHex(&current_);
  40e651:	4c 89 ef             	mov    %r13,%rdi
  40e654:	e8 57 f6 ff ff       	callq  40dcb0 <_ZN11__sanitizer8ParseHexEPPKc>
  40e659:	48 89 45 00          	mov    %rax,0x0(%rbp)
  CHECK_EQ(*current_++, ' ');
  40e65d:	49 8b 47 18          	mov    0x18(%r15),%rax
  40e661:	48 8d 50 01          	lea    0x1(%rax),%rdx
  40e665:	49 89 57 18          	mov    %rdx,0x18(%r15)
  40e669:	48 0f be 08          	movsbq (%rax),%rcx
  40e66d:	48 83 f9 20          	cmp    $0x20,%rcx
  40e671:	0f 85 89 02 00 00    	jne    40e900 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x4a0>
  ParseHex(&current_);
  40e677:	4c 89 ef             	mov    %r13,%rdi
  40e67a:	e8 31 f6 ff ff       	callq  40dcb0 <_ZN11__sanitizer8ParseHexEPPKc>
  CHECK_EQ(*current_++, ':');
  40e67f:	49 8b 47 18          	mov    0x18(%r15),%rax
  40e683:	48 8d 50 01          	lea    0x1(%rax),%rdx
  40e687:	49 89 57 18          	mov    %rdx,0x18(%r15)
  40e68b:	48 0f be 08          	movsbq (%rax),%rcx
  40e68f:	48 83 f9 3a          	cmp    $0x3a,%rcx
  40e693:	0f 85 7c 01 00 00    	jne    40e815 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x3b5>
  ParseHex(&current_);
  40e699:	4c 89 ef             	mov    %r13,%rdi
  40e69c:	e8 0f f6 ff ff       	callq  40dcb0 <_ZN11__sanitizer8ParseHexEPPKc>
  CHECK_EQ(*current_++, ' ');
  40e6a1:	49 8b 57 18          	mov    0x18(%r15),%rdx
  40e6a5:	48 8d 42 01          	lea    0x1(%rdx),%rax
  40e6a9:	49 89 47 18          	mov    %rax,0x18(%r15)
  40e6ad:	48 0f be 0a          	movsbq (%rdx),%rcx
  40e6b1:	48 83 f9 20          	cmp    $0x20,%rcx
  40e6b5:	74 15                	je     40e6cc <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x26c>
  40e6b7:	e9 62 02 00 00       	jmpq   40e91e <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x4be>
  40e6bc:	0f 1f 40 00          	nopl   0x0(%rax)
  while (IsDecimal(*current_))
    current_++;
  40e6c0:	49 8b 47 18          	mov    0x18(%r15),%rax
  40e6c4:	48 83 c0 01          	add    $0x1,%rax
  40e6c8:	49 89 47 18          	mov    %rax,0x18(%r15)
  CHECK_EQ(*current_++, ' ');
  ParseHex(&current_);
  CHECK_EQ(*current_++, ':');
  ParseHex(&current_);
  CHECK_EQ(*current_++, ' ');
  while (IsDecimal(*current_))
  40e6cc:	0f be 38             	movsbl (%rax),%edi
  40e6cf:	e8 5c f5 ff ff       	callq  40dc30 <_ZN11__sanitizer9IsDecimalEc>
  40e6d4:	84 c0                	test   %al,%al
  40e6d6:	75 e8                	jne    40e6c0 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x260>
    current_++;
  // Qemu may lack the trailing space.
  // http://code.google.com/p/address-sanitizer/issues/detail?id=160
  // CHECK_EQ(*current_++, ' ');
  // Skip spaces.
  while (current_ < next_line && *current_ == ' ')
  40e6d8:	49 8b 57 18          	mov    0x18(%r15),%rdx
  40e6dc:	48 39 d3             	cmp    %rdx,%rbx
  40e6df:	76 25                	jbe    40e706 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x2a6>
  40e6e1:	80 3a 20             	cmpb   $0x20,(%rdx)
  40e6e4:	75 4a                	jne    40e730 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x2d0>
  40e6e6:	48 8d 42 01          	lea    0x1(%rdx),%rax
  40e6ea:	eb 0e                	jmp    40e6fa <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x29a>
  40e6ec:	0f 1f 40 00          	nopl   0x0(%rax)
  40e6f0:	48 83 c0 01          	add    $0x1,%rax
  40e6f4:	80 78 ff 20          	cmpb   $0x20,-0x1(%rax)
  40e6f8:	75 36                	jne    40e730 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x2d0>
  40e6fa:	48 39 d8             	cmp    %rbx,%rax
    current_++;
  40e6fd:	48 89 c2             	mov    %rax,%rdx
  40e700:	49 89 47 18          	mov    %rax,0x18(%r15)
    current_++;
  // Qemu may lack the trailing space.
  // http://code.google.com/p/address-sanitizer/issues/detail?id=160
  // CHECK_EQ(*current_++, ' ');
  // Skip spaces.
  while (current_ < next_line && *current_ == ' ')
  40e704:	75 ea                	jne    40e6f0 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x290>
    current_++;
  // Fill in the filename.
  uptr i = 0;
  while (current_ < next_line) {
  40e706:	31 c0                	xor    %eax,%eax
    if (filename && i < filename_size - 1)
      filename[i++] = *current_;
    current_++;
  }
  if (filename && i < filename_size)
  40e708:	48 3b 04 24          	cmp    (%rsp),%rax
  40e70c:	72 61                	jb     40e76f <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x30f>
  40e70e:	66 90                	xchg   %ax,%ax
    filename[i] = 0;
  current_ = next_line + 1;
  40e710:	48 83 c3 01          	add    $0x1,%rbx
  40e714:	49 89 5f 18          	mov    %rbx,0x18(%r15)
  return true;
}
  40e718:	48 83 c4 28          	add    $0x28,%rsp
  40e71c:	44 89 f0             	mov    %r14d,%eax
  40e71f:	5b                   	pop    %rbx
  40e720:	5d                   	pop    %rbp
  40e721:	41 5c                	pop    %r12
  40e723:	41 5d                	pop    %r13
  40e725:	41 5e                	pop    %r14
  40e727:	41 5f                	pop    %r15
  40e729:	c3                   	retq   
  40e72a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40e730:	48 8b 0c 24          	mov    (%rsp),%rcx
  40e734:	31 c0                	xor    %eax,%eax
  40e736:	48 83 e9 01          	sub    $0x1,%rcx
  40e73a:	4d 85 e4             	test   %r12,%r12
  40e73d:	0f 84 8d 00 00 00    	je     40e7d0 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x370>
  40e743:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  while (current_ < next_line && *current_ == ' ')
    current_++;
  // Fill in the filename.
  uptr i = 0;
  while (current_ < next_line) {
    if (filename && i < filename_size - 1)
  40e748:	48 39 c1             	cmp    %rax,%rcx
  40e74b:	76 0b                	jbe    40e758 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x2f8>
      filename[i++] = *current_;
  40e74d:	0f b6 12             	movzbl (%rdx),%edx
  40e750:	41 88 14 04          	mov    %dl,(%r12,%rax,1)
  40e754:	48 83 c0 01          	add    $0x1,%rax
    current_++;
  40e758:	49 8b 77 18          	mov    0x18(%r15),%rsi
  40e75c:	48 8d 56 01          	lea    0x1(%rsi),%rdx
  // Skip spaces.
  while (current_ < next_line && *current_ == ' ')
    current_++;
  // Fill in the filename.
  uptr i = 0;
  while (current_ < next_line) {
  40e760:	48 39 d3             	cmp    %rdx,%rbx
    if (filename && i < filename_size - 1)
      filename[i++] = *current_;
    current_++;
  40e763:	49 89 57 18          	mov    %rdx,0x18(%r15)
  // Skip spaces.
  while (current_ < next_line && *current_ == ' ')
    current_++;
  // Fill in the filename.
  uptr i = 0;
  while (current_ < next_line) {
  40e767:	77 df                	ja     40e748 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x2e8>
    if (filename && i < filename_size - 1)
      filename[i++] = *current_;
    current_++;
  }
  if (filename && i < filename_size)
  40e769:	48 3b 04 24          	cmp    (%rsp),%rax
  40e76d:	73 a1                	jae    40e710 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x2b0>
  40e76f:	4d 85 e4             	test   %r12,%r12
  40e772:	74 9c                	je     40e710 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x2b0>
    filename[i] = 0;
  40e774:	41 c6 04 04 00       	movb   $0x0,(%r12,%rax,1)
  40e779:	eb 95                	jmp    40e710 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x2b0>
  40e77b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,
                               char filename[], uptr filename_size,
                               uptr *protection) {
  char *last = proc_self_maps_.data + proc_self_maps_.len;
  if (current_ >= last) return false;
  40e780:	45 31 f6             	xor    %r14d,%r14d
  40e783:	eb 93                	jmp    40e718 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x2b8>
  40e785:	0f 1f 00             	nopl   (%rax)
  CHECK(IsOneOf(*current_, '-', 'w'));
  if (*current_++ == 'w')
    *protection |= kProtectionWrite;
  CHECK(IsOneOf(*current_, '-', 'x'));
  if (*current_++ == 'x')
    *protection |= kProtectionExecute;
  40e788:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  40e78d:	48 89 f2             	mov    %rsi,%rdx
  40e790:	48 89 39             	mov    %rdi,(%rcx)
  40e793:	e9 73 fe ff ff       	jmpq   40e60b <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x1ab>
  40e798:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40e79f:	00 
  CHECK(IsOneOf(*current_, 's', 'p'));
  if (*current_++ == 's')
    *protection |= kProtectionShared;
  40e7a0:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
  40e7a5:	48 89 16             	mov    %rdx,(%rsi)
  40e7a8:	e9 8d fe ff ff       	jmpq   40e63a <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x1da>
  40e7ad:	0f 1f 00             	nopl   (%rax)
  *protection = 0;
  if (*current_++ == 'r')
    *protection |= kProtectionRead;
  CHECK(IsOneOf(*current_, '-', 'w'));
  if (*current_++ == 'w')
    *protection |= kProtectionWrite;
  40e7b0:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
  40e7b5:	4c 89 ca             	mov    %r9,%rdx
  40e7b8:	48 89 cf             	mov    %rcx,%rdi
  40e7bb:	4c 89 1e             	mov    %r11,(%rsi)
  40e7be:	4c 89 c6             	mov    %r8,%rsi
  40e7c1:	e9 24 fe ff ff       	jmpq   40e5ea <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x18a>
  40e7c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40e7cd:	00 00 00 
  40e7d0:	49 8b 47 18          	mov    0x18(%r15),%rax
  40e7d4:	48 83 c0 01          	add    $0x1,%rax
  40e7d8:	eb 09                	jmp    40e7e3 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x383>
  40e7da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  // Skip spaces.
  while (current_ < next_line && *current_ == ' ')
    current_++;
  // Fill in the filename.
  uptr i = 0;
  while (current_ < next_line) {
  40e7e0:	48 89 d0             	mov    %rdx,%rax
  40e7e3:	48 39 c3             	cmp    %rax,%rbx
  40e7e6:	48 8d 50 01          	lea    0x1(%rax),%rdx
  40e7ea:	77 f4                	ja     40e7e0 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x380>
  40e7ec:	49 89 47 18          	mov    %rax,0x18(%r15)
  40e7f0:	31 c0                	xor    %eax,%eax
  40e7f2:	e9 11 ff ff ff       	jmpq   40e708 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x2a8>
  if (*current_++ == 'x')
    *protection |= kProtectionExecute;
  CHECK(IsOneOf(*current_, 's', 'p'));
  if (*current_++ == 's')
    *protection |= kProtectionShared;
  CHECK_EQ(*current_++, ' ');
  40e7f7:	48 8d 15 9b a6 00 00 	lea    0xa69b(%rip),%rdx        # 418e99 <.LC4>
  40e7fe:	48 8d 3d ab 8f 00 00 	lea    0x8fab(%rip),%rdi        # 4177b0 <.LC2>
  40e805:	41 b8 20 00 00 00    	mov    $0x20,%r8d
  40e80b:	be 3c 00 00 00       	mov    $0x3c,%esi
  40e810:	e8 db 6b ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  *offset = ParseHex(&current_);
  CHECK_EQ(*current_++, ' ');
  ParseHex(&current_);
  CHECK_EQ(*current_++, ':');
  40e815:	48 8d 15 98 a6 00 00 	lea    0xa698(%rip),%rdx        # 418eb4 <.LC9>
  40e81c:	48 8d 3d 8d 8f 00 00 	lea    0x8f8d(%rip),%rdi        # 4177b0 <.LC2>
  40e823:	41 b8 3a 00 00 00    	mov    $0x3a,%r8d
  40e829:	be 40 00 00 00       	mov    $0x40,%esi
  40e82e:	e8 bd 6b ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  if (*current_++ == 'w')
    *protection |= kProtectionWrite;
  CHECK(IsOneOf(*current_, '-', 'x'));
  if (*current_++ == 'x')
    *protection |= kProtectionExecute;
  CHECK(IsOneOf(*current_, 's', 'p'));
  40e833:	48 8d 15 66 90 00 00 	lea    0x9066(%rip),%rdx        # 4178a0 <.LC8>
  40e83a:	48 8d 3d 6f 8f 00 00 	lea    0x8f6f(%rip),%rdi        # 4177b0 <.LC2>
  40e841:	45 31 c0             	xor    %r8d,%r8d
  40e844:	31 c9                	xor    %ecx,%ecx
  40e846:	be 39 00 00 00       	mov    $0x39,%esi
  40e84b:	e8 a0 6b ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  char *next_line = (char*)internal_memchr(current_, '\n', last - current_);
  if (next_line == 0)
    next_line = last;
  // Example: 08048000-08056000 r-xp 00000000 03:0c 64593   /foo/bar
  *start = ParseHex(&current_);
  CHECK_EQ(*current_++, '-');
  40e850:	48 8d 15 27 a6 00 00 	lea    0xa627(%rip),%rdx        # 418e7e <.LC3>
  40e857:	48 8d 3d 52 8f 00 00 	lea    0x8f52(%rip),%rdi        # 4177b0 <.LC2>
  40e85e:	41 b8 2d 00 00 00    	mov    $0x2d,%r8d
  40e864:	be 2c 00 00 00       	mov    $0x2c,%esi
  40e869:	e8 82 6b ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  *end = ParseHex(&current_);
  CHECK_EQ(*current_++, ' ');
  CHECK(IsOneOf(*current_, '-', 'r'));
  40e86e:	80 fa 2d             	cmp    $0x2d,%dl
  40e871:	0f 84 c8 fc ff ff    	je     40e53f <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0xdf>
  40e877:	48 8d 15 aa 8f 00 00 	lea    0x8faa(%rip),%rdx        # 417828 <.LC5>
  40e87e:	48 8d 3d 2b 8f 00 00 	lea    0x8f2b(%rip),%rdi        # 4177b0 <.LC2>
  40e885:	45 31 c0             	xor    %r8d,%r8d
  40e888:	31 c9                	xor    %ecx,%ecx
  40e88a:	be 2f 00 00 00       	mov    $0x2f,%esi
  40e88f:	e8 5c 6b ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    next_line = last;
  // Example: 08048000-08056000 r-xp 00000000 03:0c 64593   /foo/bar
  *start = ParseHex(&current_);
  CHECK_EQ(*current_++, '-');
  *end = ParseHex(&current_);
  CHECK_EQ(*current_++, ' ');
  40e894:	48 8d 15 fe a5 00 00 	lea    0xa5fe(%rip),%rdx        # 418e99 <.LC4>
  40e89b:	48 8d 3d 0e 8f 00 00 	lea    0x8f0e(%rip),%rdi        # 4177b0 <.LC2>
  40e8a2:	41 b8 20 00 00 00    	mov    $0x20,%r8d
  40e8a8:	be 2e 00 00 00       	mov    $0x2e,%esi
  40e8ad:	e8 3e 6b ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  if (*current_++ == 'r')
    *protection |= kProtectionRead;
  CHECK(IsOneOf(*current_, '-', 'w'));
  if (*current_++ == 'w')
    *protection |= kProtectionWrite;
  CHECK(IsOneOf(*current_, '-', 'x'));
  40e8b2:	41 80 f8 2d          	cmp    $0x2d,%r8b
  40e8b6:	0f 84 3d fd ff ff    	je     40e5f9 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x199>
  40e8bc:	48 8d 15 b5 8f 00 00 	lea    0x8fb5(%rip),%rdx        # 417878 <.LC7>
  40e8c3:	48 8d 3d e6 8e 00 00 	lea    0x8ee6(%rip),%rdi        # 4177b0 <.LC2>
  40e8ca:	45 31 c0             	xor    %r8d,%r8d
  40e8cd:	31 c9                	xor    %ecx,%ecx
  40e8cf:	be 36 00 00 00       	mov    $0x36,%esi
  40e8d4:	e8 17 6b ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  CHECK_EQ(*current_++, ' ');
  CHECK(IsOneOf(*current_, '-', 'r'));
  *protection = 0;
  if (*current_++ == 'r')
    *protection |= kProtectionRead;
  CHECK(IsOneOf(*current_, '-', 'w'));
  40e8d9:	41 80 fe 2d          	cmp    $0x2d,%r14b
  40e8dd:	0f 84 f5 fc ff ff    	je     40e5d8 <_ZN11__sanitizer19MemoryMappingLayout4NextEPmS1_S1_PcmS1_+0x178>
  40e8e3:	48 8d 15 66 8f 00 00 	lea    0x8f66(%rip),%rdx        # 417850 <.LC6>
  40e8ea:	48 8d 3d bf 8e 00 00 	lea    0x8ebf(%rip),%rdi        # 4177b0 <.LC2>
  40e8f1:	45 31 c0             	xor    %r8d,%r8d
  40e8f4:	31 c9                	xor    %ecx,%ecx
  40e8f6:	be 33 00 00 00       	mov    $0x33,%esi
  40e8fb:	e8 f0 6a ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  CHECK(IsOneOf(*current_, 's', 'p'));
  if (*current_++ == 's')
    *protection |= kProtectionShared;
  CHECK_EQ(*current_++, ' ');
  *offset = ParseHex(&current_);
  CHECK_EQ(*current_++, ' ');
  40e900:	48 8d 15 92 a5 00 00 	lea    0xa592(%rip),%rdx        # 418e99 <.LC4>
  40e907:	48 8d 3d a2 8e 00 00 	lea    0x8ea2(%rip),%rdi        # 4177b0 <.LC2>
  40e90e:	41 b8 20 00 00 00    	mov    $0x20,%r8d
  40e914:	be 3e 00 00 00       	mov    $0x3e,%esi
  40e919:	e8 d2 6a ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  ParseHex(&current_);
  CHECK_EQ(*current_++, ':');
  ParseHex(&current_);
  CHECK_EQ(*current_++, ' ');
  40e91e:	48 8d 15 74 a5 00 00 	lea    0xa574(%rip),%rdx        # 418e99 <.LC4>
  40e925:	48 8d 3d 84 8e 00 00 	lea    0x8e84(%rip),%rdi        # 4177b0 <.LC2>
  40e92c:	41 b8 20 00 00 00    	mov    $0x20,%r8d
  40e932:	be 42 00 00 00       	mov    $0x42,%esi
  40e937:	e8 b4 6a ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40e93c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040e940 <_ZN11__sanitizer20StackDepotReverseMap10IdDescPair12IdComparatorERKS1_S3_>:
}

bool StackDepotReverseMap::IdDescPair::IdComparator(
    const StackDepotReverseMap::IdDescPair &a,
    const StackDepotReverseMap::IdDescPair &b) {
  return a.id < b.id;
  40e940:	8b 06                	mov    (%rsi),%eax
  40e942:	39 07                	cmp    %eax,(%rdi)
  40e944:	0f 92 c0             	setb   %al
}
  40e947:	c3                   	retq   
  40e948:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40e94f:	00 

000000000040e950 <_ZN11__sanitizer16StackDepotHandle2idEv>:
  typedef StackDepotHandle handle_type;
};

COMPILER_CHECK(StackDepotNode::kMaxUseCount == (u32)kStackDepotMaxUseCount);

u32 StackDepotHandle::id() { return node_->id; }
  40e950:	48 8b 07             	mov    (%rdi),%rax
  40e953:	8b 40 08             	mov    0x8(%rax),%eax
  40e956:	c3                   	retq   
  40e957:	90                   	nop
  40e958:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40e95f:	00 

000000000040e960 <_ZN11__sanitizer16StackDepotHandle9use_countEv>:
int StackDepotHandle::use_count() {
  return atomic_load(&node_->hash_and_use_count, memory_order_relaxed) &
  40e960:	48 8b 07             	mov    (%rdi),%rax
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  40e963:	8b 40 0c             	mov    0xc(%rax),%eax
         StackDepotNode::kUseCountMask;
  40e966:	25 ff ff 0f 00       	and    $0xfffff,%eax
}
  40e96b:	c3                   	retq   
  40e96c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040e970 <_ZN11__sanitizer16StackDepotHandle20inc_use_count_unsafeEv>:
template<typename T>
INLINE typename T::Type atomic_fetch_add(volatile T *a,
    typename T::Type v, memory_order mo) {
  (void)mo;
  DCHECK(!((uptr)a % sizeof(*a)));
  return __sync_fetch_and_add(&a->val_dont_use, v);
  40e970:	48 8b 07             	mov    (%rdi),%rax
  40e973:	ba 01 00 00 00       	mov    $0x1,%edx
  40e978:	f0 0f c1 50 0c       	lock xadd %edx,0xc(%rax)
void StackDepotHandle::inc_use_count_unsafe() {
  u32 prev =
      atomic_fetch_add(&node_->hash_and_use_count, 1, memory_order_relaxed) &
      StackDepotNode::kUseCountMask;
  40e97d:	89 d0                	mov    %edx,%eax
  40e97f:	25 ff ff 0f 00       	and    $0xfffff,%eax
  CHECK_LT(prev + 1, StackDepotNode::kMaxUseCount);
  40e984:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  40e989:	74 02                	je     40e98d <_ZN11__sanitizer16StackDepotHandle20inc_use_count_unsafeEv+0x1d>
  40e98b:	f3 c3                	repz retq 
  40e98d:	48 8d 15 34 8f 00 00 	lea    0x8f34(%rip),%rdx        # 4178c8 <.LC0>
u32 StackDepotHandle::id() { return node_->id; }
int StackDepotHandle::use_count() {
  return atomic_load(&node_->hash_and_use_count, memory_order_relaxed) &
         StackDepotNode::kUseCountMask;
}
void StackDepotHandle::inc_use_count_unsafe() {
  40e994:	50                   	push   %rax
  u32 prev =
      atomic_fetch_add(&node_->hash_and_use_count, 1, memory_order_relaxed) &
      StackDepotNode::kUseCountMask;
  CHECK_LT(prev + 1, StackDepotNode::kMaxUseCount);
  40e995:	48 8d 3d 5c 8f 00 00 	lea    0x8f5c(%rip),%rdi        # 4178f8 <.LC1>
  40e99c:	41 b8 00 00 10 00    	mov    $0x100000,%r8d
  40e9a2:	b9 00 00 10 00       	mov    $0x100000,%ecx
  40e9a7:	be 63 00 00 00       	mov    $0x63,%esi
  40e9ac:	e8 3f 6a ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40e9b1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40e9b8:	0f 1f 84 00 00 00 00 
  40e9bf:	00 

000000000040e9c0 <_ZN11__sanitizer18StackDepotGetStatsEv>:
    StackDepot;
static StackDepot theDepot;

StackDepotStats *StackDepotGetStats() {
  return theDepot.GetStats();
}
  40e9c0:	48 8d 05 59 34 a6 00 	lea    0xa63459(%rip),%rax        # e71e20 <_ZN11__sanitizerL8theDepotE+0x800400>
  40e9c7:	c3                   	retq   
  40e9c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40e9cf:	00 

000000000040e9d0 <_ZN11__sanitizer13StackDepotGetEj>:

StackDepotHandle StackDepotPut_WithHandle(StackTrace stack) {
  return theDepot.Put(stack);
}

StackTrace StackDepotGet(u32 id) {
  40e9d0:	48 83 ec 08          	sub    $0x8,%rsp
}

template <class Node, int kReservedBits, int kTabSizeLog>
typename StackDepotBase<Node, kReservedBits, kTabSizeLog>::args_type
StackDepotBase<Node, kReservedBits, kTabSizeLog>::Get(u32 id) {
  if (id == 0) {
  40e9d4:	85 ff                	test   %edi,%edi
  40e9d6:	0f 84 8c 00 00 00    	je     40ea68 <_ZN11__sanitizer13StackDepotGetEj+0x98>
    return args_type();
  }
  CHECK_EQ(id & (((u32)-1) >> kReservedBits), id);
  40e9dc:	89 f9                	mov    %edi,%ecx
  40e9de:	41 89 f8             	mov    %edi,%r8d
  40e9e1:	81 e1 ff ff ff 7f    	and    $0x7fffffff,%ecx
  40e9e7:	4c 39 c1             	cmp    %r8,%rcx
  40e9ea:	0f 85 a8 00 00 00    	jne    40ea98 <_ZN11__sanitizer13StackDepotGetEj+0xc8>
  // High kPartBits contain part id, so we need to scan at most kPartSize lists.
  uptr part = id >> kPartShift;
  40e9f0:	89 f9                	mov    %edi,%ecx
  40e9f2:	48 8d 05 27 30 26 00 	lea    0x263027(%rip),%rax        # 671a20 <_ZN11__sanitizerL8theDepotE>
  40e9f9:	31 d2                	xor    %edx,%edx
  40e9fb:	c1 e9 17             	shr    $0x17,%ecx
  40e9fe:	48 89 ce             	mov    %rcx,%rsi
  40ea01:	48 c1 e1 0c          	shl    $0xc,%rcx
  40ea05:	48 c1 e6 0f          	shl    $0xf,%rsi
  40ea09:	48 01 c6             	add    %rax,%rsi
  for (int i = 0; i != kPartSize; i++) {
    uptr idx = part * kPartSize + i;
    CHECK_LT(idx, kTabSize);
  40ea0c:	48 81 f9 ff ff 0f 00 	cmp    $0xfffff,%rcx
  40ea13:	77 65                	ja     40ea7a <_ZN11__sanitizer13StackDepotGetEj+0xaa>
  40ea15:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
    } else if (mo == memory_order_consume) {
      // Assume that processor respects data dependencies
      // (and that compiler won't break them).
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  40ea19:	48 8b 00             	mov    (%rax),%rax
    atomic_uintptr_t *p = &tab[idx];
    uptr v = atomic_load(p, memory_order_consume);
    Node *s = (Node *)(v & ~1);
    for (; s; s = s->link) {
  40ea1c:	48 83 e0 fe          	and    $0xfffffffffffffffe,%rax
  40ea20:	75 0e                	jne    40ea30 <_ZN11__sanitizer13StackDepotGetEj+0x60>
  40ea22:	eb 2c                	jmp    40ea50 <_ZN11__sanitizer13StackDepotGetEj+0x80>
  40ea24:	0f 1f 40 00          	nopl   0x0(%rax)
  40ea28:	48 8b 00             	mov    (%rax),%rax
  40ea2b:	48 85 c0             	test   %rax,%rax
  40ea2e:	74 20                	je     40ea50 <_ZN11__sanitizer13StackDepotGetEj+0x80>
      if (s->id == id) {
  40ea30:	3b 78 08             	cmp    0x8(%rax),%edi
  40ea33:	75 f3                	jne    40ea28 <_ZN11__sanitizer13StackDepotGetEj+0x58>
    size = args.size;
    tag = args.tag;
    internal_memcpy(stack, args.trace, size * sizeof(uptr));
  }
  args_type load() const {
    return args_type(&stack[0], size, tag);
  40ea35:	8b 48 14             	mov    0x14(%rax),%ecx
  40ea38:	8b 50 10             	mov    0x10(%rax),%edx
  40ea3b:	48 83 c0 18          	add    $0x18,%rax
  return theDepot.Put(stack);
}

StackTrace StackDepotGet(u32 id) {
  return theDepot.Get(id);
}
  40ea3f:	48 83 c4 08          	add    $0x8,%rsp
  40ea43:	48 c1 e1 20          	shl    $0x20,%rcx
  40ea47:	48 09 ca             	or     %rcx,%rdx
  40ea4a:	c3                   	retq   
  40ea4b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  40ea50:	48 83 c2 08          	add    $0x8,%rdx
  40ea54:	48 83 c1 01          	add    $0x1,%rcx
    return args_type();
  }
  CHECK_EQ(id & (((u32)-1) >> kReservedBits), id);
  // High kPartBits contain part id, so we need to scan at most kPartSize lists.
  uptr part = id >> kPartShift;
  for (int i = 0; i != kPartSize; i++) {
  40ea58:	48 81 fa 00 80 00 00 	cmp    $0x8000,%rdx
  40ea5f:	75 ab                	jne    40ea0c <_ZN11__sanitizer13StackDepotGetEj+0x3c>
  40ea61:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

template <class Node, int kReservedBits, int kTabSizeLog>
typename StackDepotBase<Node, kReservedBits, kTabSizeLog>::args_type
StackDepotBase<Node, kReservedBits, kTabSizeLog>::Get(u32 id) {
  if (id == 0) {
    return args_type();
  40ea68:	31 c9                	xor    %ecx,%ecx
  40ea6a:	31 d2                	xor    %edx,%edx
  40ea6c:	31 c0                	xor    %eax,%eax
  40ea6e:	48 c1 e1 20          	shl    $0x20,%rcx
  40ea72:	48 83 c4 08          	add    $0x8,%rsp
  40ea76:	48 09 ca             	or     %rcx,%rdx
  40ea79:	c3                   	retq   
  CHECK_EQ(id & (((u32)-1) >> kReservedBits), id);
  // High kPartBits contain part id, so we need to scan at most kPartSize lists.
  uptr part = id >> kPartShift;
  for (int i = 0; i != kPartSize; i++) {
    uptr idx = part * kPartSize + i;
    CHECK_LT(idx, kTabSize);
  40ea7a:	48 8d 15 4e a4 00 00 	lea    0xa44e(%rip),%rdx        # 418ecf <.LC4>
  40ea81:	48 8d 3d 18 8f 00 00 	lea    0x8f18(%rip),%rdi        # 4179a0 <.LC3>
  40ea88:	41 b8 00 00 10 00    	mov    $0x100000,%r8d
  40ea8e:	be 93 00 00 00       	mov    $0x93,%esi
  40ea93:	e8 58 69 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
typename StackDepotBase<Node, kReservedBits, kTabSizeLog>::args_type
StackDepotBase<Node, kReservedBits, kTabSizeLog>::Get(u32 id) {
  if (id == 0) {
    return args_type();
  }
  CHECK_EQ(id & (((u32)-1) >> kReservedBits), id);
  40ea98:	48 8d 15 d1 8e 00 00 	lea    0x8ed1(%rip),%rdx        # 417970 <.LC2>
  40ea9f:	48 8d 3d fa 8e 00 00 	lea    0x8efa(%rip),%rdi        # 4179a0 <.LC3>
  40eaa6:	be 8e 00 00 00       	mov    $0x8e,%esi
  40eaab:	e8 40 69 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

000000000040eab0 <_ZN11__sanitizer17StackDepotLockAllEv>:

void StackDepotLockAll() {
  40eab0:	41 54                	push   %r12
  40eab2:	4c 8d 25 67 2f a6 00 	lea    0xa62f67(%rip),%r12        # e71a20 <_ZN11__sanitizerL8theDepotE+0x800000>
  40eab9:	55                   	push   %rbp
  40eaba:	48 8d 2d 5f 2f 26 00 	lea    0x262f5f(%rip),%rbp        # 671a20 <_ZN11__sanitizerL8theDepotE>
  40eac1:	53                   	push   %rbx
  40eac2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

template <class Node, int kReservedBits, int kTabSizeLog>
Node *StackDepotBase<Node, kReservedBits, kTabSizeLog>::lock(
    atomic_uintptr_t *p) {
  // Uses the pointer lsb as mutex.
  for (int i = 0;; i++) {
  40eac8:	31 db                	xor    %ebx,%ebx
  40eaca:	eb 20                	jmp    40eaec <_ZN11__sanitizer17StackDepotLockAllEv+0x3c>
  40eacc:	0f 1f 40 00          	nopl   0x0(%rax)
    uptr cmp = atomic_load(p, memory_order_relaxed);
    if ((cmp & 1) == 0 &&
        atomic_compare_exchange_weak(p, &cmp, cmp | 1, memory_order_acquire))
      return (Node *)cmp;
    if (i < 10)
  40ead0:	83 fb 09             	cmp    $0x9,%ebx
  40ead3:	7f 4b                	jg     40eb20 <_ZN11__sanitizer17StackDepotLockAllEv+0x70>
namespace __sanitizer {

INLINE void proc_yield(int cnt) {
  __asm__ __volatile__("" ::: "memory");
  for (int i = 0; i < cnt; i++)
    __asm__ __volatile__("pause");
  40ead5:	f3 90                	pause  
  40ead7:	f3 90                	pause  
  40ead9:	f3 90                	pause  
  40eadb:	f3 90                	pause  
  40eadd:	f3 90                	pause  
  40eadf:	f3 90                	pause  
  40eae1:	f3 90                	pause  
  40eae3:	f3 90                	pause  
  40eae5:	f3 90                	pause  
  40eae7:	f3 90                	pause  

template <class Node, int kReservedBits, int kTabSizeLog>
Node *StackDepotBase<Node, kReservedBits, kTabSizeLog>::lock(
    atomic_uintptr_t *p) {
  // Uses the pointer lsb as mutex.
  for (int i = 0;; i++) {
  40eae9:	83 c3 01             	add    $0x1,%ebx
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  40eaec:	48 8b 55 00          	mov    0x0(%rbp),%rdx
    uptr cmp = atomic_load(p, memory_order_relaxed);
    if ((cmp & 1) == 0 &&
  40eaf0:	f6 c2 01             	test   $0x1,%dl
  40eaf3:	75 db                	jne    40ead0 <_ZN11__sanitizer17StackDepotLockAllEv+0x20>
        atomic_compare_exchange_weak(p, &cmp, cmp | 1, memory_order_acquire))
  40eaf5:	48 89 d1             	mov    %rdx,%rcx
                                           typename T::Type *cmp,
                                           typename T::Type xchg,
                                           memory_order mo) {
  typedef typename T::Type Type;
  Type cmpv = *cmp;
  Type prev = __sync_val_compare_and_swap(&a->val_dont_use, cmpv, xchg);
  40eaf8:	48 89 d0             	mov    %rdx,%rax
  40eafb:	48 83 c9 01          	or     $0x1,%rcx
  40eaff:	f0 48 0f b1 4d 00    	lock cmpxchg %rcx,0x0(%rbp)
  if (prev == cmpv)
  40eb05:	48 39 c2             	cmp    %rax,%rdx
  40eb08:	75 c6                	jne    40ead0 <_ZN11__sanitizer17StackDepotLockAllEv+0x20>
  40eb0a:	48 83 c5 08          	add    $0x8,%rbp
  return args_type();
}

template <class Node, int kReservedBits, int kTabSizeLog>
void StackDepotBase<Node, kReservedBits, kTabSizeLog>::LockAll() {
  for (int i = 0; i < kTabSize; ++i) {
  40eb0e:	4c 39 e5             	cmp    %r12,%rbp
  40eb11:	75 b5                	jne    40eac8 <_ZN11__sanitizer17StackDepotLockAllEv+0x18>
  theDepot.LockAll();
}
  40eb13:	5b                   	pop    %rbx
  40eb14:	5d                   	pop    %rbp
  40eb15:	41 5c                	pop    %r12
  40eb17:	c3                   	retq   
  40eb18:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40eb1f:	00 
        atomic_compare_exchange_weak(p, &cmp, cmp | 1, memory_order_acquire))
      return (Node *)cmp;
    if (i < 10)
      proc_yield(10);
    else
      internal_sched_yield();
  40eb20:	e8 fb ca ff ff       	callq  40b620 <_ZN11__sanitizer20internal_sched_yieldEv>
  40eb25:	eb c2                	jmp    40eae9 <_ZN11__sanitizer17StackDepotLockAllEv+0x39>
  40eb27:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40eb2e:	00 00 

000000000040eb30 <_ZN11__sanitizer19StackDepotUnlockAllEv>:

void StackDepotUnlockAll() {
  40eb30:	48 8d 05 e9 2e 26 00 	lea    0x262ee9(%rip),%rax        # 671a20 <_ZN11__sanitizerL8theDepotE>
  40eb37:	48 8d 0d e2 2e a6 00 	lea    0xa62ee2(%rip),%rcx        # e71a20 <_ZN11__sanitizerL8theDepotE+0x800000>
  40eb3e:	66 90                	xchg   %ax,%ax
  40eb40:	48 8b 10             	mov    (%rax),%rdx
template <class Node, int kReservedBits, int kTabSizeLog>
void StackDepotBase<Node, kReservedBits, kTabSizeLog>::UnlockAll() {
  for (int i = 0; i < kTabSize; ++i) {
    atomic_uintptr_t *p = &tab[i];
    uptr s = atomic_load(p, memory_order_relaxed);
    unlock(p, (Node *)(s & ~1UL));
  40eb43:	48 83 e2 fe          	and    $0xfffffffffffffffe,%rdx
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  40eb47:	48 89 10             	mov    %rdx,(%rax)
      __asm__ __volatile__("" ::: "memory");
  40eb4a:	48 83 c0 08          	add    $0x8,%rax
  }
}

template <class Node, int kReservedBits, int kTabSizeLog>
void StackDepotBase<Node, kReservedBits, kTabSizeLog>::UnlockAll() {
  for (int i = 0; i < kTabSize; ++i) {
  40eb4e:	48 39 c8             	cmp    %rcx,%rax
  40eb51:	75 ed                	jne    40eb40 <_ZN11__sanitizer19StackDepotUnlockAllEv+0x10>
  theDepot.UnlockAll();
}
  40eb53:	f3 c3                	repz retq 
  40eb55:	90                   	nop
  40eb56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40eb5d:	00 00 00 

000000000040eb60 <_ZN11__sanitizer20StackDepotReverseMapC1Ev>:
    const StackDepotReverseMap::IdDescPair &a,
    const StackDepotReverseMap::IdDescPair &b) {
  return a.id < b.id;
}

StackDepotReverseMap::StackDepotReverseMap()
  40eb60:	41 57                	push   %r15
  40eb62:	ba 01 00 00 00       	mov    $0x1,%edx
class InternalMmapVectorNoCtor {
 public:
  void Initialize(uptr initial_capacity) {
    capacity_ = Max(initial_capacity, (uptr)1);
    size_ = 0;
    data_ = (T *)MmapOrDie(capacity_ * sizeof(T), "InternalMmapVectorNoCtor");
  40eb67:	48 8d 35 78 a3 00 00 	lea    0xa378(%rip),%rsi        # 418ee6 <.LC0>
  40eb6e:	41 56                	push   %r14
  40eb70:	41 55                	push   %r13
  40eb72:	41 54                	push   %r12
  40eb74:	4c 8d 25 a5 2e 26 00 	lea    0x262ea5(%rip),%r12        # 671a20 <_ZN11__sanitizerL8theDepotE>
  40eb7b:	55                   	push   %rbp
  40eb7c:	48 89 fd             	mov    %rdi,%rbp
  40eb7f:	53                   	push   %rbx
  40eb80:	48 83 ec 08          	sub    $0x8,%rsp
  40eb84:	48 8b 05 95 32 a6 00 	mov    0xa63295(%rip),%rax        # e71e20 <_ZN11__sanitizerL8theDepotE+0x800400>
template<typename T>
class InternalMmapVectorNoCtor {
 public:
  void Initialize(uptr initial_capacity) {
    capacity_ = Max(initial_capacity, (uptr)1);
    size_ = 0;
  40eb8b:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  40eb92:	00 
  40eb93:	48 83 c0 64          	add    $0x64,%rax
  40eb97:	48 0f 44 c2          	cmove  %rdx,%rax
// WARNING: The current implementation supports only POD types.
template<typename T>
class InternalMmapVectorNoCtor {
 public:
  void Initialize(uptr initial_capacity) {
    capacity_ = Max(initial_capacity, (uptr)1);
  40eb9b:	48 89 47 08          	mov    %rax,0x8(%rdi)
    size_ = 0;
    data_ = (T *)MmapOrDie(capacity_ * sizeof(T), "InternalMmapVectorNoCtor");
  40eb9f:	48 c1 e0 04          	shl    $0x4,%rax
  40eba3:	48 89 c7             	mov    %rax,%rdi
  40eba6:	e8 f5 d7 ff ff       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  40ebab:	48 89 45 00          	mov    %rax,0x0(%rbp)
  40ebaf:	90                   	nop
      v = a->val_dont_use;
    } else if (mo == memory_order_consume) {
      // Assume that processor respects data dependencies
      // (and that compiler won't break them).
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  40ebb0:	49 8b 1c 24          	mov    (%r12),%rbx
    : map_(StackDepotGetStats()->n_uniq_ids + 100) {
  for (int idx = 0; idx < StackDepot::kTabSize; idx++) {
    atomic_uintptr_t *p = &theDepot.tab[idx];
    uptr v = atomic_load(p, memory_order_consume);
    StackDepotNode *s = (StackDepotNode*)(v & ~1);
    for (; s; s = s->link) {
  40ebb4:	48 83 e3 fe          	and    $0xfffffffffffffffe,%rbx
  40ebb8:	0f 84 c2 00 00 00    	je     40ec80 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x120>
  const T &operator[](uptr i) const {
    CHECK_LT(i, size_);
    return data_[i];
  }
  void push_back(const T &element) {
    CHECK_LE(size_, capacity_);
  40ebbe:	48 8b 45 10          	mov    0x10(%rbp),%rax
  40ebc2:	4c 8b 45 08          	mov    0x8(%rbp),%r8
      IdDescPair pair = {s->id, s};
  40ebc6:	44 8b 7b 08          	mov    0x8(%rbx),%r15d
  40ebca:	49 39 c0             	cmp    %rax,%r8
  40ebcd:	73 3d                	jae    40ec0c <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0xac>
  40ebcf:	e9 f1 02 00 00       	jmpq   40eec5 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x365>
  40ebd4:	0f 1f 40 00          	nopl   0x0(%rax)
    if (size_ == capacity_) {
      uptr new_capacity = RoundUpToPowerOfTwo(size_ + 1);
      Resize(new_capacity);
    }
    data_[size_++] = element;
  40ebd8:	48 8d 42 01          	lea    0x1(%rdx),%rax
  40ebdc:	48 c1 e2 04          	shl    $0x4,%rdx
  40ebe0:	48 03 55 00          	add    0x0(%rbp),%rdx
  40ebe4:	48 89 45 10          	mov    %rax,0x10(%rbp)
  40ebe8:	48 89 5a 08          	mov    %rbx,0x8(%rdx)
    : map_(StackDepotGetStats()->n_uniq_ids + 100) {
  for (int idx = 0; idx < StackDepot::kTabSize; idx++) {
    atomic_uintptr_t *p = &theDepot.tab[idx];
    uptr v = atomic_load(p, memory_order_consume);
    StackDepotNode *s = (StackDepotNode*)(v & ~1);
    for (; s; s = s->link) {
  40ebec:	48 8b 1b             	mov    (%rbx),%rbx
  40ebef:	44 89 3a             	mov    %r15d,(%rdx)
  40ebf2:	48 85 db             	test   %rbx,%rbx
  40ebf5:	0f 84 85 00 00 00    	je     40ec80 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x120>
  const T &operator[](uptr i) const {
    CHECK_LT(i, size_);
    return data_[i];
  }
  void push_back(const T &element) {
    CHECK_LE(size_, capacity_);
  40ebfb:	4c 8b 45 08          	mov    0x8(%rbp),%r8
      IdDescPair pair = {s->id, s};
  40ebff:	44 8b 7b 08          	mov    0x8(%rbx),%r15d
  40ec03:	49 39 c0             	cmp    %rax,%r8
  40ec06:	0f 82 b9 02 00 00    	jb     40eec5 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x365>
    if (size_ == capacity_) {
  40ec0c:	4c 39 c0             	cmp    %r8,%rax
  40ec0f:	48 89 c2             	mov    %rax,%rdx
  40ec12:	75 c4                	jne    40ebd8 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x78>
INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
}

INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  40ec14:	48 83 c2 01          	add    $0x1,%rdx
  40ec18:	0f 84 c2 02 00 00    	je     40eee0 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x380>
  if (IsPowerOfTwo(size)) return size;
  40ec1e:	48 85 c2             	test   %rax,%rdx
  40ec21:	49 89 d6             	mov    %rdx,%r14
  40ec24:	0f 85 56 01 00 00    	jne    40ed80 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x220>
  bool empty() const { return size() == 0; }

 private:
  void Resize(uptr new_capacity) {
    CHECK_GT(new_capacity, 0);
    CHECK_LE(size_, new_capacity);
  40ec2a:	4c 39 f0             	cmp    %r14,%rax
  40ec2d:	0f 87 8d 01 00 00    	ja     40edc0 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x260>
    T *new_data = (T *)MmapOrDie(new_capacity * sizeof(T),
                                 "InternalMmapVector");
  40ec33:	48 8d 35 0e a3 00 00 	lea    0xa30e(%rip),%rsi        # 418f48 <.LC11>
  40ec3a:	4c 89 f7             	mov    %r14,%rdi
  40ec3d:	48 c1 e7 04          	shl    $0x4,%rdi
  40ec41:	e8 5a d7 ff ff       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
    internal_memcpy(new_data, data_, size_ * sizeof(T));
  40ec46:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  40ec4a:	48 8b 75 00          	mov    0x0(%rbp),%rsi
  40ec4e:	48 89 c7             	mov    %rax,%rdi
 private:
  void Resize(uptr new_capacity) {
    CHECK_GT(new_capacity, 0);
    CHECK_LE(size_, new_capacity);
    T *new_data = (T *)MmapOrDie(new_capacity * sizeof(T),
                                 "InternalMmapVector");
  40ec51:	49 89 c5             	mov    %rax,%r13
    internal_memcpy(new_data, data_, size_ * sizeof(T));
  40ec54:	48 c1 e2 04          	shl    $0x4,%rdx
  40ec58:	e8 b3 b2 ff ff       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
    T *old_data = data_;
    data_ = new_data;
    UnmapOrDie(old_data, capacity_ * sizeof(T));
  40ec5d:	48 8b 75 08          	mov    0x8(%rbp),%rsi
    CHECK_GT(new_capacity, 0);
    CHECK_LE(size_, new_capacity);
    T *new_data = (T *)MmapOrDie(new_capacity * sizeof(T),
                                 "InternalMmapVector");
    internal_memcpy(new_data, data_, size_ * sizeof(T));
    T *old_data = data_;
  40ec61:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
    data_ = new_data;
  40ec65:	4c 89 6d 00          	mov    %r13,0x0(%rbp)
    UnmapOrDie(old_data, capacity_ * sizeof(T));
  40ec69:	48 c1 e6 04          	shl    $0x4,%rsi
  40ec6d:	e8 ce d7 ff ff       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
    capacity_ = new_capacity;
  40ec72:	4c 89 75 08          	mov    %r14,0x8(%rbp)
  40ec76:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  40ec7a:	e9 59 ff ff ff       	jmpq   40ebd8 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x78>
  40ec7f:	90                   	nop
  return a.id < b.id;
}

StackDepotReverseMap::StackDepotReverseMap()
    : map_(StackDepotGetStats()->n_uniq_ids + 100) {
  for (int idx = 0; idx < StackDepot::kTabSize; idx++) {
  40ec80:	48 8d 05 99 2d a6 00 	lea    0xa62d99(%rip),%rax        # e71a20 <_ZN11__sanitizerL8theDepotE+0x800000>
  40ec87:	49 83 c4 08          	add    $0x8,%r12
  40ec8b:	49 39 c4             	cmp    %rax,%r12
  40ec8e:	0f 85 1c ff ff ff    	jne    40ebb0 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x50>
    atomic_uintptr_t *p = &theDepot.tab[idx];
    uptr v = atomic_load(p, memory_order_consume);
    StackDepotNode *s = (StackDepotNode*)(v & ~1);
    for (; s; s = s->link) {
      IdDescPair pair = {s->id, s};
      map_.push_back(pair);
  40ec94:	4c 8b 45 10          	mov    0x10(%rbp),%r8
};

// HeapSort for arrays and InternalMmapVector.
template<class Container, class Compare>
void InternalSort(Container *v, uptr size, Compare comp) {
  if (size < 2)
  40ec98:	49 83 f8 01          	cmp    $0x1,%r8
  40ec9c:	0f 86 c5 00 00 00    	jbe    40ed67 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x207>
  40eca2:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
  }
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
  40eca6:	bb 01 00 00 00       	mov    $0x1,%ebx
    return;
  // Stage 1: insert elements to the heap.
  for (uptr i = 1; i < size; i++) {
    uptr j, p;
    for (j = i; j > 0; j = p) {
      p = (j - 1) / 2;
  40ecab:	31 c9                	xor    %ecx,%ecx
template<class Container, class Compare>
void InternalSort(Container *v, uptr size, Compare comp) {
  if (size < 2)
    return;
  // Stage 1: insert elements to the heap.
  for (uptr i = 1; i < size; i++) {
  40ecad:	49 89 d9             	mov    %rbx,%r9
  40ecb0:	eb 13                	jmp    40ecc5 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x165>
  40ecb2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    uptr j, p;
    for (j = i; j > 0; j = p) {
      p = (j - 1) / 2;
  40ecb8:	48 8d 41 ff          	lea    -0x1(%rcx),%rax
  40ecbc:	49 89 c9             	mov    %rcx,%r9
  40ecbf:	48 d1 e8             	shr    %rax
  40ecc2:	48 89 c1             	mov    %rax,%rcx
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
    return data_[i];
  40ecc5:	49 c1 e1 04          	shl    $0x4,%r9
  40ecc9:	49 01 f9             	add    %rdi,%r9
  }
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
  40eccc:	49 39 c8             	cmp    %rcx,%r8
  40eccf:	0f 86 98 02 00 00    	jbe    40ef6d <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x40d>
    return data_[i];
  40ecd5:	48 89 ce             	mov    %rcx,%rsi
}

bool StackDepotReverseMap::IdDescPair::IdComparator(
    const StackDepotReverseMap::IdDescPair &a,
    const StackDepotReverseMap::IdDescPair &b) {
  return a.id < b.id;
  40ecd8:	45 8b 11             	mov    (%r9),%r10d
  40ecdb:	48 c1 e6 04          	shl    $0x4,%rsi
  40ecdf:	48 01 fe             	add    %rdi,%rsi
  // Stage 1: insert elements to the heap.
  for (uptr i = 1; i < size; i++) {
    uptr j, p;
    for (j = i; j > 0; j = p) {
      p = (j - 1) / 2;
      if (comp((*v)[p], (*v)[j]))
  40ece2:	44 39 16             	cmp    %r10d,(%rsi)
  40ece5:	73 1e                	jae    40ed05 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x1a5>
// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  40ece7:	4d 8b 59 08          	mov    0x8(%r9),%r11
  a = b;
  40eceb:	48 8b 06             	mov    (%rsi),%rax
  if (size < 2)
    return;
  // Stage 1: insert elements to the heap.
  for (uptr i = 1; i < size; i++) {
    uptr j, p;
    for (j = i; j > 0; j = p) {
  40ecee:	48 85 c9             	test   %rcx,%rcx
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  a = b;
  40ecf1:	48 8b 56 08          	mov    0x8(%rsi),%rdx
  40ecf5:	49 89 01             	mov    %rax,(%r9)
  40ecf8:	49 89 51 08          	mov    %rdx,0x8(%r9)
  b = tmp;
  40ecfc:	44 89 16             	mov    %r10d,(%rsi)
  40ecff:	4c 89 5e 08          	mov    %r11,0x8(%rsi)
  if (size < 2)
    return;
  // Stage 1: insert elements to the heap.
  for (uptr i = 1; i < size; i++) {
    uptr j, p;
    for (j = i; j > 0; j = p) {
  40ed03:	75 b3                	jne    40ecb8 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x158>
template<class Container, class Compare>
void InternalSort(Container *v, uptr size, Compare comp) {
  if (size < 2)
    return;
  // Stage 1: insert elements to the heap.
  for (uptr i = 1; i < size; i++) {
  40ed05:	48 8d 43 01          	lea    0x1(%rbx),%rax
  40ed09:	4c 39 c0             	cmp    %r8,%rax
  40ed0c:	0f 84 cc 00 00 00    	je     40edde <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x27e>
    uptr j, p;
    for (j = i; j > 0; j = p) {
      p = (j - 1) / 2;
  40ed12:	48 89 d9             	mov    %rbx,%rcx
template<class Container, class Compare>
void InternalSort(Container *v, uptr size, Compare comp) {
  if (size < 2)
    return;
  // Stage 1: insert elements to the heap.
  for (uptr i = 1; i < size; i++) {
  40ed15:	48 89 c3             	mov    %rax,%rbx
    uptr j, p;
    for (j = i; j > 0; j = p) {
      p = (j - 1) / 2;
  40ed18:	48 d1 e9             	shr    %rcx
  40ed1b:	eb 90                	jmp    40ecad <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x14d>
  40ed1d:	0f 1f 00             	nopl   (%rax)
  }
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
  40ed20:	49 39 d0             	cmp    %rdx,%r8
  40ed23:	0f 86 26 02 00 00    	jbe    40ef4f <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x3ef>
    return data_[i];
  40ed29:	49 89 d1             	mov    %rdx,%r9
  40ed2c:	49 c1 e1 04          	shl    $0x4,%r9
  40ed30:	49 01 f9             	add    %rdi,%r9
  }
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
  40ed33:	49 39 f0             	cmp    %rsi,%r8
  40ed36:	0f 86 49 02 00 00    	jbe    40ef85 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x425>
  40ed3c:	49 89 f2             	mov    %rsi,%r10
      uptr left = 2 * j + 1;
      uptr right = 2 * j + 2;
      max_ind = j;
      if (left < i && comp((*v)[max_ind], (*v)[left]))
        max_ind = left;
      if (right < i && comp((*v)[max_ind], (*v)[right]))
  40ed3f:	45 8b 19             	mov    (%r9),%r11d
  40ed42:	49 c1 e2 04          	shl    $0x4,%r10
  40ed46:	46 39 1c 17          	cmp    %r11d,(%rdi,%r10,1)
  40ed4a:	0f 83 b5 01 00 00    	jae    40ef05 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x3a5>
        max_ind = right;
      if (max_ind != j)
  40ed50:	48 39 c2             	cmp    %rax,%rdx
  40ed53:	0f 85 a4 01 00 00    	jne    40eefd <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x39d>
  40ed59:	48 83 eb 10          	sub    $0x10,%rbx
        break;
    }
  }
  // Stage 2: swap largest element with the last one,
  // and sink the new top.
  for (uptr i = size - 1; i > 0; i--) {
  40ed5d:	48 83 e9 01          	sub    $0x1,%rcx
  40ed61:	0f 85 86 00 00 00    	jne    40eded <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x28d>
      IdDescPair pair = {s->id, s};
      map_.push_back(pair);
    }
  }
  InternalSort(&map_, map_.size(), IdDescPair::IdComparator);
}
  40ed67:	48 83 c4 08          	add    $0x8,%rsp
  40ed6b:	5b                   	pop    %rbx
  40ed6c:	5d                   	pop    %rbp
  40ed6d:	41 5c                	pop    %r12
  40ed6f:	41 5d                	pop    %r13
  40ed71:	41 5e                	pop    %r14
  40ed73:	41 5f                	pop    %r15
  40ed75:	c3                   	retq   
  40ed76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40ed7d:	00 00 00 
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  40ed80:	48 0f bd ca          	bsr    %rdx,%rcx
  40ed84:	be 3f 00 00 00       	mov    $0x3f,%esi
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  40ed89:	bf 01 00 00 00       	mov    $0x1,%edi
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  40ed8e:	48 83 f1 3f          	xor    $0x3f,%rcx
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  40ed92:	49 89 f8             	mov    %rdi,%r8
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  40ed95:	29 ce                	sub    %ecx,%esi
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  40ed97:	8d 4e 01             	lea    0x1(%rsi),%ecx
  40ed9a:	49 d3 e0             	shl    %cl,%r8
  40ed9d:	4c 39 c2             	cmp    %r8,%rdx
  40eda0:	0f 83 6f 01 00 00    	jae    40ef15 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x3b5>
  CHECK(size > (1ULL << up));
  40eda6:	89 f1                	mov    %esi,%ecx
  40eda8:	48 d3 e7             	shl    %cl,%rdi
  40edab:	48 39 fa             	cmp    %rdi,%rdx
  40edae:	0f 86 7e 01 00 00    	jbe    40ef32 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x3d2>
  40edb4:	4d 89 c6             	mov    %r8,%r14
  bool empty() const { return size() == 0; }

 private:
  void Resize(uptr new_capacity) {
    CHECK_GT(new_capacity, 0);
    CHECK_LE(size_, new_capacity);
  40edb7:	4c 39 f0             	cmp    %r14,%rax
  40edba:	0f 86 73 fe ff ff    	jbe    40ec33 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0xd3>
  40edc0:	48 8d 15 63 a1 00 00 	lea    0xa163(%rip),%rdx        # 418f2a <.LC10>
  40edc7:	48 8d 3d 42 62 00 00 	lea    0x6242(%rip),%rdi        # 415010 <.LC1>
  40edce:	4d 89 f0             	mov    %r14,%r8
  40edd1:	48 89 c1             	mov    %rax,%rcx
  40edd4:	be 09 02 00 00       	mov    $0x209,%esi
  40edd9:	e8 12 66 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40edde:	4c 89 c0             	mov    %r8,%rax
        break;
    }
  }
  // Stage 2: swap largest element with the last one,
  // and sink the new top.
  for (uptr i = size - 1; i > 0; i--) {
  40ede1:	48 89 d9             	mov    %rbx,%rcx
  40ede4:	48 c1 e0 04          	shl    $0x4,%rax
  40ede8:	48 8d 5c 07 f0       	lea    -0x10(%rdi,%rax,1),%rbx
  }
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
  40eded:	49 39 c8             	cmp    %rcx,%r8
  40edf0:	0f 86 77 01 00 00    	jbe    40ef6d <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x40d>
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  a = b;
  40edf6:	48 8b 03             	mov    (%rbx),%rax
// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  40edf9:	44 8b 0f             	mov    (%rdi),%r9d
  40edfc:	48 8b 77 08          	mov    0x8(%rdi),%rsi
  a = b;
  40ee00:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  40ee04:	48 89 07             	mov    %rax,(%rdi)
  // Stage 2: swap largest element with the last one,
  // and sink the new top.
  for (uptr i = size - 1; i > 0; i--) {
    Swap((*v)[0], (*v)[i]);
    uptr j, max_ind;
    for (j = 0; j < i; j = max_ind) {
  40ee07:	31 c0                	xor    %eax,%eax
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  a = b;
  40ee09:	48 89 57 08          	mov    %rdx,0x8(%rdi)
  b = tmp;
  40ee0d:	44 89 0b             	mov    %r9d,(%rbx)
  40ee10:	48 89 73 08          	mov    %rsi,0x8(%rbx)
  40ee14:	eb 6b                	jmp    40ee81 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x321>
  40ee16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40ee1d:	00 00 00 
    uptr j, max_ind;
    for (j = 0; j < i; j = max_ind) {
      uptr left = 2 * j + 1;
      uptr right = 2 * j + 2;
      max_ind = j;
      if (left < i && comp((*v)[max_ind], (*v)[left]))
  40ee20:	48 89 c6             	mov    %rax,%rsi
        max_ind = left;
      if (right < i && comp((*v)[max_ind], (*v)[right]))
  40ee23:	48 39 ca             	cmp    %rcx,%rdx
  40ee26:	0f 82 f4 fe ff ff    	jb     40ed20 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x1c0>
        max_ind = right;
      if (max_ind != j)
  40ee2c:	48 39 c6             	cmp    %rax,%rsi
  40ee2f:	0f 84 24 ff ff ff    	je     40ed59 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x1f9>
  }
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
  40ee35:	49 39 f0             	cmp    %rsi,%r8
  40ee38:	0f 86 47 01 00 00    	jbe    40ef85 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x425>
  40ee3e:	49 89 f1             	mov    %rsi,%r9
  40ee41:	49 c1 e1 04          	shl    $0x4,%r9
  40ee45:	49 01 f9             	add    %rdi,%r9
  40ee48:	49 39 c0             	cmp    %rax,%r8
  40ee4b:	0f 86 19 01 00 00    	jbe    40ef6a <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x40a>
    return data_[i];
  40ee51:	48 c1 e0 04          	shl    $0x4,%rax
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  a = b;
  40ee55:	49 8b 51 08          	mov    0x8(%r9),%rdx
  // Stage 2: swap largest element with the last one,
  // and sink the new top.
  for (uptr i = size - 1; i > 0; i--) {
    Swap((*v)[0], (*v)[i]);
    uptr j, max_ind;
    for (j = 0; j < i; j = max_ind) {
  40ee59:	48 39 ce             	cmp    %rcx,%rsi
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
    return data_[i];
  40ee5c:	4c 8d 14 07          	lea    (%rdi,%rax,1),%r10
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  a = b;
  40ee60:	49 8b 01             	mov    (%r9),%rax
// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
template<class T> T Max(T a, T b) { return a > b ? a : b; }
template<class T> void Swap(T& a, T& b) {
  T tmp = a;
  40ee63:	41 8b 2a             	mov    (%r10),%ebp
  40ee66:	4d 8b 5a 08          	mov    0x8(%r10),%r11
  a = b;
  40ee6a:	49 89 02             	mov    %rax,(%r10)
  40ee6d:	49 89 52 08          	mov    %rdx,0x8(%r10)
  b = tmp;
  40ee71:	41 89 29             	mov    %ebp,(%r9)
  40ee74:	4d 89 59 08          	mov    %r11,0x8(%r9)
  // Stage 2: swap largest element with the last one,
  // and sink the new top.
  for (uptr i = size - 1; i > 0; i--) {
    Swap((*v)[0], (*v)[i]);
    uptr j, max_ind;
    for (j = 0; j < i; j = max_ind) {
  40ee78:	0f 83 db fe ff ff    	jae    40ed59 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x1f9>
  40ee7e:	48 89 f0             	mov    %rsi,%rax
      uptr left = 2 * j + 1;
  40ee81:	48 8d 14 00          	lea    (%rax,%rax,1),%rdx
  40ee85:	48 8d 72 01          	lea    0x1(%rdx),%rsi
      uptr right = 2 * j + 2;
  40ee89:	48 83 c2 02          	add    $0x2,%rdx
      max_ind = j;
      if (left < i && comp((*v)[max_ind], (*v)[left]))
  40ee8d:	48 39 ce             	cmp    %rcx,%rsi
  40ee90:	73 8e                	jae    40ee20 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x2c0>
  }
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
  40ee92:	49 39 f0             	cmp    %rsi,%r8
  40ee95:	0f 86 ea 00 00 00    	jbe    40ef85 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x425>
    return data_[i];
  40ee9b:	49 89 f1             	mov    %rsi,%r9
  40ee9e:	49 c1 e1 04          	shl    $0x4,%r9
  40eea2:	49 01 f9             	add    %rdi,%r9
  }
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
  40eea5:	49 39 c0             	cmp    %rax,%r8
  40eea8:	0f 86 bc 00 00 00    	jbe    40ef6a <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x40a>
}

bool StackDepotReverseMap::IdDescPair::IdComparator(
    const StackDepotReverseMap::IdDescPair &a,
    const StackDepotReverseMap::IdDescPair &b) {
  return a.id < b.id;
  40eeae:	49 89 c2             	mov    %rax,%r10
    uptr j, max_ind;
    for (j = 0; j < i; j = max_ind) {
      uptr left = 2 * j + 1;
      uptr right = 2 * j + 2;
      max_ind = j;
      if (left < i && comp((*v)[max_ind], (*v)[left]))
  40eeb1:	45 8b 19             	mov    (%r9),%r11d
  40eeb4:	49 c1 e2 04          	shl    $0x4,%r10
  40eeb8:	46 39 1c 17          	cmp    %r11d,(%rdi,%r10,1)
  40eebc:	48 0f 43 f0          	cmovae %rax,%rsi
  40eec0:	e9 5e ff ff ff       	jmpq   40ee23 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x2c3>
  const T &operator[](uptr i) const {
    CHECK_LT(i, size_);
    return data_[i];
  }
  void push_back(const T &element) {
    CHECK_LE(size_, capacity_);
  40eec5:	48 8d 15 33 a0 00 00 	lea    0xa033(%rip),%rdx        # 418eff <.LC4>
  40eecc:	48 8d 3d 3d 61 00 00 	lea    0x613d(%rip),%rdi        # 415010 <.LC1>
  40eed3:	48 89 c1             	mov    %rax,%rcx
  40eed6:	be e7 01 00 00       	mov    $0x1e7,%esi
  40eedb:	e8 10 65 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
}

INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  40eee0:	48 8d 15 33 a0 00 00 	lea    0xa033(%rip),%rdx        # 418f1a <.LC5>
  40eee7:	48 8d 3d 22 61 00 00 	lea    0x6122(%rip),%rdi        # 415010 <.LC1>
  40eeee:	45 31 c0             	xor    %r8d,%r8d
  40eef1:	31 c9                	xor    %ecx,%ecx
  40eef3:	be 9f 01 00 00       	mov    $0x19f,%esi
  40eef8:	e8 f3 64 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
      max_ind = j;
      if (left < i && comp((*v)[max_ind], (*v)[left]))
        max_ind = left;
      if (right < i && comp((*v)[max_ind], (*v)[right]))
        max_ind = right;
      if (max_ind != j)
  40eefd:	48 89 d6             	mov    %rdx,%rsi
  40ef00:	e9 43 ff ff ff       	jmpq   40ee48 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x2e8>
  40ef05:	48 39 c6             	cmp    %rax,%rsi
  40ef08:	0f 85 30 ff ff ff    	jne    40ee3e <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x2de>
  40ef0e:	66 90                	xchg   %ax,%ax
  40ef10:	e9 44 fe ff ff       	jmpq   40ed59 <_ZN11__sanitizer20StackDepotReverseMapC1Ev+0x1f9>
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  40ef15:	48 8d 15 fc 8a 00 00 	lea    0x8afc(%rip),%rdx        # 417a18 <.LC2>
  40ef1c:	48 8d 3d ed 60 00 00 	lea    0x60ed(%rip),%rdi        # 415010 <.LC1>
  40ef23:	45 31 c0             	xor    %r8d,%r8d
  40ef26:	31 c9                	xor    %ecx,%ecx
  40ef28:	be a3 01 00 00       	mov    $0x1a3,%esi
  40ef2d:	e8 be 64 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  CHECK(size > (1ULL << up));
  40ef32:	48 8d 15 07 8b 00 00 	lea    0x8b07(%rip),%rdx        # 417a40 <.LC10>
  40ef39:	48 8d 3d d0 60 00 00 	lea    0x60d0(%rip),%rdi        # 415010 <.LC1>
  40ef40:	45 31 c0             	xor    %r8d,%r8d
  40ef43:	31 c9                	xor    %ecx,%ecx
  40ef45:	be a4 01 00 00       	mov    $0x1a4,%esi
  40ef4a:	e8 a1 64 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  }
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
  40ef4f:	48 89 d1             	mov    %rdx,%rcx
  40ef52:	48 8d 3d b7 60 00 00 	lea    0x60b7(%rip),%rdi        # 415010 <.LC1>
  40ef59:	48 8d 15 fb 9f 00 00 	lea    0x9ffb(%rip),%rdx        # 418f5b <.LC13>
  40ef60:	be df 01 00 00       	mov    $0x1df,%esi
  40ef65:	e8 86 64 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40ef6a:	48 89 c1             	mov    %rax,%rcx
  40ef6d:	48 8d 15 e7 9f 00 00 	lea    0x9fe7(%rip),%rdx        # 418f5b <.LC13>
  40ef74:	48 8d 3d 95 60 00 00 	lea    0x6095(%rip),%rdi        # 415010 <.LC1>
  40ef7b:	be df 01 00 00       	mov    $0x1df,%esi
  40ef80:	e8 6b 64 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40ef85:	48 8d 15 cf 9f 00 00 	lea    0x9fcf(%rip),%rdx        # 418f5b <.LC13>
  40ef8c:	48 8d 3d 7d 60 00 00 	lea    0x607d(%rip),%rdi        # 415010 <.LC1>
  40ef93:	48 89 f1             	mov    %rsi,%rcx
  40ef96:	be df 01 00 00       	mov    $0x1df,%esi
  40ef9b:	e8 50 64 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

000000000040efa0 <_ZN11__sanitizer20StackDepotReverseMap3GetEj>:
    }
  }
  InternalSort(&map_, map_.size(), IdDescPair::IdComparator);
}

StackTrace StackDepotReverseMap::Get(u32 id) {
  40efa0:	48 83 ec 08          	sub    $0x8,%rsp
  if (!map_.size())
  40efa4:	4c 8b 47 10          	mov    0x10(%rdi),%r8
  40efa8:	4d 85 c0             	test   %r8,%r8
  40efab:	75 13                	jne    40efc0 <_ZN11__sanitizer20StackDepotReverseMap3GetEj+0x20>
    return StackTrace();
  40efad:	31 c0                	xor    %eax,%eax
  40efaf:	31 d2                	xor    %edx,%edx
  uptr idx = InternalBinarySearch(map_, 0, map_.size(), pair,
                                  IdDescPair::IdComparator);
  if (idx > map_.size())
    return StackTrace();
  return map_[idx].desc->load();
}
  40efb1:	48 83 c4 08          	add    $0x8,%rsp
  40efb5:	c3                   	retq   
  40efb6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40efbd:	00 00 00 
  40efc0:	4c 8b 17             	mov    (%rdi),%r10
}

template<class Container, class Value, class Compare>
uptr InternalBinarySearch(const Container &v, uptr first, uptr last,
                          const Value &val, Compare comp) {
  uptr not_found = last + 1;
  40efc3:	49 8d 48 01          	lea    0x1(%r8),%rcx
  40efc7:	4c 89 c7             	mov    %r8,%rdi
  40efca:	31 d2                	xor    %edx,%edx
  40efcc:	eb 0b                	jmp    40efd9 <_ZN11__sanitizer20StackDepotReverseMap3GetEj+0x39>
  40efce:	66 90                	xchg   %ax,%ax
  while (last >= first) {
    uptr mid = (first + last) / 2;
    if (comp(v[mid], val))
      first = mid + 1;
  40efd0:	48 8d 50 01          	lea    0x1(%rax),%rdx

template<class Container, class Value, class Compare>
uptr InternalBinarySearch(const Container &v, uptr first, uptr last,
                          const Value &val, Compare comp) {
  uptr not_found = last + 1;
  while (last >= first) {
  40efd4:	48 39 d7             	cmp    %rdx,%rdi
  40efd7:	72 24                	jb     40effd <_ZN11__sanitizer20StackDepotReverseMap3GetEj+0x5d>
    uptr mid = (first + last) / 2;
  40efd9:	48 8d 04 17          	lea    (%rdi,%rdx,1),%rax
  40efdd:	48 d1 e8             	shr    %rax
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
    return data_[i];
  }
  const T &operator[](uptr i) const {
    CHECK_LT(i, size_);
  40efe0:	49 39 c0             	cmp    %rax,%r8
  40efe3:	76 3e                	jbe    40f023 <_ZN11__sanitizer20StackDepotReverseMap3GetEj+0x83>
}

bool StackDepotReverseMap::IdDescPair::IdComparator(
    const StackDepotReverseMap::IdDescPair &a,
    const StackDepotReverseMap::IdDescPair &b) {
  return a.id < b.id;
  40efe5:	49 89 c1             	mov    %rax,%r9
  40efe8:	49 c1 e1 04          	shl    $0x4,%r9
uptr InternalBinarySearch(const Container &v, uptr first, uptr last,
                          const Value &val, Compare comp) {
  uptr not_found = last + 1;
  while (last >= first) {
    uptr mid = (first + last) / 2;
    if (comp(v[mid], val))
  40efec:	43 3b 34 0a          	cmp    (%r10,%r9,1),%esi
  40eff0:	77 de                	ja     40efd0 <_ZN11__sanitizer20StackDepotReverseMap3GetEj+0x30>
      first = mid + 1;
    else if (comp(val, v[mid]))
  40eff2:	73 62                	jae    40f056 <_ZN11__sanitizer20StackDepotReverseMap3GetEj+0xb6>
      last = mid - 1;
  40eff4:	48 8d 78 ff          	lea    -0x1(%rax),%rdi

template<class Container, class Value, class Compare>
uptr InternalBinarySearch(const Container &v, uptr first, uptr last,
                          const Value &val, Compare comp) {
  uptr not_found = last + 1;
  while (last >= first) {
  40eff8:	48 39 d7             	cmp    %rdx,%rdi
  40effb:	73 dc                	jae    40efd9 <_ZN11__sanitizer20StackDepotReverseMap3GetEj+0x39>
  if (!map_.size())
    return StackTrace();
  IdDescPair pair = {id, nullptr};
  uptr idx = InternalBinarySearch(map_, 0, map_.size(), pair,
                                  IdDescPair::IdComparator);
  if (idx > map_.size())
  40effd:	49 39 c8             	cmp    %rcx,%r8
  40f000:	72 ab                	jb     40efad <_ZN11__sanitizer20StackDepotReverseMap3GetEj+0xd>
  }
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
  40f002:	76 3a                	jbe    40f03e <_ZN11__sanitizer20StackDepotReverseMap3GetEj+0x9e>
    return StackTrace();
  return map_[idx].desc->load();
  40f004:	48 c1 e1 04          	shl    $0x4,%rcx
  40f008:	49 8b 54 0a 08       	mov    0x8(%r10,%rcx,1),%rdx
  40f00d:	8b 4a 14             	mov    0x14(%rdx),%ecx
  40f010:	48 8d 42 18          	lea    0x18(%rdx),%rax
  40f014:	8b 52 10             	mov    0x10(%rdx),%edx
}
  40f017:	48 83 c4 08          	add    $0x8,%rsp
  40f01b:	48 c1 e1 20          	shl    $0x20,%rcx
  40f01f:	48 09 ca             	or     %rcx,%rdx
  40f022:	c3                   	retq   
    return data_[i];
  }
  const T &operator[](uptr i) const {
    CHECK_LT(i, size_);
  40f023:	48 8d 15 31 9f 00 00 	lea    0x9f31(%rip),%rdx        # 418f5b <.LC13>
  40f02a:	48 8d 3d df 5f 00 00 	lea    0x5fdf(%rip),%rdi        # 415010 <.LC1>
  40f031:	48 89 c1             	mov    %rax,%rcx
  40f034:	be e3 01 00 00       	mov    $0x1e3,%esi
  40f039:	e8 b2 63 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  }
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
  40f03e:	48 8d 15 16 9f 00 00 	lea    0x9f16(%rip),%rdx        # 418f5b <.LC13>
  40f045:	48 8d 3d c4 5f 00 00 	lea    0x5fc4(%rip),%rdi        # 415010 <.LC1>
  40f04c:	be df 01 00 00       	mov    $0x1df,%esi
  40f051:	e8 9a 63 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
template<class Container, class Value, class Compare>
uptr InternalBinarySearch(const Container &v, uptr first, uptr last,
                          const Value &val, Compare comp) {
  uptr not_found = last + 1;
  while (last >= first) {
    uptr mid = (first + last) / 2;
  40f056:	48 89 c1             	mov    %rax,%rcx
  40f059:	eb a9                	jmp    40f004 <_ZN11__sanitizer20StackDepotReverseMap3GetEj+0x64>
  40f05b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000040f060 <_ZN11__sanitizer13StackDepotPutENS_10StackTraceE>:

StackDepotStats *StackDepotGetStats() {
  return theDepot.GetStats();
}

u32 StackDepotPut(StackTrace stack) {
  40f060:	48 89 f2             	mov    %rsi,%rdx
  StackDepotHandle h = theDepot.Put(stack);
  40f063:	48 89 fe             	mov    %rdi,%rsi
  40f066:	48 8d 3d b3 29 26 00 	lea    0x2629b3(%rip),%rdi        # 671a20 <_ZN11__sanitizerL8theDepotE>

StackDepotStats *StackDepotGetStats() {
  return theDepot.GetStats();
}

u32 StackDepotPut(StackTrace stack) {
  40f06d:	48 83 ec 08          	sub    $0x8,%rsp
  StackDepotHandle h = theDepot.Put(stack);
  40f071:	31 c9                	xor    %ecx,%ecx
  40f073:	e8 38 00 00 00       	callq  40f0b0 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb>
  return h.valid() ? h.id() : 0;
  40f078:	48 85 c0             	test   %rax,%rax
  40f07b:	74 0b                	je     40f088 <_ZN11__sanitizer13StackDepotPutENS_10StackTraceE+0x28>
  typedef StackDepotHandle handle_type;
};

COMPILER_CHECK(StackDepotNode::kMaxUseCount == (u32)kStackDepotMaxUseCount);

u32 StackDepotHandle::id() { return node_->id; }
  40f07d:	8b 40 08             	mov    0x8(%rax),%eax
}

u32 StackDepotPut(StackTrace stack) {
  StackDepotHandle h = theDepot.Put(stack);
  return h.valid() ? h.id() : 0;
}
  40f080:	48 83 c4 08          	add    $0x8,%rsp
  40f084:	c3                   	retq   
  40f085:	0f 1f 00             	nopl   (%rax)
  return theDepot.GetStats();
}

u32 StackDepotPut(StackTrace stack) {
  StackDepotHandle h = theDepot.Put(stack);
  return h.valid() ? h.id() : 0;
  40f088:	31 c0                	xor    %eax,%eax
}
  40f08a:	48 83 c4 08          	add    $0x8,%rsp
  40f08e:	c3                   	retq   
  40f08f:	90                   	nop

000000000040f090 <_ZN11__sanitizer24StackDepotPut_WithHandleENS_10StackTraceE>:

StackDepotHandle StackDepotPut_WithHandle(StackTrace stack) {
  40f090:	48 89 f2             	mov    %rsi,%rdx
  return theDepot.Put(stack);
  40f093:	48 89 fe             	mov    %rdi,%rsi
  40f096:	48 8d 3d 83 29 26 00 	lea    0x262983(%rip),%rdi        # 671a20 <_ZN11__sanitizerL8theDepotE>
u32 StackDepotPut(StackTrace stack) {
  StackDepotHandle h = theDepot.Put(stack);
  return h.valid() ? h.id() : 0;
}

StackDepotHandle StackDepotPut_WithHandle(StackTrace stack) {
  40f09d:	48 83 ec 08          	sub    $0x8,%rsp
  return theDepot.Put(stack);
  40f0a1:	31 c9                	xor    %ecx,%ecx
  40f0a3:	e8 08 00 00 00       	callq  40f0b0 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb>
}
  40f0a8:	48 83 c4 08          	add    $0x8,%rsp
  40f0ac:	c3                   	retq   
  40f0ad:	0f 1f 00             	nopl   (%rax)

000000000040f0b0 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb>:
  atomic_store(p, (uptr)s, memory_order_release);
}

template <class Node, int kReservedBits, int kTabSizeLog>
typename StackDepotBase<Node, kReservedBits, kTabSizeLog>::handle_type
StackDepotBase<Node, kReservedBits, kTabSizeLog>::Put(args_type args,
  40f0b0:	41 57                	push   %r15
  40f0b2:	48 89 d0             	mov    %rdx,%rax
  40f0b5:	41 89 d7             	mov    %edx,%r15d
  40f0b8:	48 c1 e8 20          	shr    $0x20,%rax
  40f0bc:	41 56                	push   %r14
  40f0be:	41 55                	push   %r13
  40f0c0:	41 54                	push   %r12
  40f0c2:	49 89 fc             	mov    %rdi,%r12
  40f0c5:	89 c7                	mov    %eax,%edi
  40f0c7:	55                   	push   %rbp
  40f0c8:	53                   	push   %rbx
  40f0c9:	48 89 f3             	mov    %rsi,%rbx
  40f0cc:	48 83 ec 48          	sub    $0x48,%rsp
                                                      bool *inserted) {
  if (inserted) *inserted = false;
  40f0d0:	48 85 c9             	test   %rcx,%rcx
  40f0d3:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40f0d8:	74 03                	je     40f0dd <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x2d>
  40f0da:	c6 01 00             	movb   $0x0,(%rcx)
    h *= m;
    h ^= h >> 15;
    return h;
  }
  static bool is_valid(const args_type &args) {
    return args.size > 0 && args.trace;
  40f0dd:	85 d2                	test   %edx,%edx
  40f0df:	0f 84 eb 01 00 00    	je     40f2d0 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x220>
  40f0e5:	48 85 db             	test   %rbx,%rbx
  40f0e8:	0f 84 e2 01 00 00    	je     40f2d0 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x220>
  static u32 hash(const args_type &args) {
    // murmur2
    const u32 m = 0x5bd1e995;
    const u32 seed = 0x9747b28c;
    const u32 r = 24;
    u32 h = seed ^ (args.size * sizeof(uptr));
  40f0ee:	8d 04 d5 00 00 00 00 	lea    0x0(,%rdx,8),%eax
    for (uptr i = 0; i < args.size; i++) {
  40f0f5:	89 d5                	mov    %edx,%ebp
  40f0f7:	31 f6                	xor    %esi,%esi
  static u32 hash(const args_type &args) {
    // murmur2
    const u32 m = 0x5bd1e995;
    const u32 seed = 0x9747b28c;
    const u32 r = 24;
    u32 h = seed ^ (args.size * sizeof(uptr));
  40f0f9:	35 8c b2 47 97       	xor    $0x9747b28c,%eax
  40f0fe:	66 90                	xchg   %ax,%ax
    for (uptr i = 0; i < args.size; i++) {
      u32 k = args.trace[i];
      k *= m;
  40f100:	44 8b 04 f3          	mov    (%rbx,%rsi,8),%r8d
    // murmur2
    const u32 m = 0x5bd1e995;
    const u32 seed = 0x9747b28c;
    const u32 r = 24;
    u32 h = seed ^ (args.size * sizeof(uptr));
    for (uptr i = 0; i < args.size; i++) {
  40f104:	48 83 c6 01          	add    $0x1,%rsi
      u32 k = args.trace[i];
      k *= m;
  40f108:	45 69 c8 95 e9 d1 5b 	imul   $0x5bd1e995,%r8d,%r9d
      k ^= k >> r;
  40f10f:	45 89 c8             	mov    %r9d,%r8d
  40f112:	41 c1 e8 18          	shr    $0x18,%r8d
  40f116:	45 31 c8             	xor    %r9d,%r8d
      k *= m;
      h *= m;
  40f119:	44 69 c8 95 e9 d1 5b 	imul   $0x5bd1e995,%eax,%r9d
    u32 h = seed ^ (args.size * sizeof(uptr));
    for (uptr i = 0; i < args.size; i++) {
      u32 k = args.trace[i];
      k *= m;
      k ^= k >> r;
      k *= m;
  40f120:	41 69 c0 95 e9 d1 5b 	imul   $0x5bd1e995,%r8d,%eax
      h *= m;
      h ^= k;
  40f127:	44 31 c8             	xor    %r9d,%eax
    // murmur2
    const u32 m = 0x5bd1e995;
    const u32 seed = 0x9747b28c;
    const u32 r = 24;
    u32 h = seed ^ (args.size * sizeof(uptr));
    for (uptr i = 0; i < args.size; i++) {
  40f12a:	48 39 ee             	cmp    %rbp,%rsi
  40f12d:	72 d1                	jb     40f100 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x50>
      k ^= k >> r;
      k *= m;
      h *= m;
      h ^= k;
    }
    h ^= h >> 13;
  40f12f:	89 c6                	mov    %eax,%esi
  40f131:	c1 ee 0d             	shr    $0xd,%esi
  40f134:	31 c6                	xor    %eax,%esi
    h *= m;
  40f136:	69 f6 95 e9 d1 5b    	imul   $0x5bd1e995,%esi,%esi
    h ^= h >> 15;
  40f13c:	41 89 f6             	mov    %esi,%r14d
  40f13f:	41 c1 ee 0f          	shr    $0xf,%r14d
  40f143:	41 31 f6             	xor    %esi,%r14d
  if (!Node::is_valid(args)) return handle_type();
  uptr h = Node::hash(args);
  atomic_uintptr_t *p = &tab[h % kTabSize];
  40f146:	44 89 f0             	mov    %r14d,%eax
  40f149:	25 ff ff 0f 00       	and    $0xfffff,%eax
  40f14e:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  40f153:	4d 8d 2c c4          	lea    (%r12,%rax,8),%r13
  40f157:	49 8b 45 00          	mov    0x0(%r13),%rax
template <class Node, int kReservedBits, int kTabSizeLog>
Node *StackDepotBase<Node, kReservedBits, kTabSizeLog>::find(Node *s,
                                                             args_type args,
                                                             u32 hash) {
  // Searches linked list s for the stack, returns its id.
  for (; s; s = s->link) {
  40f15b:	48 83 e0 fe          	and    $0xfffffffffffffffe,%rax
  40f15f:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  40f164:	0f 84 7e 00 00 00    	je     40f1e8 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x138>
  40f16a:	45 89 f1             	mov    %r14d,%r9d

  typedef StackTrace args_type;
  bool eq(u32 hash, const args_type &args) const {
    u32 hash_bits =
        atomic_load(&hash_and_use_count, memory_order_relaxed) & kHashMask;
    if ((hash & kHashMask) != hash_bits || args.size != size || args.tag != tag)
  40f16d:	49 89 fa             	mov    %rdi,%r10
  40f170:	45 89 fb             	mov    %r15d,%r11d
  40f173:	41 81 e1 00 00 f0 ff 	and    $0xfff00000,%r9d
  40f17a:	49 c1 e2 20          	shl    $0x20,%r10
  40f17e:	eb 08                	jmp    40f188 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0xd8>
  40f180:	48 8b 00             	mov    (%rax),%rax
  40f183:	48 85 c0             	test   %rax,%rax
  40f186:	74 60                	je     40f1e8 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x138>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  40f188:	8b 70 0c             	mov    0xc(%rax),%esi
  static const u32 kHashMask = ~kUseCountMask;

  typedef StackTrace args_type;
  bool eq(u32 hash, const args_type &args) const {
    u32 hash_bits =
        atomic_load(&hash_and_use_count, memory_order_relaxed) & kHashMask;
  40f18b:	81 e6 00 00 f0 ff    	and    $0xfff00000,%esi
    if ((hash & kHashMask) != hash_bits || args.size != size || args.tag != tag)
  40f191:	41 39 f1             	cmp    %esi,%r9d
  40f194:	75 ea                	jne    40f180 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0xd0>
  40f196:	4c 89 de             	mov    %r11,%rsi
  40f199:	4c 09 d6             	or     %r10,%rsi
  40f19c:	48 39 70 10          	cmp    %rsi,0x10(%rax)
  40f1a0:	75 de                	jne    40f180 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0xd0>
      return false;
    uptr i = 0;
    for (; i < size; i++) {
  40f1a2:	44 8b 40 10          	mov    0x10(%rax),%r8d
  40f1a6:	4d 85 c0             	test   %r8,%r8
  40f1a9:	0f 84 23 01 00 00    	je     40f2d2 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x222>
      if (stack[i] != args.trace[i]) return false;
  40f1af:	48 8b 33             	mov    (%rbx),%rsi
  40f1b2:	48 39 70 18          	cmp    %rsi,0x18(%rax)
  40f1b6:	75 c8                	jne    40f180 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0xd0>
  40f1b8:	31 f6                	xor    %esi,%esi
  40f1ba:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
  40f1bf:	90                   	nop
    u32 hash_bits =
        atomic_load(&hash_and_use_count, memory_order_relaxed) & kHashMask;
    if ((hash & kHashMask) != hash_bits || args.size != size || args.tag != tag)
      return false;
    uptr i = 0;
    for (; i < size; i++) {
  40f1c0:	48 83 c6 01          	add    $0x1,%rsi
  40f1c4:	4c 39 c6             	cmp    %r8,%rsi
  40f1c7:	0f 83 05 01 00 00    	jae    40f2d2 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x222>
      if (stack[i] != args.trace[i]) return false;
  40f1cd:	48 8b 14 f3          	mov    (%rbx,%rsi,8),%rdx
  40f1d1:	48 39 54 f0 18       	cmp    %rdx,0x18(%rax,%rsi,8)
  40f1d6:	74 e8                	je     40f1c0 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x110>
  40f1d8:	48 8b 00             	mov    (%rax),%rax
  40f1db:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  40f1e0:	48 85 c0             	test   %rax,%rax
  40f1e3:	75 a3                	jne    40f188 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0xd8>
  40f1e5:	0f 1f 00             	nopl   (%rax)
  40f1e8:	31 f6                	xor    %esi,%esi
  40f1ea:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
  40f1ef:	89 f3                	mov    %esi,%ebx
  40f1f1:	eb 25                	jmp    40f218 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x168>
  40f1f3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  for (int i = 0;; i++) {
    uptr cmp = atomic_load(p, memory_order_relaxed);
    if ((cmp & 1) == 0 &&
        atomic_compare_exchange_weak(p, &cmp, cmp | 1, memory_order_acquire))
      return (Node *)cmp;
    if (i < 10)
  40f1f8:	83 fb 09             	cmp    $0x9,%ebx
  40f1fb:	0f 8f e7 00 00 00    	jg     40f2e8 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x238>
namespace __sanitizer {

INLINE void proc_yield(int cnt) {
  __asm__ __volatile__("" ::: "memory");
  for (int i = 0; i < cnt; i++)
    __asm__ __volatile__("pause");
  40f201:	f3 90                	pause  
  40f203:	f3 90                	pause  
  40f205:	f3 90                	pause  
  40f207:	f3 90                	pause  
  40f209:	f3 90                	pause  
  40f20b:	f3 90                	pause  
  40f20d:	f3 90                	pause  
  40f20f:	f3 90                	pause  
  40f211:	f3 90                	pause  
  40f213:	f3 90                	pause  

template <class Node, int kReservedBits, int kTabSizeLog>
Node *StackDepotBase<Node, kReservedBits, kTabSizeLog>::lock(
    atomic_uintptr_t *p) {
  // Uses the pointer lsb as mutex.
  for (int i = 0;; i++) {
  40f215:	83 c3 01             	add    $0x1,%ebx
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  40f218:	4d 8b 4d 00          	mov    0x0(%r13),%r9
    uptr cmp = atomic_load(p, memory_order_relaxed);
    if ((cmp & 1) == 0 &&
  40f21c:	41 f6 c1 01          	test   $0x1,%r9b
  40f220:	75 d6                	jne    40f1f8 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x148>
        atomic_compare_exchange_weak(p, &cmp, cmp | 1, memory_order_acquire))
  40f222:	4c 89 ce             	mov    %r9,%rsi
                                           typename T::Type *cmp,
                                           typename T::Type xchg,
                                           memory_order mo) {
  typedef typename T::Type Type;
  Type cmpv = *cmp;
  Type prev = __sync_val_compare_and_swap(&a->val_dont_use, cmpv, xchg);
  40f225:	4c 89 c8             	mov    %r9,%rax
  40f228:	48 83 ce 01          	or     $0x1,%rsi
  40f22c:	f0 49 0f b1 75 00    	lock cmpxchg %rsi,0x0(%r13)
  if (prev == cmpv)
  40f232:	49 39 c1             	cmp    %rax,%r9
  40f235:	75 c1                	jne    40f1f8 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x148>
  // First, try to find the existing stack.
  Node *node = find(s, args, h);
  if (node) return node->get_handle();
  // If failed, lock, retry and insert new.
  Node *s2 = lock(p);
  if (s2 != s) {
  40f237:	4c 39 4c 24 18       	cmp    %r9,0x18(%rsp)
  40f23c:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
  40f241:	0f 84 c7 00 00 00    	je     40f30e <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x25e>
template <class Node, int kReservedBits, int kTabSizeLog>
Node *StackDepotBase<Node, kReservedBits, kTabSizeLog>::find(Node *s,
                                                             args_type args,
                                                             u32 hash) {
  // Searches linked list s for the stack, returns its id.
  for (; s; s = s->link) {
  40f247:	4d 85 c9             	test   %r9,%r9
  40f24a:	0f 84 be 00 00 00    	je     40f30e <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x25e>
  40f250:	45 89 f0             	mov    %r14d,%r8d

  typedef StackTrace args_type;
  bool eq(u32 hash, const args_type &args) const {
    u32 hash_bits =
        atomic_load(&hash_and_use_count, memory_order_relaxed) & kHashMask;
    if ((hash & kHashMask) != hash_bits || args.size != size || args.tag != tag)
  40f253:	49 89 fa             	mov    %rdi,%r10
  40f256:	4c 89 c8             	mov    %r9,%rax
  40f259:	41 81 e0 00 00 f0 ff 	and    $0xfff00000,%r8d
  40f260:	49 c1 e2 20          	shl    $0x20,%r10
  40f264:	eb 16                	jmp    40f27c <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x1cc>
  40f266:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40f26d:	00 00 00 
  40f270:	48 8b 00             	mov    (%rax),%rax
  40f273:	48 85 c0             	test   %rax,%rax
  40f276:	0f 84 92 00 00 00    	je     40f30e <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x25e>
  40f27c:	8b 70 0c             	mov    0xc(%rax),%esi
  static const u32 kHashMask = ~kUseCountMask;

  typedef StackTrace args_type;
  bool eq(u32 hash, const args_type &args) const {
    u32 hash_bits =
        atomic_load(&hash_and_use_count, memory_order_relaxed) & kHashMask;
  40f27f:	81 e6 00 00 f0 ff    	and    $0xfff00000,%esi
    if ((hash & kHashMask) != hash_bits || args.size != size || args.tag != tag)
  40f285:	44 39 c6             	cmp    %r8d,%esi
  40f288:	75 e6                	jne    40f270 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x1c0>
  40f28a:	4c 89 fe             	mov    %r15,%rsi
  40f28d:	4c 09 d6             	or     %r10,%rsi
  40f290:	48 39 70 10          	cmp    %rsi,0x10(%rax)
  40f294:	75 da                	jne    40f270 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x1c0>
      return false;
    uptr i = 0;
    for (; i < size; i++) {
  40f296:	8b 78 10             	mov    0x10(%rax),%edi
  40f299:	48 85 ff             	test   %rdi,%rdi
  40f29c:	74 26                	je     40f2c4 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x214>
      if (stack[i] != args.trace[i]) return false;
  40f29e:	48 8b 33             	mov    (%rbx),%rsi
  40f2a1:	48 39 70 18          	cmp    %rsi,0x18(%rax)
  40f2a5:	75 c9                	jne    40f270 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x1c0>
  40f2a7:	31 f6                	xor    %esi,%esi
  40f2a9:	eb 10                	jmp    40f2bb <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x20b>
  40f2ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  40f2b0:	4c 8b 1c f3          	mov    (%rbx,%rsi,8),%r11
  40f2b4:	4c 39 5c f0 18       	cmp    %r11,0x18(%rax,%rsi,8)
  40f2b9:	75 b5                	jne    40f270 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x1c0>
    u32 hash_bits =
        atomic_load(&hash_and_use_count, memory_order_relaxed) & kHashMask;
    if ((hash & kHashMask) != hash_bits || args.size != size || args.tag != tag)
      return false;
    uptr i = 0;
    for (; i < size; i++) {
  40f2bb:	48 83 c6 01          	add    $0x1,%rsi
  40f2bf:	48 39 f7             	cmp    %rsi,%rdi
  40f2c2:	77 ec                	ja     40f2b0 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x200>
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  40f2c4:	4d 89 4d 00          	mov    %r9,0x0(%r13)
      __asm__ __volatile__("" ::: "memory");
  40f2c8:	eb 08                	jmp    40f2d2 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x222>
  40f2ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
template <class Node, int kReservedBits, int kTabSizeLog>
typename StackDepotBase<Node, kReservedBits, kTabSizeLog>::handle_type
StackDepotBase<Node, kReservedBits, kTabSizeLog>::Put(args_type args,
                                                      bool *inserted) {
  if (inserted) *inserted = false;
  if (!Node::is_valid(args)) return handle_type();
  40f2d0:	31 c0                	xor    %eax,%eax
  s->store(args, h);
  s->link = s2;
  unlock(p, s);
  if (inserted) *inserted = true;
  return s->get_handle();
}
  40f2d2:	48 83 c4 48          	add    $0x48,%rsp
  40f2d6:	5b                   	pop    %rbx
  40f2d7:	5d                   	pop    %rbp
  40f2d8:	41 5c                	pop    %r12
  40f2da:	41 5d                	pop    %r13
  40f2dc:	41 5e                	pop    %r14
  40f2de:	41 5f                	pop    %r15
  40f2e0:	c3                   	retq   
  40f2e1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40f2e8:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  40f2ed:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
  40f2f2:	89 7c 24 28          	mov    %edi,0x28(%rsp)
        atomic_compare_exchange_weak(p, &cmp, cmp | 1, memory_order_acquire))
      return (Node *)cmp;
    if (i < 10)
      proc_yield(10);
    else
      internal_sched_yield();
  40f2f6:	e8 25 c3 ff ff       	callq  40b620 <_ZN11__sanitizer20internal_sched_yieldEv>
  40f2fb:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
  40f300:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
  40f305:	8b 7c 24 28          	mov    0x28(%rsp),%edi
  40f309:	e9 07 ff ff ff       	jmpq   40f215 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x165>
    if (node) {
      unlock(p, s2);
      return node->get_handle();
    }
  }
  uptr part = (h % kTabSize) / kPartSize;
  40f30e:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
template<typename T>
INLINE typename T::Type atomic_fetch_add(volatile T *a,
    typename T::Type v, memory_order mo) {
  (void)mo;
  DCHECK(!((uptr)a % sizeof(*a)));
  return __sync_fetch_and_add(&a->val_dont_use, v);
  40f313:	be 01 00 00 00       	mov    $0x1,%esi
  40f318:	48 c1 ef 0c          	shr    $0xc,%rdi
  u32 id = atomic_fetch_add(&seq[part], 1, memory_order_relaxed) + 1;
  40f31c:	48 8d 04 bd 00 00 80 	lea    0x800000(,%rdi,4),%rax
  40f323:	00 
  40f324:	f0 41 0f c1 34 04    	lock xadd %esi,(%r12,%rax,1)
  stats.n_uniq_ids++;
  40f32a:	49 83 84 24 00 04 80 	addq   $0x1,0x800400(%r12)
  40f331:	00 01 
      unlock(p, s2);
      return node->get_handle();
    }
  }
  uptr part = (h % kTabSize) / kPartSize;
  u32 id = atomic_fetch_add(&seq[part], 1, memory_order_relaxed) + 1;
  40f333:	83 c6 01             	add    $0x1,%esi
  stats.n_uniq_ids++;
  CHECK_LT(id, kMaxId);
  40f336:	89 f0                	mov    %esi,%eax
  40f338:	48 3d ff ff 7f 00    	cmp    $0x7fffff,%rax
  40f33e:	0f 87 ed 01 00 00    	ja     40f531 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x481>
  id |= part << kPartShift;
  40f344:	89 f8                	mov    %edi,%eax
  40f346:	c1 e0 17             	shl    $0x17,%eax
  40f349:	89 44 24 08          	mov    %eax,0x8(%rsp)
  40f34d:	09 74 24 08          	or     %esi,0x8(%rsp)
  CHECK_NE(id, 0);
  40f351:	44 8b 44 24 08       	mov    0x8(%rsp),%r8d
  40f356:	4d 85 c0             	test   %r8,%r8
  40f359:	0f 84 b8 01 00 00    	je     40f517 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x467>
  CHECK_EQ(id & (((u32)-1) >> kReservedBits), id);
  40f35f:	8b 44 24 08          	mov    0x8(%rsp),%eax
  40f363:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
  40f368:	49 39 c0             	cmp    %rax,%r8
  40f36b:	0f 85 8b 01 00 00    	jne    40f4fc <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x44c>
      if (stack[i] != args.trace[i]) return false;
    }
    return true;
  }
  static uptr storage_size(const args_type &args) {
    return sizeof(StackDepotNode) + (args.size - 1) * sizeof(uptr);
  40f371:	8d 42 ff             	lea    -0x1(%rdx),%eax
  40f374:	4c 8b 3d 55 ef 00 00 	mov    0xef55(%rip),%r15        # 41e2d0 <_DYNAMIC+0x2d0>
  40f37b:	4c 8d 14 c5 20 00 00 	lea    0x20(,%rax,8),%r10
  40f382:	00 
  40f383:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
      __asm__ __volatile__("" ::: "memory");
    } else if (mo == memory_order_acquire) {
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  40f388:	4d 8b 47 08          	mov    0x8(%r15),%r8
  40f38c:	49 8b 47 10          	mov    0x10(%r15),%rax
inline void *PersistentAllocator::tryAlloc(uptr size) {
  // Optimisic lock-free allocation, essentially try to bump the region ptr.
  for (;;) {
    uptr cmp = atomic_load(&region_pos, memory_order_acquire);
    uptr end = atomic_load(&region_end, memory_order_acquire);
    if (cmp == 0 || cmp + size > end) return nullptr;
  40f390:	4d 85 c0             	test   %r8,%r8
  40f393:	0f 84 87 00 00 00    	je     40f420 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x370>
  40f399:	4b 8d 34 02          	lea    (%r10,%r8,1),%rsi
  40f39d:	48 39 f0             	cmp    %rsi,%rax
  40f3a0:	72 7e                	jb     40f420 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x370>
                                           typename T::Type *cmp,
                                           typename T::Type xchg,
                                           memory_order mo) {
  typedef typename T::Type Type;
  Type cmpv = *cmp;
  Type prev = __sync_val_compare_and_swap(&a->val_dont_use, cmpv, xchg);
  40f3a2:	4c 89 c0             	mov    %r8,%rax
  40f3a5:	f0 49 0f b1 77 08    	lock cmpxchg %rsi,0x8(%r15)
  if (prev == cmpv)
  40f3ab:	49 39 c0             	cmp    %rax,%r8
  40f3ae:	75 d8                	jne    40f388 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x2d8>
  uptr memsz = Node::storage_size(args);
  s = (Node *)PersistentAlloc(memsz);
  stats.allocated += memsz;
  s->id = id;
  40f3b0:	8b 44 24 08          	mov    0x8(%rsp),%eax
  id |= part << kPartShift;
  CHECK_NE(id, 0);
  CHECK_EQ(id & (((u32)-1) >> kReservedBits), id);
  uptr memsz = Node::storage_size(args);
  s = (Node *)PersistentAlloc(memsz);
  stats.allocated += memsz;
  40f3b4:	4d 01 94 24 08 04 80 	add    %r10,0x800408(%r12)
  40f3bb:	00 
  }
  void store(const args_type &args, u32 hash) {
    atomic_store(&hash_and_use_count, hash & kHashMask, memory_order_relaxed);
    size = args.size;
    tag = args.tag;
    internal_memcpy(stack, args.trace, size * sizeof(uptr));
  40f3bc:	49 8d 78 18          	lea    0x18(%r8),%rdi
  static bool is_valid(const args_type &args) {
    return args.size > 0 && args.trace;
  }
  void store(const args_type &args, u32 hash) {
    atomic_store(&hash_and_use_count, hash & kHashMask, memory_order_relaxed);
    size = args.size;
  40f3c0:	41 89 50 10          	mov    %edx,0x10(%r8)
  }
  static bool is_valid(const args_type &args) {
    return args.size > 0 && args.trace;
  }
  void store(const args_type &args, u32 hash) {
    atomic_store(&hash_and_use_count, hash & kHashMask, memory_order_relaxed);
  40f3c4:	41 81 e6 00 00 f0 ff 	and    $0xfff00000,%r14d
    size = args.size;
    tag = args.tag;
    internal_memcpy(stack, args.trace, size * sizeof(uptr));
  40f3cb:	48 8d 14 ed 00 00 00 	lea    0x0(,%rbp,8),%rdx
  40f3d2:	00 
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  40f3d3:	45 89 70 0c          	mov    %r14d,0xc(%r8)
  40f3d7:	48 89 de             	mov    %rbx,%rsi
  40f3da:	4c 89 4c 24 18       	mov    %r9,0x18(%rsp)
  s->id = id;
  40f3df:	41 89 40 08          	mov    %eax,0x8(%r8)
    return args.size > 0 && args.trace;
  }
  void store(const args_type &args, u32 hash) {
    atomic_store(&hash_and_use_count, hash & kHashMask, memory_order_relaxed);
    size = args.size;
    tag = args.tag;
  40f3e3:	8b 44 24 10          	mov    0x10(%rsp),%eax
    internal_memcpy(stack, args.trace, size * sizeof(uptr));
  40f3e7:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  40f3ec:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
    return args.size > 0 && args.trace;
  }
  void store(const args_type &args, u32 hash) {
    atomic_store(&hash_and_use_count, hash & kHashMask, memory_order_relaxed);
    size = args.size;
    tag = args.tag;
  40f3f1:	41 89 40 14          	mov    %eax,0x14(%r8)
    internal_memcpy(stack, args.trace, size * sizeof(uptr));
  40f3f5:	e8 16 ab ff ff       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
  s->store(args, h);
  s->link = s2;
  40f3fa:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
  40f3ff:	4c 8b 4c 24 18       	mov    0x18(%rsp),%r9
  40f404:	4d 89 08             	mov    %r9,(%r8)
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  40f407:	4d 89 45 00          	mov    %r8,0x0(%r13)
  unlock(p, s);
  if (inserted) *inserted = true;
  40f40b:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
  40f410:	48 85 c9             	test   %rcx,%rcx
  40f413:	74 03                	je     40f418 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x368>
  40f415:	c6 01 01             	movb   $0x1,(%rcx)
  40f418:	4c 89 c0             	mov    %r8,%rax
  40f41b:	e9 b2 fe ff ff       	jmpq   40f2d2 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x222>
INLINE typename T::Type atomic_exchange(volatile T *a,
    typename T::Type v, memory_order mo) {
  DCHECK(!((uptr)a % sizeof(*a)));
  if (mo & (memory_order_release | memory_order_acq_rel | memory_order_seq_cst))
    __sync_synchronize();
  v = __sync_lock_test_and_set(&a->val_dont_use, v);
  40f420:	b8 01 00 00 00       	mov    $0x1,%eax
  40f425:	41 86 07             	xchg   %al,(%r15)
  void Init() {
    atomic_store(&state_, 0, memory_order_relaxed);
  }

  void Lock() {
    if (TryLock())
  40f428:	84 c0                	test   %al,%al
  40f42a:	0f 85 97 00 00 00    	jne    40f4c7 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x417>
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
      __asm__ __volatile__("" ::: "memory");
    } else if (mo == memory_order_acquire) {
      __asm__ __volatile__("" ::: "memory");
      v = a->val_dont_use;
  40f430:	4d 8b 47 08          	mov    0x8(%r15),%r8
  40f434:	49 8b 47 10          	mov    0x10(%r15),%rax
  40f438:	4d 85 c0             	test   %r8,%r8
  40f43b:	74 20                	je     40f45d <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x3ad>
  40f43d:	4b 8d 34 02          	lea    (%r10,%r8,1),%rsi
  40f441:	48 39 f0             	cmp    %rsi,%rax
  40f444:	72 17                	jb     40f45d <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x3ad>
                                           typename T::Type *cmp,
                                           typename T::Type xchg,
                                           memory_order mo) {
  typedef typename T::Type Type;
  Type cmpv = *cmp;
  Type prev = __sync_val_compare_and_swap(&a->val_dont_use, cmpv, xchg);
  40f446:	4c 89 c0             	mov    %r8,%rax
  40f449:	f0 49 0f b1 77 08    	lock cmpxchg %rsi,0x8(%r15)
  if (prev == cmpv)
  40f44f:	49 39 c0             	cmp    %rax,%r8
  40f452:	75 dc                	jne    40f430 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x380>
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  40f454:	41 c6 07 00          	movb   $0x0,(%r15)
      __asm__ __volatile__("" ::: "memory");
  40f458:	e9 53 ff ff ff       	jmpq   40f3b0 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x300>
  40f45d:	49 81 fa 00 00 01 00 	cmp    $0x10000,%r10
  40f464:	41 b8 00 00 01 00    	mov    $0x10000,%r8d
    s = tryAlloc(size);
    if (s) return s;
    atomic_store(&region_pos, 0, memory_order_relaxed);
    uptr allocsz = 64 * 1024;
    if (allocsz < size) allocsz = size;
    uptr mem = (uptr)MmapOrDie(allocsz, "stack depot");
  40f46a:	48 8d 35 20 9b 00 00 	lea    0x9b20(%rip),%rsi        # 418f91 <.LC16>
  40f471:	4d 0f 43 c2          	cmovae %r10,%r8
  DCHECK(!((uptr)a % sizeof(*a)));

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      a->val_dont_use = v;
  40f475:	49 c7 47 08 00 00 00 	movq   $0x0,0x8(%r15)
  40f47c:	00 
  40f47d:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  40f482:	4c 89 c7             	mov    %r8,%rdi
  40f485:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  40f48a:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
  40f48f:	4c 89 4c 24 28       	mov    %r9,0x28(%rsp)
  40f494:	4c 89 54 24 20       	mov    %r10,0x20(%rsp)
  40f499:	e8 02 cf ff ff       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
    atomic_store(&region_end, mem + allocsz, memory_order_release);
  40f49e:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
  40f4a3:	49 01 c0             	add    %rax,%r8
    } else if (mo == memory_order_release) {
      // On x86 stores are implicitly release.
      __asm__ __volatile__("" ::: "memory");
      a->val_dont_use = v;
  40f4a6:	4d 89 47 10          	mov    %r8,0x10(%r15)
  40f4aa:	49 89 47 08          	mov    %rax,0x8(%r15)
      __asm__ __volatile__("" ::: "memory");
  40f4ae:	4c 8b 54 24 20       	mov    0x20(%rsp),%r10
  40f4b3:	4c 8b 4c 24 28       	mov    0x28(%rsp),%r9
  40f4b8:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
  40f4bd:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
  40f4c2:	e9 69 ff ff ff       	jmpq   40f430 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x380>
      return;
    LockSlow();
  40f4c7:	4c 89 ff             	mov    %r15,%rdi
  40f4ca:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  40f4cf:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
  40f4d4:	4c 89 4c 24 20       	mov    %r9,0x20(%rsp)
  40f4d9:	4c 89 54 24 18       	mov    %r10,0x18(%rsp)
  40f4de:	e8 6d 50 ff ff       	callq  404550 <_ZN11__sanitizer15StaticSpinMutex8LockSlowEv>
  40f4e3:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
  40f4e8:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
  40f4ed:	4c 8b 4c 24 20       	mov    0x20(%rsp),%r9
  40f4f2:	4c 8b 54 24 18       	mov    0x18(%rsp),%r10
  40f4f7:	e9 34 ff ff ff       	jmpq   40f430 <_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb+0x380>
  u32 id = atomic_fetch_add(&seq[part], 1, memory_order_relaxed) + 1;
  stats.n_uniq_ids++;
  CHECK_LT(id, kMaxId);
  id |= part << kPartShift;
  CHECK_NE(id, 0);
  CHECK_EQ(id & (((u32)-1) >> kReservedBits), id);
  40f4fc:	48 8d 15 6d 84 00 00 	lea    0x846d(%rip),%rdx        # 417970 <.LC2>
  40f503:	48 8d 3d 96 84 00 00 	lea    0x8496(%rip),%rdi        # 4179a0 <.LC3>
  40f50a:	48 89 c1             	mov    %rax,%rcx
  40f50d:	be 7c 00 00 00       	mov    $0x7c,%esi
  40f512:	e8 d9 5e ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  uptr part = (h % kTabSize) / kPartSize;
  u32 id = atomic_fetch_add(&seq[part], 1, memory_order_relaxed) + 1;
  stats.n_uniq_ids++;
  CHECK_LT(id, kMaxId);
  id |= part << kPartShift;
  CHECK_NE(id, 0);
  40f517:	48 8d 15 63 9a 00 00 	lea    0x9a63(%rip),%rdx        # 418f81 <.LC15>
  40f51e:	48 8d 3d 7b 84 00 00 	lea    0x847b(%rip),%rdi        # 4179a0 <.LC3>
  40f525:	31 c9                	xor    %ecx,%ecx
  40f527:	be 7b 00 00 00       	mov    $0x7b,%esi
  40f52c:	e8 bf 5e ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    }
  }
  uptr part = (h % kTabSize) / kPartSize;
  u32 id = atomic_fetch_add(&seq[part], 1, memory_order_relaxed) + 1;
  stats.n_uniq_ids++;
  CHECK_LT(id, kMaxId);
  40f531:	48 8d 15 35 9a 00 00 	lea    0x9a35(%rip),%rdx        # 418f6d <.LC14>
  40f538:	48 8d 3d 61 84 00 00 	lea    0x8461(%rip),%rdi        # 4179a0 <.LC3>
  40f53f:	41 b8 00 00 80 00    	mov    $0x800000,%r8d
  40f545:	48 89 c1             	mov    %rax,%rcx
  40f548:	be 79 00 00 00       	mov    $0x79,%esi
  40f54d:	e8 9e 5e ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40f552:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40f559:	1f 84 00 00 00 00 00 

000000000040f560 <_ZN11__sanitizer10StackTrace20GetNextInstructionPcEm>:
#if defined(__mips__)
  return pc + 8;
#elif defined(__powerpc__)
  return pc + 4;
#else
  return pc + 1;
  40f560:	48 8d 47 01          	lea    0x1(%rdi),%rax
#endif
}
  40f564:	c3                   	retq   
  40f565:	90                   	nop
  40f566:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40f56d:	00 00 00 

000000000040f570 <_ZN11__sanitizer10StackTrace12GetCurrentPcEv>:

uptr StackTrace::GetCurrentPc() {
  return GET_CALLER_PC();
}
  40f570:	48 8b 04 24          	mov    (%rsp),%rax
  40f574:	c3                   	retq   
  40f575:	90                   	nop
  40f576:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40f57d:	00 00 00 

000000000040f580 <_ZN11__sanitizer18BufferedStackTrace4InitEPKmmm>:

void BufferedStackTrace::Init(const uptr *pcs, uptr cnt, uptr extra_top_pc) {
  40f580:	41 55                	push   %r13
  40f582:	49 89 cd             	mov    %rcx,%r13
  40f585:	41 54                	push   %r12
  40f587:	55                   	push   %rbp
  40f588:	48 89 d5             	mov    %rdx,%rbp
  40f58b:	53                   	push   %rbx
  40f58c:	48 89 fb             	mov    %rdi,%rbx
  40f58f:	48 83 ec 08          	sub    $0x8,%rsp
  size = cnt + !!extra_top_pc;
  40f593:	48 85 c9             	test   %rcx,%rcx
  40f596:	41 0f 95 c4          	setne  %r12b
  40f59a:	41 0f b6 c4          	movzbl %r12b,%eax
  40f59e:	01 d0                	add    %edx,%eax
  CHECK_LE(size, kStackTraceMax);
  40f5a0:	89 c1                	mov    %eax,%ecx
uptr StackTrace::GetCurrentPc() {
  return GET_CALLER_PC();
}

void BufferedStackTrace::Init(const uptr *pcs, uptr cnt, uptr extra_top_pc) {
  size = cnt + !!extra_top_pc;
  40f5a2:	89 47 08             	mov    %eax,0x8(%rdi)
  CHECK_LE(size, kStackTraceMax);
  40f5a5:	48 81 f9 00 01 00 00 	cmp    $0x100,%rcx
  40f5ac:	77 31                	ja     40f5df <_ZN11__sanitizer18BufferedStackTrace4InitEPKmmm+0x5f>
  internal_memcpy(trace_buffer, pcs, cnt * sizeof(trace_buffer[0]));
  40f5ae:	48 8d 14 d5 00 00 00 	lea    0x0(,%rdx,8),%rdx
  40f5b5:	00 
  40f5b6:	48 8d 7f 10          	lea    0x10(%rdi),%rdi
  40f5ba:	e8 51 a9 ff ff       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
  if (extra_top_pc)
  40f5bf:	45 84 e4             	test   %r12b,%r12b
  40f5c2:	74 05                	je     40f5c9 <_ZN11__sanitizer18BufferedStackTrace4InitEPKmmm+0x49>
    trace_buffer[cnt] = extra_top_pc;
  40f5c4:	4c 89 6c eb 10       	mov    %r13,0x10(%rbx,%rbp,8)
  top_frame_bp = 0;
  40f5c9:	48 c7 83 10 08 00 00 	movq   $0x0,0x810(%rbx)
  40f5d0:	00 00 00 00 
}
  40f5d4:	48 83 c4 08          	add    $0x8,%rsp
  40f5d8:	5b                   	pop    %rbx
  40f5d9:	5d                   	pop    %rbp
  40f5da:	41 5c                	pop    %r12
  40f5dc:	41 5d                	pop    %r13
  40f5de:	c3                   	retq   
  return GET_CALLER_PC();
}

void BufferedStackTrace::Init(const uptr *pcs, uptr cnt, uptr extra_top_pc) {
  size = cnt + !!extra_top_pc;
  CHECK_LE(size, kStackTraceMax);
  40f5df:	48 8d 15 7a 84 00 00 	lea    0x847a(%rip),%rdx        # 417a60 <.LC0>
  40f5e6:	48 8d 3d 93 84 00 00 	lea    0x8493(%rip),%rdi        # 417a80 <.LC1>
  40f5ed:	41 b8 00 01 00 00    	mov    $0x100,%r8d
  40f5f3:	be 24 00 00 00       	mov    $0x24,%esi
  40f5f8:	e8 f3 5d ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40f5fd:	90                   	nop
  40f5fe:	66 90                	xchg   %ax,%ax

000000000040f600 <_ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj>:
#endif
}

void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,
                                         uptr stack_bottom, u32 max_depth) {
  CHECK_GE(max_depth, 2);
  40f600:	44 89 c8             	mov    %r9d,%eax
  40f603:	48 83 f8 01          	cmp    $0x1,%rax
  40f607:	0f 86 8d 00 00 00    	jbe    40f69a <_ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj+0x9a>
  trace_buffer[0] = pc;
  size = 1;
  if (stack_top < 4096) return;  // Sanity check for stack top.
  40f60d:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx
}

void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,
                                         uptr stack_bottom, u32 max_depth) {
  CHECK_GE(max_depth, 2);
  trace_buffer[0] = pc;
  40f614:	48 89 77 10          	mov    %rsi,0x10(%rdi)
  size = 1;
  40f618:	c7 47 08 01 00 00 00 	movl   $0x1,0x8(%rdi)
  if (stack_top < 4096) return;  // Sanity check for stack top.
  40f61f:	76 1f                	jbe    40f640 <_ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj+0x40>
  top_frame_bp = 0;
}

// Check if given pointer points into allocated stack area.
static inline bool IsValidFrame(uptr frame, uptr stack_top, uptr stack_bottom) {
  return frame > stack_bottom && frame < stack_top - 2 * sizeof (uhwptr);
  40f621:	4c 39 c2             	cmp    %r8,%rdx
  40f624:	76 1a                	jbe    40f640 <_ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj+0x40>
  40f626:	48 83 e9 10          	sub    $0x10,%rcx
  40f62a:	48 39 ca             	cmp    %rcx,%rdx
  40f62d:	73 11                	jae    40f640 <_ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj+0x40>
  uhwptr *frame = GetCanonicFrame(bp, stack_top, stack_bottom);
  // Lowest possible address that makes sense as the next frame pointer.
  // Goes up as we walk the stack.
  uptr bottom = stack_bottom;
  // Avoid infinite loop when frame == frame[0] by using frame > prev_frame.
  while (IsValidFrame((uptr)frame, stack_top, bottom) &&
  40f62f:	f6 c2 07             	test   $0x7,%dl
  40f632:	75 0c                	jne    40f640 <_ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj+0x40>
         IsAligned((uptr)frame, sizeof(*frame)) &&
  40f634:	41 83 f9 01          	cmp    $0x1,%r9d
  40f638:	77 0e                	ja     40f648 <_ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj+0x48>
  40f63a:	f3 c3                	repz retq 
  40f63c:	0f 1f 40 00          	nopl   0x0(%rax)
  40f640:	f3 c3                	repz retq 
  40f642:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  // not have a valid frame pointer, but we can still extract the caller PC.
  // Unfortunately, there is no way to decide between GCC and LLVM frame
  // layouts. Assume LLVM.
  return bp_prev;
#else
  return (uhwptr*)bp;
  40f648:	49 89 d2             	mov    %rdx,%r10
  40f64b:	b8 01 00 00 00       	mov    $0x1,%eax
    if (!IsValidFrame((uptr)caller_frame, stack_top, bottom) ||
        !IsAligned((uptr)caller_frame, sizeof(uhwptr)))
      break;
    uhwptr pc1 = caller_frame[2];
#else
    uhwptr pc1 = frame[1];
  40f650:	4c 8b 5a 08          	mov    0x8(%rdx),%r11
#endif
    if (pc1 != pc) {
  40f654:	49 39 f3             	cmp    %rsi,%r11
  40f657:	74 10                	je     40f669 <_ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj+0x69>
      trace_buffer[size++] = (uptr) pc1;
  40f659:	44 8d 40 01          	lea    0x1(%rax),%r8d
  40f65d:	44 89 47 08          	mov    %r8d,0x8(%rdi)
  40f661:	4c 89 5c c7 10       	mov    %r11,0x10(%rdi,%rax,8)
  40f666:	44 89 c0             	mov    %r8d,%eax
    }
    bottom = (uptr)frame;
    frame = GetCanonicFrame((uptr)frame[0], stack_top, bottom);
  40f669:	48 8b 12             	mov    (%rdx),%rdx
  top_frame_bp = 0;
}

// Check if given pointer points into allocated stack area.
static inline bool IsValidFrame(uptr frame, uptr stack_top, uptr stack_bottom) {
  return frame > stack_bottom && frame < stack_top - 2 * sizeof (uhwptr);
  40f66c:	49 39 d2             	cmp    %rdx,%r10
  40f66f:	73 cf                	jae    40f640 <_ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj+0x40>
  40f671:	48 39 ca             	cmp    %rcx,%rdx
  40f674:	72 0a                	jb     40f680 <_ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj+0x80>
  40f676:	f3 c3                	repz retq 
  40f678:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40f67f:	00 
  uhwptr *frame = GetCanonicFrame(bp, stack_top, stack_bottom);
  // Lowest possible address that makes sense as the next frame pointer.
  // Goes up as we walk the stack.
  uptr bottom = stack_bottom;
  // Avoid infinite loop when frame == frame[0] by using frame > prev_frame.
  while (IsValidFrame((uptr)frame, stack_top, bottom) &&
  40f680:	f6 c2 07             	test   $0x7,%dl
  40f683:	74 0b                	je     40f690 <_ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj+0x90>
  40f685:	f3 c3                	repz retq 
  40f687:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40f68e:	00 00 
         IsAligned((uptr)frame, sizeof(*frame)) &&
  40f690:	44 39 c8             	cmp    %r9d,%eax
  40f693:	73 ab                	jae    40f640 <_ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj+0x40>
  40f695:	49 89 d2             	mov    %rdx,%r10
  40f698:	eb b6                	jmp    40f650 <_ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj+0x50>
#endif
}

void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,
                                         uptr stack_bottom, u32 max_depth) {
  CHECK_GE(max_depth, 2);
  40f69a:	48 8d 15 fc 98 00 00 	lea    0x98fc(%rip),%rdx        # 418f9d <.LC2>
  40f6a1:	48 8d 3d d8 83 00 00 	lea    0x83d8(%rip),%rdi        # 417a80 <.LC1>
  return (uhwptr*)bp;
#endif
}

void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,
                                         uptr stack_bottom, u32 max_depth) {
  40f6a8:	48 83 ec 08          	sub    $0x8,%rsp
  CHECK_GE(max_depth, 2);
  40f6ac:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  40f6b2:	48 89 c1             	mov    %rax,%rcx
  40f6b5:	be 4a 00 00 00       	mov    $0x4a,%esi
  40f6ba:	e8 31 5d ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40f6bf:	90                   	nop

000000000040f6c0 <_ZN11__sanitizer18BufferedStackTrace14PopStackFramesEm>:
static bool MatchPc(uptr cur_pc, uptr trace_pc, uptr threshold) {
  return cur_pc - trace_pc <= threshold || trace_pc - cur_pc <= threshold;
}

void BufferedStackTrace::PopStackFrames(uptr count) {
  CHECK_LT(count, size);
  40f6c0:	8b 47 08             	mov    0x8(%rdi),%eax
  40f6c3:	41 89 c0             	mov    %eax,%r8d
  40f6c6:	4c 39 c6             	cmp    %r8,%rsi
  40f6c9:	73 38                	jae    40f703 <_ZN11__sanitizer18BufferedStackTrace14PopStackFramesEm+0x43>
  size -= count;
  40f6cb:	29 f0                	sub    %esi,%eax
  for (uptr i = 0; i < size; ++i) {
  40f6cd:	89 c2                	mov    %eax,%edx
  return cur_pc - trace_pc <= threshold || trace_pc - cur_pc <= threshold;
}

void BufferedStackTrace::PopStackFrames(uptr count) {
  CHECK_LT(count, size);
  size -= count;
  40f6cf:	89 47 08             	mov    %eax,0x8(%rdi)
  for (uptr i = 0; i < size; ++i) {
  40f6d2:	48 85 d2             	test   %rdx,%rdx
  40f6d5:	74 2a                	je     40f701 <_ZN11__sanitizer18BufferedStackTrace14PopStackFramesEm+0x41>
  40f6d7:	48 8d 44 f7 10       	lea    0x10(%rdi,%rsi,8),%rax
  40f6dc:	48 01 f2             	add    %rsi,%rdx
  40f6df:	48 f7 de             	neg    %rsi
  40f6e2:	48 8d 7c d7 10       	lea    0x10(%rdi,%rdx,8),%rdi
  40f6e7:	48 8d 0c f5 00 00 00 	lea    0x0(,%rsi,8),%rcx
  40f6ee:	00 
  40f6ef:	90                   	nop
    trace_buffer[i] = trace_buffer[i + count];
  40f6f0:	48 8b 10             	mov    (%rax),%rdx
  40f6f3:	48 83 c0 08          	add    $0x8,%rax
  40f6f7:	48 89 54 08 f8       	mov    %rdx,-0x8(%rax,%rcx,1)
}

void BufferedStackTrace::PopStackFrames(uptr count) {
  CHECK_LT(count, size);
  size -= count;
  for (uptr i = 0; i < size; ++i) {
  40f6fc:	48 39 f8             	cmp    %rdi,%rax
  40f6ff:	75 ef                	jne    40f6f0 <_ZN11__sanitizer18BufferedStackTrace14PopStackFramesEm+0x30>
  40f701:	f3 c3                	repz retq 
static bool MatchPc(uptr cur_pc, uptr trace_pc, uptr threshold) {
  return cur_pc - trace_pc <= threshold || trace_pc - cur_pc <= threshold;
}

void BufferedStackTrace::PopStackFrames(uptr count) {
  CHECK_LT(count, size);
  40f703:	48 8d 15 aa 98 00 00 	lea    0x98aa(%rip),%rdx        # 418fb4 <.LC3>
  40f70a:	48 8d 3d 6f 83 00 00 	lea    0x836f(%rip),%rdi        # 417a80 <.LC1>
  40f711:	48 89 f1             	mov    %rsi,%rcx

static bool MatchPc(uptr cur_pc, uptr trace_pc, uptr threshold) {
  return cur_pc - trace_pc <= threshold || trace_pc - cur_pc <= threshold;
}

void BufferedStackTrace::PopStackFrames(uptr count) {
  40f714:	48 83 ec 08          	sub    $0x8,%rsp
  CHECK_LT(count, size);
  40f718:	be 6f 00 00 00       	mov    $0x6f,%esi
  40f71d:	e8 ce 5c ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40f722:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40f729:	1f 84 00 00 00 00 00 

000000000040f730 <_ZN11__sanitizer18BufferedStackTrace15LocatePcInTraceEm>:

uptr BufferedStackTrace::LocatePcInTrace(uptr pc) {
  // Use threshold to find PC in stack trace, as PC we want to unwind from may
  // slightly differ from return address in the actual unwinded stack trace.
  const int kPcThreshold = 304;
  for (uptr i = 0; i < size; ++i) {
  40f730:	44 8b 47 08          	mov    0x8(%rdi),%r8d
  40f734:	4d 85 c0             	test   %r8,%r8
  40f737:	74 5f                	je     40f798 <_ZN11__sanitizer18BufferedStackTrace15LocatePcInTraceEm+0x68>
    if (MatchPc(pc, trace[i], kPcThreshold))
  40f739:	48 8b 3f             	mov    (%rdi),%rdi
    frame = GetCanonicFrame((uptr)frame[0], stack_top, bottom);
  }
}

static bool MatchPc(uptr cur_pc, uptr trace_pc, uptr threshold) {
  return cur_pc - trace_pc <= threshold || trace_pc - cur_pc <= threshold;
  40f73c:	48 89 f2             	mov    %rsi,%rdx
uptr BufferedStackTrace::LocatePcInTrace(uptr pc) {
  // Use threshold to find PC in stack trace, as PC we want to unwind from may
  // slightly differ from return address in the actual unwinded stack trace.
  const int kPcThreshold = 304;
  for (uptr i = 0; i < size; ++i) {
    if (MatchPc(pc, trace[i], kPcThreshold))
  40f73f:	48 8b 07             	mov    (%rdi),%rax
    frame = GetCanonicFrame((uptr)frame[0], stack_top, bottom);
  }
}

static bool MatchPc(uptr cur_pc, uptr trace_pc, uptr threshold) {
  return cur_pc - trace_pc <= threshold || trace_pc - cur_pc <= threshold;
  40f742:	48 29 c2             	sub    %rax,%rdx
  40f745:	48 81 fa 30 01 00 00 	cmp    $0x130,%rdx
  40f74c:	76 4a                	jbe    40f798 <_ZN11__sanitizer18BufferedStackTrace15LocatePcInTraceEm+0x68>
  40f74e:	48 29 f0             	sub    %rsi,%rax
  40f751:	48 3d 30 01 00 00    	cmp    $0x130,%rax
  const int kPcThreshold = 304;
  for (uptr i = 0; i < size; ++i) {
    if (MatchPc(pc, trace[i], kPcThreshold))
      return i;
  }
  return 0;
  40f757:	b8 00 00 00 00       	mov    $0x0,%eax
    frame = GetCanonicFrame((uptr)frame[0], stack_top, bottom);
  }
}

static bool MatchPc(uptr cur_pc, uptr trace_pc, uptr threshold) {
  return cur_pc - trace_pc <= threshold || trace_pc - cur_pc <= threshold;
  40f75c:	77 0e                	ja     40f76c <_ZN11__sanitizer18BufferedStackTrace15LocatePcInTraceEm+0x3c>
  40f75e:	eb 41                	jmp    40f7a1 <_ZN11__sanitizer18BufferedStackTrace15LocatePcInTraceEm+0x71>
  40f760:	48 29 f2             	sub    %rsi,%rdx
  40f763:	48 81 fa 30 01 00 00 	cmp    $0x130,%rdx
  40f76a:	76 24                	jbe    40f790 <_ZN11__sanitizer18BufferedStackTrace15LocatePcInTraceEm+0x60>

uptr BufferedStackTrace::LocatePcInTrace(uptr pc) {
  // Use threshold to find PC in stack trace, as PC we want to unwind from may
  // slightly differ from return address in the actual unwinded stack trace.
  const int kPcThreshold = 304;
  for (uptr i = 0; i < size; ++i) {
  40f76c:	48 83 c0 01          	add    $0x1,%rax
  40f770:	4c 39 c0             	cmp    %r8,%rax
  40f773:	73 23                	jae    40f798 <_ZN11__sanitizer18BufferedStackTrace15LocatePcInTraceEm+0x68>
    if (MatchPc(pc, trace[i], kPcThreshold))
  40f775:	48 8b 14 c7          	mov    (%rdi,%rax,8),%rdx
    frame = GetCanonicFrame((uptr)frame[0], stack_top, bottom);
  }
}

static bool MatchPc(uptr cur_pc, uptr trace_pc, uptr threshold) {
  return cur_pc - trace_pc <= threshold || trace_pc - cur_pc <= threshold;
  40f779:	48 89 f1             	mov    %rsi,%rcx
  40f77c:	48 29 d1             	sub    %rdx,%rcx
  40f77f:	48 81 f9 30 01 00 00 	cmp    $0x130,%rcx
  40f786:	77 d8                	ja     40f760 <_ZN11__sanitizer18BufferedStackTrace15LocatePcInTraceEm+0x30>
  for (uptr i = 0; i < size; ++i) {
    if (MatchPc(pc, trace[i], kPcThreshold))
      return i;
  }
  return 0;
}
  40f788:	f3 c3                	repz retq 
  40f78a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40f790:	f3 c3                	repz retq 
  40f792:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  const int kPcThreshold = 304;
  for (uptr i = 0; i < size; ++i) {
    if (MatchPc(pc, trace[i], kPcThreshold))
      return i;
  }
  return 0;
  40f798:	31 c0                	xor    %eax,%eax
  40f79a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
}
  40f7a0:	c3                   	retq   
  40f7a1:	f3 c3                	repz retq 
  40f7a3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40f7aa:	84 00 00 00 00 00 

000000000040f7b0 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_>:

static const char kDefaultFormat[] = "    #%n %p %F %L";

void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,
                 const AddressInfo &info, bool vs_style,
                 const char *strip_path_prefix, const char *strip_func_prefix) {
  40f7b0:	41 57                	push   %r15
  40f7b2:	49 89 f7             	mov    %rsi,%r15
  if (0 == internal_strcmp(format, "DEFAULT"))
  40f7b5:	48 8d 35 f1 8e 00 00 	lea    0x8ef1(%rip),%rsi        # 4186ad <.LC0>

static const char kDefaultFormat[] = "    #%n %p %F %L";

void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,
                 const AddressInfo &info, bool vs_style,
                 const char *strip_path_prefix, const char *strip_func_prefix) {
  40f7bc:	41 56                	push   %r14
  40f7be:	41 55                	push   %r13
  40f7c0:	4d 89 cd             	mov    %r9,%r13
  40f7c3:	41 54                	push   %r12
  40f7c5:	49 89 cc             	mov    %rcx,%r12
  40f7c8:	55                   	push   %rbp
    if (*p != '%') {
      buffer->append("%c", *p);
      continue;
    }
    p++;
    switch (*p) {
  40f7c9:	48 8d 2d 98 99 00 00 	lea    0x9998(%rip),%rbp        # 419168 <_ZZN11__sanitizer14DumpProcessMapEvE8__func__+0x10>

static const char kDefaultFormat[] = "    #%n %p %F %L";

void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,
                 const AddressInfo &info, bool vs_style,
                 const char *strip_path_prefix, const char *strip_func_prefix) {
  40f7d0:	53                   	push   %rbx
  40f7d1:	48 89 fb             	mov    %rdi,%rbx
  if (0 == internal_strcmp(format, "DEFAULT"))
  40f7d4:	4c 89 ff             	mov    %r15,%rdi

static const char kDefaultFormat[] = "    #%n %p %F %L";

void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,
                 const AddressInfo &info, bool vs_style,
                 const char *strip_path_prefix, const char *strip_func_prefix) {
  40f7d7:	48 83 ec 28          	sub    $0x28,%rsp
  40f7db:	89 54 24 18          	mov    %edx,0x18(%rsp)
  40f7df:	44 88 44 24 0f       	mov    %r8b,0xf(%rsp)
  if (0 == internal_strcmp(format, "DEFAULT"))
  40f7e4:	e8 f7 af ff ff       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
    format = kDefaultFormat;
  40f7e9:	85 c0                	test   %eax,%eax
  40f7eb:	48 8d 05 be 9a 00 00 	lea    0x9abe(%rip),%rax        # 4192b0 <_ZN11__sanitizerL14kDefaultFormatE>
  40f7f2:	4c 0f 44 f8          	cmove  %rax,%r15
  for (const char *p = format; *p != '\0'; p++) {
  40f7f6:	41 0f be 17          	movsbl (%r15),%edx
  40f7fa:	84 d2                	test   %dl,%dl
  40f7fc:	75 23                	jne    40f821 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x71>
  40f7fe:	eb 50                	jmp    40f850 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0xa0>
    if (*p != '%') {
      buffer->append("%c", *p);
  40f800:	48 8d 35 c2 97 00 00 	lea    0x97c2(%rip),%rsi        # 418fc9 <.LC1>
  40f807:	48 89 df             	mov    %rbx,%rdi
  40f80a:	31 c0                	xor    %eax,%eax
      continue;
  40f80c:	4d 89 fe             	mov    %r15,%r14
                 const char *strip_path_prefix, const char *strip_func_prefix) {
  if (0 == internal_strcmp(format, "DEFAULT"))
    format = kDefaultFormat;
  for (const char *p = format; *p != '\0'; p++) {
    if (*p != '%') {
      buffer->append("%c", *p);
  40f80f:	e8 1c e3 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,
                 const AddressInfo &info, bool vs_style,
                 const char *strip_path_prefix, const char *strip_func_prefix) {
  if (0 == internal_strcmp(format, "DEFAULT"))
    format = kDefaultFormat;
  for (const char *p = format; *p != '\0'; p++) {
  40f814:	41 0f be 56 01       	movsbl 0x1(%r14),%edx
  40f819:	4d 8d 7e 01          	lea    0x1(%r14),%r15
  40f81d:	84 d2                	test   %dl,%dl
  40f81f:	74 2f                	je     40f850 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0xa0>
    if (*p != '%') {
  40f821:	80 fa 25             	cmp    $0x25,%dl
  40f824:	75 da                	jne    40f800 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x50>
      buffer->append("%c", *p);
      continue;
    }
    p++;
    switch (*p) {
  40f826:	41 0f b6 57 01       	movzbl 0x1(%r15),%edx
  for (const char *p = format; *p != '\0'; p++) {
    if (*p != '%') {
      buffer->append("%c", *p);
      continue;
    }
    p++;
  40f82b:	4d 8d 77 01          	lea    0x1(%r15),%r14
    switch (*p) {
  40f82f:	8d 42 db             	lea    -0x25(%rdx),%eax
  40f832:	3c 4e                	cmp    $0x4e,%al
  40f834:	0f 87 96 03 00 00    	ja     40fbd0 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x420>
  40f83a:	0f b6 c0             	movzbl %al,%eax
  40f83d:	48 63 44 85 00       	movslq 0x0(%rbp,%rax,4),%rax
  40f842:	48 01 e8             	add    %rbp,%rax
  40f845:	ff e0                	jmpq   *%rax
  40f847:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40f84e:	00 00 
      Report("Unsupported specifier in stack frame format: %c (0x%zx)!\n", *p,
             *p);
      Die();
    }
  }
}
  40f850:	48 83 c4 28          	add    $0x28,%rsp
  40f854:	5b                   	pop    %rbx
  40f855:	5d                   	pop    %rbp
  40f856:	41 5c                	pop    %r12
  40f858:	41 5d                	pop    %r13
  40f85a:	41 5e                	pop    %r14
  40f85c:	41 5f                	pop    %r15
  40f85e:	c3                   	retq   
  40f85f:	90                   	nop
      buffer->append("0x%zx", info.function_offset != AddressInfo::kUnknown
                                  ? info.function_offset
                                  : 0x0);
      break;
    case 's':
      buffer->append("%s", StripPathPrefix(info.file, strip_path_prefix));
  40f860:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  40f865:	4c 89 ee             	mov    %r13,%rsi
  40f868:	e8 b3 60 ff ff       	callq  405920 <_ZN11__sanitizer15StripPathPrefixEPKcS1_>
  40f86d:	48 8d 35 9e 8c 00 00 	lea    0x8c9e(%rip),%rsi        # 418512 <.LC18>
  40f874:	48 89 c2             	mov    %rax,%rdx
  40f877:	48 89 df             	mov    %rbx,%rdi
  40f87a:	31 c0                	xor    %eax,%eax
  40f87c:	e8 af e2 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
      break;
  40f881:	eb 91                	jmp    40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
  40f883:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
      break;
    case 'f':
      buffer->append("%s", StripFunctionName(info.function, strip_func_prefix));
      break;
    case 'q':
      buffer->append("0x%zx", info.function_offset != AddressInfo::kUnknown
  40f888:	49 8b 54 24 20       	mov    0x20(%r12),%rdx
                                  ? info.function_offset
                                  : 0x0);
  40f88d:	b8 00 00 00 00       	mov    $0x0,%eax
  40f892:	48 8d 35 3a 97 00 00 	lea    0x973a(%rip),%rsi        # 418fd3 <.LC4>
  40f899:	48 89 df             	mov    %rbx,%rdi
  40f89c:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
  40f8a0:	48 0f 44 d0          	cmove  %rax,%rdx
  40f8a4:	e8 87 e2 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
      break;
  40f8a9:	e9 66 ff ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
  40f8ae:	66 90                	xchg   %ax,%ax
    // Frame number and all fields of AddressInfo structure.
    case 'n':
      buffer->append("%zu", frame_no);
      break;
    case 'p':
      buffer->append("0x%zx", info.address);
  40f8b0:	49 8b 14 24          	mov    (%r12),%rdx
  40f8b4:	48 8d 35 18 97 00 00 	lea    0x9718(%rip),%rsi        # 418fd3 <.LC4>
  40f8bb:	48 89 df             	mov    %rbx,%rdi
  40f8be:	31 c0                	xor    %eax,%eax
  40f8c0:	e8 6b e2 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
      break;
  40f8c5:	e9 4a ff ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
  40f8ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    case 'm':
      buffer->append("%s", StripPathPrefix(info.module, strip_path_prefix));
      break;
    case 'o':
      buffer->append("0x%zx", info.module_offset);
  40f8d0:	49 8b 54 24 10       	mov    0x10(%r12),%rdx
  40f8d5:	48 8d 35 f7 96 00 00 	lea    0x96f7(%rip),%rsi        # 418fd3 <.LC4>
  40f8dc:	48 89 df             	mov    %rbx,%rdi
  40f8df:	31 c0                	xor    %eax,%eax
  40f8e1:	e8 4a e2 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
      break;
  40f8e6:	e9 29 ff ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
  40f8eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    case '%':
      buffer->append("%%");
      break;
    // Frame number and all fields of AddressInfo structure.
    case 'n':
      buffer->append("%zu", frame_no);
  40f8f0:	8b 54 24 18          	mov    0x18(%rsp),%edx
  40f8f4:	48 8d 35 d4 96 00 00 	lea    0x96d4(%rip),%rsi        # 418fcf <.LC3>
  40f8fb:	48 89 df             	mov    %rbx,%rdi
  40f8fe:	31 c0                	xor    %eax,%eax
  40f900:	e8 2b e2 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
      break;
  40f905:	e9 0a ff ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
  40f90a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    case 'p':
      buffer->append("0x%zx", info.address);
      break;
    case 'm':
      buffer->append("%s", StripPathPrefix(info.module, strip_path_prefix));
  40f910:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
  40f915:	e9 4b ff ff ff       	jmpq   40f865 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0xb5>
  40f91a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      break;
    case 's':
      buffer->append("%s", StripPathPrefix(info.file, strip_path_prefix));
      break;
    case 'l':
      buffer->append("%d", info.line);
  40f920:	41 8b 54 24 30       	mov    0x30(%r12),%edx
  40f925:	48 8d 35 ad 96 00 00 	lea    0x96ad(%rip),%rsi        # 418fd9 <.LC6>
  40f92c:	48 89 df             	mov    %rbx,%rdi
  40f92f:	31 c0                	xor    %eax,%eax
  40f931:	e8 fa e1 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
      break;
  40f936:	e9 d9 fe ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
  40f93b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
      break;
    case 'o':
      buffer->append("0x%zx", info.module_offset);
      break;
    case 'f':
      buffer->append("%s", StripFunctionName(info.function, strip_func_prefix));
  40f940:	4d 8b 7c 24 18       	mov    0x18(%r12),%r15
#include "sanitizer_stacktrace_printer.h"

namespace __sanitizer {

static const char *StripFunctionName(const char *function, const char *prefix) {
  if (!function) return nullptr;
  40f945:	4d 85 ff             	test   %r15,%r15
  40f948:	0f 84 f9 02 00 00    	je     40fc47 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x497>
  if (!prefix) return function;
  40f94e:	48 83 7c 24 60 00    	cmpq   $0x0,0x60(%rsp)
  40f954:	74 2d                	je     40f983 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x1d3>
  uptr prefix_len = internal_strlen(prefix);
  40f956:	48 8b 7c 24 60       	mov    0x60(%rsp),%rdi
  40f95b:	e8 d0 af ff ff       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  if (0 == internal_strncmp(function, prefix, prefix_len))
  40f960:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
  40f965:	4c 89 ff             	mov    %r15,%rdi
  40f968:	48 89 c2             	mov    %rax,%rdx
  40f96b:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40f970:	e8 ab ae ff ff       	callq  40a820 <_ZN11__sanitizer16internal_strncmpEPKcS1_m>
    return function + prefix_len;
  40f975:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
  40f97a:	4c 01 f9             	add    %r15,%rcx
  40f97d:	85 c0                	test   %eax,%eax
  40f97f:	4c 0f 44 f9          	cmove  %rcx,%r15
      break;
    case 'o':
      buffer->append("0x%zx", info.module_offset);
      break;
    case 'f':
      buffer->append("%s", StripFunctionName(info.function, strip_func_prefix));
  40f983:	48 8d 35 88 8b 00 00 	lea    0x8b88(%rip),%rsi        # 418512 <.LC18>
  40f98a:	4c 89 fa             	mov    %r15,%rdx
  40f98d:	48 89 df             	mov    %rbx,%rdi
  40f990:	31 c0                	xor    %eax,%eax
  40f992:	e8 99 e1 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
      break;
  40f997:	e9 78 fe ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
  40f99c:	0f 1f 40 00          	nopl   0x0(%rax)
      break;
    case 'l':
      buffer->append("%d", info.line);
      break;
    case 'c':
      buffer->append("%d", info.column);
  40f9a0:	41 8b 54 24 34       	mov    0x34(%r12),%edx
  40f9a5:	48 8d 35 2d 96 00 00 	lea    0x962d(%rip),%rsi        # 418fd9 <.LC6>
  40f9ac:	48 89 df             	mov    %rbx,%rdi
  40f9af:	31 c0                	xor    %eax,%eax
  40f9b1:	e8 7a e1 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
      break;
  40f9b6:	e9 59 fe ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
  40f9bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
      }
      break;
    case 'S':
      // File/line information.
      RenderSourceLocation(buffer, info.file, info.line, info.column, vs_style,
                           strip_path_prefix);
  40f9c0:	41 8b 4c 24 30       	mov    0x30(%r12),%ecx
  40f9c5:	45 8b 7c 24 34       	mov    0x34(%r12),%r15d
  40f9ca:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
}

void RenderSourceLocation(InternalScopedString *buffer, const char *file,
                          int line, int column, bool vs_style,
                          const char *strip_path_prefix) {
  if (vs_style && line > 0) {
  40f9cf:	85 c9                	test   %ecx,%ecx
  40f9d1:	41 0f 9f c1          	setg   %r9b
  40f9d5:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%rsp)
  40f9da:	0f 85 e9 00 00 00    	jne    40fac9 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x319>
      buffer->append(",%d", column);
    buffer->append(")");
    return;
  }

  buffer->append("%s", StripPathPrefix(file, strip_path_prefix));
  40f9e0:	4c 89 ee             	mov    %r13,%rsi
  40f9e3:	44 89 4c 24 10       	mov    %r9d,0x10(%rsp)
  40f9e8:	89 4c 24 1c          	mov    %ecx,0x1c(%rsp)
  40f9ec:	e8 2f 5f ff ff       	callq  405920 <_ZN11__sanitizer15StripPathPrefixEPKcS1_>
  40f9f1:	48 8d 35 1a 8b 00 00 	lea    0x8b1a(%rip),%rsi        # 418512 <.LC18>
  40f9f8:	48 89 c2             	mov    %rax,%rdx
  40f9fb:	48 89 df             	mov    %rbx,%rdi
  40f9fe:	31 c0                	xor    %eax,%eax
  40fa00:	e8 2b e1 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  if (line > 0) {
  40fa05:	44 8b 4c 24 10       	mov    0x10(%rsp),%r9d
  40fa0a:	45 84 c9             	test   %r9b,%r9b
  40fa0d:	0f 84 01 fe ff ff    	je     40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
    buffer->append(":%d", line);
  40fa13:	8b 4c 24 1c          	mov    0x1c(%rsp),%ecx
  40fa17:	48 8d 35 d7 95 00 00 	lea    0x95d7(%rip),%rsi        # 418ff5 <.LC12>
  40fa1e:	31 c0                	xor    %eax,%eax
  40fa20:	48 89 df             	mov    %rbx,%rdi
  40fa23:	89 ca                	mov    %ecx,%edx
  40fa25:	e8 06 e1 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
    if (column > 0)
  40fa2a:	45 85 ff             	test   %r15d,%r15d
  40fa2d:	0f 8e e1 fd ff ff    	jle    40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
      buffer->append(":%d", column);
  40fa33:	48 8d 35 bb 95 00 00 	lea    0x95bb(%rip),%rsi        # 418ff5 <.LC12>
  40fa3a:	44 89 fa             	mov    %r15d,%edx
  40fa3d:	48 89 df             	mov    %rbx,%rdi
  40fa40:	31 c0                	xor    %eax,%eax
  40fa42:	e8 e9 e0 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  40fa47:	e9 c8 fd ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
  40fa4c:	0f 1f 40 00          	nopl   0x0(%rax)
        buffer->append("(<unknown module>)");
      }
      break;
    case 'M':
      // Module basename and offset, or PC.
      if (info.address & kExternalPCBit)
  40fa50:	49 8b 14 24          	mov    (%r12),%rdx
  40fa54:	48 b8 00 00 00 00 00 	movabs $0x1000000000000000,%rax
  40fa5b:	00 00 10 
  40fa5e:	48 85 c2             	test   %rax,%rdx
  40fa61:	0f 85 ad fd ff ff    	jne    40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
        {} // There PCs are not meaningful.
      else if (info.module)
  40fa67:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
  40fa6c:	48 85 ff             	test   %rdi,%rdi
  40fa6f:	0f 84 a6 01 00 00    	je     40fc1b <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x46b>
        buffer->append("(%s+%p)", StripModuleName(info.module),
                       (void *)info.module_offset);
  40fa75:	4d 8b 7c 24 10       	mov    0x10(%r12),%r15
  40fa7a:	e8 01 5f ff ff       	callq  405980 <_ZN11__sanitizer15StripModuleNameEPKc>
  40fa7f:	48 8d 35 91 95 00 00 	lea    0x9591(%rip),%rsi        # 419017 <.LC15>
  40fa86:	48 89 c2             	mov    %rax,%rdx
  40fa89:	48 89 df             	mov    %rbx,%rdi
  40fa8c:	4c 89 f9             	mov    %r15,%rcx
  40fa8f:	31 c0                	xor    %eax,%eax
  40fa91:	e8 9a e0 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  40fa96:	e9 79 fd ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
  40fa9b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
      RenderSourceLocation(buffer, info.file, info.line, info.column, vs_style,
                           strip_path_prefix);
      break;
    case 'L':
      // Source location, or module location.
      if (info.file) {
  40faa0:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  40faa5:	48 85 ff             	test   %rdi,%rdi
  40faa8:	0f 84 3a 01 00 00    	je     40fbe8 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x438>
        RenderSourceLocation(buffer, info.file, info.line, info.column,
                             vs_style, strip_path_prefix);
  40faae:	41 8b 4c 24 30       	mov    0x30(%r12),%ecx
  40fab3:	45 8b 7c 24 34       	mov    0x34(%r12),%r15d
}

void RenderSourceLocation(InternalScopedString *buffer, const char *file,
                          int line, int column, bool vs_style,
                          const char *strip_path_prefix) {
  if (vs_style && line > 0) {
  40fab8:	85 c9                	test   %ecx,%ecx
  40faba:	41 0f 9f c1          	setg   %r9b
  40fabe:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%rsp)
  40fac3:	0f 84 17 ff ff ff    	je     40f9e0 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x230>
  40fac9:	45 84 c9             	test   %r9b,%r9b
  40facc:	0f 84 0e ff ff ff    	je     40f9e0 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x230>
    buffer->append("%s(%d", StripPathPrefix(file, strip_path_prefix), line);
  40fad2:	4c 89 ee             	mov    %r13,%rsi
  40fad5:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
  40fad9:	e8 42 5e ff ff       	callq  405920 <_ZN11__sanitizer15StripPathPrefixEPKcS1_>
  40fade:	8b 4c 24 10          	mov    0x10(%rsp),%ecx
  40fae2:	48 8d 35 00 95 00 00 	lea    0x9500(%rip),%rsi        # 418fe9 <.LC9>
  40fae9:	48 89 c2             	mov    %rax,%rdx
  40faec:	48 89 df             	mov    %rbx,%rdi
  40faef:	31 c0                	xor    %eax,%eax
  40faf1:	e8 3a e0 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
    if (column > 0)
  40faf6:	45 85 ff             	test   %r15d,%r15d
  40faf9:	7e 14                	jle    40fb0f <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x35f>
      buffer->append(",%d", column);
  40fafb:	48 8d 35 ed 94 00 00 	lea    0x94ed(%rip),%rsi        # 418fef <.LC10>
  40fb02:	44 89 fa             	mov    %r15d,%edx
  40fb05:	48 89 df             	mov    %rbx,%rdi
  40fb08:	31 c0                	xor    %eax,%eax
  40fb0a:	e8 21 e0 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
    buffer->append(")");
  40fb0f:	48 8d 35 dd 94 00 00 	lea    0x94dd(%rip),%rsi        # 418ff3 <.LC11>
  40fb16:	48 89 df             	mov    %rbx,%rdi
  40fb19:	31 c0                	xor    %eax,%eax
  40fb1b:	e8 10 e0 ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  40fb20:	e9 ef fc ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
  40fb25:	0f 1f 00             	nopl   (%rax)
      buffer->append("%d", info.column);
      break;
    // Smarter special cases.
    case 'F':
      // Function name and offset, if file is unknown.
      if (info.function) {
  40fb28:	4d 8b 7c 24 18       	mov    0x18(%r12),%r15
  40fb2d:	4d 85 ff             	test   %r15,%r15
  40fb30:	0f 84 de fc ff ff    	je     40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>

namespace __sanitizer {

static const char *StripFunctionName(const char *function, const char *prefix) {
  if (!function) return nullptr;
  if (!prefix) return function;
  40fb36:	48 83 7c 24 60 00    	cmpq   $0x0,0x60(%rsp)
  40fb3c:	74 2d                	je     40fb6b <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x3bb>
  uptr prefix_len = internal_strlen(prefix);
  40fb3e:	48 8b 7c 24 60       	mov    0x60(%rsp),%rdi
  40fb43:	e8 e8 ad ff ff       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  if (0 == internal_strncmp(function, prefix, prefix_len))
  40fb48:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
  40fb4d:	4c 89 ff             	mov    %r15,%rdi
  40fb50:	48 89 c2             	mov    %rax,%rdx
  40fb53:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40fb58:	e8 c3 ac ff ff       	callq  40a820 <_ZN11__sanitizer16internal_strncmpEPKcS1_m>
    return function + prefix_len;
  40fb5d:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
  40fb62:	4c 01 f9             	add    %r15,%rcx
  40fb65:	85 c0                	test   %eax,%eax
  40fb67:	4c 0f 44 f9          	cmove  %rcx,%r15
    // Smarter special cases.
    case 'F':
      // Function name and offset, if file is unknown.
      if (info.function) {
        buffer->append("in %s",
                       StripFunctionName(info.function, strip_func_prefix));
  40fb6b:	48 8d 35 6a 94 00 00 	lea    0x946a(%rip),%rsi        # 418fdc <.LC7>
  40fb72:	31 c0                	xor    %eax,%eax
  40fb74:	4c 89 fa             	mov    %r15,%rdx
  40fb77:	48 89 df             	mov    %rbx,%rdi
  40fb7a:	e8 b1 df ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
        if (!info.file && info.function_offset != AddressInfo::kUnknown)
  40fb7f:	49 83 7c 24 28 00    	cmpq   $0x0,0x28(%r12)
  40fb85:	0f 85 89 fc ff ff    	jne    40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
  40fb8b:	49 8b 54 24 20       	mov    0x20(%r12),%rdx
  40fb90:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
  40fb94:	0f 84 7a fc ff ff    	je     40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
          buffer->append("+0x%zx", info.function_offset);
  40fb9a:	48 8d 35 41 94 00 00 	lea    0x9441(%rip),%rsi        # 418fe2 <.LC8>
  40fba1:	48 89 df             	mov    %rbx,%rdi
  40fba4:	31 c0                	xor    %eax,%eax
  40fba6:	e8 85 df ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  40fbab:	e9 64 fc ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
      continue;
    }
    p++;
    switch (*p) {
    case '%':
      buffer->append("%%");
  40fbb0:	48 8d 35 15 94 00 00 	lea    0x9415(%rip),%rsi        # 418fcc <.LC2>
  40fbb7:	48 89 df             	mov    %rbx,%rdi
  40fbba:	31 c0                	xor    %eax,%eax
  40fbbc:	e8 6f df ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
      break;
  40fbc1:	e9 4e fc ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
  40fbc6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40fbcd:	00 00 00 
      else
        buffer->append("(%p)", (void *)info.address);
      break;
    default:
      Report("Unsupported specifier in stack frame format: %c (0x%zx)!\n", *p,
             *p);
  40fbd0:	0f be f2             	movsbl %dl,%esi
  40fbd3:	48 8d 3d 1e 7f 00 00 	lea    0x7f1e(%rip),%rdi        # 417af8 <.LC17>
  40fbda:	31 c0                	xor    %eax,%eax
  40fbdc:	89 f2                	mov    %esi,%edx
  40fbde:	e8 ad de ff ff       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
      Die();
  40fbe3:	e8 78 56 ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
    case 'L':
      // Source location, or module location.
      if (info.file) {
        RenderSourceLocation(buffer, info.file, info.line, info.column,
                             vs_style, strip_path_prefix);
      } else if (info.module) {
  40fbe8:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
  40fbed:	48 85 ff             	test   %rdi,%rdi
  40fbf0:	74 3f                	je     40fc31 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x481>
        RenderModuleLocation(buffer, info.module, info.module_offset,
                             strip_path_prefix);
  40fbf2:	4d 8b 7c 24 10       	mov    0x10(%r12),%r15
}

void RenderModuleLocation(InternalScopedString *buffer, const char *module,
                          uptr offset, const char *strip_path_prefix) {
  buffer->append("(%s+0x%zx)", StripPathPrefix(module, strip_path_prefix),
                 offset);
  40fbf7:	4c 89 ee             	mov    %r13,%rsi
  40fbfa:	e8 21 5d ff ff       	callq  405920 <_ZN11__sanitizer15StripPathPrefixEPKcS1_>
  40fbff:	48 8d 35 f3 93 00 00 	lea    0x93f3(%rip),%rsi        # 418ff9 <.LC13>
  40fc06:	48 89 c2             	mov    %rax,%rdx
  40fc09:	48 89 df             	mov    %rbx,%rdi
  40fc0c:	4c 89 f9             	mov    %r15,%rcx
  40fc0f:	31 c0                	xor    %eax,%eax
  40fc11:	e8 1a df ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  40fc16:	e9 f9 fb ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
        {} // There PCs are not meaningful.
      else if (info.module)
        buffer->append("(%s+%p)", StripModuleName(info.module),
                       (void *)info.module_offset);
      else
        buffer->append("(%p)", (void *)info.address);
  40fc1b:	48 8d 35 fd 93 00 00 	lea    0x93fd(%rip),%rsi        # 41901f <.LC16>
  40fc22:	48 89 df             	mov    %rbx,%rdi
  40fc25:	31 c0                	xor    %eax,%eax
  40fc27:	e8 04 df ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  40fc2c:	e9 e3 fb ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
                             vs_style, strip_path_prefix);
      } else if (info.module) {
        RenderModuleLocation(buffer, info.module, info.module_offset,
                             strip_path_prefix);
      } else {
        buffer->append("(<unknown module>)");
  40fc31:	48 8d 35 cc 93 00 00 	lea    0x93cc(%rip),%rsi        # 419004 <.LC14>
  40fc38:	48 89 df             	mov    %rbx,%rdi
  40fc3b:	31 c0                	xor    %eax,%eax
  40fc3d:	e8 ee de ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  40fc42:	e9 cd fb ff ff       	jmpq   40f814 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x64>
#include "sanitizer_stacktrace_printer.h"

namespace __sanitizer {

static const char *StripFunctionName(const char *function, const char *prefix) {
  if (!function) return nullptr;
  40fc47:	45 31 ff             	xor    %r15d,%r15d
  40fc4a:	e9 34 fd ff ff       	jmpq   40f983 <_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_+0x1d3>
  40fc4f:	90                   	nop

000000000040fc50 <_ZN11__sanitizer20RenderSourceLocationEPNS_20InternalScopedStringEPKciibS3_>:
  }
}

void RenderSourceLocation(InternalScopedString *buffer, const char *file,
                          int line, int column, bool vs_style,
                          const char *strip_path_prefix) {
  40fc50:	41 55                	push   %r13
  40fc52:	41 54                	push   %r12
  40fc54:	41 89 cc             	mov    %ecx,%r12d
  40fc57:	55                   	push   %rbp
  40fc58:	89 d5                	mov    %edx,%ebp
  40fc5a:	53                   	push   %rbx
  40fc5b:	48 89 fb             	mov    %rdi,%rbx
  40fc5e:	48 89 f7             	mov    %rsi,%rdi
  if (vs_style && line > 0) {
    buffer->append("%s(%d", StripPathPrefix(file, strip_path_prefix), line);
  40fc61:	4c 89 ce             	mov    %r9,%rsi
  }
}

void RenderSourceLocation(InternalScopedString *buffer, const char *file,
                          int line, int column, bool vs_style,
                          const char *strip_path_prefix) {
  40fc64:	48 83 ec 08          	sub    $0x8,%rsp
  if (vs_style && line > 0) {
  40fc68:	85 d2                	test   %edx,%edx
  40fc6a:	41 0f 9f c5          	setg   %r13b
  40fc6e:	7e 58                	jle    40fcc8 <_ZN11__sanitizer20RenderSourceLocationEPNS_20InternalScopedStringEPKciibS3_+0x78>
  40fc70:	45 84 c0             	test   %r8b,%r8b
  40fc73:	74 53                	je     40fcc8 <_ZN11__sanitizer20RenderSourceLocationEPNS_20InternalScopedStringEPKciibS3_+0x78>
    buffer->append("%s(%d", StripPathPrefix(file, strip_path_prefix), line);
  40fc75:	e8 a6 5c ff ff       	callq  405920 <_ZN11__sanitizer15StripPathPrefixEPKcS1_>
  40fc7a:	48 8d 35 68 93 00 00 	lea    0x9368(%rip),%rsi        # 418fe9 <.LC9>
  40fc81:	48 89 c2             	mov    %rax,%rdx
  40fc84:	89 e9                	mov    %ebp,%ecx
  40fc86:	31 c0                	xor    %eax,%eax
  40fc88:	48 89 df             	mov    %rbx,%rdi
  40fc8b:	e8 a0 de ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
    if (column > 0)
  40fc90:	45 85 e4             	test   %r12d,%r12d
  40fc93:	7e 14                	jle    40fca9 <_ZN11__sanitizer20RenderSourceLocationEPNS_20InternalScopedStringEPKciibS3_+0x59>
      buffer->append(",%d", column);
  40fc95:	48 8d 35 53 93 00 00 	lea    0x9353(%rip),%rsi        # 418fef <.LC10>
  40fc9c:	44 89 e2             	mov    %r12d,%edx
  40fc9f:	48 89 df             	mov    %rbx,%rdi
  40fca2:	31 c0                	xor    %eax,%eax
  40fca4:	e8 87 de ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  if (line > 0) {
    buffer->append(":%d", line);
    if (column > 0)
      buffer->append(":%d", column);
  }
}
  40fca9:	48 83 c4 08          	add    $0x8,%rsp
                          const char *strip_path_prefix) {
  if (vs_style && line > 0) {
    buffer->append("%s(%d", StripPathPrefix(file, strip_path_prefix), line);
    if (column > 0)
      buffer->append(",%d", column);
    buffer->append(")");
  40fcad:	48 89 df             	mov    %rbx,%rdi
  40fcb0:	48 8d 35 3c 93 00 00 	lea    0x933c(%rip),%rsi        # 418ff3 <.LC11>
  if (line > 0) {
    buffer->append(":%d", line);
    if (column > 0)
      buffer->append(":%d", column);
  }
}
  40fcb7:	5b                   	pop    %rbx
  40fcb8:	5d                   	pop    %rbp
  40fcb9:	41 5c                	pop    %r12
  40fcbb:	41 5d                	pop    %r13
                          const char *strip_path_prefix) {
  if (vs_style && line > 0) {
    buffer->append("%s(%d", StripPathPrefix(file, strip_path_prefix), line);
    if (column > 0)
      buffer->append(",%d", column);
    buffer->append(")");
  40fcbd:	31 c0                	xor    %eax,%eax
  40fcbf:	e9 6c de ff ff       	jmpq   40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  40fcc4:	0f 1f 40 00          	nopl   0x0(%rax)
    return;
  }

  buffer->append("%s", StripPathPrefix(file, strip_path_prefix));
  40fcc8:	e8 53 5c ff ff       	callq  405920 <_ZN11__sanitizer15StripPathPrefixEPKcS1_>
  40fccd:	48 8d 35 3e 88 00 00 	lea    0x883e(%rip),%rsi        # 418512 <.LC18>
  40fcd4:	48 89 c2             	mov    %rax,%rdx
  40fcd7:	48 89 df             	mov    %rbx,%rdi
  40fcda:	31 c0                	xor    %eax,%eax
  40fcdc:	e8 4f de ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  if (line > 0) {
  40fce1:	45 84 ed             	test   %r13b,%r13b
  40fce4:	74 3a                	je     40fd20 <_ZN11__sanitizer20RenderSourceLocationEPNS_20InternalScopedStringEPKciibS3_+0xd0>
    buffer->append(":%d", line);
  40fce6:	48 8d 35 08 93 00 00 	lea    0x9308(%rip),%rsi        # 418ff5 <.LC12>
  40fced:	31 c0                	xor    %eax,%eax
  40fcef:	89 ea                	mov    %ebp,%edx
  40fcf1:	48 89 df             	mov    %rbx,%rdi
  40fcf4:	e8 37 de ff ff       	callq  40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
    if (column > 0)
  40fcf9:	45 85 e4             	test   %r12d,%r12d
  40fcfc:	7e 22                	jle    40fd20 <_ZN11__sanitizer20RenderSourceLocationEPNS_20InternalScopedStringEPKciibS3_+0xd0>
      buffer->append(":%d", column);
  }
}
  40fcfe:	48 83 c4 08          	add    $0x8,%rsp

  buffer->append("%s", StripPathPrefix(file, strip_path_prefix));
  if (line > 0) {
    buffer->append(":%d", line);
    if (column > 0)
      buffer->append(":%d", column);
  40fd02:	48 89 df             	mov    %rbx,%rdi
  40fd05:	44 89 e2             	mov    %r12d,%edx
  }
}
  40fd08:	5b                   	pop    %rbx
  40fd09:	5d                   	pop    %rbp
  40fd0a:	41 5c                	pop    %r12
  40fd0c:	41 5d                	pop    %r13

  buffer->append("%s", StripPathPrefix(file, strip_path_prefix));
  if (line > 0) {
    buffer->append(":%d", line);
    if (column > 0)
      buffer->append(":%d", column);
  40fd0e:	48 8d 35 e0 92 00 00 	lea    0x92e0(%rip),%rsi        # 418ff5 <.LC12>
  40fd15:	31 c0                	xor    %eax,%eax
  40fd17:	e9 14 de ff ff       	jmpq   40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  40fd1c:	0f 1f 40 00          	nopl   0x0(%rax)
  }
}
  40fd20:	48 83 c4 08          	add    $0x8,%rsp
  40fd24:	5b                   	pop    %rbx
  40fd25:	5d                   	pop    %rbp
  40fd26:	41 5c                	pop    %r12
  40fd28:	41 5d                	pop    %r13
  40fd2a:	c3                   	retq   
  40fd2b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000040fd30 <_ZN11__sanitizer20RenderModuleLocationEPNS_20InternalScopedStringEPKcmS3_>:

void RenderModuleLocation(InternalScopedString *buffer, const char *module,
                          uptr offset, const char *strip_path_prefix) {
  40fd30:	55                   	push   %rbp
  40fd31:	48 89 d5             	mov    %rdx,%rbp
  40fd34:	53                   	push   %rbx
  40fd35:	48 89 fb             	mov    %rdi,%rbx
  40fd38:	48 89 f7             	mov    %rsi,%rdi
  buffer->append("(%s+0x%zx)", StripPathPrefix(module, strip_path_prefix),
                 offset);
  40fd3b:	48 89 ce             	mov    %rcx,%rsi
      buffer->append(":%d", column);
  }
}

void RenderModuleLocation(InternalScopedString *buffer, const char *module,
                          uptr offset, const char *strip_path_prefix) {
  40fd3e:	48 83 ec 08          	sub    $0x8,%rsp
  buffer->append("(%s+0x%zx)", StripPathPrefix(module, strip_path_prefix),
                 offset);
  40fd42:	e8 d9 5b ff ff       	callq  405920 <_ZN11__sanitizer15StripPathPrefixEPKcS1_>
}
  40fd47:	48 83 c4 08          	add    $0x8,%rsp
}

void RenderModuleLocation(InternalScopedString *buffer, const char *module,
                          uptr offset, const char *strip_path_prefix) {
  buffer->append("(%s+0x%zx)", StripPathPrefix(module, strip_path_prefix),
                 offset);
  40fd4b:	48 89 df             	mov    %rbx,%rdi
  40fd4e:	48 89 e9             	mov    %rbp,%rcx
}
  40fd51:	5b                   	pop    %rbx
  40fd52:	5d                   	pop    %rbp
}

void RenderModuleLocation(InternalScopedString *buffer, const char *module,
                          uptr offset, const char *strip_path_prefix) {
  buffer->append("(%s+0x%zx)", StripPathPrefix(module, strip_path_prefix),
                 offset);
  40fd53:	48 8d 35 9f 92 00 00 	lea    0x929f(%rip),%rsi        # 418ff9 <.LC13>
  40fd5a:	48 89 c2             	mov    %rax,%rdx
  40fd5d:	31 c0                	xor    %eax,%eax
  40fd5f:	e9 cc dd ff ff       	jmpq   40db30 <_ZN11__sanitizer20InternalScopedString6appendEPKcz>
  40fd64:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40fd6b:	00 00 00 00 00 

000000000040fd70 <_ZN11__sanitizer18SuppressionContextC1EPPKci>:
#include "sanitizer_libc.h"
#include "sanitizer_placement_new.h"

namespace __sanitizer {

SuppressionContext::SuppressionContext(const char *suppression_types[],
  40fd70:	53                   	push   %rbx
                                       int suppression_types_num)
    : suppression_types_(suppression_types),
      suppression_types_num_(suppression_types_num), suppressions_(1),
      can_parse_(true) {
  40fd71:	48 89 37             	mov    %rsi,(%rdi)
class InternalMmapVectorNoCtor {
 public:
  void Initialize(uptr initial_capacity) {
    capacity_ = Max(initial_capacity, (uptr)1);
    size_ = 0;
    data_ = (T *)MmapOrDie(capacity_ * sizeof(T), "InternalMmapVectorNoCtor");
  40fd74:	48 8d 35 6b 91 00 00 	lea    0x916b(%rip),%rsi        # 418ee6 <.LC0>
#include "sanitizer_libc.h"
#include "sanitizer_placement_new.h"

namespace __sanitizer {

SuppressionContext::SuppressionContext(const char *suppression_types[],
  40fd7b:	48 89 fb             	mov    %rdi,%rbx
                                       int suppression_types_num)
    : suppression_types_(suppression_types),
      suppression_types_num_(suppression_types_num), suppressions_(1),
      can_parse_(true) {
  40fd7e:	89 57 08             	mov    %edx,0x8(%rdi)
// WARNING: The current implementation supports only POD types.
template<typename T>
class InternalMmapVectorNoCtor {
 public:
  void Initialize(uptr initial_capacity) {
    capacity_ = Max(initial_capacity, (uptr)1);
  40fd81:	48 c7 47 18 01 00 00 	movq   $0x1,0x18(%rdi)
  40fd88:	00 
    size_ = 0;
  40fd89:	48 c7 47 20 00 00 00 	movq   $0x0,0x20(%rdi)
  40fd90:	00 
    data_ = (T *)MmapOrDie(capacity_ * sizeof(T), "InternalMmapVectorNoCtor");
  40fd91:	bf 20 00 00 00       	mov    $0x20,%edi
  40fd96:	e8 05 c6 ff ff       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  CHECK_LE(suppression_types_num_, kMaxSuppressionTypes);
  40fd9b:	48 63 53 08          	movslq 0x8(%rbx),%rdx
  40fd9f:	48 89 43 10          	mov    %rax,0x10(%rbx)

SuppressionContext::SuppressionContext(const char *suppression_types[],
                                       int suppression_types_num)
    : suppression_types_(suppression_types),
      suppression_types_num_(suppression_types_num), suppressions_(1),
      can_parse_(true) {
  40fda3:	c6 43 38 01          	movb   $0x1,0x38(%rbx)
  CHECK_LE(suppression_types_num_, kMaxSuppressionTypes);
  40fda7:	48 83 fa 10          	cmp    $0x10,%rdx
  40fdab:	77 0c                	ja     40fdb9 <_ZN11__sanitizer18SuppressionContextC1EPPKci+0x49>
  internal_memset(has_suppression_type_, 0, suppression_types_num_);
  40fdad:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
  40fdb1:	31 f6                	xor    %esi,%esi
}
  40fdb3:	5b                   	pop    %rbx
                                       int suppression_types_num)
    : suppression_types_(suppression_types),
      suppression_types_num_(suppression_types_num), suppressions_(1),
      can_parse_(true) {
  CHECK_LE(suppression_types_num_, kMaxSuppressionTypes);
  internal_memset(has_suppression_type_, 0, suppression_types_num_);
  40fdb4:	e9 87 a5 ff ff       	jmpq   40a340 <_ZN11__sanitizer15internal_memsetEPvim>
SuppressionContext::SuppressionContext(const char *suppression_types[],
                                       int suppression_types_num)
    : suppression_types_(suppression_types),
      suppression_types_num_(suppression_types_num), suppressions_(1),
      can_parse_(true) {
  CHECK_LE(suppression_types_num_, kMaxSuppressionTypes);
  40fdb9:	48 89 d1             	mov    %rdx,%rcx
  40fdbc:	48 8d 3d ad 7d 00 00 	lea    0x7dad(%rip),%rdi        # 417b70 <.LC2>
  40fdc3:	48 8d 15 6e 7d 00 00 	lea    0x7d6e(%rip),%rdx        # 417b38 <.LC1>
  40fdca:	41 b8 10 00 00 00    	mov    $0x10,%r8d
  40fdd0:	be 1d 00 00 00       	mov    $0x1d,%esi
  40fdd5:	e8 16 56 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  40fdda:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000040fde0 <_ZN11__sanitizer18SuppressionContext5MatchEPKcS2_PPNS_11SuppressionE>:

  Parse(file_contents);
}

bool SuppressionContext::Match(const char *str, const char *type,
                               Suppression **s) {
  40fde0:	41 57                	push   %r15
  40fde2:	41 56                	push   %r14
  40fde4:	41 55                	push   %r13
  40fde6:	41 54                	push   %r12
  40fde8:	55                   	push   %rbp
  40fde9:	48 89 fd             	mov    %rdi,%rbp
  40fdec:	53                   	push   %rbx
  40fded:	48 83 ec 08          	sub    $0x8,%rsp
uptr SuppressionContext::SuppressionCount() const {
  return suppressions_.size();
}

bool SuppressionContext::HasSuppressionType(const char *type) const {
  for (int i = 0; i < suppression_types_num_; i++) {
  40fdf1:	8b 47 08             	mov    0x8(%rdi),%eax
  Parse(file_contents);
}

bool SuppressionContext::Match(const char *str, const char *type,
                               Suppression **s) {
  can_parse_ = false;
  40fdf4:	c6 47 38 00          	movb   $0x0,0x38(%rdi)
uptr SuppressionContext::SuppressionCount() const {
  return suppressions_.size();
}

bool SuppressionContext::HasSuppressionType(const char *type) const {
  for (int i = 0; i < suppression_types_num_; i++) {
  40fdf8:	85 c0                	test   %eax,%eax
  40fdfa:	0f 8e a0 00 00 00    	jle    40fea0 <_ZN11__sanitizer18SuppressionContext5MatchEPKcS2_PPNS_11SuppressionE+0xc0>
  40fe00:	49 89 f5             	mov    %rsi,%r13
  40fe03:	49 89 d4             	mov    %rdx,%r12
  40fe06:	49 89 ce             	mov    %rcx,%r14
  40fe09:	31 db                	xor    %ebx,%ebx
  40fe0b:	eb 13                	jmp    40fe20 <_ZN11__sanitizer18SuppressionContext5MatchEPKcS2_PPNS_11SuppressionE+0x40>
  40fe0d:	0f 1f 00             	nopl   (%rax)
  40fe10:	8d 43 01             	lea    0x1(%rbx),%eax
  40fe13:	48 83 c3 01          	add    $0x1,%rbx
  40fe17:	3b 45 08             	cmp    0x8(%rbp),%eax
  40fe1a:	0f 8d 80 00 00 00    	jge    40fea0 <_ZN11__sanitizer18SuppressionContext5MatchEPKcS2_PPNS_11SuppressionE+0xc0>
    if (0 == internal_strcmp(type, suppression_types_[i]))
  40fe20:	48 8b 45 00          	mov    0x0(%rbp),%rax
  40fe24:	4c 89 e7             	mov    %r12,%rdi
  40fe27:	4c 63 fb             	movslq %ebx,%r15
  40fe2a:	48 8b 34 d8          	mov    (%rax,%rbx,8),%rsi
  40fe2e:	e8 ad a9 ff ff       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
  40fe33:	85 c0                	test   %eax,%eax
  40fe35:	75 d9                	jne    40fe10 <_ZN11__sanitizer18SuppressionContext5MatchEPKcS2_PPNS_11SuppressionE+0x30>
}

bool SuppressionContext::Match(const char *str, const char *type,
                               Suppression **s) {
  can_parse_ = false;
  if (!HasSuppressionType(type))
  40fe37:	42 80 7c 3d 28 00    	cmpb   $0x0,0x28(%rbp,%r15,1)
  40fe3d:	74 61                	je     40fea0 <_ZN11__sanitizer18SuppressionContext5MatchEPKcS2_PPNS_11SuppressionE+0xc0>
    return false;
  for (uptr i = 0; i < suppressions_.size(); i++) {
  40fe3f:	48 83 7d 20 00       	cmpq   $0x0,0x20(%rbp)
  40fe44:	74 5a                	je     40fea0 <_ZN11__sanitizer18SuppressionContext5MatchEPKcS2_PPNS_11SuppressionE+0xc0>
    Suppression &cur = suppressions_[i];
  40fe46:	48 8b 45 10          	mov    0x10(%rbp),%rax
  40fe4a:	31 db                	xor    %ebx,%ebx
  40fe4c:	eb 10                	jmp    40fe5e <_ZN11__sanitizer18SuppressionContext5MatchEPKcS2_PPNS_11SuppressionE+0x7e>
  40fe4e:	66 90                	xchg   %ax,%ax
bool SuppressionContext::Match(const char *str, const char *type,
                               Suppression **s) {
  can_parse_ = false;
  if (!HasSuppressionType(type))
    return false;
  for (uptr i = 0; i < suppressions_.size(); i++) {
  40fe50:	48 83 c3 01          	add    $0x1,%rbx
  40fe54:	48 39 5d 20          	cmp    %rbx,0x20(%rbp)
  40fe58:	76 46                	jbe    40fea0 <_ZN11__sanitizer18SuppressionContext5MatchEPKcS2_PPNS_11SuppressionE+0xc0>
    Suppression &cur = suppressions_[i];
  40fe5a:	48 8b 45 10          	mov    0x10(%rbp),%rax
  40fe5e:	49 89 df             	mov    %rbx,%r15
    if (0 == internal_strcmp(cur.type, type) && TemplateMatch(cur.templ, str)) {
  40fe61:	4c 89 e6             	mov    %r12,%rsi
  40fe64:	49 c1 e7 05          	shl    $0x5,%r15
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
    return data_[i];
  40fe68:	49 01 c7             	add    %rax,%r15
  40fe6b:	49 8b 3f             	mov    (%r15),%rdi
  40fe6e:	e8 6d a9 ff ff       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
  40fe73:	85 c0                	test   %eax,%eax
  40fe75:	75 d9                	jne    40fe50 <_ZN11__sanitizer18SuppressionContext5MatchEPKcS2_PPNS_11SuppressionE+0x70>
  40fe77:	49 8b 7f 08          	mov    0x8(%r15),%rdi
  40fe7b:	4c 89 ee             	mov    %r13,%rsi
  40fe7e:	e8 2d 5d ff ff       	callq  405bb0 <_ZN11__sanitizer13TemplateMatchEPKcS1_>
  40fe83:	84 c0                	test   %al,%al
  40fe85:	74 c9                	je     40fe50 <_ZN11__sanitizer18SuppressionContext5MatchEPKcS2_PPNS_11SuppressionE+0x70>
      *s = &cur;
  40fe87:	4d 89 3e             	mov    %r15,(%r14)
      return true;
    }
  }
  return false;
}
  40fe8a:	48 83 c4 08          	add    $0x8,%rsp
  40fe8e:	5b                   	pop    %rbx
  40fe8f:	5d                   	pop    %rbp
  40fe90:	41 5c                	pop    %r12
  40fe92:	41 5d                	pop    %r13
  40fe94:	41 5e                	pop    %r14
  40fe96:	41 5f                	pop    %r15
  40fe98:	c3                   	retq   
  40fe99:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40fea0:	48 83 c4 08          	add    $0x8,%rsp

bool SuppressionContext::Match(const char *str, const char *type,
                               Suppression **s) {
  can_parse_ = false;
  if (!HasSuppressionType(type))
    return false;
  40fea4:	31 c0                	xor    %eax,%eax
      *s = &cur;
      return true;
    }
  }
  return false;
}
  40fea6:	5b                   	pop    %rbx
  40fea7:	5d                   	pop    %rbp
  40fea8:	41 5c                	pop    %r12
  40feaa:	41 5d                	pop    %r13
  40feac:	41 5e                	pop    %r14
  40feae:	41 5f                	pop    %r15
  40feb0:	c3                   	retq   
  40feb1:	90                   	nop
  40feb2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  40feb9:	1f 84 00 00 00 00 00 

000000000040fec0 <_ZN11__sanitizer18SuppressionContext5ParseEPKc>:
  if (!*prefix)
    return str;
  return 0;
}

void SuppressionContext::Parse(const char *str) {
  40fec0:	41 57                	push   %r15
  40fec2:	41 56                	push   %r14
  40fec4:	49 89 fe             	mov    %rdi,%r14
  40fec7:	41 55                	push   %r13
  40fec9:	41 54                	push   %r12
  40fecb:	55                   	push   %rbp
  40fecc:	53                   	push   %rbx
  40fecd:	48 83 ec 28          	sub    $0x28,%rsp
  // Context must not mutate once Match has been called.
  CHECK(can_parse_);
  40fed1:	80 7f 38 00          	cmpb   $0x0,0x38(%rdi)
  40fed5:	0f 84 0e 03 00 00    	je     4101e9 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x329>
  const char *line = str;
  while (line) {
  40fedb:	48 85 f6             	test   %rsi,%rsi
  40fede:	48 89 f3             	mov    %rsi,%rbx
  40fee1:	0f 84 b7 01 00 00    	je     41009e <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x1de>
  40fee7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40feee:	00 00 
    while (line[0] == ' ' || line[0] == '\t')
  40fef0:	0f b6 03             	movzbl (%rbx),%eax
  40fef3:	3c 09                	cmp    $0x9,%al
  40fef5:	75 14                	jne    40ff0b <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x4b>
  40fef7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40fefe:	00 00 
      line++;
  40ff00:	48 83 c3 01          	add    $0x1,%rbx
void SuppressionContext::Parse(const char *str) {
  // Context must not mutate once Match has been called.
  CHECK(can_parse_);
  const char *line = str;
  while (line) {
    while (line[0] == ' ' || line[0] == '\t')
  40ff04:	0f b6 03             	movzbl (%rbx),%eax
  40ff07:	3c 09                	cmp    $0x9,%al
  40ff09:	74 f5                	je     40ff00 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x40>
  40ff0b:	3c 20                	cmp    $0x20,%al
  40ff0d:	74 f1                	je     40ff00 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x40>
      line++;
    const char *end = internal_strchr(line, '\n');
  40ff0f:	be 0a 00 00 00       	mov    $0xa,%esi
  40ff14:	48 89 df             	mov    %rbx,%rdi
  40ff17:	e8 54 a9 ff ff       	callq  40a870 <_ZN11__sanitizer15internal_strchrEPKci>
    if (end == 0)
  40ff1c:	48 85 c0             	test   %rax,%rax
  CHECK(can_parse_);
  const char *line = str;
  while (line) {
    while (line[0] == ' ' || line[0] == '\t')
      line++;
    const char *end = internal_strchr(line, '\n');
  40ff1f:	49 89 c5             	mov    %rax,%r13
    if (end == 0)
  40ff22:	0f 84 ec 01 00 00    	je     410114 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x254>
      end = line + internal_strlen(line);
    if (line != end && line[0] != '#') {
  40ff28:	4c 39 eb             	cmp    %r13,%rbx
  40ff2b:	0f 84 59 01 00 00    	je     41008a <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x1ca>
  40ff31:	80 3b 23             	cmpb   $0x23,(%rbx)
  40ff34:	4c 89 ee             	mov    %r13,%rsi
  40ff37:	0f 84 4d 01 00 00    	je     41008a <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x1ca>
  40ff3d:	0f 1f 00             	nopl   (%rax)
      const char *end2 = end;
      while (line != end2 &&
             (end2[-1] == ' ' || end2[-1] == '\t' || end2[-1] == '\r'))
  40ff40:	0f b6 56 ff          	movzbl -0x1(%rsi),%edx
  40ff44:	89 d0                	mov    %edx,%eax
  40ff46:	83 e0 fb             	and    $0xfffffffb,%eax
    const char *end = internal_strchr(line, '\n');
    if (end == 0)
      end = line + internal_strlen(line);
    if (line != end && line[0] != '#') {
      const char *end2 = end;
      while (line != end2 &&
  40ff49:	3c 09                	cmp    $0x9,%al
  40ff4b:	74 6b                	je     40ffb8 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0xf8>
  40ff4d:	80 fa 20             	cmp    $0x20,%dl
  40ff50:	74 66                	je     40ffb8 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0xf8>
             (end2[-1] == ' ' || end2[-1] == '\t' || end2[-1] == '\r'))
        end2--;
      int type;
      for (type = 0; type < suppression_types_num_; type++) {
  40ff52:	45 8b 4e 08          	mov    0x8(%r14),%r9d
  40ff56:	41 83 f9 00          	cmp    $0x0,%r9d
  40ff5a:	7e 73                	jle    40ffcf <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x10f>
  40ff5c:	49 8b 06             	mov    (%r14),%rax
  40ff5f:	45 31 e4             	xor    %r12d,%r12d
  40ff62:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        const char *next_char = StripPrefix(line, suppression_types_[type]);
  40ff68:	48 8b 38             	mov    (%rax),%rdi
  40ff6b:	48 89 da             	mov    %rbx,%rdx
  40ff6e:	48 89 f9             	mov    %rdi,%rcx
  40ff71:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  }
  return false;
}

static const char *StripPrefix(const char *str, const char *prefix) {
  while (str && *str == *prefix) {
  40ff78:	44 0f b6 01          	movzbl (%rcx),%r8d
  40ff7c:	44 38 02             	cmp    %r8b,(%rdx)
  40ff7f:	75 5f                	jne    40ffe0 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x120>
    str++;
    prefix++;
  40ff81:	48 83 c1 01          	add    $0x1,%rcx
  }
  return false;
}

static const char *StripPrefix(const char *str, const char *prefix) {
  while (str && *str == *prefix) {
  40ff85:	48 83 c2 01          	add    $0x1,%rdx
  40ff89:	75 ed                	jne    40ff78 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0xb8>
      const char *end2 = end;
      while (line != end2 &&
             (end2[-1] == ' ' || end2[-1] == '\t' || end2[-1] == '\r'))
        end2--;
      int type;
      for (type = 0; type < suppression_types_num_; type++) {
  40ff8b:	41 83 c4 01          	add    $0x1,%r12d
  40ff8f:	48 83 c0 08          	add    $0x8,%rax
  40ff93:	45 39 cc             	cmp    %r9d,%r12d
  40ff96:	75 d0                	jne    40ff68 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0xa8>
          line = ++next_char;
          break;
        }
      }
      if (type == suppression_types_num_) {
        Printf("%s: failed to parse suppressions\n", SanitizerToolName);
  40ff98:	48 8b 05 11 e3 00 00 	mov    0xe311(%rip),%rax        # 41e2b0 <_DYNAMIC+0x2b0>
  40ff9f:	48 8d 3d 42 7c 00 00 	lea    0x7c42(%rip),%rdi        # 417be8 <.LC4>
  40ffa6:	48 8b 30             	mov    (%rax),%rsi
  40ffa9:	31 c0                	xor    %eax,%eax
  40ffab:	e8 40 da ff ff       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
        Die();
  40ffb0:	e8 ab 52 ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  40ffb5:	0f 1f 00             	nopl   (%rax)
      end = line + internal_strlen(line);
    if (line != end && line[0] != '#') {
      const char *end2 = end;
      while (line != end2 &&
             (end2[-1] == ' ' || end2[-1] == '\t' || end2[-1] == '\r'))
        end2--;
  40ffb8:	48 83 ee 01          	sub    $0x1,%rsi
    const char *end = internal_strchr(line, '\n');
    if (end == 0)
      end = line + internal_strlen(line);
    if (line != end && line[0] != '#') {
      const char *end2 = end;
      while (line != end2 &&
  40ffbc:	48 39 de             	cmp    %rbx,%rsi
  40ffbf:	0f 85 7b ff ff ff    	jne    40ff40 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x80>
             (end2[-1] == ' ' || end2[-1] == '\t' || end2[-1] == '\r'))
        end2--;
      int type;
      for (type = 0; type < suppression_types_num_; type++) {
  40ffc5:	45 8b 4e 08          	mov    0x8(%r14),%r9d
  40ffc9:	41 83 f9 00          	cmp    $0x0,%r9d
  40ffcd:	7f 8d                	jg     40ff5c <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x9c>
        if (next_char && *next_char == ':') {
          line = ++next_char;
          break;
        }
      }
      if (type == suppression_types_num_) {
  40ffcf:	74 c7                	je     40ff98 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0xd8>
  40ffd1:	49 8b 06             	mov    (%r14),%rax
  40ffd4:	45 31 e4             	xor    %r12d,%r12d
  40ffd7:	48 8b 38             	mov    (%rax),%rdi
  40ffda:	eb 17                	jmp    40fff3 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x133>
  40ffdc:	0f 1f 40 00          	nopl   0x0(%rax)
static const char *StripPrefix(const char *str, const char *prefix) {
  while (str && *str == *prefix) {
    str++;
    prefix++;
  }
  if (!*prefix)
  40ffe0:	45 84 c0             	test   %r8b,%r8b
  40ffe3:	75 a6                	jne    40ff8b <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0xcb>
             (end2[-1] == ' ' || end2[-1] == '\t' || end2[-1] == '\r'))
        end2--;
      int type;
      for (type = 0; type < suppression_types_num_; type++) {
        const char *next_char = StripPrefix(line, suppression_types_[type]);
        if (next_char && *next_char == ':') {
  40ffe5:	48 85 d2             	test   %rdx,%rdx
  40ffe8:	74 a1                	je     40ff8b <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0xcb>
  40ffea:	80 3a 3a             	cmpb   $0x3a,(%rdx)
  40ffed:	75 9c                	jne    40ff8b <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0xcb>
          line = ++next_char;
  40ffef:	48 8d 5a 01          	lea    0x1(%rdx),%rbx
        Printf("%s: failed to parse suppressions\n", SanitizerToolName);
        Die();
      }
      Suppression s = {};
      s.type = suppression_types_[type];
      s.templ = (char*)InternalAlloc(end2 - line + 1);
  40fff3:	48 29 de             	sub    %rbx,%rsi
      if (type == suppression_types_num_) {
        Printf("%s: failed to parse suppressions\n", SanitizerToolName);
        Die();
      }
      Suppression s = {};
      s.type = suppression_types_[type];
  40fff6:	48 89 3c 24          	mov    %rdi,(%rsp)
      }
      if (type == suppression_types_num_) {
        Printf("%s: failed to parse suppressions\n", SanitizerToolName);
        Die();
      }
      Suppression s = {};
  40fffa:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
  410001:	00 00 
      s.type = suppression_types_[type];
      s.templ = (char*)InternalAlloc(end2 - line + 1);
  410003:	48 8d 7e 01          	lea    0x1(%rsi),%rdi
  410007:	49 89 f7             	mov    %rsi,%r15
  41000a:	31 f6                	xor    %esi,%esi
      }
      if (type == suppression_types_num_) {
        Printf("%s: failed to parse suppressions\n", SanitizerToolName);
        Die();
      }
      Suppression s = {};
  41000c:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
  410013:	00 00 
      s.type = suppression_types_[type];
      s.templ = (char*)InternalAlloc(end2 - line + 1);
  410015:	e8 16 33 ff ff       	callq  403330 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE>
      internal_memcpy(s.templ, line, end2 - line);
  41001a:	4c 89 fa             	mov    %r15,%rdx
        Printf("%s: failed to parse suppressions\n", SanitizerToolName);
        Die();
      }
      Suppression s = {};
      s.type = suppression_types_[type];
      s.templ = (char*)InternalAlloc(end2 - line + 1);
  41001d:	48 89 c5             	mov    %rax,%rbp
      internal_memcpy(s.templ, line, end2 - line);
  410020:	48 89 de             	mov    %rbx,%rsi
  410023:	48 89 c7             	mov    %rax,%rdi
        Printf("%s: failed to parse suppressions\n", SanitizerToolName);
        Die();
      }
      Suppression s = {};
      s.type = suppression_types_[type];
      s.templ = (char*)InternalAlloc(end2 - line + 1);
  410026:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
      internal_memcpy(s.templ, line, end2 - line);
  41002b:	e8 e0 9e ff ff       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
      s.templ[end2 - line] = 0;
  410030:	42 c6 44 3d 00 00    	movb   $0x0,0x0(%rbp,%r15,1)
  const T &operator[](uptr i) const {
    CHECK_LT(i, size_);
    return data_[i];
  }
  void push_back(const T &element) {
    CHECK_LE(size_, capacity_);
  410036:	49 8b 46 20          	mov    0x20(%r14),%rax
  41003a:	4d 8b 46 18          	mov    0x18(%r14),%r8
  41003e:	4c 39 c0             	cmp    %r8,%rax
  410041:	0f 87 2f 01 00 00    	ja     410176 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x2b6>
    if (size_ == capacity_) {
  410047:	48 89 c2             	mov    %rax,%rdx
  41004a:	74 61                	je     4100ad <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x1ed>
      uptr new_capacity = RoundUpToPowerOfTwo(size_ + 1);
      Resize(new_capacity);
    }
    data_[size_++] = element;
  41004c:	48 8d 42 01          	lea    0x1(%rdx),%rax
      suppressions_.push_back(s);
      has_suppression_type_[type] = true;
  410050:	4d 63 e4             	movslq %r12d,%r12
  410053:	49 89 46 20          	mov    %rax,0x20(%r14)
  410057:	48 89 d0             	mov    %rdx,%rax
  41005a:	48 8b 14 24          	mov    (%rsp),%rdx
  41005e:	48 c1 e0 05          	shl    $0x5,%rax
  410062:	49 03 46 10          	add    0x10(%r14),%rax
  410066:	48 89 10             	mov    %rdx,(%rax)
  410069:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  41006e:	48 89 50 08          	mov    %rdx,0x8(%rax)
  410072:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  410077:	48 89 50 10          	mov    %rdx,0x10(%rax)
  41007b:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
  410080:	48 89 50 18          	mov    %rdx,0x18(%rax)
  410084:	43 c6 44 26 28 01    	movb   $0x1,0x28(%r14,%r12,1)
    }
    if (end[0] == 0)
  41008a:	41 80 7d 00 00       	cmpb   $0x0,0x0(%r13)
  41008f:	74 0d                	je     41009e <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x1de>

void SuppressionContext::Parse(const char *str) {
  // Context must not mutate once Match has been called.
  CHECK(can_parse_);
  const char *line = str;
  while (line) {
  410091:	4c 89 eb             	mov    %r13,%rbx
  410094:	48 83 c3 01          	add    $0x1,%rbx
  410098:	0f 85 52 fe ff ff    	jne    40fef0 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x30>
    }
    if (end[0] == 0)
      break;
    line = end + 1;
  }
}
  41009e:	48 83 c4 28          	add    $0x28,%rsp
  4100a2:	5b                   	pop    %rbx
  4100a3:	5d                   	pop    %rbp
  4100a4:	41 5c                	pop    %r12
  4100a6:	41 5d                	pop    %r13
  4100a8:	41 5e                	pop    %r14
  4100aa:	41 5f                	pop    %r15
  4100ac:	c3                   	retq   
INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
}

INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  4100ad:	48 83 c2 01          	add    $0x1,%rdx
  4100b1:	0f 84 da 00 00 00    	je     410191 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x2d1>
  if (IsPowerOfTwo(size)) return size;
  4100b7:	48 85 c2             	test   %rax,%rdx
  4100ba:	48 89 d3             	mov    %rdx,%rbx
  4100bd:	75 66                	jne    410125 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x265>
  bool empty() const { return size() == 0; }

 private:
  void Resize(uptr new_capacity) {
    CHECK_GT(new_capacity, 0);
    CHECK_LE(size_, new_capacity);
  4100bf:	48 39 d8             	cmp    %rbx,%rax
  4100c2:	0f 87 e6 00 00 00    	ja     4101ae <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x2ee>
    T *new_data = (T *)MmapOrDie(new_capacity * sizeof(T),
                                 "InternalMmapVector");
  4100c8:	48 8d 35 79 8e 00 00 	lea    0x8e79(%rip),%rsi        # 418f48 <.LC11>
  4100cf:	48 89 df             	mov    %rbx,%rdi
  4100d2:	48 c1 e7 05          	shl    $0x5,%rdi
  4100d6:	e8 c5 c2 ff ff       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
    internal_memcpy(new_data, data_, size_ * sizeof(T));
  4100db:	49 8b 56 20          	mov    0x20(%r14),%rdx
  4100df:	49 8b 76 10          	mov    0x10(%r14),%rsi
  4100e3:	48 89 c7             	mov    %rax,%rdi
 private:
  void Resize(uptr new_capacity) {
    CHECK_GT(new_capacity, 0);
    CHECK_LE(size_, new_capacity);
    T *new_data = (T *)MmapOrDie(new_capacity * sizeof(T),
                                 "InternalMmapVector");
  4100e6:	49 89 c7             	mov    %rax,%r15
    internal_memcpy(new_data, data_, size_ * sizeof(T));
  4100e9:	48 c1 e2 05          	shl    $0x5,%rdx
  4100ed:	e8 1e 9e ff ff       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
    T *old_data = data_;
    data_ = new_data;
    UnmapOrDie(old_data, capacity_ * sizeof(T));
  4100f2:	49 8b 76 18          	mov    0x18(%r14),%rsi
    CHECK_GT(new_capacity, 0);
    CHECK_LE(size_, new_capacity);
    T *new_data = (T *)MmapOrDie(new_capacity * sizeof(T),
                                 "InternalMmapVector");
    internal_memcpy(new_data, data_, size_ * sizeof(T));
    T *old_data = data_;
  4100f6:	49 8b 7e 10          	mov    0x10(%r14),%rdi
    data_ = new_data;
  4100fa:	4d 89 7e 10          	mov    %r15,0x10(%r14)
    UnmapOrDie(old_data, capacity_ * sizeof(T));
  4100fe:	48 c1 e6 05          	shl    $0x5,%rsi
  410102:	e8 39 c3 ff ff       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
    capacity_ = new_capacity;
  410107:	49 89 5e 18          	mov    %rbx,0x18(%r14)
  41010b:	49 8b 56 20          	mov    0x20(%r14),%rdx
  41010f:	e9 38 ff ff ff       	jmpq   41004c <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x18c>
  while (line) {
    while (line[0] == ' ' || line[0] == '\t')
      line++;
    const char *end = internal_strchr(line, '\n');
    if (end == 0)
      end = line + internal_strlen(line);
  410114:	48 89 df             	mov    %rbx,%rdi
  410117:	e8 14 a8 ff ff       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  41011c:	4c 8d 2c 03          	lea    (%rbx,%rax,1),%r13
  410120:	e9 03 fe ff ff       	jmpq   40ff28 <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x68>
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  410125:	48 0f bd ca          	bsr    %rdx,%rcx
  410129:	be 3f 00 00 00       	mov    $0x3f,%esi
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  41012e:	bf 01 00 00 00       	mov    $0x1,%edi
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  410133:	48 83 f1 3f          	xor    $0x3f,%rcx
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  410137:	48 89 fb             	mov    %rdi,%rbx
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  41013a:	29 ce                	sub    %ecx,%esi
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  41013c:	8d 4e 01             	lea    0x1(%rsi),%ecx
  41013f:	48 d3 e3             	shl    %cl,%rbx
  410142:	48 39 da             	cmp    %rbx,%rdx
  410145:	0f 83 81 00 00 00    	jae    4101cc <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x30c>
  CHECK(size > (1ULL << up));
  41014b:	89 f1                	mov    %esi,%ecx
  41014d:	48 d3 e7             	shl    %cl,%rdi
  410150:	48 39 fa             	cmp    %rdi,%rdx
  410153:	0f 87 66 ff ff ff    	ja     4100bf <_ZN11__sanitizer18SuppressionContext5ParseEPKc+0x1ff>
  410159:	48 8d 15 e0 78 00 00 	lea    0x78e0(%rip),%rdx        # 417a40 <.LC10>
  410160:	48 8d 3d a9 4e 00 00 	lea    0x4ea9(%rip),%rdi        # 415010 <.LC1>
  410167:	45 31 c0             	xor    %r8d,%r8d
  41016a:	31 c9                	xor    %ecx,%ecx
  41016c:	be a4 01 00 00       	mov    $0x1a4,%esi
  410171:	e8 7a 52 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  const T &operator[](uptr i) const {
    CHECK_LT(i, size_);
    return data_[i];
  }
  void push_back(const T &element) {
    CHECK_LE(size_, capacity_);
  410176:	48 8d 15 82 8d 00 00 	lea    0x8d82(%rip),%rdx        # 418eff <.LC4>
  41017d:	48 8d 3d 8c 4e 00 00 	lea    0x4e8c(%rip),%rdi        # 415010 <.LC1>
  410184:	48 89 c1             	mov    %rax,%rcx
  410187:	be e7 01 00 00       	mov    $0x1e7,%esi
  41018c:	e8 5f 52 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
}

INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  410191:	48 8d 15 82 8d 00 00 	lea    0x8d82(%rip),%rdx        # 418f1a <.LC5>
  410198:	48 8d 3d 71 4e 00 00 	lea    0x4e71(%rip),%rdi        # 415010 <.LC1>
  41019f:	45 31 c0             	xor    %r8d,%r8d
  4101a2:	31 c9                	xor    %ecx,%ecx
  4101a4:	be 9f 01 00 00       	mov    $0x19f,%esi
  4101a9:	e8 42 52 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  bool empty() const { return size() == 0; }

 private:
  void Resize(uptr new_capacity) {
    CHECK_GT(new_capacity, 0);
    CHECK_LE(size_, new_capacity);
  4101ae:	48 8d 15 75 8d 00 00 	lea    0x8d75(%rip),%rdx        # 418f2a <.LC10>
  4101b5:	48 8d 3d 54 4e 00 00 	lea    0x4e54(%rip),%rdi        # 415010 <.LC1>
  4101bc:	49 89 d8             	mov    %rbx,%r8
  4101bf:	48 89 c1             	mov    %rax,%rcx
  4101c2:	be 09 02 00 00       	mov    $0x209,%esi
  4101c7:	e8 24 52 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  4101cc:	48 8d 15 45 78 00 00 	lea    0x7845(%rip),%rdx        # 417a18 <.LC2>
  4101d3:	48 8d 3d 36 4e 00 00 	lea    0x4e36(%rip),%rdi        # 415010 <.LC1>
  4101da:	45 31 c0             	xor    %r8d,%r8d
  4101dd:	31 c9                	xor    %ecx,%ecx
  4101df:	be a3 01 00 00       	mov    $0x1a3,%esi
  4101e4:	e8 07 52 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  return 0;
}

void SuppressionContext::Parse(const char *str) {
  // Context must not mutate once Match has been called.
  CHECK(can_parse_);
  4101e9:	48 8d 15 34 8e 00 00 	lea    0x8e34(%rip),%rdx        # 419024 <.LC3>
  4101f0:	48 8d 3d 79 79 00 00 	lea    0x7979(%rip),%rdi        # 417b70 <.LC2>
  4101f7:	45 31 c0             	xor    %r8d,%r8d
  4101fa:	31 c9                	xor    %ecx,%ecx
  4101fc:	be 69 00 00 00       	mov    $0x69,%esi
  410201:	e8 ea 51 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  410206:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  41020d:	00 00 00 

0000000000410210 <_ZN11__sanitizer18SuppressionContext13ParseFromFileEPKc>:
    return true;
  }
  return false;
}

void SuppressionContext::ParseFromFile(const char *filename) {
  410210:	41 56                	push   %r14
  410212:	41 55                	push   %r13
  410214:	41 54                	push   %r12
  410216:	55                   	push   %rbp
  410217:	53                   	push   %rbx
  410218:	48 89 f3             	mov    %rsi,%rbx
  41021b:	48 83 ec 30          	sub    $0x30,%rsp
  if (filename[0] == '\0')
  41021f:	80 3e 00             	cmpb   $0x0,(%rsi)
  410222:	75 14                	jne    410238 <_ZN11__sanitizer18SuppressionContext13ParseFromFileEPKc+0x28>
           filename);
    Die();
  }

  Parse(file_contents);
}
  410224:	48 83 c4 30          	add    $0x30,%rsp
  410228:	5b                   	pop    %rbx
  410229:	5d                   	pop    %rbp
  41022a:	41 5c                	pop    %r12
  41022c:	41 5d                	pop    %r13
  41022e:	41 5e                	pop    %r14
  410230:	c3                   	retq   
  410231:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  410238:	48 8d 35 3a 83 00 00 	lea    0x833a(%rip),%rsi        # 418579 <.LC1>
  41023f:	48 89 fd             	mov    %rdi,%rbp
  410242:	bf 00 10 00 00       	mov    $0x1000,%edi
  410247:	e8 54 c1 ff ff       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
    return;

  // If we cannot find the file, check if its location is relative to
  // the location of the executable.
  InternalScopedString new_file_path(kMaxPathLength);
  if (!FileExists(filename) && !IsAbsolutePath(filename) &&
  41024c:	48 89 df             	mov    %rbx,%rdi

class InternalScopedString : public InternalScopedBuffer<char> {
 public:
  explicit InternalScopedString(uptr max_length)
      : InternalScopedBuffer<char>(max_length), length_(0) {
    (*this)[0] = '\0';
  41024f:	c6 00 00             	movb   $0x0,(%rax)
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  410252:	49 89 c4             	mov    %rax,%r12
  410255:	e8 06 b4 ff ff       	callq  40b660 <_ZN11__sanitizer10FileExistsEPKc>
  41025a:	84 c0                	test   %al,%al
  41025c:	74 62                	je     4102c0 <_ZN11__sanitizer18SuppressionContext13ParseFromFileEPKc+0xb0>
  typename T::Type v;

  if (sizeof(*a) < 8 || sizeof(void*) == 8) {
    // Assume that aligned loads are atomic.
    if (mo == memory_order_relaxed) {
      v = a->val_dont_use;
  41025e:	48 8b 05 5b e0 00 00 	mov    0xe05b(%rip),%rax        # 41e2c0 <_DYNAMIC+0x2c0>
  410265:	8b 00                	mov    (%rax),%eax
                                          new_file_path.size())) {
    filename = new_file_path.data();
  }

  // Read the file.
  VPrintf(1, "%s: reading suppressions file at %s\n",
  410267:	85 c0                	test   %eax,%eax
  410269:	0f 85 a1 00 00 00    	jne    410310 <_ZN11__sanitizer18SuppressionContext13ParseFromFileEPKc+0x100>
          SanitizerToolName, filename);
  char *file_contents;
  uptr buffer_size;
  uptr contents_size;
  if (!ReadFileToBuffer(filename, &file_contents, &buffer_size,
                        &contents_size)) {
  41026f:	48 8d 4c 24 20       	lea    0x20(%rsp),%rcx
  410274:	48 8d 54 24 10       	lea    0x10(%rsp),%rdx
  410279:	45 31 c9             	xor    %r9d,%r9d
  41027c:	48 89 e6             	mov    %rsp,%rsi
  41027f:	41 b8 00 00 00 04    	mov    $0x4000000,%r8d
  410285:	48 89 df             	mov    %rbx,%rdi
  410288:	e8 63 53 ff ff       	callq  4055f0 <_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi>
  VPrintf(1, "%s: reading suppressions file at %s\n",
          SanitizerToolName, filename);
  char *file_contents;
  uptr buffer_size;
  uptr contents_size;
  if (!ReadFileToBuffer(filename, &file_contents, &buffer_size,
  41028d:	84 c0                	test   %al,%al
  41028f:	0f 84 f2 00 00 00    	je     410387 <_ZN11__sanitizer18SuppressionContext13ParseFromFileEPKc+0x177>
    Printf("%s: failed to read suppressions file '%s'\n", SanitizerToolName,
           filename);
    Die();
  }

  Parse(file_contents);
  410295:	48 8b 34 24          	mov    (%rsp),%rsi
  410299:	48 89 ef             	mov    %rbp,%rdi
  41029c:	e8 1f fc ff ff       	callq  40fec0 <_ZN11__sanitizer18SuppressionContext5ParseEPKc>
  }
  ~InternalScopedBuffer() {
    UnmapOrDie(ptr_, cnt_ * sizeof(T));
  4102a1:	4c 89 e7             	mov    %r12,%rdi
  4102a4:	be 00 10 00 00       	mov    $0x1000,%esi
  4102a9:	e8 92 c1 ff ff       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
}
  4102ae:	48 83 c4 30          	add    $0x30,%rsp
  4102b2:	5b                   	pop    %rbx
  4102b3:	5d                   	pop    %rbp
  4102b4:	41 5c                	pop    %r12
  4102b6:	41 5d                	pop    %r13
  4102b8:	41 5e                	pop    %r14
  4102ba:	c3                   	retq   
  4102bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    return;

  // If we cannot find the file, check if its location is relative to
  // the location of the executable.
  InternalScopedString new_file_path(kMaxPathLength);
  if (!FileExists(filename) && !IsAbsolutePath(filename) &&
  4102c0:	48 89 df             	mov    %rbx,%rdi
  4102c3:	e8 38 c9 ff ff       	callq  40cc00 <_ZN11__sanitizer14IsAbsolutePathEPKc>
  4102c8:	84 c0                	test   %al,%al
  4102ca:	75 92                	jne    41025e <_ZN11__sanitizer18SuppressionContext13ParseFromFileEPKc+0x4e>
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  4102cc:	48 8d 35 a6 82 00 00 	lea    0x82a6(%rip),%rsi        # 418579 <.LC1>
  4102d3:	bf 00 10 00 00       	mov    $0x1000,%edi
  4102d8:	e8 c3 c0 ff ff       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>

static bool GetPathAssumingFileIsRelativeToExec(const char *file_path,
                                                /*out*/char *new_file_path,
                                                uptr new_file_path_size) {
  InternalScopedString exec(kMaxPathLength);
  if (ReadBinaryNameCached(exec.data(), exec.size())) {
  4102dd:	be 00 10 00 00       	mov    $0x1000,%esi

class InternalScopedString : public InternalScopedBuffer<char> {
 public:
  explicit InternalScopedString(uptr max_length)
      : InternalScopedBuffer<char>(max_length), length_(0) {
    (*this)[0] = '\0';
  4102e2:	c6 00 00             	movb   $0x0,(%rax)
  4102e5:	48 89 c7             	mov    %rax,%rdi
template<typename T>
class InternalScopedBuffer {
 public:
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  4102e8:	49 89 c5             	mov    %rax,%r13
  4102eb:	e8 a0 5c ff ff       	callq  405f90 <_ZN11__sanitizer20ReadBinaryNameCachedEPcm>
  4102f0:	48 85 c0             	test   %rax,%rax
  4102f3:	75 3b                	jne    410330 <_ZN11__sanitizer18SuppressionContext13ParseFromFileEPKc+0x120>
  }
  ~InternalScopedBuffer() {
    UnmapOrDie(ptr_, cnt_ * sizeof(T));
  4102f5:	be 00 10 00 00       	mov    $0x1000,%esi
  4102fa:	4c 89 ef             	mov    %r13,%rdi
  4102fd:	e8 3e c1 ff ff       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  410302:	e9 57 ff ff ff       	jmpq   41025e <_ZN11__sanitizer18SuppressionContext13ParseFromFileEPKc+0x4e>
  410307:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  41030e:	00 00 
                                          new_file_path.size())) {
    filename = new_file_path.data();
  }

  // Read the file.
  VPrintf(1, "%s: reading suppressions file at %s\n",
  410310:	48 8b 05 99 df 00 00 	mov    0xdf99(%rip),%rax        # 41e2b0 <_DYNAMIC+0x2b0>
  410317:	48 8d 3d f2 78 00 00 	lea    0x78f2(%rip),%rdi        # 417c10 <.LC13>
  41031e:	48 89 da             	mov    %rbx,%rdx
  410321:	48 8b 30             	mov    (%rax),%rsi
  410324:	31 c0                	xor    %eax,%eax
  410326:	e8 c5 d6 ff ff       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  41032b:	e9 3f ff ff ff       	jmpq   41026f <_ZN11__sanitizer18SuppressionContext13ParseFromFileEPKc+0x5f>
static bool GetPathAssumingFileIsRelativeToExec(const char *file_path,
                                                /*out*/char *new_file_path,
                                                uptr new_file_path_size) {
  InternalScopedString exec(kMaxPathLength);
  if (ReadBinaryNameCached(exec.data(), exec.size())) {
    const char *file_name_pos = StripModuleName(exec.data());
  410330:	4c 89 ef             	mov    %r13,%rdi
  return LeastSignificantSetBitIndex(x);
}

// Don't use std::min, std::max or std::swap, to minimize dependency
// on libstdc++.
template<class T> T Min(T a, T b) { return a < b ? a : b; }
  410333:	41 be ff 0f 00 00    	mov    $0xfff,%r14d
  410339:	e8 42 56 ff ff       	callq  405980 <_ZN11__sanitizer15StripModuleNameEPKc>
    uptr path_to_exec_len = file_name_pos - exec.data();
  41033e:	4c 29 e8             	sub    %r13,%rax
    internal_strncat(new_file_path, exec.data(),
                     Min(path_to_exec_len, new_file_path_size - 1));
  410341:	4c 89 ee             	mov    %r13,%rsi
  410344:	4c 89 e7             	mov    %r12,%rdi
  410347:	48 3d fe 0f 00 00    	cmp    $0xffe,%rax
  41034d:	49 0f 47 c6          	cmova  %r14,%rax
  410351:	48 89 c2             	mov    %rax,%rdx
  410354:	e8 f7 a5 ff ff       	callq  40a950 <_ZN11__sanitizer16internal_strncatEPcPKcm>
    internal_strncat(new_file_path, file_path,
                     new_file_path_size - internal_strlen(new_file_path) - 1);
  410359:	4c 89 e7             	mov    %r12,%rdi
  41035c:	e8 cf a5 ff ff       	callq  40a930 <_ZN11__sanitizer15internal_strlenEPKc>
  410361:	4c 89 f2             	mov    %r14,%rdx
  410364:	48 89 de             	mov    %rbx,%rsi
  410367:	4c 89 e7             	mov    %r12,%rdi
  41036a:	48 29 c2             	sub    %rax,%rdx
  explicit InternalScopedBuffer(uptr cnt) {
    cnt_ = cnt;
    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), "InternalScopedBuffer");
  }
  ~InternalScopedBuffer() {
    UnmapOrDie(ptr_, cnt_ * sizeof(T));
  41036d:	4c 89 e3             	mov    %r12,%rbx
  410370:	e8 db a5 ff ff       	callq  40a950 <_ZN11__sanitizer16internal_strncatEPcPKcm>
  410375:	be 00 10 00 00       	mov    $0x1000,%esi
  41037a:	4c 89 ef             	mov    %r13,%rdi
  41037d:	e8 be c0 ff ff       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
  410382:	e9 d7 fe ff ff       	jmpq   41025e <_ZN11__sanitizer18SuppressionContext13ParseFromFileEPKc+0x4e>
  uptr buffer_size;
  uptr contents_size;
  if (!ReadFileToBuffer(filename, &file_contents, &buffer_size,
                        &contents_size)) {
    Printf("%s: failed to read suppressions file '%s'\n", SanitizerToolName,
           filename);
  410387:	48 8b 05 22 df 00 00 	mov    0xdf22(%rip),%rax        # 41e2b0 <_DYNAMIC+0x2b0>
  41038e:	48 8d 3d a3 78 00 00 	lea    0x78a3(%rip),%rdi        # 417c38 <.LC14>
  410395:	48 89 da             	mov    %rbx,%rdx
  410398:	48 8b 30             	mov    (%rax),%rsi
  41039b:	31 c0                	xor    %eax,%eax
  41039d:	e8 4e d6 ff ff       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
    Die();
  4103a2:	e8 b9 4e ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  4103a7:	90                   	nop
  4103a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4103af:	00 

00000000004103b0 <_ZNK11__sanitizer18SuppressionContext16SuppressionCountEv>:
    line = end + 1;
  }
}

uptr SuppressionContext::SuppressionCount() const {
  return suppressions_.size();
  4103b0:	48 8b 47 20          	mov    0x20(%rdi),%rax
}
  4103b4:	c3                   	retq   
  4103b5:	90                   	nop
  4103b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4103bd:	00 00 00 

00000000004103c0 <_ZNK11__sanitizer18SuppressionContext18HasSuppressionTypeEPKc>:

bool SuppressionContext::HasSuppressionType(const char *type) const {
  4103c0:	41 55                	push   %r13
  4103c2:	41 54                	push   %r12
  4103c4:	49 89 f4             	mov    %rsi,%r12
  4103c7:	55                   	push   %rbp
  4103c8:	48 89 fd             	mov    %rdi,%rbp
  4103cb:	53                   	push   %rbx
  for (int i = 0; i < suppression_types_num_; i++) {
  4103cc:	31 db                	xor    %ebx,%ebx

uptr SuppressionContext::SuppressionCount() const {
  return suppressions_.size();
}

bool SuppressionContext::HasSuppressionType(const char *type) const {
  4103ce:	48 83 ec 08          	sub    $0x8,%rsp
  for (int i = 0; i < suppression_types_num_; i++) {
  4103d2:	8b 47 08             	mov    0x8(%rdi),%eax
  4103d5:	85 c0                	test   %eax,%eax
  4103d7:	7f 13                	jg     4103ec <_ZNK11__sanitizer18SuppressionContext18HasSuppressionTypeEPKc+0x2c>
  4103d9:	eb 3d                	jmp    410418 <_ZNK11__sanitizer18SuppressionContext18HasSuppressionTypeEPKc+0x58>
  4103db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  4103e0:	8d 43 01             	lea    0x1(%rbx),%eax
  4103e3:	48 83 c3 01          	add    $0x1,%rbx
  4103e7:	3b 45 08             	cmp    0x8(%rbp),%eax
  4103ea:	7d 2c                	jge    410418 <_ZNK11__sanitizer18SuppressionContext18HasSuppressionTypeEPKc+0x58>
    if (0 == internal_strcmp(type, suppression_types_[i]))
  4103ec:	48 8b 45 00          	mov    0x0(%rbp),%rax
  4103f0:	4c 89 e7             	mov    %r12,%rdi
  4103f3:	4c 63 eb             	movslq %ebx,%r13
  4103f6:	48 8b 34 d8          	mov    (%rax,%rbx,8),%rsi
  4103fa:	e8 e1 a3 ff ff       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
  4103ff:	85 c0                	test   %eax,%eax
  410401:	75 dd                	jne    4103e0 <_ZNK11__sanitizer18SuppressionContext18HasSuppressionTypeEPKc+0x20>
      return has_suppression_type_[i];
  410403:	42 0f b6 44 2d 28    	movzbl 0x28(%rbp,%r13,1),%eax
  }
  return false;
}
  410409:	48 83 c4 08          	add    $0x8,%rsp
  41040d:	5b                   	pop    %rbx
  41040e:	5d                   	pop    %rbp
  41040f:	41 5c                	pop    %r12
  410411:	41 5d                	pop    %r13
  410413:	c3                   	retq   
  410414:	0f 1f 40 00          	nopl   0x0(%rax)
  410418:	48 83 c4 08          	add    $0x8,%rsp
bool SuppressionContext::HasSuppressionType(const char *type) const {
  for (int i = 0; i < suppression_types_num_; i++) {
    if (0 == internal_strcmp(type, suppression_types_[i]))
      return has_suppression_type_[i];
  }
  return false;
  41041c:	31 c0                	xor    %eax,%eax
}
  41041e:	5b                   	pop    %rbx
  41041f:	5d                   	pop    %rbp
  410420:	41 5c                	pop    %r12
  410422:	41 5d                	pop    %r13
  410424:	c3                   	retq   
  410425:	90                   	nop
  410426:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  41042d:	00 00 00 

0000000000410430 <_ZNK11__sanitizer18SuppressionContext13SuppressionAtEm>:

const Suppression *SuppressionContext::SuppressionAt(uptr i) const {
  CHECK_LT(i, suppressions_.size());
  410430:	4c 8b 47 20          	mov    0x20(%rdi),%r8
  410434:	4c 39 c6             	cmp    %r8,%rsi
  410437:	73 0c                	jae    410445 <_ZNK11__sanitizer18SuppressionContext13SuppressionAtEm+0x15>
    CHECK_LT(i, size_);
    return data_[i];
  }
  const T &operator[](uptr i) const {
    CHECK_LT(i, size_);
    return data_[i];
  410439:	48 89 f0             	mov    %rsi,%rax
  41043c:	48 c1 e0 05          	shl    $0x5,%rax
  410440:	48 03 47 10          	add    0x10(%rdi),%rax
  return &suppressions_[i];
}
  410444:	c3                   	retq   
  }
  return false;
}

const Suppression *SuppressionContext::SuppressionAt(uptr i) const {
  CHECK_LT(i, suppressions_.size());
  410445:	48 8d 15 1c 78 00 00 	lea    0x781c(%rip),%rdx        # 417c68 <.LC15>
      return has_suppression_type_[i];
  }
  return false;
}

const Suppression *SuppressionContext::SuppressionAt(uptr i) const {
  41044c:	50                   	push   %rax
  CHECK_LT(i, suppressions_.size());
  41044d:	48 8d 3d 1c 77 00 00 	lea    0x771c(%rip),%rdi        # 417b70 <.LC2>
  410454:	48 89 f1             	mov    %rsi,%rcx
  410457:	be 9d 00 00 00       	mov    $0x9d,%esi
  41045c:	e8 8f 4f ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  410461:	90                   	nop
  410462:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  410469:	1f 84 00 00 00 00 00 

0000000000410470 <_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE>:
  return &suppressions_[i];
}

void SuppressionContext::GetMatched(
    InternalMmapVector<Suppression *> *matched) {
  410470:	41 57                	push   %r15
  410472:	41 56                	push   %r14
  410474:	49 89 fe             	mov    %rdi,%r14
  410477:	41 55                	push   %r13
  410479:	41 54                	push   %r12
  41047b:	55                   	push   %rbp
  41047c:	53                   	push   %rbx
  41047d:	48 83 ec 08          	sub    $0x8,%rsp
  for (uptr i = 0; i < suppressions_.size(); i++)
    if (atomic_load_relaxed(&suppressions_[i].hit_count))
  410481:	48 8b 57 20          	mov    0x20(%rdi),%rdx
  return &suppressions_[i];
}

void SuppressionContext::GetMatched(
    InternalMmapVector<Suppression *> *matched) {
  for (uptr i = 0; i < suppressions_.size(); i++)
  410485:	48 85 d2             	test   %rdx,%rdx
  410488:	74 5f                	je     4104e9 <_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE+0x79>
  41048a:	49 89 f5             	mov    %rsi,%r13
    if (atomic_load_relaxed(&suppressions_[i].hit_count))
  41048d:	48 8b 47 10          	mov    0x10(%rdi),%rax
  return &suppressions_[i];
}

void SuppressionContext::GetMatched(
    InternalMmapVector<Suppression *> *matched) {
  for (uptr i = 0; i < suppressions_.size(); i++)
  410491:	31 db                	xor    %ebx,%ebx
  410493:	eb 10                	jmp    4104a5 <_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE+0x35>
  410495:	0f 1f 00             	nopl   (%rax)
  410498:	48 83 c3 01          	add    $0x1,%rbx
  41049c:	48 39 d3             	cmp    %rdx,%rbx
  41049f:	73 48                	jae    4104e9 <_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE+0x79>
    if (atomic_load_relaxed(&suppressions_[i].hit_count))
  4104a1:	49 8b 46 10          	mov    0x10(%r14),%rax
  4104a5:	48 89 dd             	mov    %rbx,%rbp
  4104a8:	48 c1 e5 05          	shl    $0x5,%rbp
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
    return data_[i];
  4104ac:	48 01 c5             	add    %rax,%rbp
  4104af:	8b 45 10             	mov    0x10(%rbp),%eax
  4104b2:	85 c0                	test   %eax,%eax
  4104b4:	74 e2                	je     410498 <_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE+0x28>
  const T &operator[](uptr i) const {
    CHECK_LT(i, size_);
    return data_[i];
  }
  void push_back(const T &element) {
    CHECK_LE(size_, capacity_);
  4104b6:	49 8b 45 10          	mov    0x10(%r13),%rax
  4104ba:	4d 8b 45 08          	mov    0x8(%r13),%r8
  4104be:	4c 39 c0             	cmp    %r8,%rax
  4104c1:	0f 87 01 01 00 00    	ja     4105c8 <_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE+0x158>
    if (size_ == capacity_) {
  4104c7:	48 89 c2             	mov    %rax,%rdx
  4104ca:	74 34                	je     410500 <_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE+0x90>
      uptr new_capacity = RoundUpToPowerOfTwo(size_ + 1);
      Resize(new_capacity);
    }
    data_[size_++] = element;
  4104cc:	49 8b 45 00          	mov    0x0(%r13),%rax
  4104d0:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  return &suppressions_[i];
}

void SuppressionContext::GetMatched(
    InternalMmapVector<Suppression *> *matched) {
  for (uptr i = 0; i < suppressions_.size(); i++)
  4104d4:	48 83 c3 01          	add    $0x1,%rbx
  4104d8:	49 89 4d 10          	mov    %rcx,0x10(%r13)
  4104dc:	48 89 2c d0          	mov    %rbp,(%rax,%rdx,8)
  4104e0:	49 8b 56 20          	mov    0x20(%r14),%rdx
  4104e4:	48 39 d3             	cmp    %rdx,%rbx
  4104e7:	72 b8                	jb     4104a1 <_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE+0x31>
    if (atomic_load_relaxed(&suppressions_[i].hit_count))
      matched->push_back(&suppressions_[i]);
}
  4104e9:	48 83 c4 08          	add    $0x8,%rsp
  4104ed:	5b                   	pop    %rbx
  4104ee:	5d                   	pop    %rbp
  4104ef:	41 5c                	pop    %r12
  4104f1:	41 5d                	pop    %r13
  4104f3:	41 5e                	pop    %r14
  4104f5:	41 5f                	pop    %r15
  4104f7:	c3                   	retq   
  4104f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4104ff:	00 
INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
}

INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  410500:	48 83 c2 01          	add    $0x1,%rdx
  410504:	0f 84 d9 00 00 00    	je     4105e3 <_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE+0x173>
  if (IsPowerOfTwo(size)) return size;
  41050a:	48 85 c2             	test   %rax,%rdx
  41050d:	49 89 d7             	mov    %rdx,%r15
  410510:	75 5e                	jne    410570 <_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE+0x100>
  bool empty() const { return size() == 0; }

 private:
  void Resize(uptr new_capacity) {
    CHECK_GT(new_capacity, 0);
    CHECK_LE(size_, new_capacity);
  410512:	49 39 c7             	cmp    %rax,%r15
  410515:	0f 82 e5 00 00 00    	jb     410600 <_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE+0x190>
    T *new_data = (T *)MmapOrDie(new_capacity * sizeof(T),
                                 "InternalMmapVector");
  41051b:	4a 8d 3c fd 00 00 00 	lea    0x0(,%r15,8),%rdi
  410522:	00 
  410523:	48 8d 35 1e 8a 00 00 	lea    0x8a1e(%rip),%rsi        # 418f48 <.LC11>
  41052a:	e8 71 be ff ff       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  41052f:	49 89 c4             	mov    %rax,%r12
    internal_memcpy(new_data, data_, size_ * sizeof(T));
  410532:	49 8b 45 10          	mov    0x10(%r13),%rax
  410536:	49 8b 75 00          	mov    0x0(%r13),%rsi
  41053a:	4c 89 e7             	mov    %r12,%rdi
  41053d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  410544:	00 
  410545:	e8 c6 99 ff ff       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
    T *old_data = data_;
    data_ = new_data;
    UnmapOrDie(old_data, capacity_ * sizeof(T));
  41054a:	49 8b 45 08          	mov    0x8(%r13),%rax
    CHECK_GT(new_capacity, 0);
    CHECK_LE(size_, new_capacity);
    T *new_data = (T *)MmapOrDie(new_capacity * sizeof(T),
                                 "InternalMmapVector");
    internal_memcpy(new_data, data_, size_ * sizeof(T));
    T *old_data = data_;
  41054e:	49 8b 7d 00          	mov    0x0(%r13),%rdi
    data_ = new_data;
  410552:	4d 89 65 00          	mov    %r12,0x0(%r13)
    UnmapOrDie(old_data, capacity_ * sizeof(T));
  410556:	48 8d 34 c5 00 00 00 	lea    0x0(,%rax,8),%rsi
  41055d:	00 
  41055e:	e8 dd be ff ff       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
    capacity_ = new_capacity;
  410563:	4d 89 7d 08          	mov    %r15,0x8(%r13)
  410567:	49 8b 55 10          	mov    0x10(%r13),%rdx
  41056b:	e9 5c ff ff ff       	jmpq   4104cc <_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE+0x5c>
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  410570:	48 0f bd ca          	bsr    %rdx,%rcx
  410574:	be 3f 00 00 00       	mov    $0x3f,%esi
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  410579:	bf 01 00 00 00       	mov    $0x1,%edi
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  41057e:	48 83 f1 3f          	xor    $0x3f,%rcx
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  410582:	49 89 ff             	mov    %rdi,%r15
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  410585:	29 ce                	sub    %ecx,%esi
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  410587:	8d 4e 01             	lea    0x1(%rsi),%ecx
  41058a:	49 d3 e7             	shl    %cl,%r15
  41058d:	4c 39 fa             	cmp    %r15,%rdx
  410590:	0f 83 88 00 00 00    	jae    41061e <_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE+0x1ae>
  CHECK(size > (1ULL << up));
  410596:	89 f1                	mov    %esi,%ecx
  410598:	48 d3 e7             	shl    %cl,%rdi
  41059b:	48 39 fa             	cmp    %rdi,%rdx
  41059e:	0f 87 6e ff ff ff    	ja     410512 <_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE+0xa2>
  4105a4:	48 8d 15 95 74 00 00 	lea    0x7495(%rip),%rdx        # 417a40 <.LC10>
  4105ab:	48 8d 3d 5e 4a 00 00 	lea    0x4a5e(%rip),%rdi        # 415010 <.LC1>
  4105b2:	45 31 c0             	xor    %r8d,%r8d
  4105b5:	31 c9                	xor    %ecx,%ecx
  4105b7:	be a4 01 00 00       	mov    $0x1a4,%esi
  4105bc:	e8 2f 4e ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  4105c1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  const T &operator[](uptr i) const {
    CHECK_LT(i, size_);
    return data_[i];
  }
  void push_back(const T &element) {
    CHECK_LE(size_, capacity_);
  4105c8:	48 8d 15 30 89 00 00 	lea    0x8930(%rip),%rdx        # 418eff <.LC4>
  4105cf:	48 8d 3d 3a 4a 00 00 	lea    0x4a3a(%rip),%rdi        # 415010 <.LC1>
  4105d6:	48 89 c1             	mov    %rax,%rcx
  4105d9:	be e7 01 00 00       	mov    $0x1e7,%esi
  4105de:	e8 0d 4e ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
}

INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  4105e3:	48 8d 15 30 89 00 00 	lea    0x8930(%rip),%rdx        # 418f1a <.LC5>
  4105ea:	48 8d 3d 1f 4a 00 00 	lea    0x4a1f(%rip),%rdi        # 415010 <.LC1>
  4105f1:	45 31 c0             	xor    %r8d,%r8d
  4105f4:	31 c9                	xor    %ecx,%ecx
  4105f6:	be 9f 01 00 00       	mov    $0x19f,%esi
  4105fb:	e8 f0 4d ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  bool empty() const { return size() == 0; }

 private:
  void Resize(uptr new_capacity) {
    CHECK_GT(new_capacity, 0);
    CHECK_LE(size_, new_capacity);
  410600:	48 8d 15 23 89 00 00 	lea    0x8923(%rip),%rdx        # 418f2a <.LC10>
  410607:	48 8d 3d 02 4a 00 00 	lea    0x4a02(%rip),%rdi        # 415010 <.LC1>
  41060e:	4d 89 f8             	mov    %r15,%r8
  410611:	48 89 c1             	mov    %rax,%rcx
  410614:	be 09 02 00 00       	mov    $0x209,%esi
  410619:	e8 d2 4d ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  41061e:	48 8d 15 f3 73 00 00 	lea    0x73f3(%rip),%rdx        # 417a18 <.LC2>
  410625:	48 8d 3d e4 49 00 00 	lea    0x49e4(%rip),%rdi        # 415010 <.LC1>
  41062c:	45 31 c0             	xor    %r8d,%r8d
  41062f:	31 c9                	xor    %ecx,%ecx
  410631:	be a3 01 00 00       	mov    $0x1a3,%esi
  410636:	e8 b5 4d ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  41063b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000410640 <_ZN11__sanitizer11AddressInfoC1Ev>:
#include "sanitizer_placement_new.h"
#include "sanitizer_symbolizer_internal.h"

namespace __sanitizer {

AddressInfo::AddressInfo() {
  410640:	53                   	push   %rbx
  internal_memset(this, 0, sizeof(AddressInfo));
  410641:	ba 38 00 00 00       	mov    $0x38,%edx
#include "sanitizer_placement_new.h"
#include "sanitizer_symbolizer_internal.h"

namespace __sanitizer {

AddressInfo::AddressInfo() {
  410646:	48 89 fb             	mov    %rdi,%rbx
  internal_memset(this, 0, sizeof(AddressInfo));
  410649:	31 f6                	xor    %esi,%esi
  41064b:	e8 f0 9c ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  function_offset = kUnknown;
  410650:	48 c7 43 20 ff ff ff 	movq   $0xffffffffffffffff,0x20(%rbx)
  410657:	ff 
}
  410658:	5b                   	pop    %rbx
  410659:	c3                   	retq   
  41065a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000410660 <_ZN11__sanitizer11AddressInfo5ClearEv>:

void AddressInfo::Clear() {
  410660:	53                   	push   %rbx
  410661:	48 89 fb             	mov    %rdi,%rbx
  InternalFree(module);
  410664:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
  410668:	31 f6                	xor    %esi,%esi
  41066a:	e8 01 36 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(function);
  41066f:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  410673:	31 f6                	xor    %esi,%esi
  410675:	e8 f6 35 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(file);
  41067a:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
  41067e:	31 f6                	xor    %esi,%esi
  410680:	e8 eb 35 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  internal_memset(this, 0, sizeof(AddressInfo));
  410685:	48 89 df             	mov    %rbx,%rdi
  410688:	ba 38 00 00 00       	mov    $0x38,%edx
  41068d:	31 f6                	xor    %esi,%esi
  41068f:	e8 ac 9c ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  function_offset = kUnknown;
  410694:	48 c7 43 20 ff ff ff 	movq   $0xffffffffffffffff,0x20(%rbx)
  41069b:	ff 
}
  41069c:	5b                   	pop    %rbx
  41069d:	c3                   	retq   
  41069e:	66 90                	xchg   %ax,%ax

00000000004106a0 <_ZN11__sanitizer11AddressInfo14FillModuleInfoEPKcm>:

void AddressInfo::FillModuleInfo(const char *mod_name, uptr mod_offset) {
  4106a0:	55                   	push   %rbp
  4106a1:	48 89 d5             	mov    %rdx,%rbp
  4106a4:	53                   	push   %rbx
  4106a5:	48 89 fb             	mov    %rdi,%rbx
  module = internal_strdup(mod_name);
  4106a8:	48 89 f7             	mov    %rsi,%rdi
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
}

void AddressInfo::FillModuleInfo(const char *mod_name, uptr mod_offset) {
  4106ab:	48 83 ec 08          	sub    $0x8,%rsp
  module = internal_strdup(mod_name);
  4106af:	e8 0c 9d ff ff       	callq  40a3c0 <_ZN11__sanitizer15internal_strdupEPKc>
  module_offset = mod_offset;
  4106b4:	48 89 6b 10          	mov    %rbp,0x10(%rbx)
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
}

void AddressInfo::FillModuleInfo(const char *mod_name, uptr mod_offset) {
  module = internal_strdup(mod_name);
  4106b8:	48 89 43 08          	mov    %rax,0x8(%rbx)
  module_offset = mod_offset;
}
  4106bc:	48 83 c4 08          	add    $0x8,%rsp
  4106c0:	5b                   	pop    %rbx
  4106c1:	5d                   	pop    %rbp
  4106c2:	c3                   	retq   
  4106c3:	90                   	nop
  4106c4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4106cb:	00 00 00 00 00 

00000000004106d0 <_ZN11__sanitizer15SymbolizedStackC1Ev>:

SymbolizedStack::SymbolizedStack() : next(nullptr), info() {}
  4106d0:	53                   	push   %rbx
  4106d1:	48 89 fb             	mov    %rdi,%rbx
  4106d4:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
  4106db:	48 8d 7f 08          	lea    0x8(%rdi),%rdi
#include "sanitizer_symbolizer_internal.h"

namespace __sanitizer {

AddressInfo::AddressInfo() {
  internal_memset(this, 0, sizeof(AddressInfo));
  4106df:	ba 38 00 00 00       	mov    $0x38,%edx
  4106e4:	31 f6                	xor    %esi,%esi
  4106e6:	e8 55 9c ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  function_offset = kUnknown;
  4106eb:	48 c7 43 28 ff ff ff 	movq   $0xffffffffffffffff,0x28(%rbx)
  4106f2:	ff 
void AddressInfo::FillModuleInfo(const char *mod_name, uptr mod_offset) {
  module = internal_strdup(mod_name);
  module_offset = mod_offset;
}

SymbolizedStack::SymbolizedStack() : next(nullptr), info() {}
  4106f3:	5b                   	pop    %rbx
  4106f4:	c3                   	retq   
  4106f5:	90                   	nop
  4106f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4106fd:	00 00 00 

0000000000410700 <_ZN11__sanitizer15SymbolizedStack3NewEm>:

SymbolizedStack *SymbolizedStack::New(uptr addr) {
  410700:	55                   	push   %rbp
  void *mem = InternalAlloc(sizeof(SymbolizedStack));
  410701:	31 f6                	xor    %esi,%esi
  module_offset = mod_offset;
}

SymbolizedStack::SymbolizedStack() : next(nullptr), info() {}

SymbolizedStack *SymbolizedStack::New(uptr addr) {
  410703:	48 89 fd             	mov    %rdi,%rbp
  void *mem = InternalAlloc(sizeof(SymbolizedStack));
  410706:	bf 40 00 00 00       	mov    $0x40,%edi
  module_offset = mod_offset;
}

SymbolizedStack::SymbolizedStack() : next(nullptr), info() {}

SymbolizedStack *SymbolizedStack::New(uptr addr) {
  41070b:	53                   	push   %rbx
  41070c:	48 83 ec 08          	sub    $0x8,%rsp
  void *mem = InternalAlloc(sizeof(SymbolizedStack));
  410710:	e8 1b 2c ff ff       	callq  403330 <_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES5_EEEE>
void AddressInfo::FillModuleInfo(const char *mod_name, uptr mod_offset) {
  module = internal_strdup(mod_name);
  module_offset = mod_offset;
}

SymbolizedStack::SymbolizedStack() : next(nullptr), info() {}
  410715:	48 8d 78 08          	lea    0x8(%rax),%rdi

SymbolizedStack *SymbolizedStack::New(uptr addr) {
  void *mem = InternalAlloc(sizeof(SymbolizedStack));
  410719:	48 89 c3             	mov    %rax,%rbx
void AddressInfo::FillModuleInfo(const char *mod_name, uptr mod_offset) {
  module = internal_strdup(mod_name);
  module_offset = mod_offset;
}

SymbolizedStack::SymbolizedStack() : next(nullptr), info() {}
  41071c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
#include "sanitizer_symbolizer_internal.h"

namespace __sanitizer {

AddressInfo::AddressInfo() {
  internal_memset(this, 0, sizeof(AddressInfo));
  410723:	ba 38 00 00 00       	mov    $0x38,%edx
  410728:	31 f6                	xor    %esi,%esi
  41072a:	e8 11 9c ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  function_offset = kUnknown;
  41072f:	48 c7 43 28 ff ff ff 	movq   $0xffffffffffffffff,0x28(%rbx)
  410736:	ff 
SymbolizedStack::SymbolizedStack() : next(nullptr), info() {}

SymbolizedStack *SymbolizedStack::New(uptr addr) {
  void *mem = InternalAlloc(sizeof(SymbolizedStack));
  SymbolizedStack *res = new(mem) SymbolizedStack();
  res->info.address = addr;
  410737:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
  return res;
}
  41073b:	48 83 c4 08          	add    $0x8,%rsp
  41073f:	48 89 d8             	mov    %rbx,%rax
  410742:	5b                   	pop    %rbx
  410743:	5d                   	pop    %rbp
  410744:	c3                   	retq   
  410745:	90                   	nop
  410746:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  41074d:	00 00 00 

0000000000410750 <_ZN11__sanitizer15SymbolizedStack8ClearAllEv>:

void SymbolizedStack::ClearAll() {
  410750:	41 57                	push   %r15
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
}

void AddressInfo::Clear() {
  InternalFree(module);
  410752:	31 f6                	xor    %esi,%esi
  SymbolizedStack *res = new(mem) SymbolizedStack();
  res->info.address = addr;
  return res;
}

void SymbolizedStack::ClearAll() {
  410754:	41 56                	push   %r14
  410756:	41 55                	push   %r13
  410758:	41 54                	push   %r12
  41075a:	55                   	push   %rbp
  41075b:	53                   	push   %rbx
  41075c:	48 89 fb             	mov    %rdi,%rbx
  41075f:	48 83 ec 28          	sub    $0x28,%rsp
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
}

void AddressInfo::Clear() {
  InternalFree(module);
  410763:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  410767:	e8 04 35 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(function);
  41076c:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
  410770:	31 f6                	xor    %esi,%esi
  410772:	e8 f9 34 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(file);
  410777:	48 8b 7b 30          	mov    0x30(%rbx),%rdi
  41077b:	31 f6                	xor    %esi,%esi
  41077d:	e8 ee 34 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  res->info.address = addr;
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  410782:	48 8d 7b 08          	lea    0x8(%rbx),%rdi

void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  410786:	31 f6                	xor    %esi,%esi
  410788:	ba 38 00 00 00       	mov    $0x38,%edx
  41078d:	e8 ae 9b ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  410792:	48 8b 2b             	mov    (%rbx),%rbp
void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
  410795:	48 c7 43 28 ff ff ff 	movq   $0xffffffffffffffff,0x28(%rbx)
  41079c:	ff 
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  41079d:	48 85 ed             	test   %rbp,%rbp
  4107a0:	0f 84 d1 02 00 00    	je     410a77 <_ZN11__sanitizer15SymbolizedStack8ClearAllEv+0x327>
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
}

void AddressInfo::Clear() {
  InternalFree(module);
  4107a6:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  4107aa:	31 f6                	xor    %esi,%esi
  4107ac:	e8 bf 34 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(function);
  4107b1:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  4107b5:	31 f6                	xor    %esi,%esi
  4107b7:	e8 b4 34 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(file);
  4107bc:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  4107c0:	31 f6                	xor    %esi,%esi
  4107c2:	e8 a9 34 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  res->info.address = addr;
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  4107c7:	48 8d 7d 08          	lea    0x8(%rbp),%rdi

void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  4107cb:	31 f6                	xor    %esi,%esi
  4107cd:	ba 38 00 00 00       	mov    $0x38,%edx
  4107d2:	e8 69 9b ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  4107d7:	4c 8b 65 00          	mov    0x0(%rbp),%r12
void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
  4107db:	48 c7 45 28 ff ff ff 	movq   $0xffffffffffffffff,0x28(%rbp)
  4107e2:	ff 
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  4107e3:	4d 85 e4             	test   %r12,%r12
  4107e6:	0f 84 81 02 00 00    	je     410a6d <_ZN11__sanitizer15SymbolizedStack8ClearAllEv+0x31d>
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
}

void AddressInfo::Clear() {
  InternalFree(module);
  4107ec:	49 8b 7c 24 10       	mov    0x10(%r12),%rdi
  4107f1:	31 f6                	xor    %esi,%esi
  4107f3:	e8 78 34 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(function);
  4107f8:	49 8b 7c 24 20       	mov    0x20(%r12),%rdi
  4107fd:	31 f6                	xor    %esi,%esi
  4107ff:	e8 6c 34 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(file);
  410804:	49 8b 7c 24 30       	mov    0x30(%r12),%rdi
  410809:	31 f6                	xor    %esi,%esi
  41080b:	e8 60 34 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  res->info.address = addr;
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  410810:	49 8d 7c 24 08       	lea    0x8(%r12),%rdi

void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  410815:	31 f6                	xor    %esi,%esi
  410817:	ba 38 00 00 00       	mov    $0x38,%edx
  41081c:	e8 1f 9b ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  410821:	4d 8b 2c 24          	mov    (%r12),%r13
void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
  410825:	49 c7 44 24 28 ff ff 	movq   $0xffffffffffffffff,0x28(%r12)
  41082c:	ff ff 
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  41082e:	4d 85 ed             	test   %r13,%r13
  410831:	0f 84 2c 02 00 00    	je     410a63 <_ZN11__sanitizer15SymbolizedStack8ClearAllEv+0x313>
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
}

void AddressInfo::Clear() {
  InternalFree(module);
  410837:	49 8b 7d 10          	mov    0x10(%r13),%rdi
  41083b:	31 f6                	xor    %esi,%esi
  41083d:	e8 2e 34 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(function);
  410842:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  410846:	31 f6                	xor    %esi,%esi
  410848:	e8 23 34 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(file);
  41084d:	49 8b 7d 30          	mov    0x30(%r13),%rdi
  410851:	31 f6                	xor    %esi,%esi
  410853:	e8 18 34 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  res->info.address = addr;
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  410858:	49 8d 7d 08          	lea    0x8(%r13),%rdi

void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  41085c:	31 f6                	xor    %esi,%esi
  41085e:	ba 38 00 00 00       	mov    $0x38,%edx
  410863:	e8 d8 9a ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  410868:	4d 8b 75 00          	mov    0x0(%r13),%r14
void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
  41086c:	49 c7 45 28 ff ff ff 	movq   $0xffffffffffffffff,0x28(%r13)
  410873:	ff 
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  410874:	4d 85 f6             	test   %r14,%r14
  410877:	0f 84 dc 01 00 00    	je     410a59 <_ZN11__sanitizer15SymbolizedStack8ClearAllEv+0x309>
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
}

void AddressInfo::Clear() {
  InternalFree(module);
  41087d:	49 8b 7e 10          	mov    0x10(%r14),%rdi
  410881:	31 f6                	xor    %esi,%esi
  410883:	e8 e8 33 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(function);
  410888:	49 8b 7e 20          	mov    0x20(%r14),%rdi
  41088c:	31 f6                	xor    %esi,%esi
  41088e:	e8 dd 33 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(file);
  410893:	49 8b 7e 30          	mov    0x30(%r14),%rdi
  410897:	31 f6                	xor    %esi,%esi
  410899:	e8 d2 33 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  res->info.address = addr;
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  41089e:	49 8d 7e 08          	lea    0x8(%r14),%rdi

void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  4108a2:	31 f6                	xor    %esi,%esi
  4108a4:	ba 38 00 00 00       	mov    $0x38,%edx
  4108a9:	e8 92 9a ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  4108ae:	4d 8b 3e             	mov    (%r14),%r15
void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
  4108b1:	49 c7 46 28 ff ff ff 	movq   $0xffffffffffffffff,0x28(%r14)
  4108b8:	ff 
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  4108b9:	4d 85 ff             	test   %r15,%r15
  4108bc:	0f 84 8d 01 00 00    	je     410a4f <_ZN11__sanitizer15SymbolizedStack8ClearAllEv+0x2ff>
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
}

void AddressInfo::Clear() {
  InternalFree(module);
  4108c2:	49 8b 7f 10          	mov    0x10(%r15),%rdi
  4108c6:	31 f6                	xor    %esi,%esi
  4108c8:	e8 a3 33 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(function);
  4108cd:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4108d1:	31 f6                	xor    %esi,%esi
  4108d3:	e8 98 33 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(file);
  4108d8:	49 8b 7f 30          	mov    0x30(%r15),%rdi
  4108dc:	31 f6                	xor    %esi,%esi
  4108de:	e8 8d 33 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  res->info.address = addr;
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  4108e3:	49 8d 7f 08          	lea    0x8(%r15),%rdi

void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  4108e7:	31 f6                	xor    %esi,%esi
  4108e9:	ba 38 00 00 00       	mov    $0x38,%edx
  4108ee:	e8 4d 9a ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  4108f3:	49 8b 07             	mov    (%r15),%rax
void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
  4108f6:	49 c7 47 28 ff ff ff 	movq   $0xffffffffffffffff,0x28(%r15)
  4108fd:	ff 
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  4108fe:	48 85 c0             	test   %rax,%rax
  410901:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  410906:	0f 84 39 01 00 00    	je     410a45 <_ZN11__sanitizer15SymbolizedStack8ClearAllEv+0x2f5>
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
}

void AddressInfo::Clear() {
  InternalFree(module);
  41090c:	48 8b 78 10          	mov    0x10(%rax),%rdi
  410910:	31 f6                	xor    %esi,%esi
  410912:	e8 59 33 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(function);
  410917:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  41091c:	31 f6                	xor    %esi,%esi
  41091e:	48 8b 78 20          	mov    0x20(%rax),%rdi
  410922:	e8 49 33 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(file);
  410927:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  41092c:	31 f6                	xor    %esi,%esi
  41092e:	48 8b 78 30          	mov    0x30(%rax),%rdi
  410932:	e8 39 33 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  res->info.address = addr;
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  410937:	48 8b 44 24 08       	mov    0x8(%rsp),%rax

void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  41093c:	31 f6                	xor    %esi,%esi
  41093e:	ba 38 00 00 00       	mov    $0x38,%edx
  res->info.address = addr;
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  410943:	48 8d 78 08          	lea    0x8(%rax),%rdi

void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  410947:	e8 f4 99 ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  function_offset = kUnknown;
  41094c:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  410951:	48 c7 40 28 ff ff ff 	movq   $0xffffffffffffffff,0x28(%rax)
  410958:	ff 
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  410959:	48 8b 00             	mov    (%rax),%rax
  41095c:	48 85 c0             	test   %rax,%rax
  41095f:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  410964:	0f 84 cf 00 00 00    	je     410a39 <_ZN11__sanitizer15SymbolizedStack8ClearAllEv+0x2e9>
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
}

void AddressInfo::Clear() {
  InternalFree(module);
  41096a:	48 8b 78 10          	mov    0x10(%rax),%rdi
  41096e:	31 f6                	xor    %esi,%esi
  410970:	e8 fb 32 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(function);
  410975:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  41097a:	31 f6                	xor    %esi,%esi
  41097c:	48 8b 78 20          	mov    0x20(%rax),%rdi
  410980:	e8 eb 32 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(file);
  410985:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  41098a:	31 f6                	xor    %esi,%esi
  41098c:	48 8b 78 30          	mov    0x30(%rax),%rdi
  410990:	e8 db 32 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  res->info.address = addr;
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  410995:	48 8b 44 24 10       	mov    0x10(%rsp),%rax

void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  41099a:	31 f6                	xor    %esi,%esi
  41099c:	ba 38 00 00 00       	mov    $0x38,%edx
  res->info.address = addr;
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  4109a1:	48 8d 78 08          	lea    0x8(%rax),%rdi

void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  4109a5:	e8 96 99 ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  function_offset = kUnknown;
  4109aa:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  4109af:	48 8b 08             	mov    (%rax),%rcx
void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
  4109b2:	48 c7 40 28 ff ff ff 	movq   $0xffffffffffffffff,0x28(%rax)
  4109b9:	ff 
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  4109ba:	48 85 c9             	test   %rcx,%rcx
  4109bd:	74 6e                	je     410a2d <_ZN11__sanitizer15SymbolizedStack8ClearAllEv+0x2dd>
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
}

void AddressInfo::Clear() {
  InternalFree(module);
  4109bf:	48 8b 79 10          	mov    0x10(%rcx),%rdi
  4109c3:	31 f6                	xor    %esi,%esi
  4109c5:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  4109ca:	e8 a1 32 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(function);
  4109cf:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  4109d4:	31 f6                	xor    %esi,%esi
  4109d6:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  4109da:	e8 91 32 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(file);
  4109df:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  4109e4:	31 f6                	xor    %esi,%esi
  4109e6:	48 8b 79 30          	mov    0x30(%rcx),%rdi
  4109ea:	e8 81 32 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  res->info.address = addr;
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  4109ef:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx

void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  4109f4:	31 f6                	xor    %esi,%esi
  4109f6:	ba 38 00 00 00       	mov    $0x38,%edx
  res->info.address = addr;
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  4109fb:	48 8d 79 08          	lea    0x8(%rcx),%rdi

void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  4109ff:	e8 3c 99 ff ff       	callq  40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  function_offset = kUnknown;
  410a04:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  410a09:	48 8b 39             	mov    (%rcx),%rdi
void AddressInfo::Clear() {
  InternalFree(module);
  InternalFree(function);
  InternalFree(file);
  internal_memset(this, 0, sizeof(AddressInfo));
  function_offset = kUnknown;
  410a0c:	48 c7 41 28 ff ff ff 	movq   $0xffffffffffffffff,0x28(%rcx)
  410a13:	ff 
  return res;
}

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
  410a14:	48 85 ff             	test   %rdi,%rdi
  410a17:	74 0a                	je     410a23 <_ZN11__sanitizer15SymbolizedStack8ClearAllEv+0x2d3>
    next->ClearAll();
  410a19:	e8 32 fd ff ff       	callq  410750 <_ZN11__sanitizer15SymbolizedStack8ClearAllEv>
  410a1e:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  InternalFree(this);
  410a23:	31 f6                	xor    %esi,%esi
  410a25:	48 89 cf             	mov    %rcx,%rdi
  410a28:	e8 43 32 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  410a2d:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  410a32:	31 f6                	xor    %esi,%esi
  410a34:	e8 37 32 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  410a39:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  410a3e:	31 f6                	xor    %esi,%esi
  410a40:	e8 2b 32 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  410a45:	31 f6                	xor    %esi,%esi
  410a47:	4c 89 ff             	mov    %r15,%rdi
  410a4a:	e8 21 32 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  410a4f:	31 f6                	xor    %esi,%esi
  410a51:	4c 89 f7             	mov    %r14,%rdi
  410a54:	e8 17 32 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  410a59:	31 f6                	xor    %esi,%esi
  410a5b:	4c 89 ef             	mov    %r13,%rdi
  410a5e:	e8 0d 32 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  410a63:	31 f6                	xor    %esi,%esi
  410a65:	4c 89 e7             	mov    %r12,%rdi
  410a68:	e8 03 32 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  410a6d:	31 f6                	xor    %esi,%esi
  410a6f:	48 89 ef             	mov    %rbp,%rdi
  410a72:	e8 f9 31 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
}
  410a77:	48 83 c4 28          	add    $0x28,%rsp

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
    next->ClearAll();
  InternalFree(this);
  410a7b:	48 89 df             	mov    %rbx,%rdi
  410a7e:	31 f6                	xor    %esi,%esi
}
  410a80:	5b                   	pop    %rbx
  410a81:	5d                   	pop    %rbp
  410a82:	41 5c                	pop    %r12
  410a84:	41 5d                	pop    %r13
  410a86:	41 5e                	pop    %r14
  410a88:	41 5f                	pop    %r15

void SymbolizedStack::ClearAll() {
  info.Clear();
  if (next)
    next->ClearAll();
  InternalFree(this);
  410a8a:	e9 e1 31 ff ff       	jmpq   403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  410a8f:	90                   	nop

0000000000410a90 <_ZN11__sanitizer8DataInfoC1Ev>:
}

DataInfo::DataInfo() {
  internal_memset(this, 0, sizeof(DataInfo));
  410a90:	ba 28 00 00 00       	mov    $0x28,%edx
  410a95:	31 f6                	xor    %esi,%esi
  410a97:	e9 a4 98 ff ff       	jmpq   40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  410a9c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000410aa0 <_ZN11__sanitizer8DataInfo5ClearEv>:
}

void DataInfo::Clear() {
  410aa0:	53                   	push   %rbx
  410aa1:	48 89 fb             	mov    %rdi,%rbx
  InternalFree(module);
  410aa4:	48 8b 3f             	mov    (%rdi),%rdi
  410aa7:	31 f6                	xor    %esi,%esi
  410aa9:	e8 c2 31 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  InternalFree(name);
  410aae:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  410ab2:	31 f6                	xor    %esi,%esi
  410ab4:	e8 b7 31 ff ff       	callq  403c70 <_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32ILm0ELy140737488355328ELm0ENS_12SizeClassMapILm17ELm64ELm14EEELm20ENS_15TwoLevelByteMapILy32768ELy4096ENS_20NoOpMapUnmapCallbackEEES6_EEEE>
  internal_memset(this, 0, sizeof(DataInfo));
  410ab9:	48 89 df             	mov    %rbx,%rdi
  410abc:	ba 28 00 00 00       	mov    $0x28,%edx
  410ac1:	31 f6                	xor    %esi,%esi
}
  410ac3:	5b                   	pop    %rbx
}

void DataInfo::Clear() {
  InternalFree(module);
  InternalFree(name);
  internal_memset(this, 0, sizeof(DataInfo));
  410ac4:	e9 77 98 ff ff       	jmpq   40a340 <_ZN11__sanitizer15internal_memsetEPvim>
  410ac9:	90                   	nop
  410aca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000410ad0 <_ZN11__sanitizer10Symbolizer8AddHooksEPFvvES2_>:
Symbolizer *Symbolizer::symbolizer_;
StaticSpinMutex Symbolizer::init_mu_;
LowLevelAllocator Symbolizer::symbolizer_allocator_;

void Symbolizer::AddHooks(Symbolizer::StartSymbolizationHook start_hook,
                          Symbolizer::EndSymbolizationHook end_hook) {
  410ad0:	48 83 ec 08          	sub    $0x8,%rsp
  CHECK(start_hook_ == 0 && end_hook_ == 0);
  410ad4:	48 83 bf a8 00 0a 00 	cmpq   $0x0,0xa00a8(%rdi)
  410adb:	00 
  410adc:	74 22                	je     410b00 <_ZN11__sanitizer10Symbolizer8AddHooksEPFvvES2_+0x30>
  410ade:	48 8d 15 ab 71 00 00 	lea    0x71ab(%rip),%rdx        # 417c90 <.LC0>
  410ae5:	48 8d 3d d4 71 00 00 	lea    0x71d4(%rip),%rdi        # 417cc0 <.LC1>
  410aec:	45 31 c0             	xor    %r8d,%r8d
  410aef:	31 c9                	xor    %ecx,%ecx
  410af1:	be 49 00 00 00       	mov    $0x49,%esi
  410af6:	e8 f5 48 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  410afb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  410b00:	48 83 bf b0 00 0a 00 	cmpq   $0x0,0xa00b0(%rdi)
  410b07:	00 
  410b08:	75 d4                	jne    410ade <_ZN11__sanitizer10Symbolizer8AddHooksEPFvvES2_+0xe>
  start_hook_ = start_hook;
  410b0a:	48 89 b7 a8 00 0a 00 	mov    %rsi,0xa00a8(%rdi)
  end_hook_ = end_hook;
  410b11:	48 89 97 b0 00 0a 00 	mov    %rdx,0xa00b0(%rdi)
}
  410b18:	48 83 c4 08          	add    $0x8,%rsp
  410b1c:	c3                   	retq   
  410b1d:	90                   	nop
  410b1e:	66 90                	xchg   %ax,%ax

0000000000410b20 <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc>:

const char *Symbolizer::ModuleNameOwner::GetOwnedCopy(const char *str) {
  410b20:	41 55                	push   %r13
  410b22:	41 54                	push   %r12
  410b24:	49 89 f4             	mov    %rsi,%r12
  410b27:	55                   	push   %rbp
  410b28:	48 89 fd             	mov    %rdi,%rbp
  410b2b:	53                   	push   %rbx
  410b2c:	48 83 ec 08          	sub    $0x8,%rsp
  mu_->CheckLocked();
  410b30:	48 8b 7f 20          	mov    0x20(%rdi),%rdi
  410b34:	e8 37 ae ff ff       	callq  40b970 <_ZN11__sanitizer13BlockingMutex11CheckLockedEv>

  // 'str' will be the same string multiple times in a row, optimize this case.
  if (last_match_ && !internal_strcmp(last_match_, str))
  410b39:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  410b3d:	48 85 ff             	test   %rdi,%rdi
  410b40:	74 0c                	je     410b4e <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0x2e>
  410b42:	4c 89 e6             	mov    %r12,%rsi
  410b45:	e8 96 9c ff ff       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
  410b4a:	85 c0                	test   %eax,%eax
  410b4c:	74 62                	je     410bb0 <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0x90>
    return last_match_;

  // FIXME: this is linear search.
  // We should optimize this further if this turns out to be a bottleneck later.
  for (uptr i = 0; i < storage_.size(); ++i) {
  410b4e:	48 83 7d 10 00       	cmpq   $0x0,0x10(%rbp)
  410b53:	74 6b                	je     410bc0 <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0xa0>
    if (!internal_strcmp(storage_[i], str)) {
  410b55:	48 8b 45 00          	mov    0x0(%rbp),%rax
  410b59:	31 db                	xor    %ebx,%ebx
  410b5b:	eb 11                	jmp    410b6e <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0x4e>
  410b5d:	0f 1f 00             	nopl   (%rax)
  if (last_match_ && !internal_strcmp(last_match_, str))
    return last_match_;

  // FIXME: this is linear search.
  // We should optimize this further if this turns out to be a bottleneck later.
  for (uptr i = 0; i < storage_.size(); ++i) {
  410b60:	48 83 c3 01          	add    $0x1,%rbx
  410b64:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
  410b68:	76 56                	jbe    410bc0 <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0xa0>
    if (!internal_strcmp(storage_[i], str)) {
  410b6a:	48 8b 45 00          	mov    0x0(%rbp),%rax
  410b6e:	48 8b 3c d8          	mov    (%rax,%rbx,8),%rdi
  410b72:	4c 89 e6             	mov    %r12,%rsi
  410b75:	4c 8d 2c dd 00 00 00 	lea    0x0(,%rbx,8),%r13
  410b7c:	00 
  410b7d:	e8 5e 9c ff ff       	callq  40a7e0 <_ZN11__sanitizer15internal_strcmpEPKcS1_>
  410b82:	85 c0                	test   %eax,%eax
  410b84:	75 da                	jne    410b60 <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0x40>
  410b86:	4c 8b 45 10          	mov    0x10(%rbp),%r8
  410b8a:	48 8b 45 00          	mov    0x0(%rbp),%rax
  }
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
  410b8e:	49 39 d8             	cmp    %rbx,%r8
  410b91:	0f 86 85 01 00 00    	jbe    410d1c <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0x1fc>
      last_match_ = storage_[i];
  410b97:	4a 8b 04 28          	mov    (%rax,%r13,1),%rax
  410b9b:	48 89 45 18          	mov    %rax,0x18(%rbp)
    }
  }
  last_match_ = internal_strdup(str);
  storage_.push_back(last_match_);
  return last_match_;
}
  410b9f:	48 83 c4 08          	add    $0x8,%rsp
  410ba3:	5b                   	pop    %rbx
  410ba4:	5d                   	pop    %rbp
  410ba5:	41 5c                	pop    %r12
  410ba7:	41 5d                	pop    %r13
  410ba9:	c3                   	retq   
  410baa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
const char *Symbolizer::ModuleNameOwner::GetOwnedCopy(const char *str) {
  mu_->CheckLocked();

  // 'str' will be the same string multiple times in a row, optimize this case.
  if (last_match_ && !internal_strcmp(last_match_, str))
    return last_match_;
  410bb0:	48 8b 45 18          	mov    0x18(%rbp),%rax
    }
  }
  last_match_ = internal_strdup(str);
  storage_.push_back(last_match_);
  return last_match_;
}
  410bb4:	48 83 c4 08          	add    $0x8,%rsp
  410bb8:	5b                   	pop    %rbx
  410bb9:	5d                   	pop    %rbp
  410bba:	41 5c                	pop    %r12
  410bbc:	41 5d                	pop    %r13
  410bbe:	c3                   	retq   
  410bbf:	90                   	nop
    if (!internal_strcmp(storage_[i], str)) {
      last_match_ = storage_[i];
      return last_match_;
    }
  }
  last_match_ = internal_strdup(str);
  410bc0:	4c 89 e7             	mov    %r12,%rdi
  410bc3:	e8 f8 97 ff ff       	callq  40a3c0 <_ZN11__sanitizer15internal_strdupEPKc>
  const T &operator[](uptr i) const {
    CHECK_LT(i, size_);
    return data_[i];
  }
  void push_back(const T &element) {
    CHECK_LE(size_, capacity_);
  410bc8:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  410bcc:	4c 8b 45 08          	mov    0x8(%rbp),%r8
  410bd0:	48 89 45 18          	mov    %rax,0x18(%rbp)
  410bd4:	4c 39 c2             	cmp    %r8,%rdx
  410bd7:	48 89 d1             	mov    %rdx,%rcx
  410bda:	0f 87 06 01 00 00    	ja     410ce6 <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0x1c6>
    if (size_ == capacity_) {
  410be0:	74 1f                	je     410c01 <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0xe1>
      uptr new_capacity = RoundUpToPowerOfTwo(size_ + 1);
      Resize(new_capacity);
    }
    data_[size_++] = element;
  410be2:	48 8b 55 00          	mov    0x0(%rbp),%rdx
  410be6:	48 8d 71 01          	lea    0x1(%rcx),%rsi
  410bea:	48 89 75 10          	mov    %rsi,0x10(%rbp)
  410bee:	48 89 04 ca          	mov    %rax,(%rdx,%rcx,8)
  storage_.push_back(last_match_);
  return last_match_;
  410bf2:	48 8b 45 18          	mov    0x18(%rbp),%rax
}
  410bf6:	48 83 c4 08          	add    $0x8,%rsp
  410bfa:	5b                   	pop    %rbx
  410bfb:	5d                   	pop    %rbp
  410bfc:	41 5c                	pop    %r12
  410bfe:	41 5d                	pop    %r13
  410c00:	c3                   	retq   
INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
}

INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  410c01:	48 89 d0             	mov    %rdx,%rax
  410c04:	48 83 c0 01          	add    $0x1,%rax
  410c08:	0f 84 bb 00 00 00    	je     410cc9 <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0x1a9>
  if (IsPowerOfTwo(size)) return size;
  410c0e:	48 85 d0             	test   %rdx,%rax
  410c11:	48 89 c3             	mov    %rax,%rbx
  410c14:	75 62                	jne    410c78 <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0x158>
  bool empty() const { return size() == 0; }

 private:
  void Resize(uptr new_capacity) {
    CHECK_GT(new_capacity, 0);
    CHECK_LE(size_, new_capacity);
  410c16:	48 39 da             	cmp    %rbx,%rdx
  410c19:	0f 87 df 00 00 00    	ja     410cfe <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0x1de>
    T *new_data = (T *)MmapOrDie(new_capacity * sizeof(T),
                                 "InternalMmapVector");
  410c1f:	48 8d 3c dd 00 00 00 	lea    0x0(,%rbx,8),%rdi
  410c26:	00 
  410c27:	48 8d 35 1a 83 00 00 	lea    0x831a(%rip),%rsi        # 418f48 <.LC11>
  410c2e:	e8 6d b7 ff ff       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  410c33:	49 89 c4             	mov    %rax,%r12
    internal_memcpy(new_data, data_, size_ * sizeof(T));
  410c36:	48 8b 45 10          	mov    0x10(%rbp),%rax
  410c3a:	48 8b 75 00          	mov    0x0(%rbp),%rsi
  410c3e:	4c 89 e7             	mov    %r12,%rdi
  410c41:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  410c48:	00 
  410c49:	e8 c2 92 ff ff       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
    T *old_data = data_;
    data_ = new_data;
    UnmapOrDie(old_data, capacity_ * sizeof(T));
  410c4e:	48 8b 45 08          	mov    0x8(%rbp),%rax
    CHECK_GT(new_capacity, 0);
    CHECK_LE(size_, new_capacity);
    T *new_data = (T *)MmapOrDie(new_capacity * sizeof(T),
                                 "InternalMmapVector");
    internal_memcpy(new_data, data_, size_ * sizeof(T));
    T *old_data = data_;
  410c52:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
    data_ = new_data;
  410c56:	4c 89 65 00          	mov    %r12,0x0(%rbp)
    UnmapOrDie(old_data, capacity_ * sizeof(T));
  410c5a:	48 8d 34 c5 00 00 00 	lea    0x0(,%rax,8),%rsi
  410c61:	00 
  410c62:	e8 d9 b7 ff ff       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
    capacity_ = new_capacity;
  410c67:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
  410c6b:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  410c6f:	48 8b 45 18          	mov    0x18(%rbp),%rax
  410c73:	e9 6a ff ff ff       	jmpq   410be2 <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0xc2>
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  410c78:	48 0f bd c8          	bsr    %rax,%rcx
  410c7c:	be 3f 00 00 00       	mov    $0x3f,%esi
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  410c81:	bf 01 00 00 00       	mov    $0x1,%edi
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  410c86:	48 83 f1 3f          	xor    $0x3f,%rcx
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  410c8a:	48 89 fb             	mov    %rdi,%rbx
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  410c8d:	29 ce                	sub    %ecx,%esi
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  410c8f:	8d 4e 01             	lea    0x1(%rsi),%ecx
  410c92:	48 d3 e3             	shl    %cl,%rbx
  410c95:	48 39 d8             	cmp    %rbx,%rax
  410c98:	0f 83 99 00 00 00    	jae    410d37 <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0x217>
  CHECK(size > (1ULL << up));
  410c9e:	89 f1                	mov    %esi,%ecx
  410ca0:	48 d3 e7             	shl    %cl,%rdi
  410ca3:	48 39 f8             	cmp    %rdi,%rax
  410ca6:	0f 87 6a ff ff ff    	ja     410c16 <_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc+0xf6>
  410cac:	48 8d 15 8d 6d 00 00 	lea    0x6d8d(%rip),%rdx        # 417a40 <.LC10>
  410cb3:	48 8d 3d 56 43 00 00 	lea    0x4356(%rip),%rdi        # 415010 <.LC1>
  410cba:	45 31 c0             	xor    %r8d,%r8d
  410cbd:	31 c9                	xor    %ecx,%ecx
  410cbf:	be a4 01 00 00       	mov    $0x1a4,%esi
  410cc4:	e8 27 47 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
INLINE bool IsPowerOfTwo(uptr x) {
  return (x & (x - 1)) == 0;
}

INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  410cc9:	48 8d 15 4a 82 00 00 	lea    0x824a(%rip),%rdx        # 418f1a <.LC5>
  410cd0:	48 8d 3d 39 43 00 00 	lea    0x4339(%rip),%rdi        # 415010 <.LC1>
  410cd7:	45 31 c0             	xor    %r8d,%r8d
  410cda:	31 c9                	xor    %ecx,%ecx
  410cdc:	be 9f 01 00 00       	mov    $0x19f,%esi
  410ce1:	e8 0a 47 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  const T &operator[](uptr i) const {
    CHECK_LT(i, size_);
    return data_[i];
  }
  void push_back(const T &element) {
    CHECK_LE(size_, capacity_);
  410ce6:	48 8d 15 12 82 00 00 	lea    0x8212(%rip),%rdx        # 418eff <.LC4>
  410ced:	48 8d 3d 1c 43 00 00 	lea    0x431c(%rip),%rdi        # 415010 <.LC1>
  410cf4:	be e7 01 00 00       	mov    $0x1e7,%esi
  410cf9:	e8 f2 46 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  bool empty() const { return size() == 0; }

 private:
  void Resize(uptr new_capacity) {
    CHECK_GT(new_capacity, 0);
    CHECK_LE(size_, new_capacity);
  410cfe:	48 89 d1             	mov    %rdx,%rcx
  410d01:	48 8d 3d 08 43 00 00 	lea    0x4308(%rip),%rdi        # 415010 <.LC1>
  410d08:	48 8d 15 1b 82 00 00 	lea    0x821b(%rip),%rdx        # 418f2a <.LC10>
  410d0f:	49 89 d8             	mov    %rbx,%r8
  410d12:	be 09 02 00 00       	mov    $0x209,%esi
  410d17:	e8 d4 46 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  }
  void Destroy() {
    UnmapOrDie(data_, capacity_ * sizeof(T));
  }
  T &operator[](uptr i) {
    CHECK_LT(i, size_);
  410d1c:	48 8d 15 38 82 00 00 	lea    0x8238(%rip),%rdx        # 418f5b <.LC13>
  410d23:	48 8d 3d e6 42 00 00 	lea    0x42e6(%rip),%rdi        # 415010 <.LC1>
  410d2a:	48 89 d9             	mov    %rbx,%rcx
  410d2d:	be df 01 00 00       	mov    $0x1df,%esi
  410d32:	e8 b9 46 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  410d37:	48 8d 15 da 6c 00 00 	lea    0x6cda(%rip),%rdx        # 417a18 <.LC2>
  410d3e:	48 8d 3d cb 42 00 00 	lea    0x42cb(%rip),%rdi        # 415010 <.LC1>
  410d45:	45 31 c0             	xor    %r8d,%r8d
  410d48:	31 c9                	xor    %ecx,%ecx
  410d4a:	be a3 01 00 00       	mov    $0x1a3,%esi
  410d4f:	e8 9c 46 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  410d54:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  410d5b:	00 00 00 00 00 

0000000000410d60 <_ZN11__sanitizer10SymbolizerC1ENS_13IntrusiveListINS_14SymbolizerToolEEE>:

Symbolizer::Symbolizer(IntrusiveList<SymbolizerTool> tools)
  410d60:	55                   	push   %rbp
class InternalMmapVectorNoCtor {
 public:
  void Initialize(uptr initial_capacity) {
    capacity_ = Max(initial_capacity, (uptr)1);
    size_ = 0;
    data_ = (T *)MmapOrDie(capacity_ * sizeof(T), "InternalMmapVectorNoCtor");
  410d61:	48 8d 35 7e 81 00 00 	lea    0x817e(%rip),%rsi        # 418ee6 <.LC0>
    : module_names_(&mu_), n_modules_(0), modules_fresh_(false), tools_(tools),
      start_hook_(0), end_hook_(0) {}
  410d68:	48 8d af 38 00 0a 00 	lea    0xa0038(%rdi),%rbp
  last_match_ = internal_strdup(str);
  storage_.push_back(last_match_);
  return last_match_;
}

Symbolizer::Symbolizer(IntrusiveList<SymbolizerTool> tools)
  410d6f:	53                   	push   %rbx
  410d70:	48 89 fb             	mov    %rdi,%rbx
  410d73:	48 83 ec 08          	sub    $0x8,%rsp
// WARNING: The current implementation supports only POD types.
template<typename T>
class InternalMmapVectorNoCtor {
 public:
  void Initialize(uptr initial_capacity) {
    capacity_ = Max(initial_capacity, (uptr)1);
  410d77:	48 c7 47 08 e8 03 00 	movq   $0x3e8,0x8(%rdi)
  410d7e:	00 
    size_ = 0;
  410d7f:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  410d86:	00 
    data_ = (T *)MmapOrDie(capacity_ * sizeof(T), "InternalMmapVectorNoCtor");
  410d87:	bf 40 1f 00 00       	mov    $0x1f40,%edi
  410d8c:	e8 0f b6 ff ff       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
  410d91:	48 8d 4b 38          	lea    0x38(%rbx),%rcx
    : module_names_(&mu_), n_modules_(0), modules_fresh_(false), tools_(tools),
      start_hook_(0), end_hook_(0) {}
  410d95:	4c 8d 43 28          	lea    0x28(%rbx),%r8
  410d99:	48 89 03             	mov    %rax,(%rbx)
  // its method should be protected by |mu_|.
  class ModuleNameOwner {
   public:
    explicit ModuleNameOwner(BlockingMutex *synchronized_by)
        : storage_(kInitialCapacity), last_match_(nullptr),
          mu_(synchronized_by) {}
  410d9c:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
  410da3:	00 
  410da4:	48 89 6b 20          	mov    %rbp,0x20(%rbx)
  410da8:	48 89 ee             	mov    %rbp,%rsi
  410dab:	48 89 c8             	mov    %rcx,%rax
  410dae:	66 90                	xchg   %ax,%ax

// Represents a binary loaded into virtual memory (e.g. this can be an
// executable or a shared object).
class LoadedModule {
 public:
  LoadedModule() : full_name_(nullptr), base_address_(0) { ranges_.clear(); }
  410db0:	48 c7 40 f0 00 00 00 	movq   $0x0,-0x10(%rax)
  410db7:	00 
  410db8:	48 c7 40 f8 00 00 00 	movq   $0x0,-0x8(%rax)
  410dbf:	00 
  410dc0:	48 89 c2             	mov    %rax,%rdx
  410dc3:	48 83 c0 28          	add    $0x28,%rax
  410dc7:	4c 29 c2             	sub    %r8,%rdx
  410dca:	48 39 f0             	cmp    %rsi,%rax
template<class Item>
struct IntrusiveList {
  friend class Iterator;

  void clear() {
    first_ = last_ = nullptr;
  410dcd:	48 c7 04 0a 00 00 00 	movq   $0x0,(%rdx,%rcx,1)
  410dd4:	00 
  410dd5:	48 c7 44 0a f8 00 00 	movq   $0x0,-0x8(%rdx,%rcx,1)
  410ddc:	00 00 
    size_ = 0;
  410dde:	48 c7 44 0a f0 00 00 	movq   $0x0,-0x10(%rdx,%rcx,1)
  410de5:	00 00 
  410de7:	75 c7                	jne    410db0 <_ZN11__sanitizer10SymbolizerC1ENS_13IntrusiveListINS_14SymbolizerToolEEE+0x50>
  410de9:	48 c7 83 28 00 0a 00 	movq   $0x0,0xa0028(%rbx)
  410df0:	00 00 00 00 
  410df4:	c6 83 30 00 0a 00 00 	movb   $0x0,0xa0030(%rbx)
  410dfb:	48 89 ef             	mov    %rbp,%rdi
  410dfe:	e8 9d aa ff ff       	callq  40b8a0 <_ZN11__sanitizer13BlockingMutexC1Ev>
  410e03:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  410e08:	48 c7 83 a8 00 0a 00 	movq   $0x0,0xa00a8(%rbx)
  410e0f:	00 00 00 00 
  410e13:	48 c7 83 b0 00 0a 00 	movq   $0x0,0xa00b0(%rbx)
  410e1a:	00 00 00 00 
  410e1e:	48 89 83 90 00 0a 00 	mov    %rax,0xa0090(%rbx)
  410e25:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  410e2a:	48 89 83 98 00 0a 00 	mov    %rax,0xa0098(%rbx)
  410e31:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  410e36:	48 89 83 a0 00 0a 00 	mov    %rax,0xa00a0(%rbx)
  410e3d:	48 83 c4 08          	add    $0x8,%rsp
  410e41:	5b                   	pop    %rbx
  410e42:	5d                   	pop    %rbp
  410e43:	c3                   	retq   
  410e44:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  410e4b:	00 00 00 00 00 

0000000000410e50 <_ZN11__sanitizer10Symbolizer15SymbolizerScopeC1EPKS0_>:

Symbolizer::SymbolizerScope::SymbolizerScope(const Symbolizer *sym)
    : sym_(sym) {
  if (sym_->start_hook_)
  410e50:	48 8b 86 a8 00 0a 00 	mov    0xa00a8(%rsi),%rax
Symbolizer::Symbolizer(IntrusiveList<SymbolizerTool> tools)
    : module_names_(&mu_), n_modules_(0), modules_fresh_(false), tools_(tools),
      start_hook_(0), end_hook_(0) {}

Symbolizer::SymbolizerScope::SymbolizerScope(const Symbolizer *sym)
    : sym_(sym) {
  410e57:	48 89 37             	mov    %rsi,(%rdi)
  if (sym_->start_hook_)
  410e5a:	48 85 c0             	test   %rax,%rax
  410e5d:	74 09                	je     410e68 <_ZN11__sanitizer10Symbolizer15SymbolizerScopeC1EPKS0_+0x18>
    sym_->start_hook_();
  410e5f:	ff e0                	jmpq   *%rax
  410e61:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  410e68:	f3 c3                	repz retq 
  410e6a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000410e70 <_ZN11__sanitizer10Symbolizer15SymbolizerScopeD1Ev>:
}

Symbolizer::SymbolizerScope::~SymbolizerScope() {
  if (sym_->end_hook_)
  410e70:	48 8b 07             	mov    (%rdi),%rax
  410e73:	48 8b 80 b0 00 0a 00 	mov    0xa00b0(%rax),%rax
  410e7a:	48 85 c0             	test   %rax,%rax
  410e7d:	74 09                	je     410e88 <_ZN11__sanitizer10Symbolizer15SymbolizerScopeD1Ev+0x18>
    sym_->end_hook_();
  410e7f:	ff e0                	jmpq   *%rax
  410e81:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  410e88:	f3 c3                	repz retq 
  410e8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000410e90 <_ZN11__sanitizer22LibbacktraceSymbolizer11SymbolizePCEmPNS_15SymbolizedStackE>:
}

bool LibbacktraceSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {
  (void)state_;
  return false;
}
  410e90:	31 c0                	xor    %eax,%eax
  410e92:	c3                   	retq   
  410e93:	90                   	nop
  410e94:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  410e9b:	00 00 00 00 00 

0000000000410ea0 <_ZN11__sanitizer22LibbacktraceSymbolizer13SymbolizeDataEmPNS_8DataInfoE>:

bool LibbacktraceSymbolizer::SymbolizeData(uptr addr, DataInfo *info) {
  return false;
}
  410ea0:	31 c0                	xor    %eax,%eax
  410ea2:	c3                   	retq   
  410ea3:	90                   	nop
  410ea4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  410eab:	00 00 00 00 00 

0000000000410eb0 <_ZN11__sanitizer22LibbacktraceSymbolizer8DemangleEPKc>:
  return 0;
}

const char *LibbacktraceSymbolizer::Demangle(const char *name) {
  return DemangleAlloc(name, /*always_alloc*/ false);
}
  410eb0:	31 c0                	xor    %eax,%eax
  410eb2:	c3                   	retq   
  410eb3:	90                   	nop
  410eb4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  410ebb:	00 00 00 00 00 

0000000000410ec0 <_ZN11__sanitizer22LibbacktraceSymbolizer3getEPNS_17LowLevelAllocatorE>:

#else  // SANITIZER_LIBBACKTRACE

LibbacktraceSymbolizer *LibbacktraceSymbolizer::get(LowLevelAllocator *alloc) {
  return 0;
}
  410ec0:	31 c0                	xor    %eax,%eax
  410ec2:	c3                   	retq   
  410ec3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  410eca:	84 00 00 00 00 00 

0000000000410ed0 <_ZN11__sanitizer14SymbolizerTool5FlushEv>:
  // and module offset values.
  virtual bool SymbolizeData(uptr addr, DataInfo *info) {
    UNIMPLEMENTED();
  }

  virtual void Flush() {}
  410ed0:	f3 c3                	repz retq 
  410ed2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  410ed9:	1f 84 00 00 00 00 00 

0000000000410ee0 <_ZN11__sanitizer12DTLS_DestroyEv>:
  if (old_dtv_size)
    DTLS_Deallocate(old_dtv, old_dtv_size);
}

void DTLS_Destroy() {
  if (!common_flags()->intercept_tls_get_addr) return;
  410ee0:	48 8b 05 d1 d3 00 00 	mov    0xd3d1(%rip),%rax        # 41e2b8 <_DYNAMIC+0x2b8>
  410ee7:	80 78 59 00          	cmpb   $0x0,0x59(%rax)
  410eeb:	74 53                	je     410f40 <_ZN11__sanitizer12DTLS_DestroyEv+0x60>
  dtls.dtv_size = new_size;
  if (old_dtv_size)
    DTLS_Deallocate(old_dtv, old_dtv_size);
}

void DTLS_Destroy() {
  410eed:	41 54                	push   %r12
  410eef:	4c 8b 25 ca d3 00 00 	mov    0xd3ca(%rip),%r12        # 41e2c0 <_DYNAMIC+0x2c0>
  410ef6:	55                   	push   %rbp
  410ef7:	53                   	push   %rbx
  410ef8:	41 8b 04 24          	mov    (%r12),%eax
  if (!common_flags()->intercept_tls_get_addr) return;
  VPrintf(2, "__tls_get_addr: DTLS_Destroy %p %zd\n", &dtls, dtls.dtv_size);
  410efc:	48 c7 c3 f0 fe ff ff 	mov    $0xfffffffffffffef0,%rbx
  410f03:	83 f8 01             	cmp    $0x1,%eax
  410f06:	76 1e                	jbe    410f26 <_ZN11__sanitizer12DTLS_DestroyEv+0x46>
  410f08:	48 89 de             	mov    %rbx,%rsi
  410f0b:	64 48 03 34 25 00 00 	add    %fs:0x0,%rsi
  410f12:	00 00 
  410f14:	64 48 8b 13          	mov    %fs:(%rbx),%rdx
  410f18:	48 8d 3d 19 6e 00 00 	lea    0x6e19(%rip),%rdi        # 417d38 <.LC0>
  410f1f:	31 c0                	xor    %eax,%eax
  410f21:	e8 ca ca ff ff       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  uptr s = dtls.dtv_size;
  410f26:	64 48 8b 2b          	mov    %fs:(%rbx),%rbp
  dtls.dtv_size = kDestroyedThread;  // Do this before unmap for AS-safety.
  410f2a:	64 48 c7 03 ff ff ff 	movq   $0xffffffffffffffff,%fs:(%rbx)
  410f31:	ff 
  DTLS_Deallocate(dtls.dtv, s);
  410f32:	64 48 8b 5b 08       	mov    %fs:0x8(%rbx),%rbx
static atomic_uintptr_t number_of_live_dtls;

static const uptr kDestroyedThread = -1;

static inline void DTLS_Deallocate(DTLS::DTV *dtv, uptr size) {
  if (!size) return;
  410f37:	48 85 ed             	test   %rbp,%rbp
  410f3a:	75 0c                	jne    410f48 <_ZN11__sanitizer12DTLS_DestroyEv+0x68>
  if (!common_flags()->intercept_tls_get_addr) return;
  VPrintf(2, "__tls_get_addr: DTLS_Destroy %p %zd\n", &dtls, dtls.dtv_size);
  uptr s = dtls.dtv_size;
  dtls.dtv_size = kDestroyedThread;  // Do this before unmap for AS-safety.
  DTLS_Deallocate(dtls.dtv, s);
}
  410f3c:	5b                   	pop    %rbx
  410f3d:	5d                   	pop    %rbp
  410f3e:	41 5c                	pop    %r12
  410f40:	f3 c3                	repz retq 
  410f42:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  410f48:	41 8b 04 24          	mov    (%r12),%eax

static const uptr kDestroyedThread = -1;

static inline void DTLS_Deallocate(DTLS::DTV *dtv, uptr size) {
  if (!size) return;
  VPrintf(2, "__tls_get_addr: DTLS_Deallocate %p %zd\n", dtv, size);
  410f4c:	83 f8 01             	cmp    $0x1,%eax
  410f4f:	76 14                	jbe    410f65 <_ZN11__sanitizer12DTLS_DestroyEv+0x85>
  410f51:	48 8d 3d 08 6e 00 00 	lea    0x6e08(%rip),%rdi        # 417d60 <.LC1>
  410f58:	48 89 ea             	mov    %rbp,%rdx
  410f5b:	48 89 de             	mov    %rbx,%rsi
  410f5e:	31 c0                	xor    %eax,%eax
  410f60:	e8 8b ca ff ff       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  UnmapOrDie(dtv, size * sizeof(DTLS::DTV));
  410f65:	48 89 ee             	mov    %rbp,%rsi
  410f68:	48 89 df             	mov    %rbx,%rdi
  410f6b:	48 c1 e6 04          	shl    $0x4,%rsi
  410f6f:	e8 cc b4 ff ff       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
template<typename T>
INLINE typename T::Type atomic_fetch_sub(volatile T *a,
    typename T::Type v, memory_order mo) {
  (void)mo;
  DCHECK(!((uptr)a % sizeof(*a)));
  return __sync_fetch_and_add(&a->val_dont_use, -v);
  410f74:	f0 48 83 2d d3 0e a6 	lock subq $0x1,0xa60ed3(%rip)        # e71e50 <_ZN11__sanitizerL19number_of_live_dtlsE>
  410f7b:	00 01 
  if (!common_flags()->intercept_tls_get_addr) return;
  VPrintf(2, "__tls_get_addr: DTLS_Destroy %p %zd\n", &dtls, dtls.dtv_size);
  uptr s = dtls.dtv_size;
  dtls.dtv_size = kDestroyedThread;  // Do this before unmap for AS-safety.
  DTLS_Deallocate(dtls.dtv, s);
}
  410f7d:	5b                   	pop    %rbx
  410f7e:	5d                   	pop    %rbp
  410f7f:	41 5c                	pop    %r12
  410f81:	eb bd                	jmp    410f40 <_ZN11__sanitizer12DTLS_DestroyEv+0x60>
  410f83:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  410f8a:	84 00 00 00 00 00 

0000000000410f90 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm>:

DTLS::DTV *DTLS_on_tls_get_addr(void *arg_void, void *res,
                                uptr static_tls_begin, uptr static_tls_end) {
  if (!common_flags()->intercept_tls_get_addr) return 0;
  410f90:	48 8b 05 21 d3 00 00 	mov    0xd321(%rip),%rax        # 41e2b8 <_DYNAMIC+0x2b8>
  410f97:	80 78 59 00          	cmpb   $0x0,0x59(%rax)
  410f9b:	0f 84 df 02 00 00    	je     411280 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x2f0>
  dtls.dtv_size = kDestroyedThread;  // Do this before unmap for AS-safety.
  DTLS_Deallocate(dtls.dtv, s);
}

DTLS::DTV *DTLS_on_tls_get_addr(void *arg_void, void *res,
                                uptr static_tls_begin, uptr static_tls_end) {
  410fa1:	41 57                	push   %r15
  410fa3:	41 56                	push   %r14
  410fa5:	49 89 d6             	mov    %rdx,%r14
  410fa8:	41 55                	push   %r13
  410faa:	41 54                	push   %r12
  410fac:	55                   	push   %rbp
  410fad:	48 89 fd             	mov    %rdi,%rbp
  410fb0:	53                   	push   %rbx
  410fb1:	48 83 ec 58          	sub    $0x58,%rsp
  if (!common_flags()->intercept_tls_get_addr) return 0;
  TlsGetAddrParam *arg = reinterpret_cast<TlsGetAddrParam *>(arg_void);
  uptr dso_id = arg->dso_id;
  if (dtls.dtv_size == kDestroyedThread) return 0;
  410fb5:	48 c7 c3 f0 fe ff ff 	mov    $0xfffffffffffffef0,%rbx

DTLS::DTV *DTLS_on_tls_get_addr(void *arg_void, void *res,
                                uptr static_tls_begin, uptr static_tls_end) {
  if (!common_flags()->intercept_tls_get_addr) return 0;
  TlsGetAddrParam *arg = reinterpret_cast<TlsGetAddrParam *>(arg_void);
  uptr dso_id = arg->dso_id;
  410fbc:	4c 8b 2f             	mov    (%rdi),%r13
  if (dtls.dtv_size == kDestroyedThread) return 0;
  410fbf:	64 48 8b 13          	mov    %fs:(%rbx),%rdx
  410fc3:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
  410fc7:	0f 84 63 02 00 00    	je     411230 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x2a0>
  DTLS_Resize(dso_id + 1);
  410fcd:	49 8d 45 01          	lea    0x1(%r13),%rax
  410fd1:	49 89 f0             	mov    %rsi,%r8
  410fd4:	49 89 cf             	mov    %rcx,%r15
  UnmapOrDie(dtv, size * sizeof(DTLS::DTV));
  atomic_fetch_sub(&number_of_live_dtls, 1, memory_order_relaxed);
}

static inline void DTLS_Resize(uptr new_size) {
  if (dtls.dtv_size >= new_size) return;
  410fd7:	48 39 c2             	cmp    %rax,%rdx
  410fda:	0f 82 c0 00 00 00    	jb     4110a0 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x110>
  410fe0:	64 4c 8b 53 08       	mov    %fs:0x8(%rbx),%r10
  if (!common_flags()->intercept_tls_get_addr) return 0;
  TlsGetAddrParam *arg = reinterpret_cast<TlsGetAddrParam *>(arg_void);
  uptr dso_id = arg->dso_id;
  if (dtls.dtv_size == kDestroyedThread) return 0;
  DTLS_Resize(dso_id + 1);
  if (dtls.dtv[dso_id].beg) return 0;
  410fe5:	49 c1 e5 04          	shl    $0x4,%r13
  410fe9:	4b 83 3c 2a 00       	cmpq   $0x0,(%r10,%r13,1)
  410fee:	0f 85 3c 02 00 00    	jne    411230 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x2a0>
  410ff4:	4c 8b 25 c5 d2 00 00 	mov    0xd2c5(%rip),%r12        # 41e2c0 <_DYNAMIC+0x2c0>
  uptr tls_size = 0;
  uptr tls_beg = reinterpret_cast<uptr>(res) - arg->offset;
  410ffb:	48 8b 4d 08          	mov    0x8(%rbp),%rcx
  410fff:	4d 89 c1             	mov    %r8,%r9
  411002:	41 8b 04 24          	mov    (%r12),%eax
  411006:	49 29 c9             	sub    %rcx,%r9
  411009:	4c 89 4c 24 40       	mov    %r9,0x40(%rsp)
  VPrintf(2, "__tls_get_addr: %p {%p,%p} => %p; tls_beg: %p; sp: %p "
  41100e:	83 f8 01             	cmp    $0x1,%eax
  411011:	76 2f                	jbe    411042 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0xb2>
  411013:	48 8b 05 36 0e a6 00 	mov    0xa60e36(%rip),%rax        # e71e50 <_ZN11__sanitizerL19number_of_live_dtlsE>
  41101a:	48 8d 3d 27 6e 00 00 	lea    0x6e27(%rip),%rdi        # 417e48 <.LC9>
  411021:	48 89 ee             	mov    %rbp,%rsi
  411024:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  411029:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
  41102e:	48 89 04 24          	mov    %rax,(%rsp)
  411032:	48 8b 55 00          	mov    0x0(%rbp),%rdx
  411036:	31 c0                	xor    %eax,%eax
  411038:	e8 b3 c9 ff ff       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  41103d:	4c 8b 4c 24 40       	mov    0x40(%rsp),%r9
             "num_live_dtls %zd\n",
          arg, arg->dso_id, arg->offset, res, tls_beg, &tls_beg,
          atomic_load(&number_of_live_dtls, memory_order_relaxed));
  if (dtls.last_memalign_ptr == tls_beg) {
  411042:	64 4c 39 4b 18       	cmp    %r9,%fs:0x18(%rbx)
  411047:	0f 84 73 01 00 00    	je     4111c0 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x230>
    tls_size = dtls.last_memalign_size;
    VPrintf(2, "__tls_get_addr: glibc <=2.18 suspected; tls={%p,%p}\n",
        tls_beg, tls_size);
  } else if (tls_beg >= static_tls_begin && tls_beg < static_tls_end) {
  41104d:	4d 39 ce             	cmp    %r9,%r14
  411050:	0f 87 2a 01 00 00    	ja     411180 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x1f0>
  411056:	4d 39 cf             	cmp    %r9,%r15
  411059:	0f 86 21 01 00 00    	jbe    411180 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x1f0>
  41105f:	41 8b 04 24          	mov    (%r12),%eax
    // This is the static TLS block which was initialized / unpoisoned at thread
    // creation.
    VPrintf(2, "__tls_get_addr: static tls: %p\n", tls_beg);
    tls_size = 0;
  411063:	31 ed                	xor    %ebp,%ebp
    VPrintf(2, "__tls_get_addr: glibc <=2.18 suspected; tls={%p,%p}\n",
        tls_beg, tls_size);
  } else if (tls_beg >= static_tls_begin && tls_beg < static_tls_end) {
    // This is the static TLS block which was initialized / unpoisoned at thread
    // creation.
    VPrintf(2, "__tls_get_addr: static tls: %p\n", tls_beg);
  411065:	83 f8 01             	cmp    $0x1,%eax
  411068:	76 16                	jbe    411080 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0xf0>
  41106a:	48 8d 3d 5f 6e 00 00 	lea    0x6e5f(%rip),%rdi        # 417ed0 <.LC11>
  411071:	4c 89 ce             	mov    %r9,%rsi
  411074:	31 c0                	xor    %eax,%eax
  411076:	e8 75 c9 ff ff       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  41107b:	4c 8b 4c 24 40       	mov    0x40(%rsp),%r9
  } else {
    VPrintf(2, "__tls_get_addr: Can't guess glibc version\n");
    // This may happen inside the DTOR of main thread, so just ignore it.
    tls_size = 0;
  }
  dtls.dtv[dso_id].beg = tls_beg;
  411080:	4c 89 e8             	mov    %r13,%rax
  411083:	64 48 03 43 08       	add    %fs:0x8(%rbx),%rax
  411088:	4c 89 08             	mov    %r9,(%rax)
  dtls.dtv[dso_id].size = tls_size;
  41108b:	48 89 68 08          	mov    %rbp,0x8(%rax)
  return dtls.dtv + dso_id;
}
  41108f:	48 83 c4 58          	add    $0x58,%rsp
  411093:	5b                   	pop    %rbx
  411094:	5d                   	pop    %rbp
  411095:	41 5c                	pop    %r12
  411097:	41 5d                	pop    %r13
  411099:	41 5e                	pop    %r14
  41109b:	41 5f                	pop    %r15
  41109d:	c3                   	retq   
  41109e:	66 90                	xchg   %ax,%ax
  return (x & (x - 1)) == 0;
}

INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;
  4110a0:	4c 85 e8             	test   %r13,%rax
  4110a3:	48 89 c1             	mov    %rax,%rcx
  4110a6:	0f 85 44 01 00 00    	jne    4111f0 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x260>
  4110ac:	48 81 f9 00 01 00 00 	cmp    $0x100,%rcx
  4110b3:	41 b9 00 01 00 00    	mov    $0x100,%r9d
static inline void DTLS_Resize(uptr new_size) {
  if (dtls.dtv_size >= new_size) return;
  new_size = RoundUpToPowerOfTwo(new_size);
  new_size = Max(new_size, 4096UL / sizeof(DTLS::DTV));
  DTLS::DTV *new_dtv =
      (DTLS::DTV *)MmapOrDie(new_size * sizeof(DTLS::DTV), "DTLS_Resize");
  4110b9:	48 8d 35 7a 7f 00 00 	lea    0x7f7a(%rip),%rsi        # 41903a <.LC5>
  4110c0:	4c 0f 43 c9          	cmovae %rcx,%r9
  4110c4:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  4110c9:	4c 89 cf             	mov    %r9,%rdi
  4110cc:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
  4110d1:	48 c1 e7 04          	shl    $0x4,%rdi
  4110d5:	e8 c6 b2 ff ff       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
template<typename T>
INLINE typename T::Type atomic_fetch_add(volatile T *a,
    typename T::Type v, memory_order mo) {
  (void)mo;
  DCHECK(!((uptr)a % sizeof(*a)));
  return __sync_fetch_and_add(&a->val_dont_use, v);
  4110da:	b9 01 00 00 00       	mov    $0x1,%ecx
  4110df:	49 89 c2             	mov    %rax,%r10
  4110e2:	f0 48 0f c1 0d 65 0d 	lock xadd %rcx,0xa60d65(%rip)        # e71e50 <_ZN11__sanitizerL19number_of_live_dtlsE>
  4110e9:	a6 00 
  4110eb:	4c 8b 25 ce d1 00 00 	mov    0xd1ce(%rip),%r12        # 41e2c0 <_DYNAMIC+0x2c0>
  uptr num_live_dtls =
      atomic_fetch_add(&number_of_live_dtls, 1, memory_order_relaxed);
  VPrintf(2, "__tls_get_addr: DTLS_Resize %p %zd\n", &dtls, num_live_dtls);
  4110f2:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
  4110f7:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
  4110fc:	41 8b 04 24          	mov    (%r12),%eax
  411100:	83 f8 01             	cmp    $0x1,%eax
  411103:	76 45                	jbe    41114a <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x1ba>
  411105:	48 89 de             	mov    %rbx,%rsi
  411108:	64 48 03 34 25 00 00 	add    %fs:0x0,%rsi
  41110f:	00 00 
  411111:	48 8d 3d 70 6c 00 00 	lea    0x6c70(%rip),%rdi        # 417d88 <.LC6>
  411118:	48 89 ca             	mov    %rcx,%rdx
  41111b:	31 c0                	xor    %eax,%eax
  41111d:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  411122:	4c 89 4c 24 20       	mov    %r9,0x20(%rsp)
  411127:	4c 89 54 24 18       	mov    %r10,0x18(%rsp)
  41112c:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  411131:	e8 ba c8 ff ff       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  411136:	4c 8b 44 24 28       	mov    0x28(%rsp),%r8
  41113b:	4c 8b 4c 24 20       	mov    0x20(%rsp),%r9
  411140:	4c 8b 54 24 18       	mov    0x18(%rsp),%r10
  411145:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
  CHECK_LT(num_live_dtls, 1 << 20);
  41114a:	48 81 f9 ff ff 0f 00 	cmp    $0xfffff,%rcx
  411151:	0f 87 e1 01 00 00    	ja     411338 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x3a8>
  uptr old_dtv_size = dtls.dtv_size;
  411157:	64 48 8b 0b          	mov    %fs:(%rbx),%rcx
  DTLS::DTV *old_dtv = dtls.dtv;
  41115b:	64 4c 8b 5b 08       	mov    %fs:0x8(%rbx),%r11
  if (old_dtv_size)
  411160:	48 85 c9             	test   %rcx,%rcx
  411163:	0f 85 1f 01 00 00    	jne    411288 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x2f8>
    internal_memcpy(new_dtv, dtls.dtv, dtls.dtv_size * sizeof(DTLS::DTV));
  dtls.dtv = new_dtv;
  411169:	64 4c 89 53 08       	mov    %r10,%fs:0x8(%rbx)
  dtls.dtv_size = new_size;
  41116e:	64 4c 89 0b          	mov    %r9,%fs:(%rbx)
  411172:	e9 6e fe ff ff       	jmpq   410fe5 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x55>
  411177:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  41117e:	00 00 
  } else if (tls_beg >= static_tls_begin && tls_beg < static_tls_end) {
    // This is the static TLS block which was initialized / unpoisoned at thread
    // creation.
    VPrintf(2, "__tls_get_addr: static tls: %p\n", tls_beg);
    tls_size = 0;
  } else if ((tls_beg % 4096) == sizeof(Glibc_2_19_tls_header)) {
  411180:	4c 89 c8             	mov    %r9,%rax
  411183:	25 ff 0f 00 00       	and    $0xfff,%eax
  411188:	48 83 f8 10          	cmp    $0x10,%rax
  41118c:	0f 84 b6 00 00 00    	je     411248 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x2b8>
  411192:	41 8b 04 24          	mov    (%r12),%eax
    VPrintf(2, "__tls_get_addr: glibc >=2.19 suspected; tls={%p %p}\n",
        tls_beg, tls_size);
  } else {
    VPrintf(2, "__tls_get_addr: Can't guess glibc version\n");
    // This may happen inside the DTOR of main thread, so just ignore it.
    tls_size = 0;
  411196:	31 ed                	xor    %ebp,%ebp
    tls_size = header->size;
    tls_beg = header->start;
    VPrintf(2, "__tls_get_addr: glibc >=2.19 suspected; tls={%p %p}\n",
        tls_beg, tls_size);
  } else {
    VPrintf(2, "__tls_get_addr: Can't guess glibc version\n");
  411198:	83 f8 01             	cmp    $0x1,%eax
  41119b:	0f 86 df fe ff ff    	jbe    411080 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0xf0>
  4111a1:	48 8d 3d 80 6d 00 00 	lea    0x6d80(%rip),%rdi        # 417f28 <.LC13>
  4111a8:	31 c0                	xor    %eax,%eax
  4111aa:	e8 41 c8 ff ff       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  4111af:	4c 8b 4c 24 40       	mov    0x40(%rsp),%r9
  4111b4:	e9 c7 fe ff ff       	jmpq   411080 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0xf0>
  4111b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  4111c0:	41 8b 04 24          	mov    (%r12),%eax
  VPrintf(2, "__tls_get_addr: %p {%p,%p} => %p; tls_beg: %p; sp: %p "
             "num_live_dtls %zd\n",
          arg, arg->dso_id, arg->offset, res, tls_beg, &tls_beg,
          atomic_load(&number_of_live_dtls, memory_order_relaxed));
  if (dtls.last_memalign_ptr == tls_beg) {
    tls_size = dtls.last_memalign_size;
  4111c4:	64 48 8b 6b 10       	mov    %fs:0x10(%rbx),%rbp
    VPrintf(2, "__tls_get_addr: glibc <=2.18 suspected; tls={%p,%p}\n",
  4111c9:	83 f8 01             	cmp    $0x1,%eax
  4111cc:	0f 86 ae fe ff ff    	jbe    411080 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0xf0>
  4111d2:	48 8d 3d bf 6c 00 00 	lea    0x6cbf(%rip),%rdi        # 417e98 <.LC10>
  4111d9:	4c 89 ce             	mov    %r9,%rsi
  4111dc:	48 89 ea             	mov    %rbp,%rdx
  4111df:	31 c0                	xor    %eax,%eax
  4111e1:	e8 0a c8 ff ff       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  4111e6:	4c 8b 4c 24 40       	mov    0x40(%rsp),%r9
  4111eb:	e9 90 fe ff ff       	jmpq   411080 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0xf0>
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  4111f0:	48 0f bd c8          	bsr    %rax,%rcx
  4111f4:	ba 3f 00 00 00       	mov    $0x3f,%edx
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  4111f9:	bf 01 00 00 00       	mov    $0x1,%edi
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  4111fe:	48 83 f1 3f          	xor    $0x3f,%rcx
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  411202:	48 89 fe             	mov    %rdi,%rsi
  unsigned long up;  // NOLINT
#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)
# ifdef _WIN64
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);
# else
  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);
  411205:	29 ca                	sub    %ecx,%edx
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  411207:	8d 4a 01             	lea    0x1(%rdx),%ecx
  41120a:	48 d3 e6             	shl    %cl,%rsi
  41120d:	48 39 f0             	cmp    %rsi,%rax
  411210:	0f 83 5d 01 00 00    	jae    411373 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x3e3>
  CHECK(size > (1ULL << up));
  411216:	89 d1                	mov    %edx,%ecx
  411218:	48 d3 e7             	shl    %cl,%rdi
  41121b:	48 39 f8             	cmp    %rdi,%rax
  41121e:	0f 86 32 01 00 00    	jbe    411356 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x3c6>
  411224:	48 89 f1             	mov    %rsi,%rcx
  411227:	e9 80 fe ff ff       	jmpq   4110ac <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x11c>
  41122c:	0f 1f 40 00          	nopl   0x0(%rax)
    tls_size = 0;
  }
  dtls.dtv[dso_id].beg = tls_beg;
  dtls.dtv[dso_id].size = tls_size;
  return dtls.dtv + dso_id;
}
  411230:	48 83 c4 58          	add    $0x58,%rsp
  DTLS_Deallocate(dtls.dtv, s);
}

DTLS::DTV *DTLS_on_tls_get_addr(void *arg_void, void *res,
                                uptr static_tls_begin, uptr static_tls_end) {
  if (!common_flags()->intercept_tls_get_addr) return 0;
  411234:	31 c0                	xor    %eax,%eax
    tls_size = 0;
  }
  dtls.dtv[dso_id].beg = tls_beg;
  dtls.dtv[dso_id].size = tls_size;
  return dtls.dtv + dso_id;
}
  411236:	5b                   	pop    %rbx
  411237:	5d                   	pop    %rbp
  411238:	41 5c                	pop    %r12
  41123a:	41 5d                	pop    %r13
  41123c:	41 5e                	pop    %r14
  41123e:	41 5f                	pop    %r15
  411240:	c3                   	retq   
  411241:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  411248:	41 8b 04 24          	mov    (%r12),%eax
    VPrintf(2, "__tls_get_addr: static tls: %p\n", tls_beg);
    tls_size = 0;
  } else if ((tls_beg % 4096) == sizeof(Glibc_2_19_tls_header)) {
    // We may want to check gnu_get_libc_version().
    Glibc_2_19_tls_header *header = (Glibc_2_19_tls_header *)tls_beg - 1;
    tls_size = header->size;
  41124c:	49 8b 69 f0          	mov    -0x10(%r9),%rbp
    tls_beg = header->start;
  411250:	4d 8b 49 f8          	mov    -0x8(%r9),%r9
    VPrintf(2, "__tls_get_addr: glibc >=2.19 suspected; tls={%p %p}\n",
  411254:	83 f8 01             	cmp    $0x1,%eax
    tls_size = 0;
  } else if ((tls_beg % 4096) == sizeof(Glibc_2_19_tls_header)) {
    // We may want to check gnu_get_libc_version().
    Glibc_2_19_tls_header *header = (Glibc_2_19_tls_header *)tls_beg - 1;
    tls_size = header->size;
    tls_beg = header->start;
  411257:	4c 89 4c 24 40       	mov    %r9,0x40(%rsp)
    VPrintf(2, "__tls_get_addr: glibc >=2.19 suspected; tls={%p %p}\n",
  41125c:	0f 86 1e fe ff ff    	jbe    411080 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0xf0>
  411262:	48 8d 3d 87 6c 00 00 	lea    0x6c87(%rip),%rdi        # 417ef0 <.LC12>
  411269:	4c 89 ce             	mov    %r9,%rsi
  41126c:	48 89 ea             	mov    %rbp,%rdx
  41126f:	31 c0                	xor    %eax,%eax
  411271:	e8 7a c7 ff ff       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  411276:	4c 8b 4c 24 40       	mov    0x40(%rsp),%r9
  41127b:	e9 00 fe ff ff       	jmpq   411080 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0xf0>
  DTLS_Deallocate(dtls.dtv, s);
}

DTLS::DTV *DTLS_on_tls_get_addr(void *arg_void, void *res,
                                uptr static_tls_begin, uptr static_tls_end) {
  if (!common_flags()->intercept_tls_get_addr) return 0;
  411280:	31 c0                	xor    %eax,%eax
    tls_size = 0;
  }
  dtls.dtv[dso_id].beg = tls_beg;
  dtls.dtv[dso_id].size = tls_size;
  return dtls.dtv + dso_id;
}
  411282:	c3                   	retq   
  411283:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  VPrintf(2, "__tls_get_addr: DTLS_Resize %p %zd\n", &dtls, num_live_dtls);
  CHECK_LT(num_live_dtls, 1 << 20);
  uptr old_dtv_size = dtls.dtv_size;
  DTLS::DTV *old_dtv = dtls.dtv;
  if (old_dtv_size)
    internal_memcpy(new_dtv, dtls.dtv, dtls.dtv_size * sizeof(DTLS::DTV));
  411288:	48 89 c8             	mov    %rcx,%rax
  41128b:	4c 89 de             	mov    %r11,%rsi
  41128e:	4c 89 d7             	mov    %r10,%rdi
  411291:	48 c1 e0 04          	shl    $0x4,%rax
  411295:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  41129a:	4c 89 4c 24 20       	mov    %r9,0x20(%rsp)
  41129f:	48 89 c2             	mov    %rax,%rdx
  4112a2:	4c 89 5c 24 18       	mov    %r11,0x18(%rsp)
  4112a7:	4c 89 54 24 10       	mov    %r10,0x10(%rsp)
  4112ac:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  4112b1:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  4112b6:	e8 55 8c ff ff       	callq  409f10 <_ZN11__sanitizer15internal_memcpyEPvPKvm>
  4112bb:	41 8b 04 24          	mov    (%r12),%eax
  dtls.dtv = new_dtv;
  4112bf:	4c 8b 54 24 10       	mov    0x10(%rsp),%r10
  dtls.dtv_size = new_size;
  4112c4:	4c 8b 4c 24 20       	mov    0x20(%rsp),%r9

static const uptr kDestroyedThread = -1;

static inline void DTLS_Deallocate(DTLS::DTV *dtv, uptr size) {
  if (!size) return;
  VPrintf(2, "__tls_get_addr: DTLS_Deallocate %p %zd\n", dtv, size);
  4112c9:	4c 8b 5c 24 18       	mov    0x18(%rsp),%r11
  4112ce:	4c 8b 44 24 28       	mov    0x28(%rsp),%r8
  4112d3:	83 f8 01             	cmp    $0x1,%eax
  CHECK_LT(num_live_dtls, 1 << 20);
  uptr old_dtv_size = dtls.dtv_size;
  DTLS::DTV *old_dtv = dtls.dtv;
  if (old_dtv_size)
    internal_memcpy(new_dtv, dtls.dtv, dtls.dtv_size * sizeof(DTLS::DTV));
  dtls.dtv = new_dtv;
  4112d6:	64 4c 89 53 08       	mov    %r10,%fs:0x8(%rbx)
  dtls.dtv_size = new_size;
  4112db:	64 4c 89 0b          	mov    %r9,%fs:(%rbx)

static const uptr kDestroyedThread = -1;

static inline void DTLS_Deallocate(DTLS::DTV *dtv, uptr size) {
  if (!size) return;
  VPrintf(2, "__tls_get_addr: DTLS_Deallocate %p %zd\n", dtv, size);
  4112df:	76 2d                	jbe    41130e <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x37e>
  4112e1:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
  4112e6:	48 8d 3d 73 6a 00 00 	lea    0x6a73(%rip),%rdi        # 417d60 <.LC1>
  4112ed:	4c 89 de             	mov    %r11,%rsi
  4112f0:	31 c0                	xor    %eax,%eax
  4112f2:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  4112f7:	4c 89 5c 24 10       	mov    %r11,0x10(%rsp)
  4112fc:	48 89 ca             	mov    %rcx,%rdx
  4112ff:	e8 ec c6 ff ff       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  411304:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
  411309:	4c 8b 5c 24 10       	mov    0x10(%rsp),%r11
  UnmapOrDie(dtv, size * sizeof(DTLS::DTV));
  41130e:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
  411313:	4c 89 df             	mov    %r11,%rdi
  411316:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  41131b:	e8 20 b1 ff ff       	callq  40c440 <_ZN11__sanitizer10UnmapOrDieEPvm>
template<typename T>
INLINE typename T::Type atomic_fetch_sub(volatile T *a,
    typename T::Type v, memory_order mo) {
  (void)mo;
  DCHECK(!((uptr)a % sizeof(*a)));
  return __sync_fetch_and_add(&a->val_dont_use, -v);
  411320:	f0 48 83 2d 27 0b a6 	lock subq $0x1,0xa60b27(%rip)        # e71e50 <_ZN11__sanitizerL19number_of_live_dtlsE>
  411327:	00 01 
  411329:	64 4c 8b 53 08       	mov    %fs:0x8(%rbx),%r10
  41132e:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
  411333:	e9 ad fc ff ff       	jmpq   410fe5 <_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm+0x55>
  DTLS::DTV *new_dtv =
      (DTLS::DTV *)MmapOrDie(new_size * sizeof(DTLS::DTV), "DTLS_Resize");
  uptr num_live_dtls =
      atomic_fetch_add(&number_of_live_dtls, 1, memory_order_relaxed);
  VPrintf(2, "__tls_get_addr: DTLS_Resize %p %zd\n", &dtls, num_live_dtls);
  CHECK_LT(num_live_dtls, 1 << 20);
  411338:	48 8d 15 71 6a 00 00 	lea    0x6a71(%rip),%rdx        # 417db0 <.LC7>
  41133f:	48 8d 3d 8a 6a 00 00 	lea    0x6a8a(%rip),%rdi        # 417dd0 <.LC8>
  411346:	41 b8 00 00 10 00    	mov    $0x100000,%r8d
  41134c:	be 3e 00 00 00       	mov    $0x3e,%esi
  411351:	e8 9a 40 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  411356:	48 8d 15 e3 66 00 00 	lea    0x66e3(%rip),%rdx        # 417a40 <.LC10>
  41135d:	48 8d 3d ac 3c 00 00 	lea    0x3cac(%rip),%rdi        # 415010 <.LC1>
  411364:	45 31 c0             	xor    %r8d,%r8d
  411367:	31 c9                	xor    %ecx,%ecx
  411369:	be a4 01 00 00       	mov    $0x1a4,%esi
  41136e:	e8 7d 40 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
INLINE uptr RoundUpToPowerOfTwo(uptr size) {
  CHECK(size);
  if (IsPowerOfTwo(size)) return size;

  uptr up = MostSignificantSetBitIndex(size);
  CHECK(size < (1ULL << (up + 1)));
  411373:	48 8d 15 9e 66 00 00 	lea    0x669e(%rip),%rdx        # 417a18 <.LC2>
  41137a:	48 8d 3d 8f 3c 00 00 	lea    0x3c8f(%rip),%rdi        # 415010 <.LC1>
  411381:	45 31 c0             	xor    %r8d,%r8d
  411384:	31 c9                	xor    %ecx,%ecx
  411386:	be a3 01 00 00       	mov    $0x1a3,%esi
  41138b:	e8 60 40 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

0000000000411390 <_ZN11__sanitizer21DTLS_on_libc_memalignEPvm>:
  dtls.dtv[dso_id].size = tls_size;
  return dtls.dtv + dso_id;
}

void DTLS_on_libc_memalign(void *ptr, uptr size) {
  if (!common_flags()->intercept_tls_get_addr) return;
  411390:	48 8b 05 21 cf 00 00 	mov    0xcf21(%rip),%rax        # 41e2b8 <_DYNAMIC+0x2b8>
  411397:	80 78 59 00          	cmpb   $0x0,0x59(%rax)
  41139b:	74 45                	je     4113e2 <_ZN11__sanitizer21DTLS_on_libc_memalignEPvm+0x52>
  dtls.dtv[dso_id].beg = tls_beg;
  dtls.dtv[dso_id].size = tls_size;
  return dtls.dtv + dso_id;
}

void DTLS_on_libc_memalign(void *ptr, uptr size) {
  41139d:	55                   	push   %rbp
  41139e:	48 89 fd             	mov    %rdi,%rbp
  4113a1:	53                   	push   %rbx
  4113a2:	48 89 f3             	mov    %rsi,%rbx
  4113a5:	48 83 ec 08          	sub    $0x8,%rsp
  4113a9:	48 8b 05 10 cf 00 00 	mov    0xcf10(%rip),%rax        # 41e2c0 <_DYNAMIC+0x2c0>
  4113b0:	8b 00                	mov    (%rax),%eax
  if (!common_flags()->intercept_tls_get_addr) return;
  VPrintf(2, "DTLS_on_libc_memalign: %p %p\n", ptr, size);
  4113b2:	83 f8 01             	cmp    $0x1,%eax
  4113b5:	76 14                	jbe    4113cb <_ZN11__sanitizer21DTLS_on_libc_memalignEPvm+0x3b>
  4113b7:	48 89 f2             	mov    %rsi,%rdx
  4113ba:	48 89 fe             	mov    %rdi,%rsi
  4113bd:	48 8d 3d 82 7c 00 00 	lea    0x7c82(%rip),%rdi        # 419046 <.LC14>
  4113c4:	31 c0                	xor    %eax,%eax
  4113c6:	e8 25 c6 ff ff       	callq  40d9f0 <_ZN11__sanitizer6PrintfEPKcz>
  dtls.last_memalign_ptr = reinterpret_cast<uptr>(ptr);
  4113cb:	48 c7 c0 f0 fe ff ff 	mov    $0xfffffffffffffef0,%rax
  4113d2:	64 48 89 68 18       	mov    %rbp,%fs:0x18(%rax)
  dtls.last_memalign_size = size;
  4113d7:	64 48 89 58 10       	mov    %rbx,%fs:0x10(%rax)
}
  4113dc:	48 83 c4 08          	add    $0x8,%rsp
  4113e0:	5b                   	pop    %rbx
  4113e1:	5d                   	pop    %rbp
  4113e2:	f3 c3                	repz retq 
  4113e4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4113eb:	00 00 00 00 00 

00000000004113f0 <_ZN11__sanitizer8DTLS_GetEv>:

DTLS *DTLS_Get() { return &dtls; }
  4113f0:	48 c7 c0 f0 fe ff ff 	mov    $0xfffffffffffffef0,%rax
  4113f7:	64 48 03 04 25 00 00 	add    %fs:0x0,%rax
  4113fe:	00 00 
  411400:	c3                   	retq   
  411401:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  411408:	0f 1f 84 00 00 00 00 
  41140f:	00 

0000000000411410 <_ZN11__sanitizerL31FindThreadContextByOsIdCallbackEPNS_17ThreadContextBaseEPv>:
  return 0;
}

static bool FindThreadContextByOsIdCallback(ThreadContextBase *tctx,
                                            void *arg) {
  return (tctx->os_id == (uptr)arg && tctx->status != ThreadStatusInvalid &&
  411410:	31 c0                	xor    %eax,%eax
  411412:	48 3b 77 20          	cmp    0x20(%rdi),%rsi
  411416:	74 08                	je     411420 <_ZN11__sanitizerL31FindThreadContextByOsIdCallbackEPNS_17ThreadContextBaseEPv+0x10>
      tctx->status != ThreadStatusDead);
}
  411418:	f3 c3                	repz retq 
  41141a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  return 0;
}

static bool FindThreadContextByOsIdCallback(ThreadContextBase *tctx,
                                            void *arg) {
  return (tctx->os_id == (uptr)arg && tctx->status != ThreadStatusInvalid &&
  411420:	f7 47 70 fb ff ff ff 	testl  $0xfffffffb,0x70(%rdi)
  411427:	0f 95 c0             	setne  %al
      tctx->status != ThreadStatusDead);
}
  41142a:	c3                   	retq   
  41142b:	90                   	nop
  41142c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000411430 <_ZN11__sanitizer17ThreadContextBaseC1Ej>:
namespace __sanitizer {

ThreadContextBase::ThreadContextBase(u32 tid)
    : tid(tid), unique_id(0), reuse_count(), os_id(0), user_id(0),
      status(ThreadStatusInvalid),
      detached(false), parent_tid(0), next(0) {
  411430:	48 8d 05 b9 fa 00 00 	lea    0xfab9(%rip),%rax        # 420ef0 <_ZTVN11__sanitizer17ThreadContextBaseE+0x10>
  411437:	89 77 08             	mov    %esi,0x8(%rdi)
  41143a:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  411441:	00 
  411442:	c7 47 18 00 00 00 00 	movl   $0x0,0x18(%rdi)
  411449:	48 c7 47 20 00 00 00 	movq   $0x0,0x20(%rdi)
  411450:	00 
  411451:	48 89 07             	mov    %rax,(%rdi)
  411454:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
  41145b:	00 
  41145c:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%rdi)
  411463:	c6 47 74 00          	movb   $0x0,0x74(%rdi)
  411467:	c7 47 78 00 00 00 00 	movl   $0x0,0x78(%rdi)
  41146e:	48 c7 87 80 00 00 00 	movq   $0x0,0x80(%rdi)
  411475:	00 00 00 00 
  name[0] = '\0';
  411479:	c6 47 30 00          	movb   $0x0,0x30(%rdi)
  41147d:	c3                   	retq   
  41147e:	66 90                	xchg   %ax,%ax

0000000000411480 <_ZN11__sanitizer17ThreadContextBaseD1Ev>:
}

ThreadContextBase::~ThreadContextBase() {
  411480:	48 8d 05 69 fa 00 00 	lea    0xfa69(%rip),%rax        # 420ef0 <_ZTVN11__sanitizer17ThreadContextBaseE+0x10>
  411487:	48 83 ec 08          	sub    $0x8,%rsp
  // ThreadContextBase should never be deleted.
  CHECK(0);
  41148b:	48 8d 15 87 6f 00 00 	lea    0x6f87(%rip),%rdx        # 418419 <.LC0>
  411492:	45 31 c0             	xor    %r8d,%r8d
  411495:	31 c9                	xor    %ecx,%ecx
  411497:	be 1c 00 00 00       	mov    $0x1c,%esi
      status(ThreadStatusInvalid),
      detached(false), parent_tid(0), next(0) {
  name[0] = '\0';
}

ThreadContextBase::~ThreadContextBase() {
  41149c:	48 89 07             	mov    %rax,(%rdi)
  // ThreadContextBase should never be deleted.
  CHECK(0);
  41149f:	48 8d 3d b2 6a 00 00 	lea    0x6ab2(%rip),%rdi        # 417f58 <.LC1>
  4114a6:	e8 45 3f ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  4114ab:	90                   	nop
  4114ac:	0f 1f 40 00          	nopl   0x0(%rax)

00000000004114b0 <_ZN11__sanitizer17ThreadContextBase7SetNameEPKc>:
}

void ThreadContextBase::SetName(const char *new_name) {
  name[0] = '\0';
  if (new_name) {
  4114b0:	48 85 f6             	test   %rsi,%rsi
ThreadContextBase::~ThreadContextBase() {
  // ThreadContextBase should never be deleted.
  CHECK(0);
}

void ThreadContextBase::SetName(const char *new_name) {
  4114b3:	53                   	push   %rbx
  4114b4:	48 89 fb             	mov    %rdi,%rbx
  name[0] = '\0';
  4114b7:	c6 47 30 00          	movb   $0x0,0x30(%rdi)
  if (new_name) {
  4114bb:	74 12                	je     4114cf <_ZN11__sanitizer17ThreadContextBase7SetNameEPKc+0x1f>
    internal_strncpy(name, new_name, sizeof(name));
  4114bd:	48 8d 7f 30          	lea    0x30(%rdi),%rdi
  4114c1:	ba 40 00 00 00       	mov    $0x40,%edx
  4114c6:	e8 e5 94 ff ff       	callq  40a9b0 <_ZN11__sanitizer16internal_strncpyEPcPKcm>
    name[sizeof(name) - 1] = '\0';
  4114cb:	c6 43 6f 00          	movb   $0x0,0x6f(%rbx)
  }
}
  4114cf:	5b                   	pop    %rbx
  4114d0:	c3                   	retq   
  4114d1:	90                   	nop
  4114d2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4114d9:	1f 84 00 00 00 00 00 

00000000004114e0 <_ZN11__sanitizer17ThreadContextBase7SetDeadEv>:

void ThreadContextBase::SetDead() {
  CHECK(status == ThreadStatusRunning ||
  4114e0:	8b 47 70             	mov    0x70(%rdi),%eax
  4114e3:	83 e8 02             	sub    $0x2,%eax
  4114e6:	83 f8 01             	cmp    $0x1,%eax
  4114e9:	77 17                	ja     411502 <_ZN11__sanitizer17ThreadContextBase7SetDeadEv+0x22>
        status == ThreadStatusFinished);
  status = ThreadStatusDead;
  user_id = 0;
  OnDead();
  4114eb:	48 8b 07             	mov    (%rdi),%rax
}

void ThreadContextBase::SetDead() {
  CHECK(status == ThreadStatusRunning ||
        status == ThreadStatusFinished);
  status = ThreadStatusDead;
  4114ee:	c7 47 70 04 00 00 00 	movl   $0x4,0x70(%rdi)
  user_id = 0;
  4114f5:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
  4114fc:	00 
  OnDead();
  4114fd:	48 8b 00             	mov    (%rax),%rax
  411500:	ff e0                	jmpq   *%rax
    name[sizeof(name) - 1] = '\0';
  }
}

void ThreadContextBase::SetDead() {
  CHECK(status == ThreadStatusRunning ||
  411502:	48 8d 15 c7 6a 00 00 	lea    0x6ac7(%rip),%rdx        # 417fd0 <.LC2>
    internal_strncpy(name, new_name, sizeof(name));
    name[sizeof(name) - 1] = '\0';
  }
}

void ThreadContextBase::SetDead() {
  411509:	50                   	push   %rax
  CHECK(status == ThreadStatusRunning ||
  41150a:	48 8d 3d 47 6a 00 00 	lea    0x6a47(%rip),%rdi        # 417f58 <.LC1>
  411511:	45 31 c0             	xor    %r8d,%r8d
  411514:	31 c9                	xor    %ecx,%ecx
  411516:	be 29 00 00 00       	mov    $0x29,%esi
  41151b:	e8 d0 3e ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

0000000000411520 <_ZN11__sanitizer17ThreadContextBase9SetJoinedEPv>:
  status = ThreadStatusDead;
  user_id = 0;
  OnDead();
}

void ThreadContextBase::SetJoined(void *arg) {
  411520:	48 83 ec 08          	sub    $0x8,%rsp
  // FIXME(dvyukov): print message and continue (it's user error).
  CHECK_EQ(false, detached);
  411524:	80 7f 74 00          	cmpb   $0x0,0x74(%rdi)
  411528:	75 26                	jne    411550 <_ZN11__sanitizer17ThreadContextBase9SetJoinedEPv+0x30>
  CHECK_EQ(ThreadStatusFinished, status);
  41152a:	44 8b 47 70          	mov    0x70(%rdi),%r8d
  41152e:	49 83 f8 03          	cmp    $0x3,%r8
  411532:	75 3c                	jne    411570 <_ZN11__sanitizer17ThreadContextBase9SetJoinedEPv+0x50>
  status = ThreadStatusDead;
  user_id = 0;
  OnJoined(arg);
  411534:	48 8b 07             	mov    (%rdi),%rax

void ThreadContextBase::SetJoined(void *arg) {
  // FIXME(dvyukov): print message and continue (it's user error).
  CHECK_EQ(false, detached);
  CHECK_EQ(ThreadStatusFinished, status);
  status = ThreadStatusDead;
  411537:	c7 47 70 04 00 00 00 	movl   $0x4,0x70(%rdi)
  user_id = 0;
  41153e:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
  411545:	00 
  OnJoined(arg);
  411546:	48 8b 40 08          	mov    0x8(%rax),%rax
}
  41154a:	48 83 c4 08          	add    $0x8,%rsp
  // FIXME(dvyukov): print message and continue (it's user error).
  CHECK_EQ(false, detached);
  CHECK_EQ(ThreadStatusFinished, status);
  status = ThreadStatusDead;
  user_id = 0;
  OnJoined(arg);
  41154e:	ff e0                	jmpq   *%rax
  OnDead();
}

void ThreadContextBase::SetJoined(void *arg) {
  // FIXME(dvyukov): print message and continue (it's user error).
  CHECK_EQ(false, detached);
  411550:	48 8d 15 0d 7b 00 00 	lea    0x7b0d(%rip),%rdx        # 419064 <.LC3>
  411557:	48 8d 3d fa 69 00 00 	lea    0x69fa(%rip),%rdi        # 417f58 <.LC1>
  41155e:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  411564:	31 c9                	xor    %ecx,%ecx
  411566:	be 31 00 00 00       	mov    $0x31,%esi
  41156b:	e8 80 3e ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  CHECK_EQ(ThreadStatusFinished, status);
  411570:	48 8d 15 a9 6a 00 00 	lea    0x6aa9(%rip),%rdx        # 418020 <.LC4>
  411577:	48 8d 3d da 69 00 00 	lea    0x69da(%rip),%rdi        # 417f58 <.LC1>
  41157e:	b9 03 00 00 00       	mov    $0x3,%ecx
  411583:	be 32 00 00 00       	mov    $0x32,%esi
  411588:	e8 63 3e ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  41158d:	90                   	nop
  41158e:	66 90                	xchg   %ax,%ax

0000000000411590 <_ZN11__sanitizer17ThreadContextBase11SetFinishedEv>:
  user_id = 0;
  OnJoined(arg);
}

void ThreadContextBase::SetFinished() {
  if (!detached)
  411590:	80 7f 74 00          	cmpb   $0x0,0x74(%rdi)
  411594:	75 07                	jne    41159d <_ZN11__sanitizer17ThreadContextBase11SetFinishedEv+0xd>
    status = ThreadStatusFinished;
  411596:	c7 47 70 03 00 00 00 	movl   $0x3,0x70(%rdi)
  OnFinished();
  41159d:	48 8b 07             	mov    (%rdi),%rax
  4115a0:	48 8b 40 10          	mov    0x10(%rax),%rax
  4115a4:	ff e0                	jmpq   *%rax
  4115a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4115ad:	00 00 00 

00000000004115b0 <_ZN11__sanitizer17ThreadContextBase10SetStartedEmPv>:
}

void ThreadContextBase::SetStarted(uptr _os_id, void *arg) {
  status = ThreadStatusRunning;
  os_id = _os_id;
  OnStarted(arg);
  4115b0:	48 8b 07             	mov    (%rdi),%rax
  OnFinished();
}

void ThreadContextBase::SetStarted(uptr _os_id, void *arg) {
  status = ThreadStatusRunning;
  os_id = _os_id;
  4115b3:	48 89 77 20          	mov    %rsi,0x20(%rdi)
  OnStarted(arg);
  4115b7:	48 89 d6             	mov    %rdx,%rsi
    status = ThreadStatusFinished;
  OnFinished();
}

void ThreadContextBase::SetStarted(uptr _os_id, void *arg) {
  status = ThreadStatusRunning;
  4115ba:	c7 47 70 02 00 00 00 	movl   $0x2,0x70(%rdi)
  os_id = _os_id;
  OnStarted(arg);
  4115c1:	48 8b 40 18          	mov    0x18(%rax),%rax
  4115c5:	ff e0                	jmpq   *%rax
  4115c7:	90                   	nop
  4115c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4115cf:	00 

00000000004115d0 <_ZN11__sanitizer17ThreadContextBase10SetCreatedEmybjPv>:
  status = ThreadStatusCreated;
  user_id = _user_id;
  unique_id = _unique_id;
  detached = _detached;
  // Parent tid makes no sense for the main thread.
  if (tid != 0)
  4115d0:	8b 47 08             	mov    0x8(%rdi),%eax
  OnStarted(arg);
}

void ThreadContextBase::SetCreated(uptr _user_id, u64 _unique_id,
                                   bool _detached, u32 _parent_tid, void *arg) {
  status = ThreadStatusCreated;
  4115d3:	c7 47 70 01 00 00 00 	movl   $0x1,0x70(%rdi)
  user_id = _user_id;
  4115da:	48 89 77 28          	mov    %rsi,0x28(%rdi)
  unique_id = _unique_id;
  4115de:	48 89 57 10          	mov    %rdx,0x10(%rdi)
  detached = _detached;
  4115e2:	88 4f 74             	mov    %cl,0x74(%rdi)
  // Parent tid makes no sense for the main thread.
  if (tid != 0)
  4115e5:	85 c0                	test   %eax,%eax
  4115e7:	74 04                	je     4115ed <_ZN11__sanitizer17ThreadContextBase10SetCreatedEmybjPv+0x1d>
    parent_tid = _parent_tid;
  4115e9:	44 89 47 78          	mov    %r8d,0x78(%rdi)
  OnCreated(arg);
  4115ed:	48 8b 07             	mov    (%rdi),%rax
  4115f0:	4c 89 ce             	mov    %r9,%rsi
  4115f3:	48 8b 40 20          	mov    0x20(%rax),%rax
  4115f7:	ff e0                	jmpq   *%rax
  4115f9:	90                   	nop
  4115fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000411600 <_ZN11__sanitizer17ThreadContextBase5ResetEv>:
}

void ThreadContextBase::Reset() {
  status = ThreadStatusInvalid;
  SetName(0);
  OnReset();
  411600:	48 8b 07             	mov    (%rdi),%rax
  // ThreadContextBase should never be deleted.
  CHECK(0);
}

void ThreadContextBase::SetName(const char *new_name) {
  name[0] = '\0';
  411603:	c6 47 30 00          	movb   $0x0,0x30(%rdi)
    parent_tid = _parent_tid;
  OnCreated(arg);
}

void ThreadContextBase::Reset() {
  status = ThreadStatusInvalid;
  411607:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%rdi)
  SetName(0);
  OnReset();
  41160e:	48 8b 40 28          	mov    0x28(%rax),%rax
  411612:	ff e0                	jmpq   *%rax
  411614:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  41161b:	00 00 00 00 00 

0000000000411620 <_ZN11__sanitizer14ThreadRegistryC1EPFPNS_17ThreadContextBaseEjEjjj>:

// ThreadRegistry implementation.

const u32 ThreadRegistry::kUnknownTid = ~0U;

ThreadRegistry::ThreadRegistry(ThreadContextFactory factory, u32 max_threads,
  411620:	53                   	push   %rbx
  411621:	48 89 fb             	mov    %rdi,%rbx
      mtx_(),
      n_contexts_(0),
      total_threads_(0),
      alive_threads_(0),
      max_alive_threads_(0),
      running_threads_(0) {
  411624:	48 89 37             	mov    %rsi,(%rdi)
  411627:	89 57 08             	mov    %edx,0x8(%rdi)
  41162a:	89 4f 0c             	mov    %ecx,0xc(%rdi)
  41162d:	48 8d 7f 18          	lea    0x18(%rdi),%rdi
  411631:	44 89 47 f8          	mov    %r8d,-0x8(%rdi)
  411635:	e8 66 a2 ff ff       	callq  40b8a0 <_ZN11__sanitizer13BlockingMutexC1Ev>
  threads_ = (ThreadContextBase **)MmapOrDie(max_threads_ * sizeof(threads_[0]),
                                             "ThreadRegistry");
  41163a:	8b 7b 08             	mov    0x8(%rbx),%edi
  41163d:	48 8d 35 3a 7a 00 00 	lea    0x7a3a(%rip),%rsi        # 41907e <.LC5>
      mtx_(),
      n_contexts_(0),
      total_threads_(0),
      alive_threads_(0),
      max_alive_threads_(0),
      running_threads_(0) {
  411644:	c7 43 70 00 00 00 00 	movl   $0x0,0x70(%rbx)
  41164b:	48 c7 43 78 00 00 00 	movq   $0x0,0x78(%rbx)
  411652:	00 
  411653:	48 c7 83 80 00 00 00 	movq   $0x0,0x80(%rbx)
  41165a:	00 00 00 00 
  41165e:	48 c7 83 88 00 00 00 	movq   $0x0,0x88(%rbx)
  411665:	00 00 00 00 
  411669:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
  411670:	00 00 00 00 
  threads_ = (ThreadContextBase **)MmapOrDie(max_threads_ * sizeof(threads_[0]),
                                             "ThreadRegistry");
  411674:	48 c1 e7 03          	shl    $0x3,%rdi
  411678:	e8 23 ad ff ff       	callq  40c3a0 <_ZN11__sanitizer9MmapOrDieEmPKc>
template<class Item>
struct IntrusiveList {
  friend class Iterator;

  void clear() {
    first_ = last_ = nullptr;
  41167d:	48 c7 83 b0 00 00 00 	movq   $0x0,0xb0(%rbx)
  411684:	00 00 00 00 
  411688:	48 89 83 98 00 00 00 	mov    %rax,0x98(%rbx)
  41168f:	48 c7 83 a8 00 00 00 	movq   $0x0,0xa8(%rbx)
  411696:	00 00 00 00 
    size_ = 0;
  41169a:	48 c7 83 a0 00 00 00 	movq   $0x0,0xa0(%rbx)
  4116a1:	00 00 00 00 
template<class Item>
struct IntrusiveList {
  friend class Iterator;

  void clear() {
    first_ = last_ = nullptr;
  4116a5:	48 c7 83 c8 00 00 00 	movq   $0x0,0xc8(%rbx)
  4116ac:	00 00 00 00 
  4116b0:	48 c7 83 c0 00 00 00 	movq   $0x0,0xc0(%rbx)
  4116b7:	00 00 00 00 
    size_ = 0;
  4116bb:	48 c7 83 b8 00 00 00 	movq   $0x0,0xb8(%rbx)
  4116c2:	00 00 00 00 
  dead_threads_.clear();
  invalid_threads_.clear();
}
  4116c6:	5b                   	pop    %rbx
  4116c7:	c3                   	retq   
  4116c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4116cf:	00 

00000000004116d0 <_ZN11__sanitizer14ThreadRegistry18GetNumberOfThreadsEPmS1_S1_>:

void ThreadRegistry::GetNumberOfThreads(uptr *total, uptr *running,
                                        uptr *alive) {
  4116d0:	41 56                	push   %r14
  4116d2:	49 89 d6             	mov    %rdx,%r14
  4116d5:	41 55                	push   %r13
  4116d7:	49 89 f5             	mov    %rsi,%r13
  4116da:	41 54                	push   %r12
  4116dc:	49 89 cc             	mov    %rcx,%r12
  4116df:	55                   	push   %rbp
  BlockingMutexLock l(&mtx_);
  4116e0:	48 8d 6f 18          	lea    0x18(%rdi),%rbp
  dead_threads_.clear();
  invalid_threads_.clear();
}

void ThreadRegistry::GetNumberOfThreads(uptr *total, uptr *running,
                                        uptr *alive) {
  4116e4:	53                   	push   %rbx
  4116e5:	48 89 fb             	mov    %rdi,%rbx
template<typename MutexType>
class GenericScopedLock {
 public:
  explicit GenericScopedLock(MutexType *mu)
      : mu_(mu) {
    mu_->Lock();
  4116e8:	48 89 ef             	mov    %rbp,%rdi
  4116eb:	e8 c0 a1 ff ff       	callq  40b8b0 <_ZN11__sanitizer13BlockingMutex4LockEv>
  BlockingMutexLock l(&mtx_);
  if (total) *total = n_contexts_;
  4116f0:	4d 85 ed             	test   %r13,%r13
  4116f3:	74 07                	je     4116fc <_ZN11__sanitizer14ThreadRegistry18GetNumberOfThreadsEPmS1_S1_+0x2c>
  4116f5:	8b 43 70             	mov    0x70(%rbx),%eax
  4116f8:	49 89 45 00          	mov    %rax,0x0(%r13)
  if (running) *running = running_threads_;
  4116fc:	4d 85 f6             	test   %r14,%r14
  4116ff:	74 0a                	je     41170b <_ZN11__sanitizer14ThreadRegistry18GetNumberOfThreadsEPmS1_S1_+0x3b>
  411701:	48 8b 83 90 00 00 00 	mov    0x90(%rbx),%rax
  411708:	49 89 06             	mov    %rax,(%r14)
  if (alive) *alive = alive_threads_;
  41170b:	4d 85 e4             	test   %r12,%r12
  41170e:	74 0b                	je     41171b <_ZN11__sanitizer14ThreadRegistry18GetNumberOfThreadsEPmS1_S1_+0x4b>
  411710:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
  411717:	49 89 04 24          	mov    %rax,(%r12)
}
  41171b:	5b                   	pop    %rbx
  }

  ~GenericScopedLock() {
    mu_->Unlock();
  41171c:	48 89 ef             	mov    %rbp,%rdi
  41171f:	5d                   	pop    %rbp
  411720:	41 5c                	pop    %r12
  411722:	41 5d                	pop    %r13
  411724:	41 5e                	pop    %r14
  411726:	e9 f5 a1 ff ff       	jmpq   40b920 <_ZN11__sanitizer13BlockingMutex6UnlockEv>
  41172b:	90                   	nop
  41172c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000411730 <_ZN11__sanitizer14ThreadRegistry18GetMaxAliveThreadsEv>:

uptr ThreadRegistry::GetMaxAliveThreads() {
  411730:	55                   	push   %rbp
  411731:	48 89 fd             	mov    %rdi,%rbp
  411734:	53                   	push   %rbx
  BlockingMutexLock l(&mtx_);
  411735:	48 8d 5f 18          	lea    0x18(%rdi),%rbx
  if (total) *total = n_contexts_;
  if (running) *running = running_threads_;
  if (alive) *alive = alive_threads_;
}

uptr ThreadRegistry::GetMaxAliveThreads() {
  411739:	48 83 ec 08          	sub    $0x8,%rsp
template<typename MutexType>
class GenericScopedLock {
 public:
  explicit GenericScopedLock(MutexType *mu)
      : mu_(mu) {
    mu_->Lock();
  41173d:	48 89 df             	mov    %rbx,%rdi
  411740:	e8 6b a1 ff ff       	callq  40b8b0 <_ZN11__sanitizer13BlockingMutex4LockEv>
  BlockingMutexLock l(&mtx_);
  return max_alive_threads_;
  411745:	48 8b ad 88 00 00 00 	mov    0x88(%rbp),%rbp
  }

  ~GenericScopedLock() {
    mu_->Unlock();
  41174c:	48 89 df             	mov    %rbx,%rdi
  41174f:	e8 cc a1 ff ff       	callq  40b920 <_ZN11__sanitizer13BlockingMutex6UnlockEv>
}
  411754:	48 83 c4 08          	add    $0x8,%rsp
  411758:	5b                   	pop    %rbx
  411759:	48 89 e8             	mov    %rbp,%rax
  41175c:	5d                   	pop    %rbp
  41175d:	c3                   	retq   
  41175e:	66 90                	xchg   %ax,%ax

0000000000411760 <_ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv>:

u32 ThreadRegistry::CreateThread(uptr user_id, bool detached, u32 parent_tid,
                                 void *arg) {
  411760:	41 57                	push   %r15
  411762:	41 89 cf             	mov    %ecx,%r15d
  411765:	41 56                	push   %r14
  411767:	41 89 d6             	mov    %edx,%r14d
  41176a:	41 55                	push   %r13
  41176c:	49 89 f5             	mov    %rsi,%r13
  41176f:	41 54                	push   %r12
  BlockingMutexLock l(&mtx_);
  411771:	4c 8d 67 18          	lea    0x18(%rdi),%r12
  BlockingMutexLock l(&mtx_);
  return max_alive_threads_;
}

u32 ThreadRegistry::CreateThread(uptr user_id, bool detached, u32 parent_tid,
                                 void *arg) {
  411775:	55                   	push   %rbp
  411776:	53                   	push   %rbx
  411777:	48 89 fb             	mov    %rdi,%rbx
template<typename MutexType>
class GenericScopedLock {
 public:
  explicit GenericScopedLock(MutexType *mu)
      : mu_(mu) {
    mu_->Lock();
  41177a:	4c 89 e7             	mov    %r12,%rdi
  41177d:	48 83 ec 18          	sub    $0x18,%rsp
  411781:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  411786:	e8 25 a1 ff ff       	callq  40b8b0 <_ZN11__sanitizer13BlockingMutex4LockEv>
    return;
  invalid_threads_.push_back(tctx);
}

ThreadContextBase *ThreadRegistry::QuarantinePop() {
  if (invalid_threads_.size() == 0)
  41178b:	48 8b 83 b8 00 00 00 	mov    0xb8(%rbx),%rax
  411792:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
  411797:	48 85 c0             	test   %rax,%rax
  41179a:	0f 85 00 01 00 00    	jne    4118a0 <_ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv+0x140>
  BlockingMutexLock l(&mtx_);
  u32 tid = kUnknownTid;
  ThreadContextBase *tctx = QuarantinePop();
  if (tctx) {
    tid = tctx->tid;
  } else if (n_contexts_ < max_threads_) {
  4117a0:	8b 6b 70             	mov    0x70(%rbx),%ebp
  4117a3:	8b 53 08             	mov    0x8(%rbx),%edx
  4117a6:	39 d5                	cmp    %edx,%ebp
  4117a8:	0f 83 9d 01 00 00    	jae    41194b <_ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv+0x1eb>
    // Allocate new thread context and tid.
    tid = n_contexts_++;
  4117ae:	8d 45 01             	lea    0x1(%rbp),%eax
  4117b1:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
    tctx = context_factory_(tid);
  4117b6:	89 ef                	mov    %ebp,%edi
  ThreadContextBase *tctx = QuarantinePop();
  if (tctx) {
    tid = tctx->tid;
  } else if (n_contexts_ < max_threads_) {
    // Allocate new thread context and tid.
    tid = n_contexts_++;
  4117b8:	89 43 70             	mov    %eax,0x70(%rbx)
    tctx = context_factory_(tid);
  4117bb:	ff 13                	callq  *(%rbx)
  4117bd:	48 89 c7             	mov    %rax,%rdi
    threads_[tid] = tctx;
  4117c0:	48 8b 83 98 00 00 00 	mov    0x98(%rbx),%rax
  4117c7:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
  4117cc:	89 ea                	mov    %ebp,%edx
  4117ce:	48 89 3c d0          	mov    %rdi,(%rax,%rdx,8)
    Printf("race: limit on %u simultaneously alive goroutines is exceeded,"
        " dying\n", max_threads_);
#endif
    Die();
  }
  CHECK_NE(tctx, 0);
  4117d2:	48 85 ff             	test   %rdi,%rdi
  4117d5:	0f 84 38 01 00 00    	je     411913 <_ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv+0x1b3>
  CHECK_NE(tid, kUnknownTid);
  4117db:	83 fd ff             	cmp    $0xffffffff,%ebp
  4117de:	89 e9                	mov    %ebp,%ecx
  4117e0:	0f 84 12 01 00 00    	je     4118f8 <_ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv+0x198>
  CHECK_LT(tid, max_threads_);
  4117e6:	8b 43 08             	mov    0x8(%rbx),%eax
  4117e9:	48 39 c1             	cmp    %rax,%rcx
  4117ec:	0f 83 eb 00 00 00    	jae    4118dd <_ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv+0x17d>
  CHECK_EQ(tctx->status, ThreadStatusInvalid);
  4117f2:	8b 4f 70             	mov    0x70(%rdi),%ecx
  4117f5:	48 85 c9             	test   %rcx,%rcx
  4117f8:	0f 85 32 01 00 00    	jne    411930 <_ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv+0x1d0>
  alive_threads_++;
  4117fe:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
  411805:	48 8d 48 01          	lea    0x1(%rax),%rcx
  if (max_alive_threads_ < alive_threads_) {
  411809:	48 8b 83 88 00 00 00 	mov    0x88(%rbx),%rax
  }
  CHECK_NE(tctx, 0);
  CHECK_NE(tid, kUnknownTid);
  CHECK_LT(tid, max_threads_);
  CHECK_EQ(tctx->status, ThreadStatusInvalid);
  alive_threads_++;
  411810:	48 89 8b 80 00 00 00 	mov    %rcx,0x80(%rbx)
  if (max_alive_threads_ < alive_threads_) {
  411817:	48 39 c1             	cmp    %rax,%rcx
  41181a:	77 54                	ja     411870 <_ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv+0x110>
    max_alive_threads_++;
    CHECK_EQ(alive_threads_, max_alive_threads_);
  }
  tctx->SetCreated(user_id, total_threads_++, detached,
                   parent_tid, arg);
  41181c:	48 8b 43 78          	mov    0x78(%rbx),%rax
  411820:	48 8d 50 01          	lea    0x1(%rax),%rdx
  411824:	48 89 53 78          	mov    %rdx,0x78(%rbx)

void ThreadContextBase::SetCreated(uptr _user_id, u64 _unique_id,
                                   bool _detached, u32 _parent_tid, void *arg) {
  status = ThreadStatusCreated;
  user_id = _user_id;
  unique_id = _unique_id;
  411828:	48 89 47 10          	mov    %rax,0x10(%rdi)
  detached = _detached;
  // Parent tid makes no sense for the main thread.
  if (tid != 0)
  41182c:	8b 47 08             	mov    0x8(%rdi),%eax
  OnStarted(arg);
}

void ThreadContextBase::SetCreated(uptr _user_id, u64 _unique_id,
                                   bool _detached, u32 _parent_tid, void *arg) {
  status = ThreadStatusCreated;
  41182f:	c7 47 70 01 00 00 00 	movl   $0x1,0x70(%rdi)
  user_id = _user_id;
  411836:	4c 89 6f 28          	mov    %r13,0x28(%rdi)
  unique_id = _unique_id;
  detached = _detached;
  41183a:	44 88 77 74          	mov    %r14b,0x74(%rdi)
  // Parent tid makes no sense for the main thread.
  if (tid != 0)
  41183e:	85 c0                	test   %eax,%eax
  411840:	74 04                	je     411846 <_ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv+0xe6>
    parent_tid = _parent_tid;
  411842:	44 89 7f 78          	mov    %r15d,0x78(%rdi)
  OnCreated(arg);
  411846:	48 8b 07             	mov    (%rdi),%rax
  411849:	4c 89 c6             	mov    %r8,%rsi
  41184c:	ff 50 20             	callq  *0x20(%rax)
  }

  ~GenericScopedLock() {
    mu_->Unlock();
  41184f:	4c 89 e7             	mov    %r12,%rdi
  411852:	e8 c9 a0 ff ff       	callq  40b920 <_ZN11__sanitizer13BlockingMutex6UnlockEv>
    CHECK_EQ(alive_threads_, max_alive_threads_);
  }
  tctx->SetCreated(user_id, total_threads_++, detached,
                   parent_tid, arg);
  return tid;
}
  411857:	48 83 c4 18          	add    $0x18,%rsp
  41185b:	89 e8                	mov    %ebp,%eax
  41185d:	5b                   	pop    %rbx
  41185e:	5d                   	pop    %rbp
  41185f:	41 5c                	pop    %r12
  411861:	41 5d                	pop    %r13
  411863:	41 5e                	pop    %r14
  411865:	41 5f                	pop    %r15
  411867:	c3                   	retq   
  411868:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  41186f:	00 
  CHECK_NE(tid, kUnknownTid);
  CHECK_LT(tid, max_threads_);
  CHECK_EQ(tctx->status, ThreadStatusInvalid);
  alive_threads_++;
  if (max_alive_threads_ < alive_threads_) {
    max_alive_threads_++;
  411870:	48 83 c0 01          	add    $0x1,%rax
    CHECK_EQ(alive_threads_, max_alive_threads_);
  411874:	48 39 c1             	cmp    %rax,%rcx
  CHECK_NE(tid, kUnknownTid);
  CHECK_LT(tid, max_threads_);
  CHECK_EQ(tctx->status, ThreadStatusInvalid);
  alive_threads_++;
  if (max_alive_threads_ < alive_threads_) {
    max_alive_threads_++;
  411877:	48 89 83 88 00 00 00 	mov    %rax,0x88(%rbx)
    CHECK_EQ(alive_threads_, max_alive_threads_);
  41187e:	74 9c                	je     41181c <_ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv+0xbc>
  411880:	48 8d 15 21 68 00 00 	lea    0x6821(%rip),%rdx        # 4180a8 <.LC11>
  411887:	48 8d 3d ca 66 00 00 	lea    0x66ca(%rip),%rdi        # 417f58 <.LC1>
  41188e:	49 89 c0             	mov    %rax,%r8
  411891:	be 96 00 00 00       	mov    $0x96,%esi
  411896:	e8 55 3b ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  41189b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    return;
  invalid_threads_.push_back(tctx);
}

ThreadContextBase *ThreadRegistry::QuarantinePop() {
  if (invalid_threads_.size() == 0)
  4118a0:	48 8b bb c0 00 00 00 	mov    0xc0(%rbx),%rdi
    }
  }

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
  4118a7:	48 8b 97 80 00 00 00 	mov    0x80(%rdi),%rdx
    if (!first_)
  4118ae:	48 85 d2             	test   %rdx,%rdx
    }
  }

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
  4118b1:	48 89 93 c0 00 00 00 	mov    %rdx,0xc0(%rbx)
    if (!first_)
  4118b8:	74 16                	je     4118d0 <_ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv+0x170>
      last_ = nullptr;
    size_--;
  4118ba:	48 83 e8 01          	sub    $0x1,%rax
                                 void *arg) {
  BlockingMutexLock l(&mtx_);
  u32 tid = kUnknownTid;
  ThreadContextBase *tctx = QuarantinePop();
  if (tctx) {
    tid = tctx->tid;
  4118be:	8b 6f 08             	mov    0x8(%rdi),%ebp
  4118c1:	48 89 83 b8 00 00 00 	mov    %rax,0xb8(%rbx)
  4118c8:	e9 05 ff ff ff       	jmpq   4117d2 <_ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv+0x72>
  4118cd:	0f 1f 00             	nopl   (%rax)

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
    if (!first_)
      last_ = nullptr;
  4118d0:	48 c7 83 c8 00 00 00 	movq   $0x0,0xc8(%rbx)
  4118d7:	00 00 00 00 
  4118db:	eb dd                	jmp    4118ba <_ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv+0x15a>
#endif
    Die();
  }
  CHECK_NE(tctx, 0);
  CHECK_NE(tid, kUnknownTid);
  CHECK_LT(tid, max_threads_);
  4118dd:	48 8d 15 d6 77 00 00 	lea    0x77d6(%rip),%rdx        # 4190ba <.LC9>
  4118e4:	48 8d 3d 6d 66 00 00 	lea    0x666d(%rip),%rdi        # 417f58 <.LC1>
  4118eb:	49 89 c0             	mov    %rax,%r8
  4118ee:	be 91 00 00 00       	mov    $0x91,%esi
  4118f3:	e8 f8 3a ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
        " dying\n", max_threads_);
#endif
    Die();
  }
  CHECK_NE(tctx, 0);
  CHECK_NE(tid, kUnknownTid);
  4118f8:	48 8d 15 a0 77 00 00 	lea    0x77a0(%rip),%rdx        # 41909f <.LC8>
  4118ff:	48 8d 3d 52 66 00 00 	lea    0x6652(%rip),%rdi        # 417f58 <.LC1>
  411906:	49 89 c8             	mov    %rcx,%r8
  411909:	be 90 00 00 00       	mov    $0x90,%esi
  41190e:	e8 dd 3a ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    Printf("race: limit on %u simultaneously alive goroutines is exceeded,"
        " dying\n", max_threads_);
#endif
    Die();
  }
  CHECK_NE(tctx, 0);
  411913:	48 8d 15 73 77 00 00 	lea    0x7773(%rip),%rdx        # 41908d <.LC7>
  41191a:	48 8d 3d 37 66 00 00 	lea    0x6637(%rip),%rdi        # 417f58 <.LC1>
  411921:	45 31 c0             	xor    %r8d,%r8d
  411924:	31 c9                	xor    %ecx,%ecx
  411926:	be 8f 00 00 00       	mov    $0x8f,%esi
  41192b:	e8 c0 3a ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  CHECK_NE(tid, kUnknownTid);
  CHECK_LT(tid, max_threads_);
  CHECK_EQ(tctx->status, ThreadStatusInvalid);
  411930:	48 8d 15 41 67 00 00 	lea    0x6741(%rip),%rdx        # 418078 <.LC10>
  411937:	48 8d 3d 1a 66 00 00 	lea    0x661a(%rip),%rdi        # 417f58 <.LC1>
  41193e:	45 31 c0             	xor    %r8d,%r8d
  411941:	be 92 00 00 00       	mov    $0x92,%esi
  411946:	e8 a5 3a ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    tctx = context_factory_(tid);
    threads_[tid] = tctx;
  } else {
#ifndef SANITIZER_GO
    Report("%s: Thread limit (%u threads) exceeded. Dying.\n",
           SanitizerToolName, max_threads_);
  41194b:	48 8b 05 5e c9 00 00 	mov    0xc95e(%rip),%rax        # 41e2b0 <_DYNAMIC+0x2b0>
  411952:	48 8d 3d ef 66 00 00 	lea    0x66ef(%rip),%rdi        # 418048 <.LC6>
  411959:	48 8b 30             	mov    (%rax),%rsi
  41195c:	31 c0                	xor    %eax,%eax
  41195e:	e8 2d c1 ff ff       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
#else
    Printf("race: limit on %u simultaneously alive goroutines is exceeded,"
        " dying\n", max_threads_);
#endif
    Die();
  411963:	e8 f8 38 ff ff       	callq  405260 <_ZN11__sanitizer3DieEv>
  411968:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  41196f:	00 

0000000000411970 <_ZN11__sanitizer14ThreadRegistry30RunCallbackForEachThreadLockedEPFvPNS_17ThreadContextBaseEPvES3_>:
                   parent_tid, arg);
  return tid;
}

void ThreadRegistry::RunCallbackForEachThreadLocked(ThreadCallback cb,
                                                    void *arg) {
  411970:	41 55                	push   %r13
  411972:	49 89 fd             	mov    %rdi,%r13
  void GetNumberOfThreads(uptr *total = nullptr, uptr *running = nullptr,
                          uptr *alive = nullptr);
  uptr GetMaxAliveThreads();

  void Lock() { mtx_.Lock(); }
  void CheckLocked() { mtx_.CheckLocked(); }
  411975:	48 8d 7f 18          	lea    0x18(%rdi),%rdi
  411979:	41 54                	push   %r12
  41197b:	49 89 f4             	mov    %rsi,%r12
  41197e:	55                   	push   %rbp
  41197f:	48 89 d5             	mov    %rdx,%rbp
  411982:	53                   	push   %rbx
  CheckLocked();
  for (u32 tid = 0; tid < n_contexts_; tid++) {
  411983:	31 db                	xor    %ebx,%ebx
                   parent_tid, arg);
  return tid;
}

void ThreadRegistry::RunCallbackForEachThreadLocked(ThreadCallback cb,
                                                    void *arg) {
  411985:	48 83 ec 08          	sub    $0x8,%rsp
  411989:	e8 e2 9f ff ff       	callq  40b970 <_ZN11__sanitizer13BlockingMutex11CheckLockedEv>
  CheckLocked();
  for (u32 tid = 0; tid < n_contexts_; tid++) {
  41198e:	41 8b 55 70          	mov    0x70(%r13),%edx
  411992:	85 d2                	test   %edx,%edx
  411994:	74 2d                	je     4119c3 <_ZN11__sanitizer14ThreadRegistry30RunCallbackForEachThreadLockedEPFvPNS_17ThreadContextBaseEPvES3_+0x53>
  411996:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  41199d:	00 00 00 
    ThreadContextBase *tctx = threads_[tid];
  4119a0:	49 8b 85 98 00 00 00 	mov    0x98(%r13),%rax
  4119a7:	89 d9                	mov    %ebx,%ecx
  4119a9:	48 8b 3c c8          	mov    (%rax,%rcx,8),%rdi
    if (tctx == 0)
  4119ad:	48 85 ff             	test   %rdi,%rdi
  4119b0:	74 0a                	je     4119bc <_ZN11__sanitizer14ThreadRegistry30RunCallbackForEachThreadLockedEPFvPNS_17ThreadContextBaseEPvES3_+0x4c>
      continue;
    cb(tctx, arg);
  4119b2:	48 89 ee             	mov    %rbp,%rsi
  4119b5:	41 ff d4             	callq  *%r12
  4119b8:	41 8b 55 70          	mov    0x70(%r13),%edx
}

void ThreadRegistry::RunCallbackForEachThreadLocked(ThreadCallback cb,
                                                    void *arg) {
  CheckLocked();
  for (u32 tid = 0; tid < n_contexts_; tid++) {
  4119bc:	83 c3 01             	add    $0x1,%ebx
  4119bf:	39 d3                	cmp    %edx,%ebx
  4119c1:	72 dd                	jb     4119a0 <_ZN11__sanitizer14ThreadRegistry30RunCallbackForEachThreadLockedEPFvPNS_17ThreadContextBaseEPvES3_+0x30>
    ThreadContextBase *tctx = threads_[tid];
    if (tctx == 0)
      continue;
    cb(tctx, arg);
  }
}
  4119c3:	48 83 c4 08          	add    $0x8,%rsp
  4119c7:	5b                   	pop    %rbx
  4119c8:	5d                   	pop    %rbp
  4119c9:	41 5c                	pop    %r12
  4119cb:	41 5d                	pop    %r13
  4119cd:	c3                   	retq   
  4119ce:	66 90                	xchg   %ax,%ax

00000000004119d0 <_ZN11__sanitizer14ThreadRegistry10FindThreadEPFbPNS_17ThreadContextBaseEPvES3_>:

u32 ThreadRegistry::FindThread(FindThreadCallback cb, void *arg) {
  4119d0:	41 57                	push   %r15
  4119d2:	49 89 ff             	mov    %rdi,%r15
  4119d5:	41 56                	push   %r14
  BlockingMutexLock l(&mtx_);
  4119d7:	4c 8d 77 18          	lea    0x18(%rdi),%r14
      continue;
    cb(tctx, arg);
  }
}

u32 ThreadRegistry::FindThread(FindThreadCallback cb, void *arg) {
  4119db:	41 55                	push   %r13
template<typename MutexType>
class GenericScopedLock {
 public:
  explicit GenericScopedLock(MutexType *mu)
      : mu_(mu) {
    mu_->Lock();
  4119dd:	4c 89 f7             	mov    %r14,%rdi
  4119e0:	49 89 d5             	mov    %rdx,%r13
  4119e3:	41 54                	push   %r12
  4119e5:	49 89 f4             	mov    %rsi,%r12
  4119e8:	55                   	push   %rbp
  4119e9:	53                   	push   %rbx
  4119ea:	48 83 ec 08          	sub    $0x8,%rsp
  4119ee:	e8 bd 9e ff ff       	callq  40b8b0 <_ZN11__sanitizer13BlockingMutex4LockEv>
  BlockingMutexLock l(&mtx_);
  for (u32 tid = 0; tid < n_contexts_; tid++) {
  4119f3:	41 8b 4f 70          	mov    0x70(%r15),%ecx
  4119f7:	85 c9                	test   %ecx,%ecx
  4119f9:	74 55                	je     411a50 <_ZN11__sanitizer14ThreadRegistry10FindThreadEPFbPNS_17ThreadContextBaseEPvES3_+0x80>
  4119fb:	31 db                	xor    %ebx,%ebx
  4119fd:	eb 0c                	jmp    411a0b <_ZN11__sanitizer14ThreadRegistry10FindThreadEPFbPNS_17ThreadContextBaseEPvES3_+0x3b>
  4119ff:	90                   	nop
  411a00:	41 8b 4f 70          	mov    0x70(%r15),%ecx
  411a04:	83 c3 01             	add    $0x1,%ebx
  411a07:	39 cb                	cmp    %ecx,%ebx
  411a09:	73 45                	jae    411a50 <_ZN11__sanitizer14ThreadRegistry10FindThreadEPFbPNS_17ThreadContextBaseEPvES3_+0x80>
    ThreadContextBase *tctx = threads_[tid];
  411a0b:	49 8b 87 98 00 00 00 	mov    0x98(%r15),%rax
  411a12:	89 da                	mov    %ebx,%edx
  411a14:	48 8b 2c d0          	mov    (%rax,%rdx,8),%rbp
    if (tctx != 0 && cb(tctx, arg))
  411a18:	48 85 ed             	test   %rbp,%rbp
  411a1b:	74 e7                	je     411a04 <_ZN11__sanitizer14ThreadRegistry10FindThreadEPFbPNS_17ThreadContextBaseEPvES3_+0x34>
  411a1d:	4c 89 ee             	mov    %r13,%rsi
  411a20:	48 89 ef             	mov    %rbp,%rdi
  411a23:	41 ff d4             	callq  *%r12
  411a26:	84 c0                	test   %al,%al
  411a28:	74 d6                	je     411a00 <_ZN11__sanitizer14ThreadRegistry10FindThreadEPFbPNS_17ThreadContextBaseEPvES3_+0x30>
      return tctx->tid;
  411a2a:	8b 5d 08             	mov    0x8(%rbp),%ebx
  }

  ~GenericScopedLock() {
    mu_->Unlock();
  411a2d:	4c 89 f7             	mov    %r14,%rdi
  411a30:	e8 eb 9e ff ff       	callq  40b920 <_ZN11__sanitizer13BlockingMutex6UnlockEv>
  }
  return kUnknownTid;
}
  411a35:	48 83 c4 08          	add    $0x8,%rsp
  411a39:	89 d8                	mov    %ebx,%eax
  411a3b:	5b                   	pop    %rbx
  411a3c:	5d                   	pop    %rbp
  411a3d:	41 5c                	pop    %r12
  411a3f:	41 5d                	pop    %r13
  411a41:	41 5e                	pop    %r14
  411a43:	41 5f                	pop    %r15
  411a45:	c3                   	retq   
  411a46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  411a4d:	00 00 00 
  for (u32 tid = 0; tid < n_contexts_; tid++) {
    ThreadContextBase *tctx = threads_[tid];
    if (tctx != 0 && cb(tctx, arg))
      return tctx->tid;
  }
  return kUnknownTid;
  411a50:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  411a55:	eb d6                	jmp    411a2d <_ZN11__sanitizer14ThreadRegistry10FindThreadEPFbPNS_17ThreadContextBaseEPvES3_+0x5d>
  411a57:	90                   	nop
  411a58:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  411a5f:	00 

0000000000411a60 <_ZN11__sanitizer14ThreadRegistry23FindThreadContextLockedEPFbPNS_17ThreadContextBaseEPvES3_>:
}

ThreadContextBase *
ThreadRegistry::FindThreadContextLocked(FindThreadCallback cb, void *arg) {
  411a60:	41 56                	push   %r14
  411a62:	49 89 fe             	mov    %rdi,%r14
  411a65:	48 8d 7f 18          	lea    0x18(%rdi),%rdi
  411a69:	41 55                	push   %r13
  411a6b:	49 89 f5             	mov    %rsi,%r13
  411a6e:	41 54                	push   %r12
  411a70:	49 89 d4             	mov    %rdx,%r12
  411a73:	55                   	push   %rbp
  411a74:	53                   	push   %rbx
  CheckLocked();
  for (u32 tid = 0; tid < n_contexts_; tid++) {
  411a75:	31 db                	xor    %ebx,%ebx
  411a77:	e8 f4 9e ff ff       	callq  40b970 <_ZN11__sanitizer13BlockingMutex11CheckLockedEv>
  411a7c:	41 8b 56 70          	mov    0x70(%r14),%edx
  411a80:	85 d2                	test   %edx,%edx
  411a82:	75 17                	jne    411a9b <_ZN11__sanitizer14ThreadRegistry23FindThreadContextLockedEPFbPNS_17ThreadContextBaseEPvES3_+0x3b>
  411a84:	eb 4a                	jmp    411ad0 <_ZN11__sanitizer14ThreadRegistry23FindThreadContextLockedEPFbPNS_17ThreadContextBaseEPvES3_+0x70>
  411a86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  411a8d:	00 00 00 
  411a90:	41 8b 56 70          	mov    0x70(%r14),%edx
  411a94:	83 c3 01             	add    $0x1,%ebx
  411a97:	39 d3                	cmp    %edx,%ebx
  411a99:	73 35                	jae    411ad0 <_ZN11__sanitizer14ThreadRegistry23FindThreadContextLockedEPFbPNS_17ThreadContextBaseEPvES3_+0x70>
    ThreadContextBase *tctx = threads_[tid];
  411a9b:	49 8b 86 98 00 00 00 	mov    0x98(%r14),%rax
  411aa2:	89 d9                	mov    %ebx,%ecx
  411aa4:	48 8b 2c c8          	mov    (%rax,%rcx,8),%rbp
    if (tctx != 0 && cb(tctx, arg))
  411aa8:	48 85 ed             	test   %rbp,%rbp
  411aab:	74 e7                	je     411a94 <_ZN11__sanitizer14ThreadRegistry23FindThreadContextLockedEPFbPNS_17ThreadContextBaseEPvES3_+0x34>
  411aad:	4c 89 e6             	mov    %r12,%rsi
  411ab0:	48 89 ef             	mov    %rbp,%rdi
  411ab3:	41 ff d5             	callq  *%r13
  411ab6:	84 c0                	test   %al,%al
  411ab8:	74 d6                	je     411a90 <_ZN11__sanitizer14ThreadRegistry23FindThreadContextLockedEPFbPNS_17ThreadContextBaseEPvES3_+0x30>
      return tctx;
  }
  return 0;
}
  411aba:	5b                   	pop    %rbx

ThreadContextBase *
ThreadRegistry::FindThreadContextLocked(FindThreadCallback cb, void *arg) {
  CheckLocked();
  for (u32 tid = 0; tid < n_contexts_; tid++) {
    ThreadContextBase *tctx = threads_[tid];
  411abb:	48 89 e8             	mov    %rbp,%rax
    if (tctx != 0 && cb(tctx, arg))
      return tctx;
  }
  return 0;
}
  411abe:	5d                   	pop    %rbp
  411abf:	41 5c                	pop    %r12
  411ac1:	41 5d                	pop    %r13
  411ac3:	41 5e                	pop    %r14
  411ac5:	c3                   	retq   
  411ac6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  411acd:	00 00 00 
  411ad0:	5b                   	pop    %rbx
  411ad1:	5d                   	pop    %rbp
  411ad2:	41 5c                	pop    %r12
  411ad4:	41 5d                	pop    %r13
  for (u32 tid = 0; tid < n_contexts_; tid++) {
    ThreadContextBase *tctx = threads_[tid];
    if (tctx != 0 && cb(tctx, arg))
      return tctx;
  }
  return 0;
  411ad6:	31 c0                	xor    %eax,%eax
}
  411ad8:	41 5e                	pop    %r14
  411ada:	c3                   	retq   
  411adb:	90                   	nop
  411adc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000411ae0 <_ZN11__sanitizer14ThreadRegistry29FindThreadContextByOsIDLockedEm>:
                                            void *arg) {
  return (tctx->os_id == (uptr)arg && tctx->status != ThreadStatusInvalid &&
      tctx->status != ThreadStatusDead);
}

ThreadContextBase *ThreadRegistry::FindThreadContextByOsIDLocked(uptr os_id) {
  411ae0:	55                   	push   %rbp
  411ae1:	48 89 fd             	mov    %rdi,%rbp
  411ae4:	48 8d 7f 18          	lea    0x18(%rdi),%rdi
  411ae8:	53                   	push   %rbx
  411ae9:	48 89 f3             	mov    %rsi,%rbx
  411aec:	48 83 ec 08          	sub    $0x8,%rsp
  411af0:	e8 7b 9e ff ff       	callq  40b970 <_ZN11__sanitizer13BlockingMutex11CheckLockedEv>
}

ThreadContextBase *
ThreadRegistry::FindThreadContextLocked(FindThreadCallback cb, void *arg) {
  CheckLocked();
  for (u32 tid = 0; tid < n_contexts_; tid++) {
  411af5:	8b 4d 70             	mov    0x70(%rbp),%ecx
  411af8:	85 c9                	test   %ecx,%ecx
  411afa:	74 44                	je     411b40 <_ZN11__sanitizer14ThreadRegistry29FindThreadContextByOsIDLockedEm+0x60>
  411afc:	48 8b bd 98 00 00 00 	mov    0x98(%rbp),%rdi
  411b03:	31 d2                	xor    %edx,%edx
  411b05:	eb 11                	jmp    411b18 <_ZN11__sanitizer14ThreadRegistry29FindThreadContextByOsIDLockedEm+0x38>
  411b07:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  411b0e:	00 00 
  411b10:	48 83 c2 01          	add    $0x1,%rdx
  411b14:	39 d1                	cmp    %edx,%ecx
  411b16:	76 28                	jbe    411b40 <_ZN11__sanitizer14ThreadRegistry29FindThreadContextByOsIDLockedEm+0x60>
    ThreadContextBase *tctx = threads_[tid];
  411b18:	48 8b 04 d7          	mov    (%rdi,%rdx,8),%rax
    if (tctx != 0 && cb(tctx, arg))
  411b1c:	48 85 c0             	test   %rax,%rax
  411b1f:	74 ef                	je     411b10 <_ZN11__sanitizer14ThreadRegistry29FindThreadContextByOsIDLockedEm+0x30>
  return 0;
}

static bool FindThreadContextByOsIdCallback(ThreadContextBase *tctx,
                                            void *arg) {
  return (tctx->os_id == (uptr)arg && tctx->status != ThreadStatusInvalid &&
  411b21:	48 3b 58 20          	cmp    0x20(%rax),%rbx
  411b25:	75 e9                	jne    411b10 <_ZN11__sanitizer14ThreadRegistry29FindThreadContextByOsIDLockedEm+0x30>
  411b27:	f7 40 70 fb ff ff ff 	testl  $0xfffffffb,0x70(%rax)
  411b2e:	74 e0                	je     411b10 <_ZN11__sanitizer14ThreadRegistry29FindThreadContextByOsIDLockedEm+0x30>
}

ThreadContextBase *ThreadRegistry::FindThreadContextByOsIDLocked(uptr os_id) {
  return FindThreadContextLocked(FindThreadContextByOsIdCallback,
                                 (void *)os_id);
}
  411b30:	48 83 c4 08          	add    $0x8,%rsp
  411b34:	5b                   	pop    %rbx
  411b35:	5d                   	pop    %rbp
  411b36:	c3                   	retq   
  411b37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  411b3e:	00 00 
  411b40:	48 83 c4 08          	add    $0x8,%rsp
  for (u32 tid = 0; tid < n_contexts_; tid++) {
    ThreadContextBase *tctx = threads_[tid];
    if (tctx != 0 && cb(tctx, arg))
      return tctx;
  }
  return 0;
  411b44:	31 c0                	xor    %eax,%eax
}

ThreadContextBase *ThreadRegistry::FindThreadContextByOsIDLocked(uptr os_id) {
  return FindThreadContextLocked(FindThreadContextByOsIdCallback,
                                 (void *)os_id);
}
  411b46:	5b                   	pop    %rbx
  411b47:	5d                   	pop    %rbp
  411b48:	c3                   	retq   
  411b49:	90                   	nop
  411b4a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000411b50 <_ZN11__sanitizer14ThreadRegistry13SetThreadNameEjPKc>:

void ThreadRegistry::SetThreadName(u32 tid, const char *name) {
  411b50:	41 55                	push   %r13
  411b52:	41 89 f5             	mov    %esi,%r13d
  411b55:	41 54                	push   %r12
  411b57:	49 89 d4             	mov    %rdx,%r12
  411b5a:	55                   	push   %rbp
  BlockingMutexLock l(&mtx_);
  411b5b:	48 8d 6f 18          	lea    0x18(%rdi),%rbp
ThreadContextBase *ThreadRegistry::FindThreadContextByOsIDLocked(uptr os_id) {
  return FindThreadContextLocked(FindThreadContextByOsIdCallback,
                                 (void *)os_id);
}

void ThreadRegistry::SetThreadName(u32 tid, const char *name) {
  411b5f:	53                   	push   %rbx
  411b60:	48 89 fb             	mov    %rdi,%rbx
template<typename MutexType>
class GenericScopedLock {
 public:
  explicit GenericScopedLock(MutexType *mu)
      : mu_(mu) {
    mu_->Lock();
  411b63:	48 89 ef             	mov    %rbp,%rdi
  411b66:	48 83 ec 08          	sub    $0x8,%rsp
  411b6a:	e8 41 9d ff ff       	callq  40b8b0 <_ZN11__sanitizer13BlockingMutex4LockEv>
  BlockingMutexLock l(&mtx_);
  CHECK_LT(tid, n_contexts_);
  411b6f:	44 8b 43 70          	mov    0x70(%rbx),%r8d
  411b73:	44 89 e9             	mov    %r13d,%ecx
  411b76:	4c 39 c1             	cmp    %r8,%rcx
  411b79:	73 4a                	jae    411bc5 <_ZN11__sanitizer14ThreadRegistry13SetThreadNameEjPKc+0x75>
  ThreadContextBase *tctx = threads_[tid];
  411b7b:	48 8b 83 98 00 00 00 	mov    0x98(%rbx),%rax
  411b82:	48 8b 1c c8          	mov    (%rax,%rcx,8),%rbx
  CHECK_NE(tctx, 0);
  411b86:	48 85 db             	test   %rbx,%rbx
  411b89:	74 6f                	je     411bfa <_ZN11__sanitizer14ThreadRegistry13SetThreadNameEjPKc+0xaa>
  CHECK_EQ(ThreadStatusRunning, tctx->status);
  411b8b:	44 8b 43 70          	mov    0x70(%rbx),%r8d
  411b8f:	49 83 f8 02          	cmp    $0x2,%r8
  411b93:	75 48                	jne    411bdd <_ZN11__sanitizer14ThreadRegistry13SetThreadNameEjPKc+0x8d>
  CHECK(0);
}

void ThreadContextBase::SetName(const char *new_name) {
  name[0] = '\0';
  if (new_name) {
  411b95:	4d 85 e4             	test   %r12,%r12
  // ThreadContextBase should never be deleted.
  CHECK(0);
}

void ThreadContextBase::SetName(const char *new_name) {
  name[0] = '\0';
  411b98:	c6 43 30 00          	movb   $0x0,0x30(%rbx)
  if (new_name) {
  411b9c:	74 15                	je     411bb3 <_ZN11__sanitizer14ThreadRegistry13SetThreadNameEjPKc+0x63>
    internal_strncpy(name, new_name, sizeof(name));
  411b9e:	48 8d 7b 30          	lea    0x30(%rbx),%rdi
  411ba2:	ba 40 00 00 00       	mov    $0x40,%edx
  411ba7:	4c 89 e6             	mov    %r12,%rsi
  411baa:	e8 01 8e ff ff       	callq  40a9b0 <_ZN11__sanitizer16internal_strncpyEPcPKcm>
    name[sizeof(name) - 1] = '\0';
  411baf:	c6 43 6f 00          	movb   $0x0,0x6f(%rbx)
  CHECK_LT(tid, n_contexts_);
  ThreadContextBase *tctx = threads_[tid];
  CHECK_NE(tctx, 0);
  CHECK_EQ(ThreadStatusRunning, tctx->status);
  tctx->SetName(name);
}
  411bb3:	48 83 c4 08          	add    $0x8,%rsp
  }

  ~GenericScopedLock() {
    mu_->Unlock();
  411bb7:	48 89 ef             	mov    %rbp,%rdi
  411bba:	5b                   	pop    %rbx
  411bbb:	5d                   	pop    %rbp
  411bbc:	41 5c                	pop    %r12
  411bbe:	41 5d                	pop    %r13
  411bc0:	e9 5b 9d ff ff       	jmpq   40b920 <_ZN11__sanitizer13BlockingMutex6UnlockEv>
                                 (void *)os_id);
}

void ThreadRegistry::SetThreadName(u32 tid, const char *name) {
  BlockingMutexLock l(&mtx_);
  CHECK_LT(tid, n_contexts_);
  411bc5:	48 8d 15 09 75 00 00 	lea    0x7509(%rip),%rdx        # 4190d5 <.LC12>
  411bcc:	48 8d 3d 85 63 00 00 	lea    0x6385(%rip),%rdi        # 417f58 <.LC1>
  411bd3:	be ca 00 00 00       	mov    $0xca,%esi
  411bd8:	e8 13 38 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  ThreadContextBase *tctx = threads_[tid];
  CHECK_NE(tctx, 0);
  CHECK_EQ(ThreadStatusRunning, tctx->status);
  411bdd:	48 8d 15 f4 64 00 00 	lea    0x64f4(%rip),%rdx        # 4180d8 <.LC13>
  411be4:	48 8d 3d 6d 63 00 00 	lea    0x636d(%rip),%rdi        # 417f58 <.LC1>
  411beb:	b9 02 00 00 00       	mov    $0x2,%ecx
  411bf0:	be cd 00 00 00       	mov    $0xcd,%esi
  411bf5:	e8 f6 37 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

void ThreadRegistry::SetThreadName(u32 tid, const char *name) {
  BlockingMutexLock l(&mtx_);
  CHECK_LT(tid, n_contexts_);
  ThreadContextBase *tctx = threads_[tid];
  CHECK_NE(tctx, 0);
  411bfa:	48 8d 15 8c 74 00 00 	lea    0x748c(%rip),%rdx        # 41908d <.LC7>
  411c01:	48 8d 3d 50 63 00 00 	lea    0x6350(%rip),%rdi        # 417f58 <.LC1>
  411c08:	45 31 c0             	xor    %r8d,%r8d
  411c0b:	31 c9                	xor    %ecx,%ecx
  411c0d:	be cc 00 00 00       	mov    $0xcc,%esi
  411c12:	e8 d9 37 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  411c17:	90                   	nop
  411c18:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  411c1f:	00 

0000000000411c20 <_ZN11__sanitizer14ThreadRegistry21SetThreadNameByUserIdEmPKc>:
  CHECK_EQ(ThreadStatusRunning, tctx->status);
  tctx->SetName(name);
}

void ThreadRegistry::SetThreadNameByUserId(uptr user_id, const char *name) {
  411c20:	41 55                	push   %r13
  BlockingMutexLock l(&mtx_);
  411c22:	4c 8d 6f 18          	lea    0x18(%rdi),%r13
  CHECK_NE(tctx, 0);
  CHECK_EQ(ThreadStatusRunning, tctx->status);
  tctx->SetName(name);
}

void ThreadRegistry::SetThreadNameByUserId(uptr user_id, const char *name) {
  411c26:	41 54                	push   %r12
  411c28:	49 89 d4             	mov    %rdx,%r12
  411c2b:	55                   	push   %rbp
  411c2c:	48 89 f5             	mov    %rsi,%rbp
  411c2f:	53                   	push   %rbx
  411c30:	48 89 fb             	mov    %rdi,%rbx
template<typename MutexType>
class GenericScopedLock {
 public:
  explicit GenericScopedLock(MutexType *mu)
      : mu_(mu) {
    mu_->Lock();
  411c33:	4c 89 ef             	mov    %r13,%rdi
  411c36:	48 83 ec 08          	sub    $0x8,%rsp
  411c3a:	e8 71 9c ff ff       	callq  40b8b0 <_ZN11__sanitizer13BlockingMutex4LockEv>
  BlockingMutexLock l(&mtx_);
  for (u32 tid = 0; tid < n_contexts_; tid++) {
  411c3f:	8b 4b 70             	mov    0x70(%rbx),%ecx
  411c42:	85 c9                	test   %ecx,%ecx
  411c44:	74 52                	je     411c98 <_ZN11__sanitizer14ThreadRegistry21SetThreadNameByUserIdEmPKc+0x78>
  411c46:	4c 8b 83 98 00 00 00 	mov    0x98(%rbx),%r8
  411c4d:	31 c0                	xor    %eax,%eax
  411c4f:	eb 0f                	jmp    411c60 <_ZN11__sanitizer14ThreadRegistry21SetThreadNameByUserIdEmPKc+0x40>
  411c51:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  411c58:	48 83 c0 01          	add    $0x1,%rax
  411c5c:	39 c1                	cmp    %eax,%ecx
  411c5e:	76 38                	jbe    411c98 <_ZN11__sanitizer14ThreadRegistry21SetThreadNameByUserIdEmPKc+0x78>
    ThreadContextBase *tctx = threads_[tid];
  411c60:	49 8b 1c c0          	mov    (%r8,%rax,8),%rbx
    if (tctx != 0 && tctx->user_id == user_id &&
  411c64:	48 85 db             	test   %rbx,%rbx
  411c67:	74 ef                	je     411c58 <_ZN11__sanitizer14ThreadRegistry21SetThreadNameByUserIdEmPKc+0x38>
  411c69:	48 39 6b 28          	cmp    %rbp,0x28(%rbx)
  411c6d:	75 e9                	jne    411c58 <_ZN11__sanitizer14ThreadRegistry21SetThreadNameByUserIdEmPKc+0x38>
  411c6f:	8b 53 70             	mov    0x70(%rbx),%edx
  411c72:	85 d2                	test   %edx,%edx
  411c74:	74 e2                	je     411c58 <_ZN11__sanitizer14ThreadRegistry21SetThreadNameByUserIdEmPKc+0x38>
  CHECK(0);
}

void ThreadContextBase::SetName(const char *new_name) {
  name[0] = '\0';
  if (new_name) {
  411c76:	4d 85 e4             	test   %r12,%r12
  // ThreadContextBase should never be deleted.
  CHECK(0);
}

void ThreadContextBase::SetName(const char *new_name) {
  name[0] = '\0';
  411c79:	c6 43 30 00          	movb   $0x0,0x30(%rbx)
  if (new_name) {
  411c7d:	74 19                	je     411c98 <_ZN11__sanitizer14ThreadRegistry21SetThreadNameByUserIdEmPKc+0x78>
    internal_strncpy(name, new_name, sizeof(name));
  411c7f:	48 8d 7b 30          	lea    0x30(%rbx),%rdi
  411c83:	ba 40 00 00 00       	mov    $0x40,%edx
  411c88:	4c 89 e6             	mov    %r12,%rsi
  411c8b:	e8 20 8d ff ff       	callq  40a9b0 <_ZN11__sanitizer16internal_strncpyEPcPKcm>
    name[sizeof(name) - 1] = '\0';
  411c90:	c6 43 6f 00          	movb   $0x0,0x6f(%rbx)
  411c94:	0f 1f 40 00          	nopl   0x0(%rax)
        tctx->status != ThreadStatusInvalid) {
      tctx->SetName(name);
      return;
    }
  }
}
  411c98:	48 83 c4 08          	add    $0x8,%rsp
  }

  ~GenericScopedLock() {
    mu_->Unlock();
  411c9c:	4c 89 ef             	mov    %r13,%rdi
  411c9f:	5b                   	pop    %rbx
  411ca0:	5d                   	pop    %rbp
  411ca1:	41 5c                	pop    %r12
  411ca3:	41 5d                	pop    %r13
  411ca5:	e9 76 9c ff ff       	jmpq   40b920 <_ZN11__sanitizer13BlockingMutex6UnlockEv>
  411caa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000411cb0 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv>:
  } else {
    tctx->detached = true;
  }
}

void ThreadRegistry::JoinThread(u32 tid, void *arg) {
  411cb0:	41 55                	push   %r13
  411cb2:	49 89 d5             	mov    %rdx,%r13
  411cb5:	41 54                	push   %r12
  BlockingMutexLock l(&mtx_);
  411cb7:	4c 8d 67 18          	lea    0x18(%rdi),%r12
  } else {
    tctx->detached = true;
  }
}

void ThreadRegistry::JoinThread(u32 tid, void *arg) {
  411cbb:	55                   	push   %rbp
  411cbc:	89 f5                	mov    %esi,%ebp
  411cbe:	53                   	push   %rbx
  411cbf:	48 89 fb             	mov    %rdi,%rbx
template<typename MutexType>
class GenericScopedLock {
 public:
  explicit GenericScopedLock(MutexType *mu)
      : mu_(mu) {
    mu_->Lock();
  411cc2:	4c 89 e7             	mov    %r12,%rdi
  411cc5:	48 83 ec 08          	sub    $0x8,%rsp
  411cc9:	e8 e2 9b ff ff       	callq  40b8b0 <_ZN11__sanitizer13BlockingMutex4LockEv>
  BlockingMutexLock l(&mtx_);
  CHECK_LT(tid, n_contexts_);
  411cce:	44 8b 43 70          	mov    0x70(%rbx),%r8d
  411cd2:	89 e9                	mov    %ebp,%ecx
  411cd4:	4c 39 c1             	cmp    %r8,%rcx
  411cd7:	0f 83 d1 01 00 00    	jae    411eae <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0x1fe>
  ThreadContextBase *tctx = threads_[tid];
  411cdd:	48 8b 83 98 00 00 00 	mov    0x98(%rbx),%rax
  411ce4:	48 8b 2c c8          	mov    (%rax,%rcx,8),%rbp
  CHECK_NE(tctx, 0);
  411ce8:	48 85 ed             	test   %rbp,%rbp
  411ceb:	0f 84 d5 01 00 00    	je     411ec6 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0x216>
  if (tctx->status == ThreadStatusInvalid) {
  411cf1:	8b 45 70             	mov    0x70(%rbp),%eax
  411cf4:	85 c0                	test   %eax,%eax
  411cf6:	0f 84 4c 01 00 00    	je     411e48 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0x198>
  OnDead();
}

void ThreadContextBase::SetJoined(void *arg) {
  // FIXME(dvyukov): print message and continue (it's user error).
  CHECK_EQ(false, detached);
  411cfc:	80 7d 74 00          	cmpb   $0x0,0x74(%rbp)
  411d00:	0f 85 fa 01 00 00    	jne    411f00 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0x250>
  CHECK_EQ(ThreadStatusFinished, status);
  411d06:	41 89 c0             	mov    %eax,%r8d
  411d09:	49 83 f8 03          	cmp    $0x3,%r8
  411d0d:	0f 85 d0 01 00 00    	jne    411ee3 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0x233>
  status = ThreadStatusDead;
  user_id = 0;
  OnJoined(arg);
  411d13:	48 8b 45 00          	mov    0x0(%rbp),%rax

void ThreadContextBase::SetJoined(void *arg) {
  // FIXME(dvyukov): print message and continue (it's user error).
  CHECK_EQ(false, detached);
  CHECK_EQ(ThreadStatusFinished, status);
  status = ThreadStatusDead;
  411d17:	c7 45 70 04 00 00 00 	movl   $0x4,0x70(%rbp)
  user_id = 0;
  OnJoined(arg);
  411d1e:	4c 89 ee             	mov    %r13,%rsi
void ThreadContextBase::SetJoined(void *arg) {
  // FIXME(dvyukov): print message and continue (it's user error).
  CHECK_EQ(false, detached);
  CHECK_EQ(ThreadStatusFinished, status);
  status = ThreadStatusDead;
  user_id = 0;
  411d21:	48 c7 45 28 00 00 00 	movq   $0x0,0x28(%rbp)
  411d28:	00 
  OnJoined(arg);
  411d29:	48 89 ef             	mov    %rbp,%rdi
  411d2c:	ff 50 08             	callq  *0x8(%rax)
  }

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
  411d2f:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
    if (empty()) {
      x->next = nullptr;
  411d36:	48 c7 85 80 00 00 00 	movq   $0x0,0x80(%rbp)
  411d3d:	00 00 00 00 

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
    if (empty()) {
  411d41:	48 85 c0             	test   %rax,%rax
  411d44:	74 42                	je     411d88 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0xd8>
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = nullptr;
      last_->next = x;
  411d46:	48 8b 93 b0 00 00 00 	mov    0xb0(%rbx),%rdx
      last_ = x;
      size_++;
  411d4d:	48 83 c0 01          	add    $0x1,%rax
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = nullptr;
      last_->next = x;
  411d51:	48 89 aa 80 00 00 00 	mov    %rbp,0x80(%rdx)
  tctx->SetStarted(os_id, arg);
}

void ThreadRegistry::QuarantinePush(ThreadContextBase *tctx) {
  dead_threads_.push_back(tctx);
  if (dead_threads_.size() <= thread_quarantine_size_)
  411d58:	8b 53 0c             	mov    0xc(%rbx),%edx
      last_ = x;
  411d5b:	48 89 ab b0 00 00 00 	mov    %rbp,0xb0(%rbx)
      size_++;
  411d62:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)
  411d69:	48 39 c2             	cmp    %rax,%rdx
  411d6c:	72 3d                	jb     411dab <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0xfb>
  411d6e:	66 90                	xchg   %ax,%ax
    Report("%s: Join of non-existent thread\n", SanitizerToolName);
    return;
  }
  tctx->SetJoined(arg);
  QuarantinePush(tctx);
}
  411d70:	48 83 c4 08          	add    $0x8,%rsp
  }

  ~GenericScopedLock() {
    mu_->Unlock();
  411d74:	4c 89 e7             	mov    %r12,%rdi
  411d77:	5b                   	pop    %rbx
  411d78:	5d                   	pop    %rbp
  411d79:	41 5c                	pop    %r12
  411d7b:	41 5d                	pop    %r13
  411d7d:	e9 9e 9b ff ff       	jmpq   40b920 <_ZN11__sanitizer13BlockingMutex6UnlockEv>
  411d82:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  tctx->SetStarted(os_id, arg);
}

void ThreadRegistry::QuarantinePush(ThreadContextBase *tctx) {
  dead_threads_.push_back(tctx);
  if (dead_threads_.size() <= thread_quarantine_size_)
  411d88:	8b 53 0c             	mov    0xc(%rbx),%edx

  void push_back(Item *x) {
    if (empty()) {
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
  411d8b:	b0 01                	mov    $0x1,%al
  uptr size() const { return size_; }

  void push_back(Item *x) {
    if (empty()) {
      x->next = nullptr;
      first_ = last_ = x;
  411d8d:	48 89 ab b0 00 00 00 	mov    %rbp,0xb0(%rbx)
  411d94:	48 89 ab a8 00 00 00 	mov    %rbp,0xa8(%rbx)
      size_ = 1;
  411d9b:	48 c7 83 a0 00 00 00 	movq   $0x1,0xa0(%rbx)
  411da2:	01 00 00 00 
  411da6:	48 39 c2             	cmp    %rax,%rdx
  411da9:	73 c5                	jae    411d70 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0xc0>
  CHECK_EQ(ThreadStatusCreated, tctx->status);
  tctx->SetStarted(os_id, arg);
}

void ThreadRegistry::QuarantinePush(ThreadContextBase *tctx) {
  dead_threads_.push_back(tctx);
  411dab:	48 8b ab a8 00 00 00 	mov    0xa8(%rbx),%rbp
    }
  }

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
  411db2:	48 8b 95 80 00 00 00 	mov    0x80(%rbp),%rdx
    if (!first_)
  411db9:	48 85 d2             	test   %rdx,%rdx
    }
  }

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
  411dbc:	48 89 93 a8 00 00 00 	mov    %rdx,0xa8(%rbx)
    if (!first_)
  411dc3:	0f 84 af 00 00 00    	je     411e78 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0x1c8>
  if (dead_threads_.size() <= thread_quarantine_size_)
    return;
  tctx = dead_threads_.front();
  dead_threads_.pop_front();
  CHECK_EQ(tctx->status, ThreadStatusDead);
  411dc9:	8b 4d 70             	mov    0x70(%rbp),%ecx
      last_ = nullptr;
    size_--;
  411dcc:	48 83 e8 01          	sub    $0x1,%rax
  411dd0:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)
  411dd7:	48 83 f9 04          	cmp    $0x4,%rcx
  411ddb:	0f 85 3f 01 00 00    	jne    411f20 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0x270>
}

void ThreadContextBase::Reset() {
  status = ThreadStatusInvalid;
  SetName(0);
  OnReset();
  411de1:	48 8b 45 00          	mov    0x0(%rbp),%rax
    parent_tid = _parent_tid;
  OnCreated(arg);
}

void ThreadContextBase::Reset() {
  status = ThreadStatusInvalid;
  411de5:	c7 45 70 00 00 00 00 	movl   $0x0,0x70(%rbp)
  SetName(0);
  OnReset();
  411dec:	48 89 ef             	mov    %rbp,%rdi
  // ThreadContextBase should never be deleted.
  CHECK(0);
}

void ThreadContextBase::SetName(const char *new_name) {
  name[0] = '\0';
  411def:	c6 45 30 00          	movb   $0x0,0x30(%rbp)
}

void ThreadContextBase::Reset() {
  status = ThreadStatusInvalid;
  SetName(0);
  OnReset();
  411df3:	ff 50 28             	callq  *0x28(%rax)
    return;
  tctx = dead_threads_.front();
  dead_threads_.pop_front();
  CHECK_EQ(tctx->status, ThreadStatusDead);
  tctx->Reset();
  tctx->reuse_count++;
  411df6:	8b 45 18             	mov    0x18(%rbp),%eax
  411df9:	8d 50 01             	lea    0x1(%rax),%edx
  if (max_reuse_ > 0 && tctx->reuse_count >= max_reuse_)
  411dfc:	8b 43 10             	mov    0x10(%rbx),%eax
    return;
  tctx = dead_threads_.front();
  dead_threads_.pop_front();
  CHECK_EQ(tctx->status, ThreadStatusDead);
  tctx->Reset();
  tctx->reuse_count++;
  411dff:	89 55 18             	mov    %edx,0x18(%rbp)
  if (max_reuse_ > 0 && tctx->reuse_count >= max_reuse_)
  411e02:	85 c0                	test   %eax,%eax
  411e04:	75 62                	jne    411e68 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0x1b8>
  }

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
  411e06:	48 8b 83 b8 00 00 00 	mov    0xb8(%rbx),%rax
    if (empty()) {
      x->next = nullptr;
  411e0d:	48 c7 85 80 00 00 00 	movq   $0x0,0x80(%rbp)
  411e14:	00 00 00 00 

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
    if (empty()) {
  411e18:	48 85 c0             	test   %rax,%rax
  411e1b:	74 73                	je     411e90 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0x1e0>
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = nullptr;
      last_->next = x;
  411e1d:	48 8b 93 c8 00 00 00 	mov    0xc8(%rbx),%rdx
      last_ = x;
      size_++;
  411e24:	48 83 c0 01          	add    $0x1,%rax
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = nullptr;
      last_->next = x;
  411e28:	48 89 aa 80 00 00 00 	mov    %rbp,0x80(%rdx)
      last_ = x;
  411e2f:	48 89 ab c8 00 00 00 	mov    %rbp,0xc8(%rbx)
      size_++;
  411e36:	48 89 83 b8 00 00 00 	mov    %rax,0xb8(%rbx)
  411e3d:	e9 2e ff ff ff       	jmpq   411d70 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0xc0>
  411e42:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  BlockingMutexLock l(&mtx_);
  CHECK_LT(tid, n_contexts_);
  ThreadContextBase *tctx = threads_[tid];
  CHECK_NE(tctx, 0);
  if (tctx->status == ThreadStatusInvalid) {
    Report("%s: Join of non-existent thread\n", SanitizerToolName);
  411e48:	48 8b 05 61 c4 00 00 	mov    0xc461(%rip),%rax        # 41e2b0 <_DYNAMIC+0x2b0>
  411e4f:	48 8d 3d b2 62 00 00 	lea    0x62b2(%rip),%rdi        # 418108 <.LC14>
  411e56:	48 8b 30             	mov    (%rax),%rsi
  411e59:	31 c0                	xor    %eax,%eax
  411e5b:	e8 30 bc ff ff       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
  411e60:	e9 0b ff ff ff       	jmpq   411d70 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0xc0>
  411e65:	0f 1f 00             	nopl   (%rax)
  tctx = dead_threads_.front();
  dead_threads_.pop_front();
  CHECK_EQ(tctx->status, ThreadStatusDead);
  tctx->Reset();
  tctx->reuse_count++;
  if (max_reuse_ > 0 && tctx->reuse_count >= max_reuse_)
  411e68:	39 c2                	cmp    %eax,%edx
  411e6a:	72 9a                	jb     411e06 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0x156>
  411e6c:	0f 1f 40 00          	nopl   0x0(%rax)
  411e70:	e9 fb fe ff ff       	jmpq   411d70 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0xc0>
  411e75:	0f 1f 00             	nopl   (%rax)

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
    if (!first_)
      last_ = nullptr;
  411e78:	48 c7 83 b0 00 00 00 	movq   $0x0,0xb0(%rbx)
  411e7f:	00 00 00 00 
  411e83:	e9 41 ff ff ff       	jmpq   411dc9 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0x119>
  411e88:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  411e8f:	00 
  uptr size() const { return size_; }

  void push_back(Item *x) {
    if (empty()) {
      x->next = nullptr;
      first_ = last_ = x;
  411e90:	48 89 ab c8 00 00 00 	mov    %rbp,0xc8(%rbx)
  411e97:	48 89 ab c0 00 00 00 	mov    %rbp,0xc0(%rbx)
      size_ = 1;
  411e9e:	48 c7 83 b8 00 00 00 	movq   $0x1,0xb8(%rbx)
  411ea5:	01 00 00 00 
  411ea9:	e9 c2 fe ff ff       	jmpq   411d70 <_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv+0xc0>
  }
}

void ThreadRegistry::JoinThread(u32 tid, void *arg) {
  BlockingMutexLock l(&mtx_);
  CHECK_LT(tid, n_contexts_);
  411eae:	48 8d 15 20 72 00 00 	lea    0x7220(%rip),%rdx        # 4190d5 <.LC12>
  411eb5:	48 8d 3d 9c 60 00 00 	lea    0x609c(%rip),%rdi        # 417f58 <.LC1>
  411ebc:	be f1 00 00 00       	mov    $0xf1,%esi
  411ec1:	e8 2a 35 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  ThreadContextBase *tctx = threads_[tid];
  CHECK_NE(tctx, 0);
  411ec6:	48 8d 15 c0 71 00 00 	lea    0x71c0(%rip),%rdx        # 41908d <.LC7>
  411ecd:	48 8d 3d 84 60 00 00 	lea    0x6084(%rip),%rdi        # 417f58 <.LC1>
  411ed4:	45 31 c0             	xor    %r8d,%r8d
  411ed7:	31 c9                	xor    %ecx,%ecx
  411ed9:	be f3 00 00 00       	mov    $0xf3,%esi
  411ede:	e8 0d 35 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
}

void ThreadContextBase::SetJoined(void *arg) {
  // FIXME(dvyukov): print message and continue (it's user error).
  CHECK_EQ(false, detached);
  CHECK_EQ(ThreadStatusFinished, status);
  411ee3:	48 8d 15 36 61 00 00 	lea    0x6136(%rip),%rdx        # 418020 <.LC4>
  411eea:	48 8d 3d 67 60 00 00 	lea    0x6067(%rip),%rdi        # 417f58 <.LC1>
  411ef1:	b9 03 00 00 00       	mov    $0x3,%ecx
  411ef6:	be 32 00 00 00       	mov    $0x32,%esi
  411efb:	e8 f0 34 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  OnDead();
}

void ThreadContextBase::SetJoined(void *arg) {
  // FIXME(dvyukov): print message and continue (it's user error).
  CHECK_EQ(false, detached);
  411f00:	48 8d 15 5d 71 00 00 	lea    0x715d(%rip),%rdx        # 419064 <.LC3>
  411f07:	48 8d 3d 4a 60 00 00 	lea    0x604a(%rip),%rdi        # 417f58 <.LC1>
  411f0e:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  411f14:	31 c9                	xor    %ecx,%ecx
  411f16:	be 31 00 00 00       	mov    $0x31,%esi
  411f1b:	e8 d0 34 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  dead_threads_.push_back(tctx);
  if (dead_threads_.size() <= thread_quarantine_size_)
    return;
  tctx = dead_threads_.front();
  dead_threads_.pop_front();
  CHECK_EQ(tctx->status, ThreadStatusDead);
  411f20:	48 8d 15 09 62 00 00 	lea    0x6209(%rip),%rdx        # 418130 <.LC15>
  411f27:	48 8d 3d 2a 60 00 00 	lea    0x602a(%rip),%rdi        # 417f58 <.LC1>
  411f2e:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  411f34:	be 1d 01 00 00       	mov    $0x11d,%esi
  411f39:	e8 b2 34 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  411f3e:	66 90                	xchg   %ax,%ax

0000000000411f40 <_ZN11__sanitizer14ThreadRegistry11StartThreadEjmPv>:
    tctx->SetDead();
    QuarantinePush(tctx);
  }
}

void ThreadRegistry::StartThread(u32 tid, uptr os_id, void *arg) {
  411f40:	41 56                	push   %r14
  411f42:	49 89 ce             	mov    %rcx,%r14
  411f45:	41 55                	push   %r13
  411f47:	49 89 d5             	mov    %rdx,%r13
  411f4a:	41 54                	push   %r12
  411f4c:	41 89 f4             	mov    %esi,%r12d
  411f4f:	55                   	push   %rbp
  BlockingMutexLock l(&mtx_);
  411f50:	48 8d 6f 18          	lea    0x18(%rdi),%rbp
    tctx->SetDead();
    QuarantinePush(tctx);
  }
}

void ThreadRegistry::StartThread(u32 tid, uptr os_id, void *arg) {
  411f54:	53                   	push   %rbx
  411f55:	48 89 fb             	mov    %rdi,%rbx
template<typename MutexType>
class GenericScopedLock {
 public:
  explicit GenericScopedLock(MutexType *mu)
      : mu_(mu) {
    mu_->Lock();
  411f58:	48 89 ef             	mov    %rbp,%rdi
  411f5b:	e8 50 99 ff ff       	callq  40b8b0 <_ZN11__sanitizer13BlockingMutex4LockEv>
  BlockingMutexLock l(&mtx_);
  running_threads_++;
  CHECK_LT(tid, n_contexts_);
  411f60:	44 8b 43 70          	mov    0x70(%rbx),%r8d
  411f64:	44 89 e1             	mov    %r12d,%ecx
  }
}

void ThreadRegistry::StartThread(u32 tid, uptr os_id, void *arg) {
  BlockingMutexLock l(&mtx_);
  running_threads_++;
  411f67:	48 83 83 90 00 00 00 	addq   $0x1,0x90(%rbx)
  411f6e:	01 
  CHECK_LT(tid, n_contexts_);
  411f6f:	4c 39 c1             	cmp    %r8,%rcx
  411f72:	73 3e                	jae    411fb2 <_ZN11__sanitizer14ThreadRegistry11StartThreadEjmPv+0x72>
  ThreadContextBase *tctx = threads_[tid];
  411f74:	48 8b 93 98 00 00 00 	mov    0x98(%rbx),%rdx
  411f7b:	48 8b 3c ca          	mov    (%rdx,%rcx,8),%rdi
  CHECK_NE(tctx, 0);
  411f7f:	48 85 ff             	test   %rdi,%rdi
  411f82:	74 63                	je     411fe7 <_ZN11__sanitizer14ThreadRegistry11StartThreadEjmPv+0xa7>
  CHECK_EQ(ThreadStatusCreated, tctx->status);
  411f84:	44 8b 47 70          	mov    0x70(%rdi),%r8d
  411f88:	49 83 f8 01          	cmp    $0x1,%r8
  411f8c:	75 3c                	jne    411fca <_ZN11__sanitizer14ThreadRegistry11StartThreadEjmPv+0x8a>
}

void ThreadContextBase::SetStarted(uptr _os_id, void *arg) {
  status = ThreadStatusRunning;
  os_id = _os_id;
  OnStarted(arg);
  411f8e:	48 8b 17             	mov    (%rdi),%rdx
  OnFinished();
}

void ThreadContextBase::SetStarted(uptr _os_id, void *arg) {
  status = ThreadStatusRunning;
  os_id = _os_id;
  411f91:	4c 89 6f 20          	mov    %r13,0x20(%rdi)
  OnStarted(arg);
  411f95:	4c 89 f6             	mov    %r14,%rsi
    status = ThreadStatusFinished;
  OnFinished();
}

void ThreadContextBase::SetStarted(uptr _os_id, void *arg) {
  status = ThreadStatusRunning;
  411f98:	c7 47 70 02 00 00 00 	movl   $0x2,0x70(%rdi)
  os_id = _os_id;
  OnStarted(arg);
  411f9f:	ff 52 18             	callq  *0x18(%rdx)
  CHECK_LT(tid, n_contexts_);
  ThreadContextBase *tctx = threads_[tid];
  CHECK_NE(tctx, 0);
  CHECK_EQ(ThreadStatusCreated, tctx->status);
  tctx->SetStarted(os_id, arg);
}
  411fa2:	5b                   	pop    %rbx
  }

  ~GenericScopedLock() {
    mu_->Unlock();
  411fa3:	48 89 ef             	mov    %rbp,%rdi
  411fa6:	5d                   	pop    %rbp
  411fa7:	41 5c                	pop    %r12
  411fa9:	41 5d                	pop    %r13
  411fab:	41 5e                	pop    %r14
  411fad:	e9 6e 99 ff ff       	jmpq   40b920 <_ZN11__sanitizer13BlockingMutex6UnlockEv>
}

void ThreadRegistry::StartThread(u32 tid, uptr os_id, void *arg) {
  BlockingMutexLock l(&mtx_);
  running_threads_++;
  CHECK_LT(tid, n_contexts_);
  411fb2:	48 8d 15 1c 71 00 00 	lea    0x711c(%rip),%rdx        # 4190d5 <.LC12>
  411fb9:	48 8d 3d 98 5f 00 00 	lea    0x5f98(%rip),%rdi        # 417f58 <.LC1>
  411fc0:	be 10 01 00 00       	mov    $0x110,%esi
  411fc5:	e8 26 34 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  ThreadContextBase *tctx = threads_[tid];
  CHECK_NE(tctx, 0);
  CHECK_EQ(ThreadStatusCreated, tctx->status);
  411fca:	48 8d 15 8f 61 00 00 	lea    0x618f(%rip),%rdx        # 418160 <.LC16>
  411fd1:	48 8d 3d 80 5f 00 00 	lea    0x5f80(%rip),%rdi        # 417f58 <.LC1>
  411fd8:	b9 01 00 00 00       	mov    $0x1,%ecx
  411fdd:	be 13 01 00 00       	mov    $0x113,%esi
  411fe2:	e8 09 34 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
void ThreadRegistry::StartThread(u32 tid, uptr os_id, void *arg) {
  BlockingMutexLock l(&mtx_);
  running_threads_++;
  CHECK_LT(tid, n_contexts_);
  ThreadContextBase *tctx = threads_[tid];
  CHECK_NE(tctx, 0);
  411fe7:	48 8d 15 9f 70 00 00 	lea    0x709f(%rip),%rdx        # 41908d <.LC7>
  411fee:	48 8d 3d 63 5f 00 00 	lea    0x5f63(%rip),%rdi        # 417f58 <.LC1>
  411ff5:	45 31 c0             	xor    %r8d,%r8d
  411ff8:	31 c9                	xor    %ecx,%ecx
  411ffa:	be 12 01 00 00       	mov    $0x112,%esi
  411fff:	e8 ec 33 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  412004:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  41200b:	00 00 00 00 00 

0000000000412010 <_ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE>:
  CHECK_EQ(ThreadStatusCreated, tctx->status);
  tctx->SetStarted(os_id, arg);
}

void ThreadRegistry::QuarantinePush(ThreadContextBase *tctx) {
  412010:	55                   	push   %rbp
  412011:	53                   	push   %rbx
  412012:	48 89 fb             	mov    %rdi,%rbx
  412015:	48 83 ec 08          	sub    $0x8,%rsp
  }

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
  412019:	48 8b 87 a0 00 00 00 	mov    0xa0(%rdi),%rax
    if (empty()) {
      x->next = nullptr;
  412020:	48 c7 86 80 00 00 00 	movq   $0x0,0x80(%rsi)
  412027:	00 00 00 00 

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
    if (empty()) {
  41202b:	48 85 c0             	test   %rax,%rax
  41202e:	75 30                	jne    412060 <_ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE+0x50>
  dead_threads_.push_back(tctx);
  if (dead_threads_.size() <= thread_quarantine_size_)
  412030:	8b 53 0c             	mov    0xc(%rbx),%edx
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
  412033:	b0 01                	mov    $0x1,%al
  uptr size() const { return size_; }

  void push_back(Item *x) {
    if (empty()) {
      x->next = nullptr;
      first_ = last_ = x;
  412035:	48 89 b7 b0 00 00 00 	mov    %rsi,0xb0(%rdi)
  41203c:	48 89 b7 a8 00 00 00 	mov    %rsi,0xa8(%rdi)
      size_ = 1;
  412043:	48 c7 87 a0 00 00 00 	movq   $0x1,0xa0(%rdi)
  41204a:	01 00 00 00 
  41204e:	48 39 c2             	cmp    %rax,%rdx
  412051:	72 35                	jb     412088 <_ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE+0x78>
  tctx->Reset();
  tctx->reuse_count++;
  if (max_reuse_ > 0 && tctx->reuse_count >= max_reuse_)
    return;
  invalid_threads_.push_back(tctx);
}
  412053:	48 83 c4 08          	add    $0x8,%rsp
  412057:	5b                   	pop    %rbx
  412058:	5d                   	pop    %rbp
  412059:	c3                   	retq   
  41205a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    } else {
      x->next = nullptr;
      last_->next = x;
  412060:	48 8b 97 b0 00 00 00 	mov    0xb0(%rdi),%rdx
      last_ = x;
      size_++;
  412067:	48 83 c0 01          	add    $0x1,%rax
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = nullptr;
      last_->next = x;
  41206b:	48 89 b2 80 00 00 00 	mov    %rsi,0x80(%rdx)
  tctx->SetStarted(os_id, arg);
}

void ThreadRegistry::QuarantinePush(ThreadContextBase *tctx) {
  dead_threads_.push_back(tctx);
  if (dead_threads_.size() <= thread_quarantine_size_)
  412072:	8b 53 0c             	mov    0xc(%rbx),%edx
      last_ = x;
  412075:	48 89 b7 b0 00 00 00 	mov    %rsi,0xb0(%rdi)
      size_++;
  41207c:	48 89 87 a0 00 00 00 	mov    %rax,0xa0(%rdi)
  412083:	48 39 c2             	cmp    %rax,%rdx
  412086:	73 cb                	jae    412053 <_ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE+0x43>
  CHECK_EQ(ThreadStatusCreated, tctx->status);
  tctx->SetStarted(os_id, arg);
}

void ThreadRegistry::QuarantinePush(ThreadContextBase *tctx) {
  dead_threads_.push_back(tctx);
  412088:	48 8b ab a8 00 00 00 	mov    0xa8(%rbx),%rbp
    }
  }

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
  41208f:	48 8b 95 80 00 00 00 	mov    0x80(%rbp),%rdx
    if (!first_)
  412096:	48 85 d2             	test   %rdx,%rdx
    }
  }

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
  412099:	48 89 93 a8 00 00 00 	mov    %rdx,0xa8(%rbx)
    if (!first_)
  4120a0:	0f 84 aa 00 00 00    	je     412150 <_ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE+0x140>
  if (dead_threads_.size() <= thread_quarantine_size_)
    return;
  tctx = dead_threads_.front();
  dead_threads_.pop_front();
  CHECK_EQ(tctx->status, ThreadStatusDead);
  4120a6:	8b 4d 70             	mov    0x70(%rbp),%ecx
      last_ = nullptr;
    size_--;
  4120a9:	48 83 e8 01          	sub    $0x1,%rax
  4120ad:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)
  4120b4:	48 83 f9 04          	cmp    $0x4,%rcx
  4120b8:	0f 85 a2 00 00 00    	jne    412160 <_ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE+0x150>
}

void ThreadContextBase::Reset() {
  status = ThreadStatusInvalid;
  SetName(0);
  OnReset();
  4120be:	48 8b 45 00          	mov    0x0(%rbp),%rax
    parent_tid = _parent_tid;
  OnCreated(arg);
}

void ThreadContextBase::Reset() {
  status = ThreadStatusInvalid;
  4120c2:	c7 45 70 00 00 00 00 	movl   $0x0,0x70(%rbp)
  SetName(0);
  OnReset();
  4120c9:	48 89 ef             	mov    %rbp,%rdi
  // ThreadContextBase should never be deleted.
  CHECK(0);
}

void ThreadContextBase::SetName(const char *new_name) {
  name[0] = '\0';
  4120cc:	c6 45 30 00          	movb   $0x0,0x30(%rbp)
}

void ThreadContextBase::Reset() {
  status = ThreadStatusInvalid;
  SetName(0);
  OnReset();
  4120d0:	ff 50 28             	callq  *0x28(%rax)
    return;
  tctx = dead_threads_.front();
  dead_threads_.pop_front();
  CHECK_EQ(tctx->status, ThreadStatusDead);
  tctx->Reset();
  tctx->reuse_count++;
  4120d3:	8b 45 18             	mov    0x18(%rbp),%eax
  4120d6:	8d 50 01             	lea    0x1(%rax),%edx
  if (max_reuse_ > 0 && tctx->reuse_count >= max_reuse_)
  4120d9:	8b 43 10             	mov    0x10(%rbx),%eax
    return;
  tctx = dead_threads_.front();
  dead_threads_.pop_front();
  CHECK_EQ(tctx->status, ThreadStatusDead);
  tctx->Reset();
  tctx->reuse_count++;
  4120dc:	89 55 18             	mov    %edx,0x18(%rbp)
  if (max_reuse_ > 0 && tctx->reuse_count >= max_reuse_)
  4120df:	85 c0                	test   %eax,%eax
  4120e1:	74 08                	je     4120eb <_ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE+0xdb>
  4120e3:	39 c2                	cmp    %eax,%edx
  4120e5:	0f 83 68 ff ff ff    	jae    412053 <_ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE+0x43>
  }

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
  4120eb:	48 8b 83 b8 00 00 00 	mov    0xb8(%rbx),%rax
    if (empty()) {
      x->next = nullptr;
  4120f2:	48 c7 85 80 00 00 00 	movq   $0x0,0x80(%rbp)
  4120f9:	00 00 00 00 

  bool empty() const { return size_ == 0; }
  uptr size() const { return size_; }

  void push_back(Item *x) {
    if (empty()) {
  4120fd:	48 85 c0             	test   %rax,%rax
  412100:	74 2e                	je     412130 <_ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE+0x120>
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = nullptr;
      last_->next = x;
  412102:	48 8b 93 c8 00 00 00 	mov    0xc8(%rbx),%rdx
      last_ = x;
      size_++;
  412109:	48 83 c0 01          	add    $0x1,%rax
      x->next = nullptr;
      first_ = last_ = x;
      size_ = 1;
    } else {
      x->next = nullptr;
      last_->next = x;
  41210d:	48 89 aa 80 00 00 00 	mov    %rbp,0x80(%rdx)
      last_ = x;
  412114:	48 89 ab c8 00 00 00 	mov    %rbp,0xc8(%rbx)
      size_++;
  41211b:	48 89 83 b8 00 00 00 	mov    %rax,0xb8(%rbx)
    return;
  invalid_threads_.push_back(tctx);
}
  412122:	48 83 c4 08          	add    $0x8,%rsp
  412126:	5b                   	pop    %rbx
  412127:	5d                   	pop    %rbp
  412128:	c3                   	retq   
  412129:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  uptr size() const { return size_; }

  void push_back(Item *x) {
    if (empty()) {
      x->next = nullptr;
      first_ = last_ = x;
  412130:	48 89 ab c8 00 00 00 	mov    %rbp,0xc8(%rbx)
  412137:	48 89 ab c0 00 00 00 	mov    %rbp,0xc0(%rbx)
      size_ = 1;
  41213e:	48 c7 83 b8 00 00 00 	movq   $0x1,0xb8(%rbx)
  412145:	01 00 00 00 
  412149:	48 83 c4 08          	add    $0x8,%rsp
  41214d:	5b                   	pop    %rbx
  41214e:	5d                   	pop    %rbp
  41214f:	c3                   	retq   

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
    if (!first_)
      last_ = nullptr;
  412150:	48 c7 83 b0 00 00 00 	movq   $0x0,0xb0(%rbx)
  412157:	00 00 00 00 
  41215b:	e9 46 ff ff ff       	jmpq   4120a6 <_ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE+0x96>
  dead_threads_.push_back(tctx);
  if (dead_threads_.size() <= thread_quarantine_size_)
    return;
  tctx = dead_threads_.front();
  dead_threads_.pop_front();
  CHECK_EQ(tctx->status, ThreadStatusDead);
  412160:	48 8d 15 c9 5f 00 00 	lea    0x5fc9(%rip),%rdx        # 418130 <.LC15>
  412167:	48 8d 3d ea 5d 00 00 	lea    0x5dea(%rip),%rdi        # 417f58 <.LC1>
  41216e:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  412174:	be 1d 01 00 00       	mov    $0x11d,%esi
  412179:	e8 72 32 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  41217e:	66 90                	xchg   %ax,%ax

0000000000412180 <_ZN11__sanitizer14ThreadRegistry12DetachThreadEjPv>:
      return;
    }
  }
}

void ThreadRegistry::DetachThread(u32 tid, void *arg) {
  412180:	41 55                	push   %r13
  412182:	49 89 d5             	mov    %rdx,%r13
  412185:	41 54                	push   %r12
  BlockingMutexLock l(&mtx_);
  412187:	4c 8d 67 18          	lea    0x18(%rdi),%r12
      return;
    }
  }
}

void ThreadRegistry::DetachThread(u32 tid, void *arg) {
  41218b:	55                   	push   %rbp
  41218c:	48 89 fd             	mov    %rdi,%rbp
template<typename MutexType>
class GenericScopedLock {
 public:
  explicit GenericScopedLock(MutexType *mu)
      : mu_(mu) {
    mu_->Lock();
  41218f:	4c 89 e7             	mov    %r12,%rdi
  412192:	53                   	push   %rbx
  412193:	89 f3                	mov    %esi,%ebx
  412195:	48 83 ec 08          	sub    $0x8,%rsp
  412199:	e8 12 97 ff ff       	callq  40b8b0 <_ZN11__sanitizer13BlockingMutex4LockEv>
  BlockingMutexLock l(&mtx_);
  CHECK_LT(tid, n_contexts_);
  41219e:	44 8b 45 70          	mov    0x70(%rbp),%r8d
  4121a2:	89 d9                	mov    %ebx,%ecx
  4121a4:	4c 39 c1             	cmp    %r8,%rcx
  4121a7:	0f 83 87 00 00 00    	jae    412234 <_ZN11__sanitizer14ThreadRegistry12DetachThreadEjPv+0xb4>
  ThreadContextBase *tctx = threads_[tid];
  4121ad:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
  4121b4:	48 8b 1c c8          	mov    (%rax,%rcx,8),%rbx
  CHECK_NE(tctx, 0);
  4121b8:	48 85 db             	test   %rbx,%rbx
  4121bb:	0f 84 8b 00 00 00    	je     41224c <_ZN11__sanitizer14ThreadRegistry12DetachThreadEjPv+0xcc>
  if (tctx->status == ThreadStatusInvalid) {
  4121c1:	8b 43 70             	mov    0x70(%rbx),%eax
  4121c4:	85 c0                	test   %eax,%eax
  4121c6:	74 28                	je     4121f0 <_ZN11__sanitizer14ThreadRegistry12DetachThreadEjPv+0x70>
    Report("%s: Detach of non-existent thread\n", SanitizerToolName);
    return;
  }
  tctx->OnDetached(arg);
  4121c8:	48 8b 03             	mov    (%rbx),%rax
  4121cb:	4c 89 ee             	mov    %r13,%rsi
  4121ce:	48 89 df             	mov    %rbx,%rdi
  4121d1:	ff 50 30             	callq  *0x30(%rax)
  if (tctx->status == ThreadStatusFinished) {
  4121d4:	83 7b 70 03          	cmpl   $0x3,0x70(%rbx)
  4121d8:	74 36                	je     412210 <_ZN11__sanitizer14ThreadRegistry12DetachThreadEjPv+0x90>
    tctx->SetDead();
    QuarantinePush(tctx);
  } else {
    tctx->detached = true;
  4121da:	c6 43 74 01          	movb   $0x1,0x74(%rbx)
  }
}
  4121de:	48 83 c4 08          	add    $0x8,%rsp
  }

  ~GenericScopedLock() {
    mu_->Unlock();
  4121e2:	4c 89 e7             	mov    %r12,%rdi
  4121e5:	5b                   	pop    %rbx
  4121e6:	5d                   	pop    %rbp
  4121e7:	41 5c                	pop    %r12
  4121e9:	41 5d                	pop    %r13
  4121eb:	e9 30 97 ff ff       	jmpq   40b920 <_ZN11__sanitizer13BlockingMutex6UnlockEv>
  BlockingMutexLock l(&mtx_);
  CHECK_LT(tid, n_contexts_);
  ThreadContextBase *tctx = threads_[tid];
  CHECK_NE(tctx, 0);
  if (tctx->status == ThreadStatusInvalid) {
    Report("%s: Detach of non-existent thread\n", SanitizerToolName);
  4121f0:	48 8b 05 b9 c0 00 00 	mov    0xc0b9(%rip),%rax        # 41e2b0 <_DYNAMIC+0x2b0>
  4121f7:	48 8d 3d 92 5f 00 00 	lea    0x5f92(%rip),%rdi        # 418190 <.LC17>
  4121fe:	48 8b 30             	mov    (%rax),%rsi
  412201:	31 c0                	xor    %eax,%eax
  412203:	e8 88 b8 ff ff       	callq  40da90 <_ZN11__sanitizer6ReportEPKcz>
  412208:	eb d4                	jmp    4121de <_ZN11__sanitizer14ThreadRegistry12DetachThreadEjPv+0x5e>
  41220a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
void ThreadContextBase::SetDead() {
  CHECK(status == ThreadStatusRunning ||
        status == ThreadStatusFinished);
  status = ThreadStatusDead;
  user_id = 0;
  OnDead();
  412210:	48 8b 03             	mov    (%rbx),%rax
  412213:	48 89 df             	mov    %rbx,%rdi
}

void ThreadContextBase::SetDead() {
  CHECK(status == ThreadStatusRunning ||
        status == ThreadStatusFinished);
  status = ThreadStatusDead;
  412216:	c7 43 70 04 00 00 00 	movl   $0x4,0x70(%rbx)
  user_id = 0;
  41221d:	48 c7 43 28 00 00 00 	movq   $0x0,0x28(%rbx)
  412224:	00 
  OnDead();
  412225:	ff 10                	callq  *(%rax)
    return;
  }
  tctx->OnDetached(arg);
  if (tctx->status == ThreadStatusFinished) {
    tctx->SetDead();
    QuarantinePush(tctx);
  412227:	48 89 de             	mov    %rbx,%rsi
  41222a:	48 89 ef             	mov    %rbp,%rdi
  41222d:	e8 de fd ff ff       	callq  412010 <_ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE>
  412232:	eb aa                	jmp    4121de <_ZN11__sanitizer14ThreadRegistry12DetachThreadEjPv+0x5e>
  }
}

void ThreadRegistry::DetachThread(u32 tid, void *arg) {
  BlockingMutexLock l(&mtx_);
  CHECK_LT(tid, n_contexts_);
  412234:	48 8d 15 9a 6e 00 00 	lea    0x6e9a(%rip),%rdx        # 4190d5 <.LC12>
  41223b:	48 8d 3d 16 5d 00 00 	lea    0x5d16(%rip),%rdi        # 417f58 <.LC1>
  412242:	be df 00 00 00       	mov    $0xdf,%esi
  412247:	e8 a4 31 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  ThreadContextBase *tctx = threads_[tid];
  CHECK_NE(tctx, 0);
  41224c:	48 8d 15 3a 6e 00 00 	lea    0x6e3a(%rip),%rdx        # 41908d <.LC7>
  412253:	48 8d 3d fe 5c 00 00 	lea    0x5cfe(%rip),%rdi        # 417f58 <.LC1>
  41225a:	45 31 c0             	xor    %r8d,%r8d
  41225d:	31 c9                	xor    %ecx,%ecx
  41225f:	be e1 00 00 00       	mov    $0xe1,%esi
  412264:	e8 87 31 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  412269:	90                   	nop
  41226a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000412270 <_ZN11__sanitizer14ThreadRegistry12FinishThreadEj>:
  }
  tctx->SetJoined(arg);
  QuarantinePush(tctx);
}

void ThreadRegistry::FinishThread(u32 tid) {
  412270:	41 54                	push   %r12
  BlockingMutexLock l(&mtx_);
  412272:	4c 8d 67 18          	lea    0x18(%rdi),%r12
  }
  tctx->SetJoined(arg);
  QuarantinePush(tctx);
}

void ThreadRegistry::FinishThread(u32 tid) {
  412276:	55                   	push   %rbp
  412277:	48 89 fd             	mov    %rdi,%rbp
template<typename MutexType>
class GenericScopedLock {
 public:
  explicit GenericScopedLock(MutexType *mu)
      : mu_(mu) {
    mu_->Lock();
  41227a:	4c 89 e7             	mov    %r12,%rdi
  41227d:	53                   	push   %rbx
  41227e:	89 f3                	mov    %esi,%ebx
  412280:	e8 2b 96 ff ff       	callq  40b8b0 <_ZN11__sanitizer13BlockingMutex4LockEv>
  BlockingMutexLock l(&mtx_);
  CHECK_GT(alive_threads_, 0);
  412285:	48 8b 85 80 00 00 00 	mov    0x80(%rbp),%rax
  41228c:	48 85 c0             	test   %rax,%rax
  41228f:	0f 84 ce 00 00 00    	je     412363 <_ZN11__sanitizer14ThreadRegistry12FinishThreadEj+0xf3>
  alive_threads_--;
  412295:	48 83 e8 01          	sub    $0x1,%rax
  412299:	48 89 85 80 00 00 00 	mov    %rax,0x80(%rbp)
  CHECK_GT(running_threads_, 0);
  4122a0:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
  4122a7:	48 85 c0             	test   %rax,%rax
  4122aa:	0f 84 22 01 00 00    	je     4123d2 <_ZN11__sanitizer14ThreadRegistry12FinishThreadEj+0x162>
  running_threads_--;
  CHECK_LT(tid, n_contexts_);
  4122b0:	44 8b 45 70          	mov    0x70(%rbp),%r8d
  4122b4:	89 d9                	mov    %ebx,%ecx
void ThreadRegistry::FinishThread(u32 tid) {
  BlockingMutexLock l(&mtx_);
  CHECK_GT(alive_threads_, 0);
  alive_threads_--;
  CHECK_GT(running_threads_, 0);
  running_threads_--;
  4122b6:	48 83 e8 01          	sub    $0x1,%rax
  4122ba:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
  CHECK_LT(tid, n_contexts_);
  4122c1:	4c 39 c1             	cmp    %r8,%rcx
  4122c4:	0f 83 f0 00 00 00    	jae    4123ba <_ZN11__sanitizer14ThreadRegistry12FinishThreadEj+0x14a>
  ThreadContextBase *tctx = threads_[tid];
  4122ca:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
  4122d1:	48 8b 1c c8          	mov    (%rax,%rcx,8),%rbx
  CHECK_NE(tctx, 0);
  4122d5:	48 85 db             	test   %rbx,%rbx
  4122d8:	0f 84 bf 00 00 00    	je     41239d <_ZN11__sanitizer14ThreadRegistry12FinishThreadEj+0x12d>
  CHECK_EQ(ThreadStatusRunning, tctx->status);
  4122de:	44 8b 43 70          	mov    0x70(%rbx),%r8d
  4122e2:	49 83 f8 02          	cmp    $0x2,%r8
  4122e6:	0f 85 94 00 00 00    	jne    412380 <_ZN11__sanitizer14ThreadRegistry12FinishThreadEj+0x110>
  user_id = 0;
  OnJoined(arg);
}

void ThreadContextBase::SetFinished() {
  if (!detached)
  4122ec:	80 7b 74 00          	cmpb   $0x0,0x74(%rbx)
  4122f0:	74 1e                	je     412310 <_ZN11__sanitizer14ThreadRegistry12FinishThreadEj+0xa0>
    status = ThreadStatusFinished;
  OnFinished();
  4122f2:	48 8b 03             	mov    (%rbx),%rax
  4122f5:	48 89 df             	mov    %rbx,%rdi
  4122f8:	ff 50 10             	callq  *0x10(%rax)
  CHECK_LT(tid, n_contexts_);
  ThreadContextBase *tctx = threads_[tid];
  CHECK_NE(tctx, 0);
  CHECK_EQ(ThreadStatusRunning, tctx->status);
  tctx->SetFinished();
  if (tctx->detached) {
  4122fb:	80 7b 74 00          	cmpb   $0x0,0x74(%rbx)
  4122ff:	75 25                	jne    412326 <_ZN11__sanitizer14ThreadRegistry12FinishThreadEj+0xb6>
    tctx->SetDead();
    QuarantinePush(tctx);
  }
}
  412301:	5b                   	pop    %rbx
  412302:	5d                   	pop    %rbp
  }

  ~GenericScopedLock() {
    mu_->Unlock();
  412303:	4c 89 e7             	mov    %r12,%rdi
  412306:	41 5c                	pop    %r12
  412308:	e9 13 96 ff ff       	jmpq   40b920 <_ZN11__sanitizer13BlockingMutex6UnlockEv>
  41230d:	0f 1f 00             	nopl   (%rax)
}

void ThreadContextBase::SetFinished() {
  if (!detached)
    status = ThreadStatusFinished;
  OnFinished();
  412310:	48 8b 03             	mov    (%rbx),%rax
  OnJoined(arg);
}

void ThreadContextBase::SetFinished() {
  if (!detached)
    status = ThreadStatusFinished;
  412313:	c7 43 70 03 00 00 00 	movl   $0x3,0x70(%rbx)
  OnFinished();
  41231a:	48 89 df             	mov    %rbx,%rdi
  41231d:	ff 50 10             	callq  *0x10(%rax)
  CHECK_LT(tid, n_contexts_);
  ThreadContextBase *tctx = threads_[tid];
  CHECK_NE(tctx, 0);
  CHECK_EQ(ThreadStatusRunning, tctx->status);
  tctx->SetFinished();
  if (tctx->detached) {
  412320:	80 7b 74 00          	cmpb   $0x0,0x74(%rbx)
  412324:	74 db                	je     412301 <_ZN11__sanitizer14ThreadRegistry12FinishThreadEj+0x91>
    name[sizeof(name) - 1] = '\0';
  }
}

void ThreadContextBase::SetDead() {
  CHECK(status == ThreadStatusRunning ||
  412326:	8b 43 70             	mov    0x70(%rbx),%eax
  412329:	83 e8 02             	sub    $0x2,%eax
  41232c:	83 f8 01             	cmp    $0x1,%eax
  41232f:	0f 87 ba 00 00 00    	ja     4123ef <_ZN11__sanitizer14ThreadRegistry12FinishThreadEj+0x17f>
        status == ThreadStatusFinished);
  status = ThreadStatusDead;
  user_id = 0;
  OnDead();
  412335:	48 8b 03             	mov    (%rbx),%rax
  412338:	48 89 df             	mov    %rbx,%rdi
}

void ThreadContextBase::SetDead() {
  CHECK(status == ThreadStatusRunning ||
        status == ThreadStatusFinished);
  status = ThreadStatusDead;
  41233b:	c7 43 70 04 00 00 00 	movl   $0x4,0x70(%rbx)
  user_id = 0;
  412342:	48 c7 43 28 00 00 00 	movq   $0x0,0x28(%rbx)
  412349:	00 
  OnDead();
  41234a:	ff 10                	callq  *(%rax)
  CHECK_NE(tctx, 0);
  CHECK_EQ(ThreadStatusRunning, tctx->status);
  tctx->SetFinished();
  if (tctx->detached) {
    tctx->SetDead();
    QuarantinePush(tctx);
  41234c:	48 89 ef             	mov    %rbp,%rdi
  41234f:	48 89 de             	mov    %rbx,%rsi
  412352:	e8 b9 fc ff ff       	callq  412010 <_ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE>
  }
}
  412357:	5b                   	pop    %rbx
  412358:	5d                   	pop    %rbp
  412359:	4c 89 e7             	mov    %r12,%rdi
  41235c:	41 5c                	pop    %r12
  41235e:	e9 bd 95 ff ff       	jmpq   40b920 <_ZN11__sanitizer13BlockingMutex6UnlockEv>
  QuarantinePush(tctx);
}

void ThreadRegistry::FinishThread(u32 tid) {
  BlockingMutexLock l(&mtx_);
  CHECK_GT(alive_threads_, 0);
  412363:	48 8d 15 85 6d 00 00 	lea    0x6d85(%rip),%rdx        # 4190ef <.LC18>
  41236a:	48 8d 3d e7 5b 00 00 	lea    0x5be7(%rip),%rdi        # 417f58 <.LC1>
  412371:	45 31 c0             	xor    %r8d,%r8d
  412374:	31 c9                	xor    %ecx,%ecx
  412376:	be fe 00 00 00       	mov    $0xfe,%esi
  41237b:	e8 70 30 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  CHECK_GT(running_threads_, 0);
  running_threads_--;
  CHECK_LT(tid, n_contexts_);
  ThreadContextBase *tctx = threads_[tid];
  CHECK_NE(tctx, 0);
  CHECK_EQ(ThreadStatusRunning, tctx->status);
  412380:	48 8d 15 51 5d 00 00 	lea    0x5d51(%rip),%rdx        # 4180d8 <.LC13>
  412387:	48 8d 3d ca 5b 00 00 	lea    0x5bca(%rip),%rdi        # 417f58 <.LC1>
  41238e:	b9 02 00 00 00       	mov    $0x2,%ecx
  412393:	be 05 01 00 00       	mov    $0x105,%esi
  412398:	e8 53 30 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  alive_threads_--;
  CHECK_GT(running_threads_, 0);
  running_threads_--;
  CHECK_LT(tid, n_contexts_);
  ThreadContextBase *tctx = threads_[tid];
  CHECK_NE(tctx, 0);
  41239d:	48 8d 15 e9 6c 00 00 	lea    0x6ce9(%rip),%rdx        # 41908d <.LC7>
  4123a4:	48 8d 3d ad 5b 00 00 	lea    0x5bad(%rip),%rdi        # 417f58 <.LC1>
  4123ab:	45 31 c0             	xor    %r8d,%r8d
  4123ae:	31 c9                	xor    %ecx,%ecx
  4123b0:	be 04 01 00 00       	mov    $0x104,%esi
  4123b5:	e8 36 30 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  BlockingMutexLock l(&mtx_);
  CHECK_GT(alive_threads_, 0);
  alive_threads_--;
  CHECK_GT(running_threads_, 0);
  running_threads_--;
  CHECK_LT(tid, n_contexts_);
  4123ba:	48 8d 15 14 6d 00 00 	lea    0x6d14(%rip),%rdx        # 4190d5 <.LC12>
  4123c1:	48 8d 3d 90 5b 00 00 	lea    0x5b90(%rip),%rdi        # 417f58 <.LC1>
  4123c8:	be 02 01 00 00       	mov    $0x102,%esi
  4123cd:	e8 1e 30 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>

void ThreadRegistry::FinishThread(u32 tid) {
  BlockingMutexLock l(&mtx_);
  CHECK_GT(alive_threads_, 0);
  alive_threads_--;
  CHECK_GT(running_threads_, 0);
  4123d2:	48 8d 15 31 6d 00 00 	lea    0x6d31(%rip),%rdx        # 41910a <.LC19>
  4123d9:	48 8d 3d 78 5b 00 00 	lea    0x5b78(%rip),%rdi        # 417f58 <.LC1>
  4123e0:	45 31 c0             	xor    %r8d,%r8d
  4123e3:	31 c9                	xor    %ecx,%ecx
  4123e5:	be 00 01 00 00       	mov    $0x100,%esi
  4123ea:	e8 01 30 ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
    name[sizeof(name) - 1] = '\0';
  }
}

void ThreadContextBase::SetDead() {
  CHECK(status == ThreadStatusRunning ||
  4123ef:	48 8d 15 da 5b 00 00 	lea    0x5bda(%rip),%rdx        # 417fd0 <.LC2>
  4123f6:	48 8d 3d 5b 5b 00 00 	lea    0x5b5b(%rip),%rdi        # 417f58 <.LC1>
  4123fd:	45 31 c0             	xor    %r8d,%r8d
  412400:	31 c9                	xor    %ecx,%ecx
  412402:	be 29 00 00 00       	mov    $0x29,%esi
  412407:	e8 e4 2f ff ff       	callq  4053f0 <_ZN11__sanitizer11CheckFailedEPKciS1_yy>
  41240c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000412410 <_ZN11__sanitizer14ThreadRegistry13QuarantinePopEv>:
    return;
  invalid_threads_.push_back(tctx);
}

ThreadContextBase *ThreadRegistry::QuarantinePop() {
  if (invalid_threads_.size() == 0)
  412410:	48 8b 97 b8 00 00 00 	mov    0xb8(%rdi),%rdx
    return 0;
  412417:	31 c0                	xor    %eax,%eax
    return;
  invalid_threads_.push_back(tctx);
}

ThreadContextBase *ThreadRegistry::QuarantinePop() {
  if (invalid_threads_.size() == 0)
  412419:	48 85 d2             	test   %rdx,%rdx
  41241c:	74 25                	je     412443 <_ZN11__sanitizer14ThreadRegistry13QuarantinePopEv+0x33>
  41241e:	48 8b 87 c0 00 00 00 	mov    0xc0(%rdi),%rax
    }
  }

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
  412425:	48 8b 88 80 00 00 00 	mov    0x80(%rax),%rcx
    if (!first_)
  41242c:	48 85 c9             	test   %rcx,%rcx
    }
  }

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
  41242f:	48 89 8f c0 00 00 00 	mov    %rcx,0xc0(%rdi)
    if (!first_)
  412436:	74 10                	je     412448 <_ZN11__sanitizer14ThreadRegistry13QuarantinePopEv+0x38>
      last_ = nullptr;
    size_--;
  412438:	48 83 ea 01          	sub    $0x1,%rdx
  41243c:	48 89 97 b8 00 00 00 	mov    %rdx,0xb8(%rdi)
    return 0;
  ThreadContextBase *tctx = invalid_threads_.front();
  invalid_threads_.pop_front();
  return tctx;
}
  412443:	f3 c3                	repz retq 
  412445:	0f 1f 00             	nopl   (%rax)

  void pop_front() {
    CHECK(!empty());
    first_ = first_->next;
    if (!first_)
      last_ = nullptr;
  412448:	48 c7 87 c8 00 00 00 	movq   $0x0,0xc8(%rdi)
  41244f:	00 00 00 00 
  412453:	eb e3                	jmp    412438 <_ZN11__sanitizer14ThreadRegistry13QuarantinePopEv+0x28>
  412455:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  41245c:	00 00 00 00 

0000000000412460 <_ZN11__sanitizer17ThreadContextBase6OnDeadEv>:
  void Reset();

  // The following methods may be overriden by subclasses.
  // Some of them take opaque arg that may be optionally be used
  // by subclasses.
  virtual void OnDead() {}
  412460:	f3 c3                	repz retq 
  412462:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  412469:	1f 84 00 00 00 00 00 

0000000000412470 <_ZN11__sanitizer17ThreadContextBase8OnJoinedEPv>:
  virtual void OnJoined(void *arg) {}
  412470:	f3 c3                	repz retq 
  412472:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  412479:	1f 84 00 00 00 00 00 

0000000000412480 <_ZN11__sanitizer17ThreadContextBase10OnFinishedEv>:
  virtual void OnFinished() {}
  412480:	f3 c3                	repz retq 
  412482:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  412489:	1f 84 00 00 00 00 00 

0000000000412490 <_ZN11__sanitizer17ThreadContextBase9OnStartedEPv>:
  virtual void OnStarted(void *arg) {}
  412490:	f3 c3                	repz retq 
  412492:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  412499:	1f 84 00 00 00 00 00 

00000000004124a0 <_ZN11__sanitizer17ThreadContextBase9OnCreatedEPv>:
  virtual void OnCreated(void *arg) {}
  4124a0:	f3 c3                	repz retq 
  4124a2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4124a9:	1f 84 00 00 00 00 00 

00000000004124b0 <_ZN11__sanitizer17ThreadContextBase7OnResetEv>:
  virtual void OnReset() {}
  4124b0:	f3 c3                	repz retq 
  4124b2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4124b9:	1f 84 00 00 00 00 00 

00000000004124c0 <_ZN11__sanitizer17ThreadContextBase10OnDetachedEPv>:
  virtual void OnDetached(void *arg) {}
  4124c0:	f3 c3                	repz retq 
  4124c2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4124c9:	1f 84 00 00 00 00 00 

00000000004124d0 <_ZN11__sanitizer13WriteToSyslogEPKc>:
#include "sanitizer_libc.h"

namespace __sanitizer {

#if SANITIZER_LINUX
void WriteToSyslog(const char *buffer) {}
  4124d0:	f3 c3                	repz retq 
  4124d2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4124d9:	1f 84 00 00 00 00 00 

00000000004124e0 <_ZN11__sanitizer5AbortEv>:
#endif

void Abort() { internal__exit(1); }
  4124e0:	48 83 ec 08          	sub    $0x8,%rsp
  4124e4:	bf 01 00 00 00       	mov    $0x1,%edi
  4124e9:	e8 42 91 ff ff       	callq  40b630 <_ZN11__sanitizer14internal__exitEi>
  4124ee:	66 90                	xchg   %ax,%ax

00000000004124f0 <_Z14dummy_functioni>:

StructPtr_t *struct_ptr;

void
dummy_function(int i)
{
  4124f0:	55                   	push   %rbp
  4124f1:	48 89 e5             	mov    %rsp,%rbp
  4124f4:	89 f9                	mov    %edi,%ecx
	printf("Number is %d \n", i);
  4124f6:	bf b8 81 41 00       	mov    $0x4181b8,%edi
  4124fb:	31 c0                	xor    %eax,%eax
  4124fd:	89 ce                	mov    %ecx,%esi
  4124ff:	e8 7c fd fe ff       	callq  402280 <printf@plt>
	//return i+1;
}
  412504:	5d                   	pop    %rbp
  412505:	c3                   	retq   
  412506:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  41250d:	00 00 00 

0000000000412510 <_Z18allocate_structurev>:

void
allocate_structure() {
  412510:	55                   	push   %rbp
  412511:	48 89 e5             	mov    %rsp,%rbp
  412514:	41 57                	push   %r15
  412516:	41 56                	push   %r14
  412518:	41 55                	push   %r13
  41251a:	41 54                	push   %r12
  41251c:	53                   	push   %rbx
  41251d:	50                   	push   %rax
  41251e:	49 c7 c4 e0 fe ff ff 	mov    $0xfffffffffffffee0,%r12
  412525:	64 4d 8b 2c 24       	mov    %fs:(%r12),%r13
  41252a:	4c 89 eb             	mov    %r13,%rbx
  41252d:	48 83 e3 c0          	and    $0xffffffffffffffc0,%rbx
  412531:	4c 8d 73 c0          	lea    -0x40(%rbx),%r14
  412535:	64 4d 89 34 24       	mov    %r14,%fs:(%r12)
        int i = 10;
  41253a:	be 04 00 00 00       	mov    $0x4,%esi
  41253f:	4c 89 f7             	mov    %r14,%rdi
  412542:	e8 19 1d 00 00       	callq  414260 <dang_init_heapobj>
  412547:	c7 43 c0 0a 00 00 00 	movl   $0xa,-0x40(%rbx)
        printf("Application Stack address 2 %p\n", &i);
  41254e:	bf c8 81 41 00       	mov    $0x4181c8,%edi
  412553:	31 c0                	xor    %eax,%eax
  412555:	4c 89 f6             	mov    %r14,%rsi
  412558:	e8 23 fd fe ff       	callq  402280 <printf@plt>
	struct_ptr = (StructPtr_t *)malloc(sizeof(StructPtr_t));
  41255d:	bf 08 00 00 00       	mov    $0x8,%edi
  412562:	e8 29 fd fe ff       	callq  402290 <malloc@plt>
  412567:	48 89 c3             	mov    %rax,%rbx
  41256a:	bf 80 1e e7 00       	mov    $0xe71e80,%edi
  41256f:	48 89 de             	mov    %rbx,%rsi
  412572:	e8 e9 21 00 00       	callq  414760 <inlinedang_registerptr>
  412577:	48 89 1d 02 f9 a5 00 	mov    %rbx,0xa5f902(%rip)        # e71e80 <struct_ptr>
	if (struct_ptr == NULL) {
  41257e:	48 85 db             	test   %rbx,%rbx
  412581:	74 5a                	je     4125dd <_Z18allocate_structurev+0xcd>
		perror("Structure cannnot be allocated \n");
		exit(EXIT_FAILURE);
	}
	struct_ptr->ptr = (char *)malloc(sizeof(char)*(strlen(DBG_MSG) + 1));
  412583:	bf 0c 00 00 00       	mov    $0xc,%edi
  412588:	e8 03 fd fe ff       	callq  402290 <malloc@plt>
  41258d:	49 89 c7             	mov    %rax,%r15
  412590:	48 89 df             	mov    %rbx,%rdi
  412593:	4c 89 fe             	mov    %r15,%rsi
  412596:	e8 c5 21 00 00       	callq  414760 <inlinedang_registerptr>
  41259b:	4c 89 3b             	mov    %r15,(%rbx)
	strncpy(struct_ptr->ptr, DBG_MSG, strlen(DBG_MSG) + 1);
  41259e:	48 8b 05 db f8 a5 00 	mov    0xa5f8db(%rip),%rax        # e71e80 <struct_ptr>
  4125a5:	48 8b 00             	mov    (%rax),%rax
  4125a8:	48 b9 48 65 6c 6c 6f 	movabs $0x6f57206f6c6c6548,%rcx
  4125af:	20 57 6f 
  4125b2:	48 89 08             	mov    %rcx,(%rax)
  4125b5:	c7 40 08 72 6c 64 00 	movl   $0x646c72,0x8(%rax)
}
  4125bc:	be 04 00 00 00       	mov    $0x4,%esi
  4125c1:	4c 89 f7             	mov    %r14,%rdi
  4125c4:	e8 27 1e 00 00       	callq  4143f0 <dang_freeptr>
  4125c9:	64 4d 89 2c 24       	mov    %r13,%fs:(%r12)
  4125ce:	48 83 c4 08          	add    $0x8,%rsp
  4125d2:	5b                   	pop    %rbx
  4125d3:	41 5c                	pop    %r12
  4125d5:	41 5d                	pop    %r13
  4125d7:	41 5e                	pop    %r14
  4125d9:	41 5f                	pop    %r15
  4125db:	5d                   	pop    %rbp
  4125dc:	c3                   	retq   
allocate_structure() {
        int i = 10;
        printf("Application Stack address 2 %p\n", &i);
	struct_ptr = (StructPtr_t *)malloc(sizeof(StructPtr_t));
	if (struct_ptr == NULL) {
		perror("Structure cannnot be allocated \n");
  4125dd:	bf e8 81 41 00       	mov    $0x4181e8,%edi
  4125e2:	e8 b9 fc fe ff       	callq  4022a0 <perror@plt>
		exit(EXIT_FAILURE);
  4125e7:	bf 01 00 00 00       	mov    $0x1,%edi
  4125ec:	e8 bf fc fe ff       	callq  4022b0 <exit@plt>
  4125f1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4125f8:	0f 1f 84 00 00 00 00 
  4125ff:	00 

0000000000412600 <_Z9loop_testPc>:

char *loop_ptr;

void
loop_test(char *msg)
{
  412600:	55                   	push   %rbp
  412601:	48 89 e5             	mov    %rsp,%rbp
  412604:	53                   	push   %rbx
  412605:	50                   	push   %rax
  412606:	48 89 fb             	mov    %rdi,%rbx
    loop_ptr = msg;
  412609:	bf 88 1e e7 00       	mov    $0xe71e88,%edi
  41260e:	48 89 de             	mov    %rbx,%rsi
  412611:	e8 4a 21 00 00       	callq  414760 <inlinedang_registerptr>
  412616:	eb 1e                	jmp    412636 <_Z9loop_testPc+0x36>
  412618:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  41261f:	00 
    while (*loop_ptr != '\0') {
        printf("%c ", *loop_ptr);
  412620:	bf 20 82 41 00       	mov    $0x418220,%edi
  412625:	31 c0                	xor    %eax,%eax
  412627:	e8 54 fc fe ff       	callq  402280 <printf@plt>
        loop_ptr += 1;
  41262c:	48 8b 1d 55 f8 a5 00 	mov    0xa5f855(%rip),%rbx        # e71e88 <loop_ptr>
  412633:	48 ff c3             	inc    %rbx
char *loop_ptr;

void
loop_test(char *msg)
{
    loop_ptr = msg;
  412636:	48 89 1d 4b f8 a5 00 	mov    %rbx,0xa5f84b(%rip)        # e71e88 <loop_ptr>
    while (*loop_ptr != '\0') {
        printf("%c ", *loop_ptr);
  41263d:	0f be 33             	movsbl (%rbx),%esi
  412640:	85 f6                	test   %esi,%esi
  412642:	75 dc                	jne    412620 <_Z9loop_testPc+0x20>
        loop_ptr += 1;
    }
    printf("\n");
  412644:	bf 0a 00 00 00       	mov    $0xa,%edi
  412649:	e8 72 fc fe ff       	callq  4022c0 <putchar@plt>
    return;
  41264e:	48 83 c4 08          	add    $0x8,%rsp
  412652:	5b                   	pop    %rbx
  412653:	5d                   	pop    %rbp
  412654:	c3                   	retq   
  412655:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  41265c:	00 00 00 00 

0000000000412660 <main>:
}
    

int
main(int argc, char *argv[])
{
  412660:	55                   	push   %rbp
  412661:	48 89 e5             	mov    %rsp,%rbp
  412664:	41 57                	push   %r15
  412666:	41 56                	push   %r14
  412668:	41 55                	push   %r13
  41266a:	41 54                	push   %r12
  41266c:	53                   	push   %rbx
  41266d:	50                   	push   %rax
  41266e:	49 c7 c7 e0 fe ff ff 	mov    $0xfffffffffffffee0,%r15
  412675:	64 4d 8b 27          	mov    %fs:(%r15),%r12
  412679:	4c 89 e3             	mov    %r12,%rbx
  41267c:	48 83 e3 c0          	and    $0xffffffffffffffc0,%rbx
  412680:	4c 8d 73 c0          	lea    -0x40(%rbx),%r14
  412684:	64 4d 89 37          	mov    %r14,%fs:(%r15)
	/* Local LHS function pointer */
	void (*function_ptr)(int) = dummy_function;
        int i = 10;
  412688:	be 04 00 00 00       	mov    $0x4,%esi
  41268d:	4c 89 f7             	mov    %r14,%rdi
  412690:	e8 cb 1b 00 00       	callq  414260 <dang_init_heapobj>
  412695:	c7 43 c0 0a 00 00 00 	movl   $0xa,-0x40(%rbx)
        printf("Application Stack address 1 %p\n", &i);
  41269c:	bf 28 82 41 00       	mov    $0x418228,%edi
	function_ptr_global = dummy_function;
	function_ptr_global(3);
        
        /* Using freed memory */
        //printf("Using freed object %s and %s\n", msg, struct_ptr->ptr);
	return 0;
  4126a1:	31 c0                	xor    %eax,%eax
main(int argc, char *argv[])
{
	/* Local LHS function pointer */
	void (*function_ptr)(int) = dummy_function;
        int i = 10;
        printf("Application Stack address 1 %p\n", &i);
  4126a3:	4c 89 f6             	mov    %r14,%rsi
  4126a6:	e8 d5 fb fe ff       	callq  402280 <printf@plt>
	//char 	*ptr_str;
	
	allocate_structure();
  4126ab:	e8 60 fe ff ff       	callq  412510 <_Z18allocate_structurev>
	/* Return value of the malloc is not stored in the local variable.
 	 * Thus, store instruction will be used to store return value of
 	 * the malloc (even in -03).
 	 * Result : Correctly figure its out.
 	 */
	msg = (char *)malloc(sizeof(char) * (strlen(DBG_MSG) + 1));
  4126b0:	bf 0c 00 00 00       	mov    $0xc,%edi
  4126b5:	e8 d6 fb fe ff       	callq  402290 <malloc@plt>
  4126ba:	48 89 c3             	mov    %rax,%rbx
  4126bd:	bf 60 1e e7 00       	mov    $0xe71e60,%edi
  4126c2:	48 89 de             	mov    %rbx,%rsi
  4126c5:	e8 96 20 00 00       	callq  414760 <inlinedang_registerptr>
  4126ca:	48 89 1d 8f f7 a5 00 	mov    %rbx,0xa5f78f(%rip)        # e71e60 <msg>
 	 * be used. lhs is non-stack pointer.
 	 * TODO: This operation when -O3 is opted will have proper rhs and lhs
 	 * pointer. But when no optimization is asked,it will have first
 	 * type cast msg pointer to 64 bit integer.
 	 */
	ptr_str = msg;	/* Start from 'World' */
  4126d1:	bf 58 1e e7 00       	mov    $0xe71e58,%edi
  4126d6:	48 89 de             	mov    %rbx,%rsi
  4126d9:	e8 82 20 00 00       	callq  414760 <inlinedang_registerptr>
  4126de:	48 89 1d 73 f7 a5 00 	mov    %rbx,0xa5f773(%rip)        # e71e58 <ptr_str>
	
	/* Copy Global string and print the message */
	strncpy(msg, DBG_MSG, (strlen(DBG_MSG)+1));
  4126e5:	48 b8 48 65 6c 6c 6f 	movabs $0x6f57206f6c6c6548,%rax
  4126ec:	20 57 6f 
  4126ef:	48 89 03             	mov    %rax,(%rbx)
  4126f2:	c7 43 08 72 6c 64 00 	movl   $0x646c72,0x8(%rbx)
	printf("Addr %p %p:%s \n", &msg, msg, msg);
  4126f9:	bf 48 82 41 00       	mov    $0x418248,%edi
	/* Return value of the malloc is not stored in the local variable.
 	 * Thus, store instruction will be used to store return value of
 	 * the malloc (even in -03).
 	 * Result : Correctly figure its out.
 	 */
	msg = (char *)malloc(sizeof(char) * (strlen(DBG_MSG) + 1));
  4126fe:	be 60 1e e7 00       	mov    $0xe71e60,%esi
	function_ptr_global = dummy_function;
	function_ptr_global(3);
        
        /* Using freed memory */
        //printf("Using freed object %s and %s\n", msg, struct_ptr->ptr);
	return 0;
  412703:	31 c0                	xor    %eax,%eax
 	 */
	ptr_str = msg;	/* Start from 'World' */
	
	/* Copy Global string and print the message */
	strncpy(msg, DBG_MSG, (strlen(DBG_MSG)+1));
	printf("Addr %p %p:%s \n", &msg, msg, msg);
  412705:	48 89 da             	mov    %rbx,%rdx
  412708:	48 89 d9             	mov    %rbx,%rcx
  41270b:	e8 70 fb fe ff       	callq  402280 <printf@plt>
        //loop_test(msg);
	
	*ptr_str = 'C'; 	/* Use is required otherwise compiler will remove dead code */
  412710:	48 8b 05 41 f7 a5 00 	mov    0xa5f741(%rip),%rax        # e71e58 <ptr_str>
  412717:	c6 00 43             	movb   $0x43,(%rax)
	
	/* RHS is a Pointer arithmatic with constant offset. 
 	 * This is tracked properly with and without optimization.
 	 */
	ptr_str = msg + 1;
  41271a:	4c 8b 2d 3f f7 a5 00 	mov    0xa5f73f(%rip),%r13        # e71e60 <msg>
  412721:	49 8d 5d 01          	lea    0x1(%r13),%rbx
 	 * be used. lhs is non-stack pointer.
 	 * TODO: This operation when -O3 is opted will have proper rhs and lhs
 	 * pointer. But when no optimization is asked,it will have first
 	 * type cast msg pointer to 64 bit integer.
 	 */
	ptr_str = msg;	/* Start from 'World' */
  412725:	bf 58 1e e7 00       	mov    $0xe71e58,%edi
	*ptr_str = 'C'; 	/* Use is required otherwise compiler will remove dead code */
	
	/* RHS is a Pointer arithmatic with constant offset. 
 	 * This is tracked properly with and without optimization.
 	 */
	ptr_str = msg + 1;
  41272a:	48 89 de             	mov    %rbx,%rsi
  41272d:	e8 2e 20 00 00       	callq  414760 <inlinedang_registerptr>
  412732:	48 89 1d 1f f7 a5 00 	mov    %rbx,0xa5f71f(%rip)        # e71e58 <ptr_str>
	*ptr_str = 'C';
  412739:	41 c6 45 01 43       	movb   $0x43,0x1(%r13)
	
	/* RHS is a pointer arithmatic with variable offset.
 	 * This is also tracked properly with and without optimization.
 	 */
	offset = 2;
  41273e:	c7 05 30 f7 a5 00 02 	movl   $0x2,0xa5f730(%rip)        # e71e78 <offset>
  412745:	00 00 00 
	ptr_str = struct_ptr->ptr + offset;
  412748:	48 8b 05 31 f7 a5 00 	mov    0xa5f731(%rip),%rax        # e71e80 <struct_ptr>
  41274f:	48 8b 00             	mov    (%rax),%rax
	*ptr_str = 'C';
  412752:	c6 40 02 43          	movb   $0x43,0x2(%rax)
	/* RHS is variable but not pointer type
 	 * Same as above constant on rhs.
 	 */
	ptr_str = (char *)((long)offset);

	ptr_str = msg;
  412756:	48 8b 1d 03 f7 a5 00 	mov    0xa5f703(%rip),%rbx        # e71e60 <msg>
 	 * be used. lhs is non-stack pointer.
 	 * TODO: This operation when -O3 is opted will have proper rhs and lhs
 	 * pointer. But when no optimization is asked,it will have first
 	 * type cast msg pointer to 64 bit integer.
 	 */
	ptr_str = msg;	/* Start from 'World' */
  41275d:	bf 58 1e e7 00       	mov    $0xe71e58,%edi
	/* RHS is variable but not pointer type
 	 * Same as above constant on rhs.
 	 */
	ptr_str = (char *)((long)offset);

	ptr_str = msg;
  412762:	48 89 de             	mov    %rbx,%rsi
  412765:	e8 f6 1f 00 00       	callq  414760 <inlinedang_registerptr>
  41276a:	48 89 1d e7 f6 a5 00 	mov    %rbx,0xa5f6e7(%rip)        # e71e58 <ptr_str>

	/* free original pointer */
	free(msg);			/* Looks like it zero outs memory object */
  412771:	48 89 df             	mov    %rbx,%rdi
  412774:	e8 57 fb fe ff       	callq  4022d0 <free@plt>
	free(struct_ptr->ptr);
  412779:	48 8b 05 00 f7 a5 00 	mov    0xa5f700(%rip),%rax        # e71e80 <struct_ptr>
  412780:	48 8b 38             	mov    (%rax),%rdi
  412783:	e8 48 fb fe ff       	callq  4022d0 <free@plt>
	ptr_str = struct_ptr->ptr;
  412788:	48 8b 3d f1 f6 a5 00 	mov    0xa5f6f1(%rip),%rdi        # e71e80 <struct_ptr>
  41278f:	48 8b 07             	mov    (%rdi),%rax
  412792:	48 89 05 bf f6 a5 00 	mov    %rax,0xa5f6bf(%rip)        # e71e58 <ptr_str>
	free(struct_ptr);
  412799:	e8 32 fb fe ff       	callq  4022d0 <free@plt>

	/* Now access dangling pointer */
        printf("Addr %p %p\n", msg, struct_ptr);
  41279e:	48 8b 35 bb f6 a5 00 	mov    0xa5f6bb(%rip),%rsi        # e71e60 <msg>
  4127a5:	48 8b 15 d4 f6 a5 00 	mov    0xa5f6d4(%rip),%rdx        # e71e80 <struct_ptr>
  4127ac:	bf 58 82 41 00       	mov    $0x418258,%edi
	function_ptr_global = dummy_function;
	function_ptr_global(3);
        
        /* Using freed memory */
        //printf("Using freed object %s and %s\n", msg, struct_ptr->ptr);
	return 0;
  4127b1:	31 c0                	xor    %eax,%eax
	free(struct_ptr->ptr);
	ptr_str = struct_ptr->ptr;
	free(struct_ptr);

	/* Now access dangling pointer */
        printf("Addr %p %p\n", msg, struct_ptr);
  4127b3:	e8 c8 fa fe ff       	callq  402280 <printf@plt>
    //ptr_str = struct_ptr->ptr;	
	/* RHS global store operation should be skipped */
	printf("Printing global pointer %p %p %p\n", msg, struct_ptr, ptr_str);
  4127b8:	48 8b 35 a1 f6 a5 00 	mov    0xa5f6a1(%rip),%rsi        # e71e60 <msg>
  4127bf:	48 8b 15 ba f6 a5 00 	mov    0xa5f6ba(%rip),%rdx        # e71e80 <struct_ptr>
  4127c6:	48 8b 0d 8b f6 a5 00 	mov    0xa5f68b(%rip),%rcx        # e71e58 <ptr_str>
  4127cd:	bf 68 82 41 00       	mov    $0x418268,%edi
	function_ptr_global = dummy_function;
	function_ptr_global(3);
        
        /* Using freed memory */
        //printf("Using freed object %s and %s\n", msg, struct_ptr->ptr);
	return 0;
  4127d2:	31 c0                	xor    %eax,%eax

	/* Now access dangling pointer */
        printf("Addr %p %p\n", msg, struct_ptr);
    //ptr_str = struct_ptr->ptr;	
	/* RHS global store operation should be skipped */
	printf("Printing global pointer %p %p %p\n", msg, struct_ptr, ptr_str);
  4127d4:	e8 a7 fa fe ff       	callq  402280 <printf@plt>
	*ptr_str = 'C';
	
	/* RHS is a pointer arithmatic with variable offset.
 	 * This is also tracked properly with and without optimization.
 	 */
	offset = 2;
  4127d9:	bf 02 00 00 00       	mov    $0x2,%edi
    //ptr_str = struct_ptr->ptr;	
	/* RHS global store operation should be skipped */
	printf("Printing global pointer %p %p %p\n", msg, struct_ptr, ptr_str);

	/* CAll function ptr */
	function_ptr(2);
  4127de:	e8 0d fd ff ff       	callq  4124f0 <_Z14dummy_functioni>

	/* Check global function pointer assignment */
	function_ptr_global = dummy_function;
  4127e3:	48 c7 05 82 f6 a5 00 	movq   $0x4124f0,0xa5f682(%rip)        # e71e70 <function_ptr_global>
  4127ea:	f0 24 41 00 
StructPtr_t *struct_ptr;

void
dummy_function(int i)
{
	printf("Number is %d \n", i);
  4127ee:	bf b8 81 41 00       	mov    $0x4181b8,%edi
  4127f3:	be 03 00 00 00       	mov    $0x3,%esi
	function_ptr_global = dummy_function;
	function_ptr_global(3);
        
        /* Using freed memory */
        //printf("Using freed object %s and %s\n", msg, struct_ptr->ptr);
	return 0;
  4127f8:	31 c0                	xor    %eax,%eax
StructPtr_t *struct_ptr;

void
dummy_function(int i)
{
	printf("Number is %d \n", i);
  4127fa:	e8 81 fa fe ff       	callq  402280 <printf@plt>
int
main(int argc, char *argv[])
{
	/* Local LHS function pointer */
	void (*function_ptr)(int) = dummy_function;
        int i = 10;
  4127ff:	be 04 00 00 00       	mov    $0x4,%esi
	function_ptr_global = dummy_function;
	function_ptr_global(3);
        
        /* Using freed memory */
        //printf("Using freed object %s and %s\n", msg, struct_ptr->ptr);
	return 0;
  412804:	4c 89 f7             	mov    %r14,%rdi
  412807:	e8 e4 1b 00 00       	callq  4143f0 <dang_freeptr>
  41280c:	64 4d 89 27          	mov    %r12,%fs:(%r15)
  412810:	31 c0                	xor    %eax,%eax
  412812:	48 83 c4 08          	add    $0x8,%rsp
  412816:	5b                   	pop    %rbx
  412817:	41 5c                	pop    %r12
  412819:	41 5d                	pop    %r13
  41281b:	41 5e                	pop    %r14
  41281d:	41 5f                	pop    %r15
  41281f:	5d                   	pop    %rbp
  412820:	c3                   	retq   
  412821:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  412828:	0f 1f 84 00 00 00 00 
  41282f:	00 

0000000000412830 <metaset_1>:
  412830:	41 56                	push   %r14
  412832:	53                   	push   %rbx
  412833:	50                   	push   %rax
  412834:	48 89 fb             	mov    %rdi,%rbx
  412837:	48 c1 eb 0c          	shr    $0xc,%rbx
  41283b:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  412842:	40 00 00 
  412845:	4c 8b 34 d8          	mov    (%rax,%rbx,8),%r14
  412849:	41 0f b6 ce          	movzbl %r14b,%ecx
  41284d:	b8 01 00 00 00       	mov    $0x1,%eax
  412852:	d3 e0                	shl    %cl,%eax
  412854:	48 98                	cltq   
  412856:	48 8d 44 06 ff       	lea    -0x1(%rsi,%rax,1),%rax
  41285b:	48 d3 e8             	shr    %cl,%rax
  41285e:	48 85 c0             	test   %rax,%rax
  412861:	74 1f                	je     412882 <metaset_1+0x52>
  412863:	4c 89 f6             	mov    %r14,%rsi
  412866:	48 c1 ee 08          	shr    $0x8,%rsi
  41286a:	48 c1 e3 0c          	shl    $0xc,%rbx
  41286e:	48 29 df             	sub    %rbx,%rdi
  412871:	48 d3 ef             	shr    %cl,%rdi
  412874:	48 01 f7             	add    %rsi,%rdi
  412877:	0f b6 f2             	movzbl %dl,%esi
  41287a:	48 89 c2             	mov    %rax,%rdx
  41287d:	e8 5e fa fe ff       	callq  4022e0 <memset@plt>
  412882:	4c 89 f0             	mov    %r14,%rax
  412885:	48 83 c4 08          	add    $0x8,%rsp
  412889:	5b                   	pop    %rbx
  41288a:	41 5e                	pop    %r14
  41288c:	c3                   	retq   
  41288d:	0f 1f 00             	nopl   (%rax)

0000000000412890 <metaset_2>:
  412890:	49 89 f8             	mov    %rdi,%r8
  412893:	49 c1 e8 0c          	shr    $0xc,%r8
  412897:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  41289e:	40 00 00 
  4128a1:	4a 8b 04 c0          	mov    (%rax,%r8,8),%rax
  4128a5:	0f b6 c8             	movzbl %al,%ecx
  4128a8:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  4128ae:	41 d3 e1             	shl    %cl,%r9d
  4128b1:	4d 63 c9             	movslq %r9d,%r9
  4128b4:	4e 8d 5c 0e ff       	lea    -0x1(%rsi,%r9,1),%r11
  4128b9:	49 d3 eb             	shr    %cl,%r11
  4128bc:	4d 85 db             	test   %r11,%r11
  4128bf:	74 7d                	je     41293e <metaset_2+0xae>
  4128c1:	49 89 c1             	mov    %rax,%r9
  4128c4:	49 c1 e9 08          	shr    $0x8,%r9
  4128c8:	49 c1 e0 0c          	shl    $0xc,%r8
  4128cc:	4c 29 c7             	sub    %r8,%rdi
  4128cf:	48 d3 ef             	shr    %cl,%rdi
  4128d2:	49 8d 0c 79          	lea    (%r9,%rdi,2),%rcx
  4128d6:	4d 8d 53 ff          	lea    -0x1(%r11),%r10
  4128da:	4d 89 d8             	mov    %r11,%r8
  4128dd:	49 83 e0 07          	and    $0x7,%r8
  4128e1:	74 1f                	je     412902 <metaset_2+0x72>
  4128e3:	4c 01 c7             	add    %r8,%rdi
  4128e6:	44 89 de             	mov    %r11d,%esi
  4128e9:	83 e6 07             	and    $0x7,%esi
  4128ec:	48 f7 de             	neg    %rsi
  4128ef:	90                   	nop
  4128f0:	66 89 11             	mov    %dx,(%rcx)
  4128f3:	48 83 c1 02          	add    $0x2,%rcx
  4128f7:	48 ff c6             	inc    %rsi
  4128fa:	75 f4                	jne    4128f0 <metaset_2+0x60>
  4128fc:	49 8d 0c 79          	lea    (%r9,%rdi,2),%rcx
  412900:	eb 03                	jmp    412905 <metaset_2+0x75>
  412902:	45 31 c0             	xor    %r8d,%r8d
  412905:	49 83 fa 07          	cmp    $0x7,%r10
  412909:	72 33                	jb     41293e <metaset_2+0xae>
  41290b:	66 0f 6e c2          	movd   %edx,%xmm0
  41290f:	66 0f 70 c0 c4       	pshufd $0xc4,%xmm0,%xmm0
  412914:	f2 0f 70 c0 00       	pshuflw $0x0,%xmm0,%xmm0
  412919:	f3 0f 70 c0 00       	pshufhw $0x0,%xmm0,%xmm0
  41291e:	4d 29 c3             	sub    %r8,%r11
  412921:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  412928:	0f 1f 84 00 00 00 00 
  41292f:	00 
  412930:	f3 0f 7f 01          	movdqu %xmm0,(%rcx)
  412934:	48 83 c1 10          	add    $0x10,%rcx
  412938:	49 83 c3 f8          	add    $0xfffffffffffffff8,%r11
  41293c:	75 f2                	jne    412930 <metaset_2+0xa0>
  41293e:	c3                   	retq   
  41293f:	90                   	nop

0000000000412940 <metaset_4>:
  412940:	49 89 f8             	mov    %rdi,%r8
  412943:	49 c1 e8 0c          	shr    $0xc,%r8
  412947:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  41294e:	40 00 00 
  412951:	4a 8b 04 c0          	mov    (%rax,%r8,8),%rax
  412955:	0f b6 c8             	movzbl %al,%ecx
  412958:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  41295e:	41 d3 e1             	shl    %cl,%r9d
  412961:	4d 63 c9             	movslq %r9d,%r9
  412964:	4e 8d 5c 0e ff       	lea    -0x1(%rsi,%r9,1),%r11
  412969:	49 d3 eb             	shr    %cl,%r11
  41296c:	4d 85 db             	test   %r11,%r11
  41296f:	74 72                	je     4129e3 <metaset_4+0xa3>
  412971:	49 89 c1             	mov    %rax,%r9
  412974:	49 c1 e9 08          	shr    $0x8,%r9
  412978:	49 c1 e0 0c          	shl    $0xc,%r8
  41297c:	4c 29 c7             	sub    %r8,%rdi
  41297f:	48 d3 ef             	shr    %cl,%rdi
  412982:	49 8d 0c b9          	lea    (%r9,%rdi,4),%rcx
  412986:	4d 8d 53 ff          	lea    -0x1(%r11),%r10
  41298a:	4d 89 d8             	mov    %r11,%r8
  41298d:	49 83 e0 07          	and    $0x7,%r8
  412991:	74 1e                	je     4129b1 <metaset_4+0x71>
  412993:	4c 01 c7             	add    %r8,%rdi
  412996:	44 89 de             	mov    %r11d,%esi
  412999:	83 e6 07             	and    $0x7,%esi
  41299c:	48 f7 de             	neg    %rsi
  41299f:	90                   	nop
  4129a0:	89 11                	mov    %edx,(%rcx)
  4129a2:	48 83 c1 04          	add    $0x4,%rcx
  4129a6:	48 ff c6             	inc    %rsi
  4129a9:	75 f5                	jne    4129a0 <metaset_4+0x60>
  4129ab:	49 8d 0c b9          	lea    (%r9,%rdi,4),%rcx
  4129af:	eb 03                	jmp    4129b4 <metaset_4+0x74>
  4129b1:	45 31 c0             	xor    %r8d,%r8d
  4129b4:	49 83 fa 07          	cmp    $0x7,%r10
  4129b8:	72 29                	jb     4129e3 <metaset_4+0xa3>
  4129ba:	66 0f 6e c2          	movd   %edx,%xmm0
  4129be:	66 0f 70 c0 00       	pshufd $0x0,%xmm0,%xmm0
  4129c3:	4d 29 c3             	sub    %r8,%r11
  4129c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4129cd:	00 00 00 
  4129d0:	f3 0f 7f 01          	movdqu %xmm0,(%rcx)
  4129d4:	f3 0f 7f 41 10       	movdqu %xmm0,0x10(%rcx)
  4129d9:	48 83 c1 20          	add    $0x20,%rcx
  4129dd:	49 83 c3 f8          	add    $0xfffffffffffffff8,%r11
  4129e1:	75 ed                	jne    4129d0 <metaset_4+0x90>
  4129e3:	c3                   	retq   
  4129e4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4129eb:	00 00 00 00 00 

00000000004129f0 <metaset_8>:
  4129f0:	49 89 f8             	mov    %rdi,%r8
  4129f3:	49 c1 e8 0c          	shr    $0xc,%r8
  4129f7:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  4129fe:	40 00 00 
  412a01:	4a 8b 04 c0          	mov    (%rax,%r8,8),%rax
  412a05:	0f b6 c8             	movzbl %al,%ecx
  412a08:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  412a0e:	41 d3 e1             	shl    %cl,%r9d
  412a11:	4d 63 c9             	movslq %r9d,%r9
  412a14:	4e 8d 5c 0e ff       	lea    -0x1(%rsi,%r9,1),%r11
  412a19:	49 d3 eb             	shr    %cl,%r11
  412a1c:	4d 85 db             	test   %r11,%r11
  412a1f:	74 78                	je     412a99 <metaset_8+0xa9>
  412a21:	49 89 c1             	mov    %rax,%r9
  412a24:	49 c1 e9 08          	shr    $0x8,%r9
  412a28:	49 c1 e0 0c          	shl    $0xc,%r8
  412a2c:	4c 29 c7             	sub    %r8,%rdi
  412a2f:	48 d3 ef             	shr    %cl,%rdi
  412a32:	49 8d 0c f9          	lea    (%r9,%rdi,8),%rcx
  412a36:	4d 8d 53 ff          	lea    -0x1(%r11),%r10
  412a3a:	4d 89 d8             	mov    %r11,%r8
  412a3d:	49 83 e0 07          	and    $0x7,%r8
  412a41:	74 1f                	je     412a62 <metaset_8+0x72>
  412a43:	4c 01 c7             	add    %r8,%rdi
  412a46:	44 89 de             	mov    %r11d,%esi
  412a49:	83 e6 07             	and    $0x7,%esi
  412a4c:	48 f7 de             	neg    %rsi
  412a4f:	90                   	nop
  412a50:	48 89 11             	mov    %rdx,(%rcx)
  412a53:	48 83 c1 08          	add    $0x8,%rcx
  412a57:	48 ff c6             	inc    %rsi
  412a5a:	75 f4                	jne    412a50 <metaset_8+0x60>
  412a5c:	49 8d 0c f9          	lea    (%r9,%rdi,8),%rcx
  412a60:	eb 03                	jmp    412a65 <metaset_8+0x75>
  412a62:	45 31 c0             	xor    %r8d,%r8d
  412a65:	49 83 fa 07          	cmp    $0x7,%r10
  412a69:	72 2e                	jb     412a99 <metaset_8+0xa9>
  412a6b:	4d 29 c3             	sub    %r8,%r11
  412a6e:	66 90                	xchg   %ax,%ax
  412a70:	48 89 11             	mov    %rdx,(%rcx)
  412a73:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  412a77:	48 89 51 10          	mov    %rdx,0x10(%rcx)
  412a7b:	48 89 51 18          	mov    %rdx,0x18(%rcx)
  412a7f:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  412a83:	48 89 51 28          	mov    %rdx,0x28(%rcx)
  412a87:	48 89 51 30          	mov    %rdx,0x30(%rcx)
  412a8b:	48 89 51 38          	mov    %rdx,0x38(%rcx)
  412a8f:	48 83 c1 40          	add    $0x40,%rcx
  412a93:	49 83 c3 f8          	add    $0xfffffffffffffff8,%r11
  412a97:	75 d7                	jne    412a70 <metaset_8+0x80>
  412a99:	c3                   	retq   
  412a9a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000412aa0 <metaset_16>:
  412aa0:	53                   	push   %rbx
  412aa1:	49 89 c8             	mov    %rcx,%r8
  412aa4:	49 89 fa             	mov    %rdi,%r10
  412aa7:	49 c1 ea 0c          	shr    $0xc,%r10
  412aab:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  412ab2:	40 00 00 
  412ab5:	4a 8b 04 d0          	mov    (%rax,%r10,8),%rax
  412ab9:	0f b6 c8             	movzbl %al,%ecx
  412abc:	bb 01 00 00 00       	mov    $0x1,%ebx
  412ac1:	d3 e3                	shl    %cl,%ebx
  412ac3:	48 63 db             	movslq %ebx,%rbx
  412ac6:	48 8d 74 1e ff       	lea    -0x1(%rsi,%rbx,1),%rsi
  412acb:	48 d3 ee             	shr    %cl,%rsi
  412ace:	48 85 f6             	test   %rsi,%rsi
  412ad1:	0f 84 b2 00 00 00    	je     412b89 <metaset_16+0xe9>
  412ad7:	49 89 c1             	mov    %rax,%r9
  412ada:	49 c1 e9 08          	shr    $0x8,%r9
  412ade:	49 c1 e2 0c          	shl    $0xc,%r10
  412ae2:	4c 29 d7             	sub    %r10,%rdi
  412ae5:	48 d3 ef             	shr    %cl,%rdi
  412ae8:	48 89 f9             	mov    %rdi,%rcx
  412aeb:	48 c1 e1 04          	shl    $0x4,%rcx
  412aef:	4c 01 c9             	add    %r9,%rcx
  412af2:	4c 8d 5e ff          	lea    -0x1(%rsi),%r11
  412af6:	49 89 f2             	mov    %rsi,%r10
  412af9:	49 83 e2 07          	and    $0x7,%r10
  412afd:	74 2d                	je     412b2c <metaset_16+0x8c>
  412aff:	4c 01 d7             	add    %r10,%rdi
  412b02:	89 f3                	mov    %esi,%ebx
  412b04:	83 e3 07             	and    $0x7,%ebx
  412b07:	48 f7 db             	neg    %rbx
  412b0a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  412b10:	48 89 11             	mov    %rdx,(%rcx)
  412b13:	4c 89 41 08          	mov    %r8,0x8(%rcx)
  412b17:	48 83 c1 10          	add    $0x10,%rcx
  412b1b:	48 ff c3             	inc    %rbx
  412b1e:	75 f0                	jne    412b10 <metaset_16+0x70>
  412b20:	48 c1 e7 04          	shl    $0x4,%rdi
  412b24:	49 01 f9             	add    %rdi,%r9
  412b27:	4c 89 c9             	mov    %r9,%rcx
  412b2a:	eb 03                	jmp    412b2f <metaset_16+0x8f>
  412b2c:	45 31 d2             	xor    %r10d,%r10d
  412b2f:	49 83 fb 07          	cmp    $0x7,%r11
  412b33:	72 54                	jb     412b89 <metaset_16+0xe9>
  412b35:	4c 29 d6             	sub    %r10,%rsi
  412b38:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  412b3f:	00 
  412b40:	48 89 11             	mov    %rdx,(%rcx)
  412b43:	4c 89 41 08          	mov    %r8,0x8(%rcx)
  412b47:	48 89 51 10          	mov    %rdx,0x10(%rcx)
  412b4b:	4c 89 41 18          	mov    %r8,0x18(%rcx)
  412b4f:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  412b53:	4c 89 41 28          	mov    %r8,0x28(%rcx)
  412b57:	48 89 51 30          	mov    %rdx,0x30(%rcx)
  412b5b:	4c 89 41 38          	mov    %r8,0x38(%rcx)
  412b5f:	48 89 51 40          	mov    %rdx,0x40(%rcx)
  412b63:	4c 89 41 48          	mov    %r8,0x48(%rcx)
  412b67:	48 89 51 50          	mov    %rdx,0x50(%rcx)
  412b6b:	4c 89 41 58          	mov    %r8,0x58(%rcx)
  412b6f:	48 89 51 60          	mov    %rdx,0x60(%rcx)
  412b73:	4c 89 41 68          	mov    %r8,0x68(%rcx)
  412b77:	48 89 51 70          	mov    %rdx,0x70(%rcx)
  412b7b:	4c 89 41 78          	mov    %r8,0x78(%rcx)
  412b7f:	48 83 e9 80          	sub    $0xffffffffffffff80,%rcx
  412b83:	48 83 c6 f8          	add    $0xfffffffffffffff8,%rsi
  412b87:	75 b7                	jne    412b40 <metaset_16+0xa0>
  412b89:	5b                   	pop    %rbx
  412b8a:	c3                   	retq   
  412b8b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000412b90 <metaset_alignment_1>:
  412b90:	41 56                	push   %r14
  412b92:	53                   	push   %rbx
  412b93:	50                   	push   %rax
  412b94:	48 89 fb             	mov    %rdi,%rbx
  412b97:	48 c1 eb 0c          	shr    $0xc,%rbx
  412b9b:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  412ba2:	40 00 00 
  412ba5:	4c 8b 34 d8          	mov    (%rax,%rbx,8),%r14
  412ba9:	b8 01 00 00 00       	mov    $0x1,%eax
  412bae:	d3 e0                	shl    %cl,%eax
  412bb0:	48 98                	cltq   
  412bb2:	48 8d 44 06 ff       	lea    -0x1(%rsi,%rax,1),%rax
  412bb7:	48 d3 e8             	shr    %cl,%rax
  412bba:	48 85 c0             	test   %rax,%rax
  412bbd:	74 1f                	je     412bde <metaset_alignment_1+0x4e>
  412bbf:	4c 89 f6             	mov    %r14,%rsi
  412bc2:	48 c1 ee 08          	shr    $0x8,%rsi
  412bc6:	48 c1 e3 0c          	shl    $0xc,%rbx
  412bca:	48 29 df             	sub    %rbx,%rdi
  412bcd:	48 d3 ef             	shr    %cl,%rdi
  412bd0:	48 01 f7             	add    %rsi,%rdi
  412bd3:	0f b6 f2             	movzbl %dl,%esi
  412bd6:	48 89 c2             	mov    %rax,%rdx
  412bd9:	e8 02 f7 fe ff       	callq  4022e0 <memset@plt>
  412bde:	4c 89 f0             	mov    %r14,%rax
  412be1:	48 83 c4 08          	add    $0x8,%rsp
  412be5:	5b                   	pop    %rbx
  412be6:	41 5e                	pop    %r14
  412be8:	c3                   	retq   
  412be9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000412bf0 <metaset_alignment_2>:
  412bf0:	49 89 f8             	mov    %rdi,%r8
  412bf3:	49 c1 e8 0c          	shr    $0xc,%r8
  412bf7:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  412bfe:	40 00 00 
  412c01:	4a 8b 04 c0          	mov    (%rax,%r8,8),%rax
  412c05:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  412c0b:	41 d3 e1             	shl    %cl,%r9d
  412c0e:	4d 63 c9             	movslq %r9d,%r9
  412c11:	4e 8d 5c 0e ff       	lea    -0x1(%rsi,%r9,1),%r11
  412c16:	49 d3 eb             	shr    %cl,%r11
  412c19:	4d 85 db             	test   %r11,%r11
  412c1c:	0f 84 7c 00 00 00    	je     412c9e <metaset_alignment_2+0xae>
  412c22:	49 89 c1             	mov    %rax,%r9
  412c25:	49 c1 e9 08          	shr    $0x8,%r9
  412c29:	49 c1 e0 0c          	shl    $0xc,%r8
  412c2d:	4c 29 c7             	sub    %r8,%rdi
  412c30:	48 d3 ef             	shr    %cl,%rdi
  412c33:	49 8d 0c 79          	lea    (%r9,%rdi,2),%rcx
  412c37:	4d 8d 53 ff          	lea    -0x1(%r11),%r10
  412c3b:	4d 89 d8             	mov    %r11,%r8
  412c3e:	49 83 e0 07          	and    $0x7,%r8
  412c42:	74 1e                	je     412c62 <metaset_alignment_2+0x72>
  412c44:	4c 01 c7             	add    %r8,%rdi
  412c47:	44 89 de             	mov    %r11d,%esi
  412c4a:	83 e6 07             	and    $0x7,%esi
  412c4d:	48 f7 de             	neg    %rsi
  412c50:	66 89 11             	mov    %dx,(%rcx)
  412c53:	48 83 c1 02          	add    $0x2,%rcx
  412c57:	48 ff c6             	inc    %rsi
  412c5a:	75 f4                	jne    412c50 <metaset_alignment_2+0x60>
  412c5c:	49 8d 0c 79          	lea    (%r9,%rdi,2),%rcx
  412c60:	eb 03                	jmp    412c65 <metaset_alignment_2+0x75>
  412c62:	45 31 c0             	xor    %r8d,%r8d
  412c65:	49 83 fa 07          	cmp    $0x7,%r10
  412c69:	72 33                	jb     412c9e <metaset_alignment_2+0xae>
  412c6b:	66 0f 6e c2          	movd   %edx,%xmm0
  412c6f:	66 0f 70 c0 c4       	pshufd $0xc4,%xmm0,%xmm0
  412c74:	f2 0f 70 c0 00       	pshuflw $0x0,%xmm0,%xmm0
  412c79:	f3 0f 70 c0 00       	pshufhw $0x0,%xmm0,%xmm0
  412c7e:	4d 29 c3             	sub    %r8,%r11
  412c81:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  412c88:	0f 1f 84 00 00 00 00 
  412c8f:	00 
  412c90:	f3 0f 7f 01          	movdqu %xmm0,(%rcx)
  412c94:	48 83 c1 10          	add    $0x10,%rcx
  412c98:	49 83 c3 f8          	add    $0xfffffffffffffff8,%r11
  412c9c:	75 f2                	jne    412c90 <metaset_alignment_2+0xa0>
  412c9e:	c3                   	retq   
  412c9f:	90                   	nop

0000000000412ca0 <metaset_alignment_4>:
  412ca0:	49 89 f8             	mov    %rdi,%r8
  412ca3:	49 c1 e8 0c          	shr    $0xc,%r8
  412ca7:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  412cae:	40 00 00 
  412cb1:	4a 8b 04 c0          	mov    (%rax,%r8,8),%rax
  412cb5:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  412cbb:	41 d3 e1             	shl    %cl,%r9d
  412cbe:	4d 63 c9             	movslq %r9d,%r9
  412cc1:	4e 8d 5c 0e ff       	lea    -0x1(%rsi,%r9,1),%r11
  412cc6:	49 d3 eb             	shr    %cl,%r11
  412cc9:	4d 85 db             	test   %r11,%r11
  412ccc:	74 75                	je     412d43 <metaset_alignment_4+0xa3>
  412cce:	49 89 c1             	mov    %rax,%r9
  412cd1:	49 c1 e9 08          	shr    $0x8,%r9
  412cd5:	49 c1 e0 0c          	shl    $0xc,%r8
  412cd9:	4c 29 c7             	sub    %r8,%rdi
  412cdc:	48 d3 ef             	shr    %cl,%rdi
  412cdf:	49 8d 0c b9          	lea    (%r9,%rdi,4),%rcx
  412ce3:	4d 8d 53 ff          	lea    -0x1(%r11),%r10
  412ce7:	4d 89 d8             	mov    %r11,%r8
  412cea:	49 83 e0 07          	and    $0x7,%r8
  412cee:	74 21                	je     412d11 <metaset_alignment_4+0x71>
  412cf0:	4c 01 c7             	add    %r8,%rdi
  412cf3:	44 89 de             	mov    %r11d,%esi
  412cf6:	83 e6 07             	and    $0x7,%esi
  412cf9:	48 f7 de             	neg    %rsi
  412cfc:	0f 1f 40 00          	nopl   0x0(%rax)
  412d00:	89 11                	mov    %edx,(%rcx)
  412d02:	48 83 c1 04          	add    $0x4,%rcx
  412d06:	48 ff c6             	inc    %rsi
  412d09:	75 f5                	jne    412d00 <metaset_alignment_4+0x60>
  412d0b:	49 8d 0c b9          	lea    (%r9,%rdi,4),%rcx
  412d0f:	eb 03                	jmp    412d14 <metaset_alignment_4+0x74>
  412d11:	45 31 c0             	xor    %r8d,%r8d
  412d14:	49 83 fa 07          	cmp    $0x7,%r10
  412d18:	72 29                	jb     412d43 <metaset_alignment_4+0xa3>
  412d1a:	66 0f 6e c2          	movd   %edx,%xmm0
  412d1e:	66 0f 70 c0 00       	pshufd $0x0,%xmm0,%xmm0
  412d23:	4d 29 c3             	sub    %r8,%r11
  412d26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  412d2d:	00 00 00 
  412d30:	f3 0f 7f 01          	movdqu %xmm0,(%rcx)
  412d34:	f3 0f 7f 41 10       	movdqu %xmm0,0x10(%rcx)
  412d39:	48 83 c1 20          	add    $0x20,%rcx
  412d3d:	49 83 c3 f8          	add    $0xfffffffffffffff8,%r11
  412d41:	75 ed                	jne    412d30 <metaset_alignment_4+0x90>
  412d43:	c3                   	retq   
  412d44:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  412d4b:	00 00 00 00 00 

0000000000412d50 <metaset_alignment_8>:
  412d50:	49 89 f8             	mov    %rdi,%r8
  412d53:	49 c1 e8 0c          	shr    $0xc,%r8
  412d57:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  412d5e:	40 00 00 
  412d61:	4a 8b 04 c0          	mov    (%rax,%r8,8),%rax
  412d65:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  412d6b:	41 d3 e1             	shl    %cl,%r9d
  412d6e:	4d 63 c9             	movslq %r9d,%r9
  412d71:	4e 8d 5c 0e ff       	lea    -0x1(%rsi,%r9,1),%r11
  412d76:	49 d3 eb             	shr    %cl,%r11
  412d79:	4d 85 db             	test   %r11,%r11
  412d7c:	74 7b                	je     412df9 <metaset_alignment_8+0xa9>
  412d7e:	49 89 c1             	mov    %rax,%r9
  412d81:	49 c1 e9 08          	shr    $0x8,%r9
  412d85:	49 c1 e0 0c          	shl    $0xc,%r8
  412d89:	4c 29 c7             	sub    %r8,%rdi
  412d8c:	48 d3 ef             	shr    %cl,%rdi
  412d8f:	49 8d 0c f9          	lea    (%r9,%rdi,8),%rcx
  412d93:	4d 8d 53 ff          	lea    -0x1(%r11),%r10
  412d97:	4d 89 d8             	mov    %r11,%r8
  412d9a:	49 83 e0 07          	and    $0x7,%r8
  412d9e:	74 22                	je     412dc2 <metaset_alignment_8+0x72>
  412da0:	4c 01 c7             	add    %r8,%rdi
  412da3:	44 89 de             	mov    %r11d,%esi
  412da6:	83 e6 07             	and    $0x7,%esi
  412da9:	48 f7 de             	neg    %rsi
  412dac:	0f 1f 40 00          	nopl   0x0(%rax)
  412db0:	48 89 11             	mov    %rdx,(%rcx)
  412db3:	48 83 c1 08          	add    $0x8,%rcx
  412db7:	48 ff c6             	inc    %rsi
  412dba:	75 f4                	jne    412db0 <metaset_alignment_8+0x60>
  412dbc:	49 8d 0c f9          	lea    (%r9,%rdi,8),%rcx
  412dc0:	eb 03                	jmp    412dc5 <metaset_alignment_8+0x75>
  412dc2:	45 31 c0             	xor    %r8d,%r8d
  412dc5:	49 83 fa 07          	cmp    $0x7,%r10
  412dc9:	72 2e                	jb     412df9 <metaset_alignment_8+0xa9>
  412dcb:	4d 29 c3             	sub    %r8,%r11
  412dce:	66 90                	xchg   %ax,%ax
  412dd0:	48 89 11             	mov    %rdx,(%rcx)
  412dd3:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  412dd7:	48 89 51 10          	mov    %rdx,0x10(%rcx)
  412ddb:	48 89 51 18          	mov    %rdx,0x18(%rcx)
  412ddf:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  412de3:	48 89 51 28          	mov    %rdx,0x28(%rcx)
  412de7:	48 89 51 30          	mov    %rdx,0x30(%rcx)
  412deb:	48 89 51 38          	mov    %rdx,0x38(%rcx)
  412def:	48 83 c1 40          	add    $0x40,%rcx
  412df3:	49 83 c3 f8          	add    $0xfffffffffffffff8,%r11
  412df7:	75 d7                	jne    412dd0 <metaset_alignment_8+0x80>
  412df9:	c3                   	retq   
  412dfa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000412e00 <metaset_alignment_16>:
  412e00:	53                   	push   %rbx
  412e01:	4d 89 c1             	mov    %r8,%r9
  412e04:	49 89 c8             	mov    %rcx,%r8
  412e07:	49 89 fb             	mov    %rdi,%r11
  412e0a:	49 c1 eb 0c          	shr    $0xc,%r11
  412e0e:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  412e15:	40 00 00 
  412e18:	4a 8b 04 d8          	mov    (%rax,%r11,8),%rax
  412e1c:	bb 01 00 00 00       	mov    $0x1,%ebx
  412e21:	44 88 c9             	mov    %r9b,%cl
  412e24:	d3 e3                	shl    %cl,%ebx
  412e26:	48 63 cb             	movslq %ebx,%rcx
  412e29:	48 8d 74 0e ff       	lea    -0x1(%rsi,%rcx,1),%rsi
  412e2e:	44 88 c9             	mov    %r9b,%cl
  412e31:	48 d3 ee             	shr    %cl,%rsi
  412e34:	48 85 f6             	test   %rsi,%rsi
  412e37:	0f 84 bc 00 00 00    	je     412ef9 <metaset_alignment_16+0xf9>
  412e3d:	49 89 c2             	mov    %rax,%r10
  412e40:	49 c1 ea 08          	shr    $0x8,%r10
  412e44:	49 c1 e3 0c          	shl    $0xc,%r11
  412e48:	4c 29 df             	sub    %r11,%rdi
  412e4b:	44 88 c9             	mov    %r9b,%cl
  412e4e:	48 d3 ef             	shr    %cl,%rdi
  412e51:	48 89 f9             	mov    %rdi,%rcx
  412e54:	48 c1 e1 04          	shl    $0x4,%rcx
  412e58:	4c 01 d1             	add    %r10,%rcx
  412e5b:	4c 8d 5e ff          	lea    -0x1(%rsi),%r11
  412e5f:	49 89 f1             	mov    %rsi,%r9
  412e62:	49 83 e1 07          	and    $0x7,%r9
  412e66:	74 34                	je     412e9c <metaset_alignment_16+0x9c>
  412e68:	4c 01 cf             	add    %r9,%rdi
  412e6b:	89 f3                	mov    %esi,%ebx
  412e6d:	83 e3 07             	and    $0x7,%ebx
  412e70:	48 f7 db             	neg    %rbx
  412e73:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  412e7a:	84 00 00 00 00 00 
  412e80:	48 89 11             	mov    %rdx,(%rcx)
  412e83:	4c 89 41 08          	mov    %r8,0x8(%rcx)
  412e87:	48 83 c1 10          	add    $0x10,%rcx
  412e8b:	48 ff c3             	inc    %rbx
  412e8e:	75 f0                	jne    412e80 <metaset_alignment_16+0x80>
  412e90:	48 c1 e7 04          	shl    $0x4,%rdi
  412e94:	49 01 fa             	add    %rdi,%r10
  412e97:	4c 89 d1             	mov    %r10,%rcx
  412e9a:	eb 03                	jmp    412e9f <metaset_alignment_16+0x9f>
  412e9c:	45 31 c9             	xor    %r9d,%r9d
  412e9f:	49 83 fb 07          	cmp    $0x7,%r11
  412ea3:	72 54                	jb     412ef9 <metaset_alignment_16+0xf9>
  412ea5:	4c 29 ce             	sub    %r9,%rsi
  412ea8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  412eaf:	00 
  412eb0:	48 89 11             	mov    %rdx,(%rcx)
  412eb3:	4c 89 41 08          	mov    %r8,0x8(%rcx)
  412eb7:	48 89 51 10          	mov    %rdx,0x10(%rcx)
  412ebb:	4c 89 41 18          	mov    %r8,0x18(%rcx)
  412ebf:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  412ec3:	4c 89 41 28          	mov    %r8,0x28(%rcx)
  412ec7:	48 89 51 30          	mov    %rdx,0x30(%rcx)
  412ecb:	4c 89 41 38          	mov    %r8,0x38(%rcx)
  412ecf:	48 89 51 40          	mov    %rdx,0x40(%rcx)
  412ed3:	4c 89 41 48          	mov    %r8,0x48(%rcx)
  412ed7:	48 89 51 50          	mov    %rdx,0x50(%rcx)
  412edb:	4c 89 41 58          	mov    %r8,0x58(%rcx)
  412edf:	48 89 51 60          	mov    %rdx,0x60(%rcx)
  412ee3:	4c 89 41 68          	mov    %r8,0x68(%rcx)
  412ee7:	48 89 51 70          	mov    %rdx,0x70(%rcx)
  412eeb:	4c 89 41 78          	mov    %r8,0x78(%rcx)
  412eef:	48 83 e9 80          	sub    $0xffffffffffffff80,%rcx
  412ef3:	48 83 c6 f8          	add    $0xfffffffffffffff8,%rsi
  412ef7:	75 b7                	jne    412eb0 <metaset_alignment_16+0xb0>
  412ef9:	5b                   	pop    %rbx
  412efa:	c3                   	retq   
  412efb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000412f00 <metaset_alignment_safe_1>:
  412f00:	41 56                	push   %r14
  412f02:	53                   	push   %rbx
  412f03:	50                   	push   %rax
  412f04:	48 89 fb             	mov    %rdi,%rbx
  412f07:	48 c1 eb 0c          	shr    $0xc,%rbx
  412f0b:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  412f12:	40 00 00 
  412f15:	4c 8b 34 d8          	mov    (%rax,%rbx,8),%r14
  412f19:	31 c0                	xor    %eax,%eax
  412f1b:	4d 85 f6             	test   %r14,%r14
  412f1e:	74 38                	je     412f58 <metaset_alignment_safe_1+0x58>
  412f20:	b8 01 00 00 00       	mov    $0x1,%eax
  412f25:	d3 e0                	shl    %cl,%eax
  412f27:	48 98                	cltq   
  412f29:	48 8d 44 06 ff       	lea    -0x1(%rsi,%rax,1),%rax
  412f2e:	48 d3 e8             	shr    %cl,%rax
  412f31:	48 85 c0             	test   %rax,%rax
  412f34:	74 1f                	je     412f55 <metaset_alignment_safe_1+0x55>
  412f36:	4c 89 f6             	mov    %r14,%rsi
  412f39:	48 c1 ee 08          	shr    $0x8,%rsi
  412f3d:	48 c1 e3 0c          	shl    $0xc,%rbx
  412f41:	48 29 df             	sub    %rbx,%rdi
  412f44:	48 d3 ef             	shr    %cl,%rdi
  412f47:	48 01 f7             	add    %rsi,%rdi
  412f4a:	0f b6 f2             	movzbl %dl,%esi
  412f4d:	48 89 c2             	mov    %rax,%rdx
  412f50:	e8 8b f3 fe ff       	callq  4022e0 <memset@plt>
  412f55:	4c 89 f0             	mov    %r14,%rax
  412f58:	48 83 c4 08          	add    $0x8,%rsp
  412f5c:	5b                   	pop    %rbx
  412f5d:	41 5e                	pop    %r14
  412f5f:	c3                   	retq   

0000000000412f60 <metaset_alignment_safe_2>:
  412f60:	49 89 f9             	mov    %rdi,%r9
  412f63:	49 c1 e9 0c          	shr    $0xc,%r9
  412f67:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  412f6e:	40 00 00 
  412f71:	4e 8b 04 c8          	mov    (%rax,%r9,8),%r8
  412f75:	31 c0                	xor    %eax,%eax
  412f77:	4d 85 c0             	test   %r8,%r8
  412f7a:	0f 84 a1 00 00 00    	je     413021 <metaset_alignment_safe_2+0xc1>
  412f80:	b8 01 00 00 00       	mov    $0x1,%eax
  412f85:	d3 e0                	shl    %cl,%eax
  412f87:	48 98                	cltq   
  412f89:	48 8d 74 06 ff       	lea    -0x1(%rsi,%rax,1),%rsi
  412f8e:	48 d3 ee             	shr    %cl,%rsi
  412f91:	48 85 f6             	test   %rsi,%rsi
  412f94:	0f 84 84 00 00 00    	je     41301e <metaset_alignment_safe_2+0xbe>
  412f9a:	4d 89 c3             	mov    %r8,%r11
  412f9d:	49 c1 eb 08          	shr    $0x8,%r11
  412fa1:	49 c1 e1 0c          	shl    $0xc,%r9
  412fa5:	4c 29 cf             	sub    %r9,%rdi
  412fa8:	48 d3 ef             	shr    %cl,%rdi
  412fab:	49 8d 0c 7b          	lea    (%r11,%rdi,2),%rcx
  412faf:	4c 8d 56 ff          	lea    -0x1(%rsi),%r10
  412fb3:	49 89 f1             	mov    %rsi,%r9
  412fb6:	49 83 e1 07          	and    $0x7,%r9
  412fba:	74 26                	je     412fe2 <metaset_alignment_safe_2+0x82>
  412fbc:	4c 01 cf             	add    %r9,%rdi
  412fbf:	89 f0                	mov    %esi,%eax
  412fc1:	83 e0 07             	and    $0x7,%eax
  412fc4:	48 f7 d8             	neg    %rax
  412fc7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  412fce:	00 00 
  412fd0:	66 89 11             	mov    %dx,(%rcx)
  412fd3:	48 83 c1 02          	add    $0x2,%rcx
  412fd7:	48 ff c0             	inc    %rax
  412fda:	75 f4                	jne    412fd0 <metaset_alignment_safe_2+0x70>
  412fdc:	49 8d 0c 7b          	lea    (%r11,%rdi,2),%rcx
  412fe0:	eb 03                	jmp    412fe5 <metaset_alignment_safe_2+0x85>
  412fe2:	45 31 c9             	xor    %r9d,%r9d
  412fe5:	49 83 fa 07          	cmp    $0x7,%r10
  412fe9:	72 33                	jb     41301e <metaset_alignment_safe_2+0xbe>
  412feb:	66 0f 6e c2          	movd   %edx,%xmm0
  412fef:	66 0f 70 c0 c4       	pshufd $0xc4,%xmm0,%xmm0
  412ff4:	f2 0f 70 c0 00       	pshuflw $0x0,%xmm0,%xmm0
  412ff9:	f3 0f 70 c0 00       	pshufhw $0x0,%xmm0,%xmm0
  412ffe:	4c 29 ce             	sub    %r9,%rsi
  413001:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  413008:	0f 1f 84 00 00 00 00 
  41300f:	00 
  413010:	f3 0f 7f 01          	movdqu %xmm0,(%rcx)
  413014:	48 83 c1 10          	add    $0x10,%rcx
  413018:	48 83 c6 f8          	add    $0xfffffffffffffff8,%rsi
  41301c:	75 f2                	jne    413010 <metaset_alignment_safe_2+0xb0>
  41301e:	4c 89 c0             	mov    %r8,%rax
  413021:	c3                   	retq   
  413022:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  413029:	1f 84 00 00 00 00 00 

0000000000413030 <metaset_alignment_safe_4>:
  413030:	49 89 f9             	mov    %rdi,%r9
  413033:	49 c1 e9 0c          	shr    $0xc,%r9
  413037:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  41303e:	40 00 00 
  413041:	4e 8b 04 c8          	mov    (%rax,%r9,8),%r8
  413045:	31 c0                	xor    %eax,%eax
  413047:	4d 85 c0             	test   %r8,%r8
  41304a:	0f 84 96 00 00 00    	je     4130e6 <metaset_alignment_safe_4+0xb6>
  413050:	b8 01 00 00 00       	mov    $0x1,%eax
  413055:	d3 e0                	shl    %cl,%eax
  413057:	48 98                	cltq   
  413059:	48 8d 74 06 ff       	lea    -0x1(%rsi,%rax,1),%rsi
  41305e:	48 d3 ee             	shr    %cl,%rsi
  413061:	48 85 f6             	test   %rsi,%rsi
  413064:	74 7d                	je     4130e3 <metaset_alignment_safe_4+0xb3>
  413066:	4d 89 c3             	mov    %r8,%r11
  413069:	49 c1 eb 08          	shr    $0x8,%r11
  41306d:	49 c1 e1 0c          	shl    $0xc,%r9
  413071:	4c 29 cf             	sub    %r9,%rdi
  413074:	48 d3 ef             	shr    %cl,%rdi
  413077:	49 8d 0c bb          	lea    (%r11,%rdi,4),%rcx
  41307b:	4c 8d 56 ff          	lea    -0x1(%rsi),%r10
  41307f:	49 89 f1             	mov    %rsi,%r9
  413082:	49 83 e1 07          	and    $0x7,%r9
  413086:	74 29                	je     4130b1 <metaset_alignment_safe_4+0x81>
  413088:	4c 01 cf             	add    %r9,%rdi
  41308b:	89 f0                	mov    %esi,%eax
  41308d:	83 e0 07             	and    $0x7,%eax
  413090:	48 f7 d8             	neg    %rax
  413093:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  41309a:	84 00 00 00 00 00 
  4130a0:	89 11                	mov    %edx,(%rcx)
  4130a2:	48 83 c1 04          	add    $0x4,%rcx
  4130a6:	48 ff c0             	inc    %rax
  4130a9:	75 f5                	jne    4130a0 <metaset_alignment_safe_4+0x70>
  4130ab:	49 8d 0c bb          	lea    (%r11,%rdi,4),%rcx
  4130af:	eb 03                	jmp    4130b4 <metaset_alignment_safe_4+0x84>
  4130b1:	45 31 c9             	xor    %r9d,%r9d
  4130b4:	49 83 fa 07          	cmp    $0x7,%r10
  4130b8:	72 29                	jb     4130e3 <metaset_alignment_safe_4+0xb3>
  4130ba:	66 0f 6e c2          	movd   %edx,%xmm0
  4130be:	66 0f 70 c0 00       	pshufd $0x0,%xmm0,%xmm0
  4130c3:	4c 29 ce             	sub    %r9,%rsi
  4130c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4130cd:	00 00 00 
  4130d0:	f3 0f 7f 01          	movdqu %xmm0,(%rcx)
  4130d4:	f3 0f 7f 41 10       	movdqu %xmm0,0x10(%rcx)
  4130d9:	48 83 c1 20          	add    $0x20,%rcx
  4130dd:	48 83 c6 f8          	add    $0xfffffffffffffff8,%rsi
  4130e1:	75 ed                	jne    4130d0 <metaset_alignment_safe_4+0xa0>
  4130e3:	4c 89 c0             	mov    %r8,%rax
  4130e6:	c3                   	retq   
  4130e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4130ee:	00 00 

00000000004130f0 <metaset_alignment_safe_8>:
  4130f0:	49 89 f9             	mov    %rdi,%r9
  4130f3:	49 c1 e9 0c          	shr    $0xc,%r9
  4130f7:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  4130fe:	40 00 00 
  413101:	4e 8b 04 c8          	mov    (%rax,%r9,8),%r8
  413105:	31 c0                	xor    %eax,%eax
  413107:	4d 85 c0             	test   %r8,%r8
  41310a:	0f 84 9c 00 00 00    	je     4131ac <metaset_alignment_safe_8+0xbc>
  413110:	b8 01 00 00 00       	mov    $0x1,%eax
  413115:	d3 e0                	shl    %cl,%eax
  413117:	48 98                	cltq   
  413119:	48 8d 74 06 ff       	lea    -0x1(%rsi,%rax,1),%rsi
  41311e:	48 d3 ee             	shr    %cl,%rsi
  413121:	48 85 f6             	test   %rsi,%rsi
  413124:	0f 84 7f 00 00 00    	je     4131a9 <metaset_alignment_safe_8+0xb9>
  41312a:	4d 89 c3             	mov    %r8,%r11
  41312d:	49 c1 eb 08          	shr    $0x8,%r11
  413131:	49 c1 e1 0c          	shl    $0xc,%r9
  413135:	4c 29 cf             	sub    %r9,%rdi
  413138:	48 d3 ef             	shr    %cl,%rdi
  41313b:	49 8d 0c fb          	lea    (%r11,%rdi,8),%rcx
  41313f:	4c 8d 56 ff          	lea    -0x1(%rsi),%r10
  413143:	49 89 f1             	mov    %rsi,%r9
  413146:	49 83 e1 07          	and    $0x7,%r9
  41314a:	74 26                	je     413172 <metaset_alignment_safe_8+0x82>
  41314c:	4c 01 cf             	add    %r9,%rdi
  41314f:	89 f0                	mov    %esi,%eax
  413151:	83 e0 07             	and    $0x7,%eax
  413154:	48 f7 d8             	neg    %rax
  413157:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  41315e:	00 00 
  413160:	48 89 11             	mov    %rdx,(%rcx)
  413163:	48 83 c1 08          	add    $0x8,%rcx
  413167:	48 ff c0             	inc    %rax
  41316a:	75 f4                	jne    413160 <metaset_alignment_safe_8+0x70>
  41316c:	49 8d 0c fb          	lea    (%r11,%rdi,8),%rcx
  413170:	eb 03                	jmp    413175 <metaset_alignment_safe_8+0x85>
  413172:	45 31 c9             	xor    %r9d,%r9d
  413175:	49 83 fa 07          	cmp    $0x7,%r10
  413179:	72 2e                	jb     4131a9 <metaset_alignment_safe_8+0xb9>
  41317b:	4c 29 ce             	sub    %r9,%rsi
  41317e:	66 90                	xchg   %ax,%ax
  413180:	48 89 11             	mov    %rdx,(%rcx)
  413183:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  413187:	48 89 51 10          	mov    %rdx,0x10(%rcx)
  41318b:	48 89 51 18          	mov    %rdx,0x18(%rcx)
  41318f:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  413193:	48 89 51 28          	mov    %rdx,0x28(%rcx)
  413197:	48 89 51 30          	mov    %rdx,0x30(%rcx)
  41319b:	48 89 51 38          	mov    %rdx,0x38(%rcx)
  41319f:	48 83 c1 40          	add    $0x40,%rcx
  4131a3:	48 83 c6 f8          	add    $0xfffffffffffffff8,%rsi
  4131a7:	75 d7                	jne    413180 <metaset_alignment_safe_8+0x90>
  4131a9:	4c 89 c0             	mov    %r8,%rax
  4131ac:	c3                   	retq   
  4131ad:	0f 1f 00             	nopl   (%rax)

00000000004131b0 <metaset_alignment_safe_16>:
  4131b0:	53                   	push   %rbx
  4131b1:	49 89 c9             	mov    %rcx,%r9
  4131b4:	49 89 fb             	mov    %rdi,%r11
  4131b7:	49 c1 eb 0c          	shr    $0xc,%r11
  4131bb:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  4131c2:	40 00 00 
  4131c5:	4e 8b 14 d8          	mov    (%rax,%r11,8),%r10
  4131c9:	31 c0                	xor    %eax,%eax
  4131cb:	4d 85 d2             	test   %r10,%r10
  4131ce:	0f 84 d8 00 00 00    	je     4132ac <metaset_alignment_safe_16+0xfc>
  4131d4:	b8 01 00 00 00       	mov    $0x1,%eax
  4131d9:	44 88 c1             	mov    %r8b,%cl
  4131dc:	d3 e0                	shl    %cl,%eax
  4131de:	48 98                	cltq   
  4131e0:	48 8d 44 06 ff       	lea    -0x1(%rsi,%rax,1),%rax
  4131e5:	44 88 c1             	mov    %r8b,%cl
  4131e8:	48 d3 e8             	shr    %cl,%rax
  4131eb:	48 85 c0             	test   %rax,%rax
  4131ee:	0f 84 b5 00 00 00    	je     4132a9 <metaset_alignment_safe_16+0xf9>
  4131f4:	4c 89 d6             	mov    %r10,%rsi
  4131f7:	48 c1 ee 08          	shr    $0x8,%rsi
  4131fb:	49 c1 e3 0c          	shl    $0xc,%r11
  4131ff:	4c 29 df             	sub    %r11,%rdi
  413202:	44 88 c1             	mov    %r8b,%cl
  413205:	48 d3 ef             	shr    %cl,%rdi
  413208:	48 89 f9             	mov    %rdi,%rcx
  41320b:	48 c1 e1 04          	shl    $0x4,%rcx
  41320f:	48 01 f1             	add    %rsi,%rcx
  413212:	4c 8d 58 ff          	lea    -0x1(%rax),%r11
  413216:	49 89 c0             	mov    %rax,%r8
  413219:	49 83 e0 07          	and    $0x7,%r8
  41321d:	74 2d                	je     41324c <metaset_alignment_safe_16+0x9c>
  41321f:	4c 01 c7             	add    %r8,%rdi
  413222:	89 c3                	mov    %eax,%ebx
  413224:	83 e3 07             	and    $0x7,%ebx
  413227:	48 f7 db             	neg    %rbx
  41322a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  413230:	48 89 11             	mov    %rdx,(%rcx)
  413233:	4c 89 49 08          	mov    %r9,0x8(%rcx)
  413237:	48 83 c1 10          	add    $0x10,%rcx
  41323b:	48 ff c3             	inc    %rbx
  41323e:	75 f0                	jne    413230 <metaset_alignment_safe_16+0x80>
  413240:	48 c1 e7 04          	shl    $0x4,%rdi
  413244:	48 01 fe             	add    %rdi,%rsi
  413247:	48 89 f1             	mov    %rsi,%rcx
  41324a:	eb 03                	jmp    41324f <metaset_alignment_safe_16+0x9f>
  41324c:	45 31 c0             	xor    %r8d,%r8d
  41324f:	49 83 fb 07          	cmp    $0x7,%r11
  413253:	72 54                	jb     4132a9 <metaset_alignment_safe_16+0xf9>
  413255:	4c 29 c0             	sub    %r8,%rax
  413258:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  41325f:	00 
  413260:	48 89 11             	mov    %rdx,(%rcx)
  413263:	4c 89 49 08          	mov    %r9,0x8(%rcx)
  413267:	48 89 51 10          	mov    %rdx,0x10(%rcx)
  41326b:	4c 89 49 18          	mov    %r9,0x18(%rcx)
  41326f:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  413273:	4c 89 49 28          	mov    %r9,0x28(%rcx)
  413277:	48 89 51 30          	mov    %rdx,0x30(%rcx)
  41327b:	4c 89 49 38          	mov    %r9,0x38(%rcx)
  41327f:	48 89 51 40          	mov    %rdx,0x40(%rcx)
  413283:	4c 89 49 48          	mov    %r9,0x48(%rcx)
  413287:	48 89 51 50          	mov    %rdx,0x50(%rcx)
  41328b:	4c 89 49 58          	mov    %r9,0x58(%rcx)
  41328f:	48 89 51 60          	mov    %rdx,0x60(%rcx)
  413293:	4c 89 49 68          	mov    %r9,0x68(%rcx)
  413297:	48 89 51 70          	mov    %rdx,0x70(%rcx)
  41329b:	4c 89 49 78          	mov    %r9,0x78(%rcx)
  41329f:	48 83 e9 80          	sub    $0xffffffffffffff80,%rcx
  4132a3:	48 83 c0 f8          	add    $0xfffffffffffffff8,%rax
  4132a7:	75 b7                	jne    413260 <metaset_alignment_safe_16+0xb0>
  4132a9:	4c 89 d0             	mov    %r10,%rax
  4132ac:	5b                   	pop    %rbx
  4132ad:	c3                   	retq   
  4132ae:	66 90                	xchg   %ax,%ax

00000000004132b0 <metaset_fast_1>:
  4132b0:	53                   	push   %rbx
  4132b1:	4c 89 c3             	mov    %r8,%rbx
  4132b4:	b8 01 00 00 00       	mov    $0x1,%eax
  4132b9:	d3 e0                	shl    %cl,%eax
  4132bb:	48 98                	cltq   
  4132bd:	48 8d 44 06 ff       	lea    -0x1(%rsi,%rax,1),%rax
  4132c2:	48 d3 e8             	shr    %cl,%rax
  4132c5:	48 85 c0             	test   %rax,%rax
  4132c8:	74 22                	je     4132ec <metaset_fast_1+0x3c>
  4132ca:	48 89 de             	mov    %rbx,%rsi
  4132cd:	48 c1 ee 08          	shr    $0x8,%rsi
  4132d1:	49 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%r9
  4132d8:	4c 29 cf             	sub    %r9,%rdi
  4132db:	48 d3 ff             	sar    %cl,%rdi
  4132de:	48 01 f7             	add    %rsi,%rdi
  4132e1:	0f b6 f2             	movzbl %dl,%esi
  4132e4:	48 89 c2             	mov    %rax,%rdx
  4132e7:	e8 f4 ef fe ff       	callq  4022e0 <memset@plt>
  4132ec:	48 89 d8             	mov    %rbx,%rax
  4132ef:	5b                   	pop    %rbx
  4132f0:	c3                   	retq   
  4132f1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4132f8:	0f 1f 84 00 00 00 00 
  4132ff:	00 

0000000000413300 <metaset_fast_2>:
  413300:	b8 01 00 00 00       	mov    $0x1,%eax
  413305:	d3 e0                	shl    %cl,%eax
  413307:	48 98                	cltq   
  413309:	48 8d 74 06 ff       	lea    -0x1(%rsi,%rax,1),%rsi
  41330e:	48 d3 ee             	shr    %cl,%rsi
  413311:	48 85 f6             	test   %rsi,%rsi
  413314:	0f 84 84 00 00 00    	je     41339e <metaset_fast_2+0x9e>
  41331a:	4d 89 c3             	mov    %r8,%r11
  41331d:	49 c1 eb 08          	shr    $0x8,%r11
  413321:	49 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%r9
  413328:	4c 29 cf             	sub    %r9,%rdi
  41332b:	48 d3 ff             	sar    %cl,%rdi
  41332e:	49 8d 0c 7b          	lea    (%r11,%rdi,2),%rcx
  413332:	4c 8d 56 ff          	lea    -0x1(%rsi),%r10
  413336:	49 89 f1             	mov    %rsi,%r9
  413339:	49 83 e1 07          	and    $0x7,%r9
  41333d:	74 23                	je     413362 <metaset_fast_2+0x62>
  41333f:	4c 01 cf             	add    %r9,%rdi
  413342:	89 f0                	mov    %esi,%eax
  413344:	83 e0 07             	and    $0x7,%eax
  413347:	48 f7 d8             	neg    %rax
  41334a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  413350:	66 89 11             	mov    %dx,(%rcx)
  413353:	48 83 c1 02          	add    $0x2,%rcx
  413357:	48 ff c0             	inc    %rax
  41335a:	75 f4                	jne    413350 <metaset_fast_2+0x50>
  41335c:	49 8d 0c 7b          	lea    (%r11,%rdi,2),%rcx
  413360:	eb 03                	jmp    413365 <metaset_fast_2+0x65>
  413362:	45 31 c9             	xor    %r9d,%r9d
  413365:	49 83 fa 07          	cmp    $0x7,%r10
  413369:	72 33                	jb     41339e <metaset_fast_2+0x9e>
  41336b:	66 0f 6e c2          	movd   %edx,%xmm0
  41336f:	66 0f 70 c0 c4       	pshufd $0xc4,%xmm0,%xmm0
  413374:	f2 0f 70 c0 00       	pshuflw $0x0,%xmm0,%xmm0
  413379:	f3 0f 70 c0 00       	pshufhw $0x0,%xmm0,%xmm0
  41337e:	4c 29 ce             	sub    %r9,%rsi
  413381:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  413388:	0f 1f 84 00 00 00 00 
  41338f:	00 
  413390:	f3 0f 7f 01          	movdqu %xmm0,(%rcx)
  413394:	48 83 c1 10          	add    $0x10,%rcx
  413398:	48 83 c6 f8          	add    $0xfffffffffffffff8,%rsi
  41339c:	75 f2                	jne    413390 <metaset_fast_2+0x90>
  41339e:	4c 89 c0             	mov    %r8,%rax
  4133a1:	c3                   	retq   
  4133a2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4133a9:	1f 84 00 00 00 00 00 

00000000004133b0 <metaset_fast_4>:
  4133b0:	b8 01 00 00 00       	mov    $0x1,%eax
  4133b5:	d3 e0                	shl    %cl,%eax
  4133b7:	48 98                	cltq   
  4133b9:	48 8d 74 06 ff       	lea    -0x1(%rsi,%rax,1),%rsi
  4133be:	48 d3 ee             	shr    %cl,%rsi
  4133c1:	48 85 f6             	test   %rsi,%rsi
  4133c4:	74 7d                	je     413443 <metaset_fast_4+0x93>
  4133c6:	4d 89 c3             	mov    %r8,%r11
  4133c9:	49 c1 eb 08          	shr    $0x8,%r11
  4133cd:	49 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%r9
  4133d4:	4c 29 cf             	sub    %r9,%rdi
  4133d7:	48 d3 ff             	sar    %cl,%rdi
  4133da:	49 8d 0c bb          	lea    (%r11,%rdi,4),%rcx
  4133de:	4c 8d 56 ff          	lea    -0x1(%rsi),%r10
  4133e2:	49 89 f1             	mov    %rsi,%r9
  4133e5:	49 83 e1 07          	and    $0x7,%r9
  4133e9:	74 26                	je     413411 <metaset_fast_4+0x61>
  4133eb:	4c 01 cf             	add    %r9,%rdi
  4133ee:	89 f0                	mov    %esi,%eax
  4133f0:	83 e0 07             	and    $0x7,%eax
  4133f3:	48 f7 d8             	neg    %rax
  4133f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4133fd:	00 00 00 
  413400:	89 11                	mov    %edx,(%rcx)
  413402:	48 83 c1 04          	add    $0x4,%rcx
  413406:	48 ff c0             	inc    %rax
  413409:	75 f5                	jne    413400 <metaset_fast_4+0x50>
  41340b:	49 8d 0c bb          	lea    (%r11,%rdi,4),%rcx
  41340f:	eb 03                	jmp    413414 <metaset_fast_4+0x64>
  413411:	45 31 c9             	xor    %r9d,%r9d
  413414:	49 83 fa 07          	cmp    $0x7,%r10
  413418:	72 29                	jb     413443 <metaset_fast_4+0x93>
  41341a:	66 0f 6e c2          	movd   %edx,%xmm0
  41341e:	66 0f 70 c0 00       	pshufd $0x0,%xmm0,%xmm0
  413423:	4c 29 ce             	sub    %r9,%rsi
  413426:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  41342d:	00 00 00 
  413430:	f3 0f 7f 01          	movdqu %xmm0,(%rcx)
  413434:	f3 0f 7f 41 10       	movdqu %xmm0,0x10(%rcx)
  413439:	48 83 c1 20          	add    $0x20,%rcx
  41343d:	48 83 c6 f8          	add    $0xfffffffffffffff8,%rsi
  413441:	75 ed                	jne    413430 <metaset_fast_4+0x80>
  413443:	4c 89 c0             	mov    %r8,%rax
  413446:	c3                   	retq   
  413447:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  41344e:	00 00 

0000000000413450 <metaset_fast_8>:
  413450:	b8 01 00 00 00       	mov    $0x1,%eax
  413455:	d3 e0                	shl    %cl,%eax
  413457:	48 98                	cltq   
  413459:	48 8d 74 06 ff       	lea    -0x1(%rsi,%rax,1),%rsi
  41345e:	48 d3 ee             	shr    %cl,%rsi
  413461:	48 85 f6             	test   %rsi,%rsi
  413464:	0f 84 7f 00 00 00    	je     4134e9 <metaset_fast_8+0x99>
  41346a:	4d 89 c3             	mov    %r8,%r11
  41346d:	49 c1 eb 08          	shr    $0x8,%r11
  413471:	49 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%r9
  413478:	4c 29 cf             	sub    %r9,%rdi
  41347b:	48 d3 ff             	sar    %cl,%rdi
  41347e:	49 8d 0c fb          	lea    (%r11,%rdi,8),%rcx
  413482:	4c 8d 56 ff          	lea    -0x1(%rsi),%r10
  413486:	49 89 f1             	mov    %rsi,%r9
  413489:	49 83 e1 07          	and    $0x7,%r9
  41348d:	74 23                	je     4134b2 <metaset_fast_8+0x62>
  41348f:	4c 01 cf             	add    %r9,%rdi
  413492:	89 f0                	mov    %esi,%eax
  413494:	83 e0 07             	and    $0x7,%eax
  413497:	48 f7 d8             	neg    %rax
  41349a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  4134a0:	48 89 11             	mov    %rdx,(%rcx)
  4134a3:	48 83 c1 08          	add    $0x8,%rcx
  4134a7:	48 ff c0             	inc    %rax
  4134aa:	75 f4                	jne    4134a0 <metaset_fast_8+0x50>
  4134ac:	49 8d 0c fb          	lea    (%r11,%rdi,8),%rcx
  4134b0:	eb 03                	jmp    4134b5 <metaset_fast_8+0x65>
  4134b2:	45 31 c9             	xor    %r9d,%r9d
  4134b5:	49 83 fa 07          	cmp    $0x7,%r10
  4134b9:	72 2e                	jb     4134e9 <metaset_fast_8+0x99>
  4134bb:	4c 29 ce             	sub    %r9,%rsi
  4134be:	66 90                	xchg   %ax,%ax
  4134c0:	48 89 11             	mov    %rdx,(%rcx)
  4134c3:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  4134c7:	48 89 51 10          	mov    %rdx,0x10(%rcx)
  4134cb:	48 89 51 18          	mov    %rdx,0x18(%rcx)
  4134cf:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  4134d3:	48 89 51 28          	mov    %rdx,0x28(%rcx)
  4134d7:	48 89 51 30          	mov    %rdx,0x30(%rcx)
  4134db:	48 89 51 38          	mov    %rdx,0x38(%rcx)
  4134df:	48 83 c1 40          	add    $0x40,%rcx
  4134e3:	48 83 c6 f8          	add    $0xfffffffffffffff8,%rsi
  4134e7:	75 d7                	jne    4134c0 <metaset_fast_8+0x70>
  4134e9:	4c 89 c0             	mov    %r8,%rax
  4134ec:	c3                   	retq   
  4134ed:	0f 1f 00             	nopl   (%rax)

00000000004134f0 <metaset_fast_16>:
  4134f0:	53                   	push   %rbx
  4134f1:	48 89 c8             	mov    %rcx,%rax
  4134f4:	bb 01 00 00 00       	mov    $0x1,%ebx
  4134f9:	44 88 c1             	mov    %r8b,%cl
  4134fc:	d3 e3                	shl    %cl,%ebx
  4134fe:	48 63 cb             	movslq %ebx,%rcx
  413501:	48 8d 74 0e ff       	lea    -0x1(%rsi,%rcx,1),%rsi
  413506:	44 88 c1             	mov    %r8b,%cl
  413509:	48 d3 ee             	shr    %cl,%rsi
  41350c:	48 85 f6             	test   %rsi,%rsi
  41350f:	0f 84 c4 00 00 00    	je     4135d9 <metaset_fast_16+0xe9>
  413515:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
  41351a:	4d 89 ca             	mov    %r9,%r10
  41351d:	49 c1 ea 08          	shr    $0x8,%r10
  413521:	48 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%rcx
  413528:	48 29 cf             	sub    %rcx,%rdi
  41352b:	44 88 c1             	mov    %r8b,%cl
  41352e:	48 d3 ff             	sar    %cl,%rdi
  413531:	48 89 f9             	mov    %rdi,%rcx
  413534:	48 c1 e1 04          	shl    $0x4,%rcx
  413538:	4c 01 d1             	add    %r10,%rcx
  41353b:	4c 8d 5e ff          	lea    -0x1(%rsi),%r11
  41353f:	49 89 f0             	mov    %rsi,%r8
  413542:	49 83 e0 07          	and    $0x7,%r8
  413546:	74 34                	je     41357c <metaset_fast_16+0x8c>
  413548:	4c 01 c7             	add    %r8,%rdi
  41354b:	89 f3                	mov    %esi,%ebx
  41354d:	83 e3 07             	and    $0x7,%ebx
  413550:	48 f7 db             	neg    %rbx
  413553:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  41355a:	84 00 00 00 00 00 
  413560:	48 89 11             	mov    %rdx,(%rcx)
  413563:	48 89 41 08          	mov    %rax,0x8(%rcx)
  413567:	48 83 c1 10          	add    $0x10,%rcx
  41356b:	48 ff c3             	inc    %rbx
  41356e:	75 f0                	jne    413560 <metaset_fast_16+0x70>
  413570:	48 c1 e7 04          	shl    $0x4,%rdi
  413574:	49 01 fa             	add    %rdi,%r10
  413577:	4c 89 d1             	mov    %r10,%rcx
  41357a:	eb 03                	jmp    41357f <metaset_fast_16+0x8f>
  41357c:	45 31 c0             	xor    %r8d,%r8d
  41357f:	49 83 fb 07          	cmp    $0x7,%r11
  413583:	72 54                	jb     4135d9 <metaset_fast_16+0xe9>
  413585:	4c 29 c6             	sub    %r8,%rsi
  413588:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  41358f:	00 
  413590:	48 89 11             	mov    %rdx,(%rcx)
  413593:	48 89 41 08          	mov    %rax,0x8(%rcx)
  413597:	48 89 51 10          	mov    %rdx,0x10(%rcx)
  41359b:	48 89 41 18          	mov    %rax,0x18(%rcx)
  41359f:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  4135a3:	48 89 41 28          	mov    %rax,0x28(%rcx)
  4135a7:	48 89 51 30          	mov    %rdx,0x30(%rcx)
  4135ab:	48 89 41 38          	mov    %rax,0x38(%rcx)
  4135af:	48 89 51 40          	mov    %rdx,0x40(%rcx)
  4135b3:	48 89 41 48          	mov    %rax,0x48(%rcx)
  4135b7:	48 89 51 50          	mov    %rdx,0x50(%rcx)
  4135bb:	48 89 41 58          	mov    %rax,0x58(%rcx)
  4135bf:	48 89 51 60          	mov    %rdx,0x60(%rcx)
  4135c3:	48 89 41 68          	mov    %rax,0x68(%rcx)
  4135c7:	48 89 51 70          	mov    %rdx,0x70(%rcx)
  4135cb:	48 89 41 78          	mov    %rax,0x78(%rcx)
  4135cf:	48 83 e9 80          	sub    $0xffffffffffffff80,%rcx
  4135d3:	48 83 c6 f8          	add    $0xfffffffffffffff8,%rsi
  4135d7:	75 b7                	jne    413590 <metaset_fast_16+0xa0>
  4135d9:	4c 89 c8             	mov    %r9,%rax
  4135dc:	5b                   	pop    %rbx
  4135dd:	c3                   	retq   
  4135de:	66 90                	xchg   %ax,%ax

00000000004135e0 <metaset_fixed_1>:
  4135e0:	50                   	push   %rax
  4135e1:	48 89 f0             	mov    %rsi,%rax
  4135e4:	48 83 c0 07          	add    $0x7,%rax
  4135e8:	48 c1 e8 03          	shr    $0x3,%rax
  4135ec:	74 1f                	je     41360d <metaset_fixed_1+0x2d>
  4135ee:	48 c1 ef 03          	shr    $0x3,%rdi
  4135f2:	48 b9 00 00 00 00 00 	movabs $0x400000000000,%rcx
  4135f9:	40 00 00 
  4135fc:	48 01 f9             	add    %rdi,%rcx
  4135ff:	0f b6 f2             	movzbl %dl,%esi
  413602:	48 89 cf             	mov    %rcx,%rdi
  413605:	48 89 c2             	mov    %rax,%rdx
  413608:	e8 d3 ec fe ff       	callq  4022e0 <memset@plt>
  41360d:	31 c0                	xor    %eax,%eax
  41360f:	5a                   	pop    %rdx
  413610:	c3                   	retq   
  413611:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  413618:	0f 1f 84 00 00 00 00 
  41361f:	00 

0000000000413620 <metaset_fixed_2>:
  413620:	48 8d 46 07          	lea    0x7(%rsi),%rax
  413624:	48 c1 e8 03          	shr    $0x3,%rax
  413628:	0f 84 80 00 00 00    	je     4136ae <metaset_fixed_2+0x8e>
  41362e:	49 ba 00 00 00 00 00 	movabs $0x400000000000,%r10
  413635:	40 00 00 
  413638:	48 c1 ef 03          	shr    $0x3,%rdi
  41363c:	49 8d 0c 7a          	lea    (%r10,%rdi,2),%rcx
  413640:	4c 8d 48 ff          	lea    -0x1(%rax),%r9
  413644:	49 89 c0             	mov    %rax,%r8
  413647:	49 83 e0 07          	and    $0x7,%r8
  41364b:	74 25                	je     413672 <metaset_fixed_2+0x52>
  41364d:	4c 01 c7             	add    %r8,%rdi
  413650:	83 c6 07             	add    $0x7,%esi
  413653:	c1 ee 03             	shr    $0x3,%esi
  413656:	83 e6 07             	and    $0x7,%esi
  413659:	48 f7 de             	neg    %rsi
  41365c:	0f 1f 40 00          	nopl   0x0(%rax)
  413660:	66 89 11             	mov    %dx,(%rcx)
  413663:	48 83 c1 02          	add    $0x2,%rcx
  413667:	48 ff c6             	inc    %rsi
  41366a:	75 f4                	jne    413660 <metaset_fixed_2+0x40>
  41366c:	49 8d 0c 7a          	lea    (%r10,%rdi,2),%rcx
  413670:	eb 03                	jmp    413675 <metaset_fixed_2+0x55>
  413672:	45 31 c0             	xor    %r8d,%r8d
  413675:	49 83 f9 07          	cmp    $0x7,%r9
  413679:	72 33                	jb     4136ae <metaset_fixed_2+0x8e>
  41367b:	66 0f 6e c2          	movd   %edx,%xmm0
  41367f:	66 0f 70 c0 c4       	pshufd $0xc4,%xmm0,%xmm0
  413684:	f2 0f 70 c0 00       	pshuflw $0x0,%xmm0,%xmm0
  413689:	f3 0f 70 c0 00       	pshufhw $0x0,%xmm0,%xmm0
  41368e:	4c 29 c0             	sub    %r8,%rax
  413691:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  413698:	0f 1f 84 00 00 00 00 
  41369f:	00 
  4136a0:	f3 0f 7f 01          	movdqu %xmm0,(%rcx)
  4136a4:	48 83 c1 10          	add    $0x10,%rcx
  4136a8:	48 83 c0 f8          	add    $0xfffffffffffffff8,%rax
  4136ac:	75 f2                	jne    4136a0 <metaset_fixed_2+0x80>
  4136ae:	31 c0                	xor    %eax,%eax
  4136b0:	c3                   	retq   
  4136b1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4136b8:	0f 1f 84 00 00 00 00 
  4136bf:	00 

00000000004136c0 <metaset_fixed_4>:
  4136c0:	48 8d 46 07          	lea    0x7(%rsi),%rax
  4136c4:	48 c1 e8 03          	shr    $0x3,%rax
  4136c8:	74 79                	je     413743 <metaset_fixed_4+0x83>
  4136ca:	49 ba 00 00 00 00 00 	movabs $0x400000000000,%r10
  4136d1:	40 00 00 
  4136d4:	48 c1 ef 03          	shr    $0x3,%rdi
  4136d8:	49 8d 0c ba          	lea    (%r10,%rdi,4),%rcx
  4136dc:	4c 8d 48 ff          	lea    -0x1(%rax),%r9
  4136e0:	49 89 c0             	mov    %rax,%r8
  4136e3:	49 83 e0 07          	and    $0x7,%r8
  4136e7:	74 28                	je     413711 <metaset_fixed_4+0x51>
  4136e9:	4c 01 c7             	add    %r8,%rdi
  4136ec:	83 c6 07             	add    $0x7,%esi
  4136ef:	c1 ee 03             	shr    $0x3,%esi
  4136f2:	83 e6 07             	and    $0x7,%esi
  4136f5:	48 f7 de             	neg    %rsi
  4136f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4136ff:	00 
  413700:	89 11                	mov    %edx,(%rcx)
  413702:	48 83 c1 04          	add    $0x4,%rcx
  413706:	48 ff c6             	inc    %rsi
  413709:	75 f5                	jne    413700 <metaset_fixed_4+0x40>
  41370b:	49 8d 0c ba          	lea    (%r10,%rdi,4),%rcx
  41370f:	eb 03                	jmp    413714 <metaset_fixed_4+0x54>
  413711:	45 31 c0             	xor    %r8d,%r8d
  413714:	49 83 f9 07          	cmp    $0x7,%r9
  413718:	72 29                	jb     413743 <metaset_fixed_4+0x83>
  41371a:	66 0f 6e c2          	movd   %edx,%xmm0
  41371e:	66 0f 70 c0 00       	pshufd $0x0,%xmm0,%xmm0
  413723:	4c 29 c0             	sub    %r8,%rax
  413726:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  41372d:	00 00 00 
  413730:	f3 0f 7f 01          	movdqu %xmm0,(%rcx)
  413734:	f3 0f 7f 41 10       	movdqu %xmm0,0x10(%rcx)
  413739:	48 83 c1 20          	add    $0x20,%rcx
  41373d:	48 83 c0 f8          	add    $0xfffffffffffffff8,%rax
  413741:	75 ed                	jne    413730 <metaset_fixed_4+0x70>
  413743:	31 c0                	xor    %eax,%eax
  413745:	c3                   	retq   
  413746:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  41374d:	00 00 00 

0000000000413750 <metaset_fixed_8>:
  413750:	48 8d 46 07          	lea    0x7(%rsi),%rax
  413754:	48 c1 e8 03          	shr    $0x3,%rax
  413758:	0f 84 9b 00 00 00    	je     4137f9 <metaset_fixed_8+0xa9>
  41375e:	49 ba 00 00 00 00 00 	movabs $0x400000000000,%r10
  413765:	40 00 00 
  413768:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
  41376c:	4a 8d 0c 17          	lea    (%rdi,%r10,1),%rcx
  413770:	4c 8d 48 ff          	lea    -0x1(%rax),%r9
  413774:	49 89 c0             	mov    %rax,%r8
  413777:	49 83 e0 07          	and    $0x7,%r8
  41377b:	74 3a                	je     4137b7 <metaset_fixed_8+0x67>
  41377d:	4e 8d 1c c5 00 00 00 	lea    0x0(,%r8,8),%r11
  413784:	00 
  413785:	83 c6 07             	add    $0x7,%esi
  413788:	c1 ee 03             	shr    $0x3,%esi
  41378b:	83 e6 07             	and    $0x7,%esi
  41378e:	48 f7 de             	neg    %rsi
  413791:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  413798:	0f 1f 84 00 00 00 00 
  41379f:	00 
  4137a0:	48 89 11             	mov    %rdx,(%rcx)
  4137a3:	48 83 c1 08          	add    $0x8,%rcx
  4137a7:	48 ff c6             	inc    %rsi
  4137aa:	75 f4                	jne    4137a0 <metaset_fixed_8+0x50>
  4137ac:	4c 01 df             	add    %r11,%rdi
  4137af:	49 01 fa             	add    %rdi,%r10
  4137b2:	4c 89 d1             	mov    %r10,%rcx
  4137b5:	eb 03                	jmp    4137ba <metaset_fixed_8+0x6a>
  4137b7:	45 31 c0             	xor    %r8d,%r8d
  4137ba:	49 83 f9 07          	cmp    $0x7,%r9
  4137be:	72 39                	jb     4137f9 <metaset_fixed_8+0xa9>
  4137c0:	4c 29 c0             	sub    %r8,%rax
  4137c3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4137ca:	84 00 00 00 00 00 
  4137d0:	48 89 11             	mov    %rdx,(%rcx)
  4137d3:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  4137d7:	48 89 51 10          	mov    %rdx,0x10(%rcx)
  4137db:	48 89 51 18          	mov    %rdx,0x18(%rcx)
  4137df:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  4137e3:	48 89 51 28          	mov    %rdx,0x28(%rcx)
  4137e7:	48 89 51 30          	mov    %rdx,0x30(%rcx)
  4137eb:	48 89 51 38          	mov    %rdx,0x38(%rcx)
  4137ef:	48 83 c1 40          	add    $0x40,%rcx
  4137f3:	48 83 c0 f8          	add    $0xfffffffffffffff8,%rax
  4137f7:	75 d7                	jne    4137d0 <metaset_fixed_8+0x80>
  4137f9:	31 c0                	xor    %eax,%eax
  4137fb:	c3                   	retq   
  4137fc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000413800 <metaset_fixed_16>:
  413800:	4c 8d 46 07          	lea    0x7(%rsi),%r8
  413804:	49 c1 e8 03          	shr    $0x3,%r8
  413808:	0f 84 bb 00 00 00    	je     4138c9 <metaset_fixed_16+0xc9>
  41380e:	49 bb 00 00 00 00 00 	movabs $0x400000000000,%r11
  413815:	40 00 00 
  413818:	48 c1 ef 03          	shr    $0x3,%rdi
  41381c:	48 89 f8             	mov    %rdi,%rax
  41381f:	48 c1 e0 04          	shl    $0x4,%rax
  413823:	4c 01 d8             	add    %r11,%rax
  413826:	4d 8d 50 ff          	lea    -0x1(%r8),%r10
  41382a:	4d 89 c1             	mov    %r8,%r9
  41382d:	49 83 e1 07          	and    $0x7,%r9
  413831:	74 39                	je     41386c <metaset_fixed_16+0x6c>
  413833:	4c 01 cf             	add    %r9,%rdi
  413836:	83 c6 07             	add    $0x7,%esi
  413839:	c1 ee 03             	shr    $0x3,%esi
  41383c:	83 e6 07             	and    $0x7,%esi
  41383f:	48 f7 de             	neg    %rsi
  413842:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  413849:	1f 84 00 00 00 00 00 
  413850:	48 89 10             	mov    %rdx,(%rax)
  413853:	48 89 48 08          	mov    %rcx,0x8(%rax)
  413857:	48 83 c0 10          	add    $0x10,%rax
  41385b:	48 ff c6             	inc    %rsi
  41385e:	75 f0                	jne    413850 <metaset_fixed_16+0x50>
  413860:	48 c1 e7 04          	shl    $0x4,%rdi
  413864:	49 01 fb             	add    %rdi,%r11
  413867:	4c 89 d8             	mov    %r11,%rax
  41386a:	eb 03                	jmp    41386f <metaset_fixed_16+0x6f>
  41386c:	45 31 c9             	xor    %r9d,%r9d
  41386f:	49 83 fa 07          	cmp    $0x7,%r10
  413873:	72 54                	jb     4138c9 <metaset_fixed_16+0xc9>
  413875:	4d 29 c8             	sub    %r9,%r8
  413878:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  41387f:	00 
  413880:	48 89 10             	mov    %rdx,(%rax)
  413883:	48 89 48 08          	mov    %rcx,0x8(%rax)
  413887:	48 89 50 10          	mov    %rdx,0x10(%rax)
  41388b:	48 89 48 18          	mov    %rcx,0x18(%rax)
  41388f:	48 89 50 20          	mov    %rdx,0x20(%rax)
  413893:	48 89 48 28          	mov    %rcx,0x28(%rax)
  413897:	48 89 50 30          	mov    %rdx,0x30(%rax)
  41389b:	48 89 48 38          	mov    %rcx,0x38(%rax)
  41389f:	48 89 50 40          	mov    %rdx,0x40(%rax)
  4138a3:	48 89 48 48          	mov    %rcx,0x48(%rax)
  4138a7:	48 89 50 50          	mov    %rdx,0x50(%rax)
  4138ab:	48 89 48 58          	mov    %rcx,0x58(%rax)
  4138af:	48 89 50 60          	mov    %rdx,0x60(%rax)
  4138b3:	48 89 48 68          	mov    %rcx,0x68(%rax)
  4138b7:	48 89 50 70          	mov    %rdx,0x70(%rax)
  4138bb:	48 89 48 78          	mov    %rcx,0x78(%rax)
  4138bf:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  4138c3:	49 83 c0 f8          	add    $0xfffffffffffffff8,%r8
  4138c7:	75 b7                	jne    413880 <metaset_fixed_16+0x80>
  4138c9:	31 c0                	xor    %eax,%eax
  4138cb:	c3                   	retq   
  4138cc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000004138d0 <metacheck_1>:
  4138d0:	39 f7                	cmp    %esi,%edi
  4138d2:	75 01                	jne    4138d5 <metacheck_1+0x5>
  4138d4:	c3                   	retq   
  4138d5:	0f 0b                	ud2    
  4138d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4138de:	00 00 

00000000004138e0 <metacheck_2>:
  4138e0:	39 f7                	cmp    %esi,%edi
  4138e2:	75 01                	jne    4138e5 <metacheck_2+0x5>
  4138e4:	c3                   	retq   
  4138e5:	0f 0b                	ud2    
  4138e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4138ee:	00 00 

00000000004138f0 <metacheck_4>:
  4138f0:	39 f7                	cmp    %esi,%edi
  4138f2:	75 01                	jne    4138f5 <metacheck_4+0x5>
  4138f4:	c3                   	retq   
  4138f5:	0f 0b                	ud2    
  4138f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4138fe:	00 00 

0000000000413900 <metacheck_8>:
  413900:	48 39 f7             	cmp    %rsi,%rdi
  413903:	75 01                	jne    413906 <metacheck_8+0x6>
  413905:	c3                   	retq   
  413906:	0f 0b                	ud2    
  413908:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  41390f:	00 

0000000000413910 <metabaseget>:
  413910:	48 c1 ef 0c          	shr    $0xc,%rdi
  413914:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  41391b:	40 00 00 
  41391e:	48 8b 04 f8          	mov    (%rax,%rdi,8),%rax
  413922:	c3                   	retq   
  413923:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  41392a:	84 00 00 00 00 00 

0000000000413930 <metaget_1>:
  413930:	48 89 f8             	mov    %rdi,%rax
  413933:	48 c1 e8 0c          	shr    $0xc,%rax
  413937:	48 b9 00 00 00 00 00 	movabs $0x400000000000,%rcx
  41393e:	40 00 00 
  413941:	48 8b 0c c1          	mov    (%rcx,%rax,8),%rcx
  413945:	48 85 c9             	test   %rcx,%rcx
  413948:	74 14                	je     41395e <metaget_1+0x2e>
  41394a:	48 89 ca             	mov    %rcx,%rdx
  41394d:	48 c1 ea 08          	shr    $0x8,%rdx
  413951:	48 c1 e0 0c          	shl    $0xc,%rax
  413955:	48 29 c7             	sub    %rax,%rdi
  413958:	48 d3 ef             	shr    %cl,%rdi
  41395b:	8a 14 3a             	mov    (%rdx,%rdi,1),%dl
  41395e:	0f b6 c2             	movzbl %dl,%eax
  413961:	c3                   	retq   
  413962:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  413969:	1f 84 00 00 00 00 00 

0000000000413970 <metaget_2>:
  413970:	48 89 f8             	mov    %rdi,%rax
  413973:	48 c1 e8 0c          	shr    $0xc,%rax
  413977:	48 b9 00 00 00 00 00 	movabs $0x400000000000,%rcx
  41397e:	40 00 00 
  413981:	48 8b 0c c1          	mov    (%rcx,%rax,8),%rcx
  413985:	48 85 c9             	test   %rcx,%rcx
  413988:	74 15                	je     41399f <metaget_2+0x2f>
  41398a:	48 89 ca             	mov    %rcx,%rdx
  41398d:	48 c1 ea 08          	shr    $0x8,%rdx
  413991:	48 c1 e0 0c          	shl    $0xc,%rax
  413995:	48 29 c7             	sub    %rax,%rdi
  413998:	48 d3 ef             	shr    %cl,%rdi
  41399b:	0f b7 14 7a          	movzwl (%rdx,%rdi,2),%edx
  41399f:	0f b7 c2             	movzwl %dx,%eax
  4139a2:	c3                   	retq   
  4139a3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4139aa:	84 00 00 00 00 00 

00000000004139b0 <metaget_4>:
  4139b0:	48 89 fa             	mov    %rdi,%rdx
  4139b3:	48 c1 ea 0c          	shr    $0xc,%rdx
  4139b7:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  4139be:	40 00 00 
  4139c1:	48 8b 0c d0          	mov    (%rax,%rdx,8),%rcx
  4139c5:	48 85 c9             	test   %rcx,%rcx
  4139c8:	74 14                	je     4139de <metaget_4+0x2e>
  4139ca:	48 89 c8             	mov    %rcx,%rax
  4139cd:	48 c1 e8 08          	shr    $0x8,%rax
  4139d1:	48 c1 e2 0c          	shl    $0xc,%rdx
  4139d5:	48 29 d7             	sub    %rdx,%rdi
  4139d8:	48 d3 ef             	shr    %cl,%rdi
  4139db:	8b 04 b8             	mov    (%rax,%rdi,4),%eax
  4139de:	c3                   	retq   
  4139df:	90                   	nop

00000000004139e0 <metaget_8>:
  4139e0:	48 89 fa             	mov    %rdi,%rdx
  4139e3:	48 c1 ea 0c          	shr    $0xc,%rdx
  4139e7:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  4139ee:	40 00 00 
  4139f1:	48 8b 0c d0          	mov    (%rax,%rdx,8),%rcx
  4139f5:	31 c0                	xor    %eax,%eax
  4139f7:	48 85 c9             	test   %rcx,%rcx
  4139fa:	74 15                	je     413a11 <metaget_8+0x31>
  4139fc:	48 89 c8             	mov    %rcx,%rax
  4139ff:	48 c1 e8 08          	shr    $0x8,%rax
  413a03:	48 c1 e2 0c          	shl    $0xc,%rdx
  413a07:	48 29 d7             	sub    %rdx,%rdi
  413a0a:	48 d3 ef             	shr    %cl,%rdi
  413a0d:	48 8b 04 f8          	mov    (%rax,%rdi,8),%rax
  413a11:	c3                   	retq   
  413a12:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  413a19:	1f 84 00 00 00 00 00 

0000000000413a20 <metaget_16>:
  413a20:	48 89 fe             	mov    %rdi,%rsi
  413a23:	48 c1 ee 0c          	shr    $0xc,%rsi
  413a27:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  413a2e:	40 00 00 
  413a31:	48 8b 0c f0          	mov    (%rax,%rsi,8),%rcx
  413a35:	31 c0                	xor    %eax,%eax
  413a37:	48 85 c9             	test   %rcx,%rcx
  413a3a:	ba 00 00 00 00       	mov    $0x0,%edx
  413a3f:	74 1e                	je     413a5f <metaget_16+0x3f>
  413a41:	48 89 ca             	mov    %rcx,%rdx
  413a44:	48 c1 ea 08          	shr    $0x8,%rdx
  413a48:	48 c1 e6 0c          	shl    $0xc,%rsi
  413a4c:	48 29 f7             	sub    %rsi,%rdi
  413a4f:	48 d3 ef             	shr    %cl,%rdi
  413a52:	48 c1 e7 04          	shl    $0x4,%rdi
  413a56:	48 8b 04 3a          	mov    (%rdx,%rdi,1),%rax
  413a5a:	48 8b 54 3a 08       	mov    0x8(%rdx,%rdi,1),%rdx
  413a5f:	c3                   	retq   

0000000000413a60 <metaget_deep_8>:
  413a60:	48 89 f8             	mov    %rdi,%rax
  413a63:	48 c1 e8 0c          	shr    $0xc,%rax
  413a67:	48 b9 00 00 00 00 00 	movabs $0x400000000000,%rcx
  413a6e:	40 00 00 
  413a71:	48 8b 0c c1          	mov    (%rcx,%rax,8),%rcx
  413a75:	48 89 ca             	mov    %rcx,%rdx
  413a78:	48 c1 ea 08          	shr    $0x8,%rdx
  413a7c:	48 c1 e0 0c          	shl    $0xc,%rax
  413a80:	48 29 c7             	sub    %rax,%rdi
  413a83:	48 d3 ef             	shr    %cl,%rdi
  413a86:	48 8b 04 fa          	mov    (%rdx,%rdi,8),%rax
  413a8a:	48 8b 00             	mov    (%rax),%rax
  413a8d:	c3                   	retq   
  413a8e:	66 90                	xchg   %ax,%ax

0000000000413a90 <metaget_fixed_1>:
  413a90:	48 c1 ef 03          	shr    $0x3,%rdi
  413a94:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  413a9b:	40 00 00 
  413a9e:	0f b6 04 07          	movzbl (%rdi,%rax,1),%eax
  413aa2:	c3                   	retq   
  413aa3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  413aaa:	84 00 00 00 00 00 

0000000000413ab0 <metaget_fixed_2>:
  413ab0:	48 c1 ef 03          	shr    $0x3,%rdi
  413ab4:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  413abb:	40 00 00 
  413abe:	0f b7 04 07          	movzwl (%rdi,%rax,1),%eax
  413ac2:	c3                   	retq   
  413ac3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  413aca:	84 00 00 00 00 00 

0000000000413ad0 <metaget_fixed_4>:
  413ad0:	48 c1 ef 03          	shr    $0x3,%rdi
  413ad4:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  413adb:	40 00 00 
  413ade:	8b 04 07             	mov    (%rdi,%rax,1),%eax
  413ae1:	c3                   	retq   
  413ae2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  413ae9:	1f 84 00 00 00 00 00 

0000000000413af0 <metaget_fixed_8>:
  413af0:	48 c1 ef 03          	shr    $0x3,%rdi
  413af4:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  413afb:	40 00 00 
  413afe:	48 8b 04 07          	mov    (%rdi,%rax,1),%rax
  413b02:	c3                   	retq   
  413b03:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  413b0a:	84 00 00 00 00 00 

0000000000413b10 <metaget_base_1>:
  413b10:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  413b17:	48 89 f0             	mov    %rsi,%rax
  413b1a:	48 c1 e8 08          	shr    $0x8,%rax
  413b1e:	48 29 d7             	sub    %rdx,%rdi
  413b21:	40 88 f1             	mov    %sil,%cl
  413b24:	48 d3 ef             	shr    %cl,%rdi
  413b27:	0f b6 04 38          	movzbl (%rax,%rdi,1),%eax
  413b2b:	c3                   	retq   
  413b2c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000413b30 <metaget_base_2>:
  413b30:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  413b37:	48 89 f0             	mov    %rsi,%rax
  413b3a:	48 c1 e8 08          	shr    $0x8,%rax
  413b3e:	48 29 d7             	sub    %rdx,%rdi
  413b41:	40 88 f1             	mov    %sil,%cl
  413b44:	48 d3 ef             	shr    %cl,%rdi
  413b47:	0f b7 04 78          	movzwl (%rax,%rdi,2),%eax
  413b4b:	c3                   	retq   
  413b4c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000413b50 <metaget_base_4>:
  413b50:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  413b57:	48 89 f0             	mov    %rsi,%rax
  413b5a:	48 c1 e8 08          	shr    $0x8,%rax
  413b5e:	48 29 d7             	sub    %rdx,%rdi
  413b61:	40 88 f1             	mov    %sil,%cl
  413b64:	48 d3 ef             	shr    %cl,%rdi
  413b67:	8b 04 b8             	mov    (%rax,%rdi,4),%eax
  413b6a:	c3                   	retq   
  413b6b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000413b70 <metaget_base_8>:
  413b70:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  413b77:	48 89 f0             	mov    %rsi,%rax
  413b7a:	48 c1 e8 08          	shr    $0x8,%rax
  413b7e:	48 29 d7             	sub    %rdx,%rdi
  413b81:	40 88 f1             	mov    %sil,%cl
  413b84:	48 d3 ef             	shr    %cl,%rdi
  413b87:	48 8b 04 f8          	mov    (%rax,%rdi,8),%rax
  413b8b:	c3                   	retq   
  413b8c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000413b90 <metaget_base_deep_8>:
  413b90:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  413b97:	48 89 f0             	mov    %rsi,%rax
  413b9a:	48 c1 e8 08          	shr    $0x8,%rax
  413b9e:	48 29 d7             	sub    %rdx,%rdi
  413ba1:	40 88 f1             	mov    %sil,%cl
  413ba4:	48 d3 ef             	shr    %cl,%rdi
  413ba7:	48 8b 04 f8          	mov    (%rax,%rdi,8),%rax
  413bab:	48 8b 00             	mov    (%rax),%rax
  413bae:	c3                   	retq   
  413baf:	90                   	nop

0000000000413bb0 <initialize_global_metadata>:
  413bb0:	41 57                	push   %r15
  413bb2:	41 56                	push   %r14
  413bb4:	53                   	push   %rbx
  413bb5:	48 83 ec 30          	sub    $0x30,%rsp
  413bb9:	8a 05 d1 e2 a5 00    	mov    0xa5e2d1(%rip),%al        # e71e90 <initialize_global_metadata.initialized>
  413bbf:	24 01                	and    $0x1,%al
  413bc1:	0f 85 2b 01 00 00    	jne    413cf2 <initialize_global_metadata+0x142>
  413bc7:	c6 05 c2 e2 a5 00 01 	movb   $0x1,0xa5e2c2(%rip)        # e71e90 <initialize_global_metadata.initialized>
  413bce:	31 c0                	xor    %eax,%eax
  413bd0:	e8 1b e7 fe ff       	callq  4022f0 <is_fixed_compression@plt>
  413bd5:	85 c0                	test   %eax,%eax
  413bd7:	0f 85 ff 00 00 00    	jne    413cdc <initialize_global_metadata+0x12c>
  413bdd:	0f 57 c0             	xorps  %xmm0,%xmm0
  413be0:	0f 29 44 24 20       	movaps %xmm0,0x20(%rsp)
  413be5:	0f 29 44 24 10       	movaps %xmm0,0x10(%rsp)
  413bea:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
  413bef:	bf b0 3b 41 00       	mov    $0x413bb0,%edi
  413bf4:	e8 07 e7 fe ff       	callq  402300 <dladdr@plt>
  413bf9:	85 c0                	test   %eax,%eax
  413bfb:	0f 84 90 04 00 00    	je     414091 <initialize_global_metadata+0x4e1>
  413c01:	4c 8b 74 24 18       	mov    0x18(%rsp),%r14
  413c06:	b8 80 1f e7 00       	mov    $0xe71f80,%eax
  413c0b:	49 39 c6             	cmp    %rax,%r14
  413c0e:	0f 87 91 04 00 00    	ja     4140a5 <initialize_global_metadata+0x4f5>
  413c14:	4d 89 f7             	mov    %r14,%r15
  413c17:	49 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%r15
  413c1e:	bb 7f 2f e7 00       	mov    $0xe72f7f,%ebx
  413c23:	4c 29 fb             	sub    %r15,%rbx
  413c26:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
  413c2d:	be 03 00 00 00       	mov    $0x3,%esi
  413c32:	48 89 df             	mov    %rbx,%rdi
  413c35:	e8 d6 e6 fe ff       	callq  402310 <allocate_metadata@plt>
  413c3a:	b9 03 00 00 00       	mov    $0x3,%ecx
  413c3f:	4c 89 ff             	mov    %r15,%rdi
  413c42:	48 89 de             	mov    %rbx,%rsi
  413c45:	48 89 c2             	mov    %rax,%rdx
  413c48:	e8 d3 e6 fe ff       	callq  402320 <set_metapagetable_entries@plt>
  413c4d:	4c 89 35 ec e2 a5 00 	mov    %r14,0xa5e2ec(%rip)        # e71f40 <dang_global_start>
  413c54:	48 c7 05 d9 e2 a5 00 	movq   $0xe71f80,0xa5e2d9(%rip)        # e71f38 <dang_global_end>
  413c5b:	80 1f e7 00 
  413c5f:	48 8d 34 24          	lea    (%rsp),%rsi
  413c63:	bf 03 00 00 00       	mov    $0x3,%edi
  413c68:	e8 73 e5 fe ff       	callq  4021e0 <getrlimit@plt>
  413c6d:	85 c0                	test   %eax,%eax
  413c6f:	75 11                	jne    413c82 <initialize_global_metadata+0xd2>
  413c71:	48 8b 04 24          	mov    (%rsp),%rax
  413c75:	48 8d 48 ff          	lea    -0x1(%rax),%rcx
  413c79:	48 81 f9 ff ff ff 7f 	cmp    $0x7fffffff,%rcx
  413c80:	72 0d                	jb     413c8f <initialize_global_metadata+0xdf>
  413c82:	48 c7 04 24 00 00 10 	movq   $0x100000,(%rsp)
  413c89:	00 
  413c8a:	b8 00 00 10 00       	mov    $0x100000,%eax
  413c8f:	48 89 e3             	mov    %rsp,%rbx
  413c92:	49 89 de             	mov    %rbx,%r14
  413c95:	49 29 c6             	sub    %rax,%r14
  413c98:	48 f7 d8             	neg    %rax
  413c9b:	48 85 c0             	test   %rax,%rax
  413c9e:	0f 8f 19 04 00 00    	jg     4140bd <initialize_global_metadata+0x50d>
  413ca4:	49 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%r14
  413cab:	48 81 c3 ff 0f 00 00 	add    $0xfff,%rbx
  413cb2:	4c 29 f3             	sub    %r14,%rbx
  413cb5:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
  413cbc:	be 03 00 00 00       	mov    $0x3,%esi
  413cc1:	48 89 df             	mov    %rbx,%rdi
  413cc4:	e8 47 e6 fe ff       	callq  402310 <allocate_metadata@plt>
  413cc9:	b9 03 00 00 00       	mov    $0x3,%ecx
  413cce:	4c 89 f7             	mov    %r14,%rdi
  413cd1:	48 89 de             	mov    %rbx,%rsi
  413cd4:	48 89 c2             	mov    %rax,%rdx
  413cd7:	e8 44 e6 fe ff       	callq  402320 <set_metapagetable_entries@plt>
  413cdc:	48 c7 05 79 e2 a5 00 	movq   $0x414260,0xa5e279(%rip)        # e71f60 <metalloc_malloc_posthook>
  413ce3:	60 42 41 00 
  413ce7:	48 c7 05 7e e2 a5 00 	movq   $0x4143f0,0xa5e27e(%rip)        # e71f70 <metalloc_free_prehook>
  413cee:	f0 43 41 00 
  413cf2:	bf 58 1e e7 00       	mov    $0xe71e58,%edi
  413cf7:	be 08 00 00 00       	mov    $0x8,%esi
  413cfc:	31 d2                	xor    %edx,%edx
  413cfe:	31 c9                	xor    %ecx,%ecx
  413d00:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413d06:	e8 a5 f4 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413d0b:	bf 60 1e e7 00       	mov    $0xe71e60,%edi
  413d10:	be 08 00 00 00       	mov    $0x8,%esi
  413d15:	31 d2                	xor    %edx,%edx
  413d17:	31 c9                	xor    %ecx,%ecx
  413d19:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413d1f:	e8 8c f4 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413d24:	bf 68 1e e7 00       	mov    $0xe71e68,%edi
  413d29:	be 08 00 00 00       	mov    $0x8,%esi
  413d2e:	31 d2                	xor    %edx,%edx
  413d30:	31 c9                	xor    %ecx,%ecx
  413d32:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413d38:	e8 73 f4 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413d3d:	bf 70 1e e7 00       	mov    $0xe71e70,%edi
  413d42:	be 08 00 00 00       	mov    $0x8,%esi
  413d47:	31 d2                	xor    %edx,%edx
  413d49:	31 c9                	xor    %ecx,%ecx
  413d4b:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413d51:	e8 5a f4 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413d56:	bf 78 1e e7 00       	mov    $0xe71e78,%edi
  413d5b:	be 04 00 00 00       	mov    $0x4,%esi
  413d60:	31 d2                	xor    %edx,%edx
  413d62:	31 c9                	xor    %ecx,%ecx
  413d64:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413d6a:	e8 41 f4 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413d6f:	bf 80 1e e7 00       	mov    $0xe71e80,%edi
  413d74:	be 08 00 00 00       	mov    $0x8,%esi
  413d79:	31 d2                	xor    %edx,%edx
  413d7b:	31 c9                	xor    %ecx,%ecx
  413d7d:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413d83:	e8 28 f4 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413d88:	bf 88 1e e7 00       	mov    $0xe71e88,%edi
  413d8d:	be 08 00 00 00       	mov    $0x8,%esi
  413d92:	31 d2                	xor    %edx,%edx
  413d94:	31 c9                	xor    %ecx,%ecx
  413d96:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413d9c:	e8 0f f4 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413da1:	bf b8 81 41 00       	mov    $0x4181b8,%edi
  413da6:	be 0f 00 00 00       	mov    $0xf,%esi
  413dab:	31 d2                	xor    %edx,%edx
  413dad:	31 c9                	xor    %ecx,%ecx
  413daf:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413db5:	e8 f6 f3 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413dba:	bf c8 81 41 00       	mov    $0x4181c8,%edi
  413dbf:	be 20 00 00 00       	mov    $0x20,%esi
  413dc4:	31 d2                	xor    %edx,%edx
  413dc6:	31 c9                	xor    %ecx,%ecx
  413dc8:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413dce:	e8 dd f3 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413dd3:	bf e8 81 41 00       	mov    $0x4181e8,%edi
  413dd8:	be 21 00 00 00       	mov    $0x21,%esi
  413ddd:	31 d2                	xor    %edx,%edx
  413ddf:	31 c9                	xor    %ecx,%ecx
  413de1:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413de7:	e8 c4 f3 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413dec:	bf 10 82 41 00       	mov    $0x418210,%edi
  413df1:	be 0c 00 00 00       	mov    $0xc,%esi
  413df6:	31 d2                	xor    %edx,%edx
  413df8:	31 c9                	xor    %ecx,%ecx
  413dfa:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413e00:	e8 ab f3 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413e05:	bf 20 82 41 00       	mov    $0x418220,%edi
  413e0a:	be 04 00 00 00       	mov    $0x4,%esi
  413e0f:	31 d2                	xor    %edx,%edx
  413e11:	31 c9                	xor    %ecx,%ecx
  413e13:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413e19:	e8 92 f3 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413e1e:	bf 28 82 41 00       	mov    $0x418228,%edi
  413e23:	be 20 00 00 00       	mov    $0x20,%esi
  413e28:	31 d2                	xor    %edx,%edx
  413e2a:	31 c9                	xor    %ecx,%ecx
  413e2c:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413e32:	e8 79 f3 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413e37:	bf 48 82 41 00       	mov    $0x418248,%edi
  413e3c:	be 10 00 00 00       	mov    $0x10,%esi
  413e41:	31 d2                	xor    %edx,%edx
  413e43:	31 c9                	xor    %ecx,%ecx
  413e45:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413e4b:	e8 60 f3 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413e50:	bf 58 82 41 00       	mov    $0x418258,%edi
  413e55:	be 0c 00 00 00       	mov    $0xc,%esi
  413e5a:	31 d2                	xor    %edx,%edx
  413e5c:	31 c9                	xor    %ecx,%ecx
  413e5e:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413e64:	e8 47 f3 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413e69:	bf 68 82 41 00       	mov    $0x418268,%edi
  413e6e:	be 22 00 00 00       	mov    $0x22,%esi
  413e73:	31 d2                	xor    %edx,%edx
  413e75:	31 c9                	xor    %ecx,%ecx
  413e77:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413e7d:	e8 2e f3 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413e82:	bf 80 1f e7 00       	mov    $0xe71f80,%edi
  413e87:	be 01 00 00 00       	mov    $0x1,%esi
  413e8c:	31 d2                	xor    %edx,%edx
  413e8e:	31 c9                	xor    %ecx,%ecx
  413e90:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413e96:	e8 15 f3 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413e9b:	bf 40 1f e7 00       	mov    $0xe71f40,%edi
  413ea0:	be 08 00 00 00       	mov    $0x8,%esi
  413ea5:	31 d2                	xor    %edx,%edx
  413ea7:	31 c9                	xor    %ecx,%ecx
  413ea9:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413eaf:	e8 fc f2 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413eb4:	bf 38 1f e7 00       	mov    $0xe71f38,%edi
  413eb9:	be 08 00 00 00       	mov    $0x8,%esi
  413ebe:	31 d2                	xor    %edx,%edx
  413ec0:	31 c9                	xor    %ecx,%ecx
  413ec2:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413ec8:	e8 e3 f2 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413ecd:	bf 78 1f e7 00       	mov    $0xe71f78,%edi
  413ed2:	be 08 00 00 00       	mov    $0x8,%esi
  413ed7:	31 d2                	xor    %edx,%edx
  413ed9:	31 c9                	xor    %ecx,%ecx
  413edb:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413ee1:	e8 ca f2 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413ee6:	bf 90 1e e7 00       	mov    $0xe71e90,%edi
  413eeb:	be 01 00 00 00       	mov    $0x1,%esi
  413ef0:	31 d2                	xor    %edx,%edx
  413ef2:	31 c9                	xor    %ecx,%ecx
  413ef4:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413efa:	e8 b1 f2 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413eff:	bf 90 82 41 00       	mov    $0x418290,%edi
  413f04:	be 2a 00 00 00       	mov    $0x2a,%esi
  413f09:	31 d2                	xor    %edx,%edx
  413f0b:	31 c9                	xor    %ecx,%ecx
  413f0d:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413f13:	e8 98 f2 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413f18:	bf c0 82 41 00       	mov    $0x4182c0,%edi
  413f1d:	be 35 00 00 00       	mov    $0x35,%esi
  413f22:	31 d2                	xor    %edx,%edx
  413f24:	31 c9                	xor    %ecx,%ecx
  413f26:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413f2c:	e8 7f f2 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413f31:	bf 50 1f e7 00       	mov    $0xe71f50,%edi
  413f36:	be 08 00 00 00       	mov    $0x8,%esi
  413f3b:	31 d2                	xor    %edx,%edx
  413f3d:	31 c9                	xor    %ecx,%ecx
  413f3f:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413f45:	e8 66 f2 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413f4a:	bf 48 1f e7 00       	mov    $0xe71f48,%edi
  413f4f:	be 08 00 00 00       	mov    $0x8,%esi
  413f54:	31 d2                	xor    %edx,%edx
  413f56:	31 c9                	xor    %ecx,%ecx
  413f58:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413f5e:	e8 4d f2 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413f63:	bf 60 1f e7 00       	mov    $0xe71f60,%edi
  413f68:	be 08 00 00 00       	mov    $0x8,%esi
  413f6d:	31 d2                	xor    %edx,%edx
  413f6f:	31 c9                	xor    %ecx,%ecx
  413f71:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413f77:	e8 34 f2 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413f7c:	bf 70 1f e7 00       	mov    $0xe71f70,%edi
  413f81:	be 08 00 00 00       	mov    $0x8,%esi
  413f86:	31 d2                	xor    %edx,%edx
  413f88:	31 c9                	xor    %ecx,%ecx
  413f8a:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413f90:	e8 1b f2 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413f95:	bf a0 1e e7 00       	mov    $0xe71ea0,%edi
  413f9a:	be 98 00 00 00       	mov    $0x98,%esi
  413f9f:	31 d2                	xor    %edx,%edx
  413fa1:	31 c9                	xor    %ecx,%ecx
  413fa3:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413fa9:	e8 02 f2 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413fae:	bf f8 82 41 00       	mov    $0x4182f8,%edi
  413fb3:	be 19 00 00 00       	mov    $0x19,%esi
  413fb8:	31 d2                	xor    %edx,%edx
  413fba:	31 c9                	xor    %ecx,%ecx
  413fbc:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413fc2:	e8 e9 f1 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413fc7:	bf 18 83 41 00       	mov    $0x418318,%edi
  413fcc:	be 0e 00 00 00       	mov    $0xe,%esi
  413fd1:	31 d2                	xor    %edx,%edx
  413fd3:	31 c9                	xor    %ecx,%ecx
  413fd5:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413fdb:	e8 d0 f1 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413fe0:	bf 28 83 41 00       	mov    $0x418328,%edi
  413fe5:	be 1b 00 00 00       	mov    $0x1b,%esi
  413fea:	31 d2                	xor    %edx,%edx
  413fec:	31 c9                	xor    %ecx,%ecx
  413fee:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  413ff4:	e8 b7 f1 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  413ff9:	64 48 8b 1c 25 00 00 	mov    %fs:0x0,%rbx
  414000:	00 00 
  414002:	48 8d bb 10 ff ff ff 	lea    -0xf0(%rbx),%rdi
  414009:	be 01 00 00 00       	mov    $0x1,%esi
  41400e:	31 d2                	xor    %edx,%edx
  414010:	31 c9                	xor    %ecx,%ecx
  414012:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  414018:	e8 93 f1 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  41401d:	48 8d bb 18 ff ff ff 	lea    -0xe8(%rbx),%rdi
  414024:	be 08 00 00 00       	mov    $0x8,%esi
  414029:	31 d2                	xor    %edx,%edx
  41402b:	31 c9                	xor    %ecx,%ecx
  41402d:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  414033:	e8 78 f1 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  414038:	bf 98 1e e7 00       	mov    $0xe71e98,%edi
  41403d:	be 08 00 00 00       	mov    $0x8,%esi
  414042:	31 d2                	xor    %edx,%edx
  414044:	31 c9                	xor    %ecx,%ecx
  414046:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  41404c:	e8 5f f1 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  414051:	48 8d bb 20 ff ff ff 	lea    -0xe0(%rbx),%rdi
  414058:	be 01 00 00 00       	mov    $0x1,%esi
  41405d:	31 d2                	xor    %edx,%edx
  41405f:	31 c9                	xor    %ecx,%ecx
  414061:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  414067:	e8 44 f1 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  41406c:	48 8d bb 28 ff ff ff 	lea    -0xd8(%rbx),%rdi
  414073:	be d0 00 00 00       	mov    $0xd0,%esi
  414078:	31 d2                	xor    %edx,%edx
  41407a:	31 c9                	xor    %ecx,%ecx
  41407c:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  414082:	e8 29 f1 ff ff       	callq  4131b0 <metaset_alignment_safe_16>
  414087:	48 83 c4 30          	add    $0x30,%rsp
  41408b:	5b                   	pop    %rbx
  41408c:	41 5e                	pop    %r14
  41408e:	41 5f                	pop    %r15
  414090:	c3                   	retq   
  414091:	bf 90 82 41 00       	mov    $0x418290,%edi
  414096:	e8 05 e2 fe ff       	callq  4022a0 <perror@plt>
  41409b:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  4140a0:	e8 0b e2 fe ff       	callq  4022b0 <exit@plt>
  4140a5:	48 8b 3d cc de a5 00 	mov    0xa5decc(%rip),%rdi        # e71f78 <stderr>
  4140ac:	be c0 82 41 00       	mov    $0x4182c0,%esi
  4140b1:	b9 80 1f e7 00       	mov    $0xe71f80,%ecx
  4140b6:	31 c0                	xor    %eax,%eax
  4140b8:	4c 89 f2             	mov    %r14,%rdx
  4140bb:	eb 14                	jmp    4140d1 <initialize_global_metadata+0x521>
  4140bd:	48 8b 3d b4 de a5 00 	mov    0xa5deb4(%rip),%rdi        # e71f78 <stderr>
  4140c4:	be c0 82 41 00       	mov    $0x4182c0,%esi
  4140c9:	31 c0                	xor    %eax,%eax
  4140cb:	4c 89 f2             	mov    %r14,%rdx
  4140ce:	48 89 d9             	mov    %rbx,%rcx
  4140d1:	e8 5a e2 fe ff       	callq  402330 <fprintf@plt>
  4140d6:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  4140db:	e8 d0 e1 fe ff       	callq  4022b0 <exit@plt>

00000000004140e0 <unsafe_stack_alloc_meta>:
  4140e0:	55                   	push   %rbp
  4140e1:	41 56                	push   %r14
  4140e3:	53                   	push   %rbx
  4140e4:	89 d5                	mov    %edx,%ebp
  4140e6:	49 89 f6             	mov    %rsi,%r14
  4140e9:	48 89 fb             	mov    %rdi,%rbx
  4140ec:	48 89 1d 5d de a5 00 	mov    %rbx,0xa5de5d(%rip)        # e71f50 <dang_stack_start>
  4140f3:	4a 8d 04 33          	lea    (%rbx,%r14,1),%rax
  4140f7:	48 89 05 4a de a5 00 	mov    %rax,0xa5de4a(%rip)        # e71f48 <dang_stack_end>
  4140fe:	31 c0                	xor    %eax,%eax
  414100:	e8 eb e1 fe ff       	callq  4022f0 <is_fixed_compression@plt>
  414105:	85 c0                	test   %eax,%eax
  414107:	74 05                	je     41410e <unsafe_stack_alloc_meta+0x2e>
  414109:	5b                   	pop    %rbx
  41410a:	41 5e                	pop    %r14
  41410c:	5d                   	pop    %rbp
  41410d:	c3                   	retq   
  41410e:	40 84 ed             	test   %bpl,%bpl
  414111:	b8 0c 00 00 00       	mov    $0xc,%eax
  414116:	be 06 00 00 00       	mov    $0x6,%esi
  41411b:	48 0f 45 f0          	cmovne %rax,%rsi
  41411f:	b8 0c 00 00 00       	mov    $0xc,%eax
  414124:	bd 06 00 00 00       	mov    $0x6,%ebp
  414129:	0f 45 e8             	cmovne %eax,%ebp
  41412c:	4c 89 f7             	mov    %r14,%rdi
  41412f:	e8 dc e1 fe ff       	callq  402310 <allocate_metadata@plt>
  414134:	48 89 df             	mov    %rbx,%rdi
  414137:	4c 89 f6             	mov    %r14,%rsi
  41413a:	48 89 c2             	mov    %rax,%rdx
  41413d:	89 e9                	mov    %ebp,%ecx
  41413f:	5b                   	pop    %rbx
  414140:	41 5e                	pop    %r14
  414142:	5d                   	pop    %rbp
  414143:	e9 d8 e1 fe ff       	jmpq   402320 <set_metapagetable_entries@plt>
  414148:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  41414f:	00 

0000000000414150 <unsafe_stack_free_meta>:
  414150:	55                   	push   %rbp
  414151:	41 56                	push   %r14
  414153:	53                   	push   %rbx
  414154:	89 d5                	mov    %edx,%ebp
  414156:	49 89 f6             	mov    %rsi,%r14
  414159:	48 89 fb             	mov    %rdi,%rbx
  41415c:	31 c0                	xor    %eax,%eax
  41415e:	e8 8d e1 fe ff       	callq  4022f0 <is_fixed_compression@plt>
  414163:	85 c0                	test   %eax,%eax
  414165:	74 05                	je     41416c <unsafe_stack_free_meta+0x1c>
  414167:	5b                   	pop    %rbx
  414168:	41 5e                	pop    %r14
  41416a:	5d                   	pop    %rbp
  41416b:	c3                   	retq   
  41416c:	40 84 ed             	test   %bpl,%bpl
  41416f:	b8 0c 00 00 00       	mov    $0xc,%eax
  414174:	ba 06 00 00 00       	mov    $0x6,%edx
  414179:	48 0f 45 d0          	cmovne %rax,%rdx
  41417d:	48 89 df             	mov    %rbx,%rdi
  414180:	4c 89 f6             	mov    %r14,%rsi
  414183:	5b                   	pop    %rbx
  414184:	41 5e                	pop    %r14
  414186:	5d                   	pop    %rbp
  414187:	e9 b4 e1 fe ff       	jmpq   402340 <deallocate_metadata@plt>
  41418c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000414190 <dang_print_strace>:
  414190:	55                   	push   %rbp
  414191:	41 56                	push   %r14
  414193:	53                   	push   %rbx
  414194:	48 81 ec 20 03 00 00 	sub    $0x320,%rsp
  41419b:	4c 8d 34 24          	lea    (%rsp),%r14
  41419f:	be 64 00 00 00       	mov    $0x64,%esi
  4141a4:	4c 89 f7             	mov    %r14,%rdi
  4141a7:	e8 a4 e1 fe ff       	callq  402350 <backtrace@plt>
  4141ac:	89 c5                	mov    %eax,%ebp
  4141ae:	4c 89 f7             	mov    %r14,%rdi
  4141b1:	89 ee                	mov    %ebp,%esi
  4141b3:	e8 a8 e1 fe ff       	callq  402360 <backtrace_symbols@plt>
  4141b8:	49 89 c6             	mov    %rax,%r14
  4141bb:	4d 85 f6             	test   %r14,%r14
  4141be:	74 3a                	je     4141fa <dang_print_strace+0x6a>
  4141c0:	bf 18 83 41 00       	mov    $0x418318,%edi
  4141c5:	e8 a6 e1 fe ff       	callq  402370 <puts@plt>
  4141ca:	85 ed                	test   %ebp,%ebp
  4141cc:	7e 22                	jle    4141f0 <dang_print_strace+0x60>
  4141ce:	4c 89 f3             	mov    %r14,%rbx
  4141d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4141d8:	0f 1f 84 00 00 00 00 
  4141df:	00 
  4141e0:	48 8b 3b             	mov    (%rbx),%rdi
  4141e3:	e8 88 e1 fe ff       	callq  402370 <puts@plt>
  4141e8:	48 83 c3 08          	add    $0x8,%rbx
  4141ec:	ff cd                	dec    %ebp
  4141ee:	75 f0                	jne    4141e0 <dang_print_strace+0x50>
  4141f0:	4c 89 f7             	mov    %r14,%rdi
  4141f3:	e8 d8 e0 fe ff       	callq  4022d0 <free@plt>
  4141f8:	eb 0a                	jmp    414204 <dang_print_strace+0x74>
  4141fa:	bf f8 82 41 00       	mov    $0x4182f8,%edi
  4141ff:	e8 6c e1 fe ff       	callq  402370 <puts@plt>
  414204:	48 81 c4 20 03 00 00 	add    $0x320,%rsp
  41420b:	5b                   	pop    %rbx
  41420c:	41 5e                	pop    %r14
  41420e:	5d                   	pop    %rbp
  41420f:	c3                   	retq   

0000000000414210 <vinod_get_stack>:
  414210:	55                   	push   %rbp
  414211:	48 89 e5             	mov    %rsp,%rbp
  414214:	53                   	push   %rbx
  414215:	48 83 e4 c0          	and    $0xffffffffffffffc0,%rsp
  414219:	48 83 ec 40          	sub    $0x40,%rsp
  41421d:	48 8d 1c 24          	lea    (%rsp),%rbx
  414221:	be 04 00 00 00       	mov    $0x4,%esi
  414226:	48 89 df             	mov    %rbx,%rdi
  414229:	e8 32 00 00 00       	callq  414260 <dang_init_heapobj>
  41422e:	bf 28 83 41 00       	mov    $0x418328,%edi
  414233:	31 c0                	xor    %eax,%eax
  414235:	48 89 de             	mov    %rbx,%rsi
  414238:	e8 43 e0 fe ff       	callq  402280 <printf@plt>
  41423d:	be 04 00 00 00       	mov    $0x4,%esi
  414242:	48 89 df             	mov    %rbx,%rdi
  414245:	e8 a6 01 00 00       	callq  4143f0 <dang_freeptr>
  41424a:	31 c0                	xor    %eax,%eax
  41424c:	48 8d 65 f8          	lea    -0x8(%rbp),%rsp
  414250:	5b                   	pop    %rbx
  414251:	5d                   	pop    %rbp
  414252:	c3                   	retq   
  414253:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  41425a:	84 00 00 00 00 00 

0000000000414260 <dang_init_heapobj>:
  414260:	41 57                	push   %r15
  414262:	41 56                	push   %r14
  414264:	53                   	push   %rbx
  414265:	49 89 f6             	mov    %rsi,%r14
  414268:	49 89 ff             	mov    %rdi,%r15
  41426b:	64 0f b6 04 25 10 ff 	movzbl %fs:0xffffffffffffff10,%eax
  414272:	ff ff 
  414274:	83 e0 01             	and    $0x1,%eax
  414277:	83 f8 01             	cmp    $0x1,%eax
  41427a:	75 0e                	jne    41428a <dang_init_heapobj+0x2a>
  41427c:	64 c6 04 25 10 ff ff 	movb   $0x0,%fs:0xffffffffffffff10
  414283:	ff 00 
  414285:	e9 2f 01 00 00       	jmpq   4143b9 <dang_init_heapobj+0x159>
  41428a:	64 48 8b 1c 25 18 ff 	mov    %fs:0xffffffffffffff18,%rbx
  414291:	ff ff 
  414293:	48 85 db             	test   %rbx,%rbx
  414296:	0f 84 23 01 00 00    	je     4143bf <dang_init_heapobj+0x15f>
  41429c:	64 c6 04 25 10 ff ff 	movb   $0x1,%fs:0xffffffffffffff10
  4142a3:	ff 01 
  4142a5:	bf 38 04 00 00       	mov    $0x438,%edi
  4142aa:	e8 e1 df fe ff       	callq  402290 <malloc@plt>
  4142af:	48 89 18             	mov    %rbx,(%rax)
  4142b2:	0f 57 c0             	xorps  %xmm0,%xmm0
  4142b5:	0f 11 40 18          	movups %xmm0,0x18(%rax)
  4142b9:	0f 11 40 08          	movups %xmm0,0x8(%rax)
  4142bd:	48 c7 40 28 80 00 00 	movq   $0x80,0x28(%rax)
  4142c4:	00 
  4142c5:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  4142cc:	00 
  4142cd:	4c 89 fb             	mov    %r15,%rbx
  4142d0:	48 c1 eb 0c          	shr    $0xc,%rbx
  4142d4:	48 b9 00 00 00 00 00 	movabs $0x400000000000,%rcx
  4142db:	40 00 00 
  4142de:	4c 8b 14 d9          	mov    (%rcx,%rbx,8),%r10
  4142e2:	41 0f b6 ca          	movzbl %r10b,%ecx
  4142e6:	ba 01 00 00 00       	mov    $0x1,%edx
  4142eb:	d3 e2                	shl    %cl,%edx
  4142ed:	48 63 d2             	movslq %edx,%rdx
  4142f0:	49 8d 7c 16 ff       	lea    -0x1(%r14,%rdx,1),%rdi
  4142f5:	48 d3 ef             	shr    %cl,%rdi
  4142f8:	48 85 ff             	test   %rdi,%rdi
  4142fb:	0f 84 b8 00 00 00    	je     4143b9 <dang_init_heapobj+0x159>
  414301:	4c 89 fe             	mov    %r15,%rsi
  414304:	48 c1 e6 20          	shl    $0x20,%rsi
  414308:	4c 09 f6             	or     %r14,%rsi
  41430b:	49 c1 ea 08          	shr    $0x8,%r10
  41430f:	48 c1 e3 0c          	shl    $0xc,%rbx
  414313:	49 29 df             	sub    %rbx,%r15
  414316:	49 d3 ef             	shr    %cl,%r15
  414319:	4c 89 f9             	mov    %r15,%rcx
  41431c:	48 c1 e1 04          	shl    $0x4,%rcx
  414320:	4c 01 d1             	add    %r10,%rcx
  414323:	4c 8d 4f ff          	lea    -0x1(%rdi),%r9
  414327:	49 89 f8             	mov    %rdi,%r8
  41432a:	49 83 e0 07          	and    $0x7,%r8
  41432e:	74 2c                	je     41435c <dang_init_heapobj+0xfc>
  414330:	4d 01 c7             	add    %r8,%r15
  414333:	89 fa                	mov    %edi,%edx
  414335:	83 e2 07             	and    $0x7,%edx
  414338:	48 f7 da             	neg    %rdx
  41433b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  414340:	48 89 01             	mov    %rax,(%rcx)
  414343:	48 89 71 08          	mov    %rsi,0x8(%rcx)
  414347:	48 83 c1 10          	add    $0x10,%rcx
  41434b:	48 ff c2             	inc    %rdx
  41434e:	75 f0                	jne    414340 <dang_init_heapobj+0xe0>
  414350:	49 c1 e7 04          	shl    $0x4,%r15
  414354:	4d 01 fa             	add    %r15,%r10
  414357:	4c 89 d1             	mov    %r10,%rcx
  41435a:	eb 03                	jmp    41435f <dang_init_heapobj+0xff>
  41435c:	45 31 c0             	xor    %r8d,%r8d
  41435f:	49 83 f9 07          	cmp    $0x7,%r9
  414363:	72 54                	jb     4143b9 <dang_init_heapobj+0x159>
  414365:	4c 29 c7             	sub    %r8,%rdi
  414368:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  41436f:	00 
  414370:	48 89 01             	mov    %rax,(%rcx)
  414373:	48 89 71 08          	mov    %rsi,0x8(%rcx)
  414377:	48 89 41 10          	mov    %rax,0x10(%rcx)
  41437b:	48 89 71 18          	mov    %rsi,0x18(%rcx)
  41437f:	48 89 41 20          	mov    %rax,0x20(%rcx)
  414383:	48 89 71 28          	mov    %rsi,0x28(%rcx)
  414387:	48 89 41 30          	mov    %rax,0x30(%rcx)
  41438b:	48 89 71 38          	mov    %rsi,0x38(%rcx)
  41438f:	48 89 41 40          	mov    %rax,0x40(%rcx)
  414393:	48 89 71 48          	mov    %rsi,0x48(%rcx)
  414397:	48 89 41 50          	mov    %rax,0x50(%rcx)
  41439b:	48 89 71 58          	mov    %rsi,0x58(%rcx)
  41439f:	48 89 41 60          	mov    %rax,0x60(%rcx)
  4143a3:	48 89 71 68          	mov    %rsi,0x68(%rcx)
  4143a7:	48 89 41 70          	mov    %rax,0x70(%rcx)
  4143ab:	48 89 71 78          	mov    %rsi,0x78(%rcx)
  4143af:	48 83 e9 80          	sub    $0xffffffffffffff80,%rcx
  4143b3:	48 83 c7 f8          	add    $0xfffffffffffffff8,%rdi
  4143b7:	75 b7                	jne    414370 <dang_init_heapobj+0x110>
  4143b9:	5b                   	pop    %rbx
  4143ba:	41 5e                	pop    %r14
  4143bc:	41 5f                	pop    %r15
  4143be:	c3                   	retq   
  4143bf:	48 8b 05 d2 da a5 00 	mov    0xa5dad2(%rip),%rax        # e71e98 <threadglobal_id>
  4143c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4143cd:	00 00 00 
  4143d0:	48 8d 58 01          	lea    0x1(%rax),%rbx
  4143d4:	f0 48 0f b1 1d bb da 	lock cmpxchg %rbx,0xa5dabb(%rip)        # e71e98 <threadglobal_id>
  4143db:	a5 00 
  4143dd:	75 f1                	jne    4143d0 <dang_init_heapobj+0x170>
  4143df:	64 48 89 1c 25 18 ff 	mov    %rbx,%fs:0xffffffffffffff18
  4143e6:	ff ff 
  4143e8:	e9 af fe ff ff       	jmpq   41429c <dang_init_heapobj+0x3c>
  4143ed:	0f 1f 00             	nopl   (%rax)

00000000004143f0 <dang_freeptr>:
  4143f0:	55                   	push   %rbp
  4143f1:	41 57                	push   %r15
  4143f3:	41 56                	push   %r14
  4143f5:	41 55                	push   %r13
  4143f7:	41 54                	push   %r12
  4143f9:	53                   	push   %rbx
  4143fa:	48 81 ec c8 00 00 00 	sub    $0xc8,%rsp
  414401:	49 89 f6             	mov    %rsi,%r14
  414404:	49 89 fc             	mov    %rdi,%r12
  414407:	64 0f b6 04 25 20 ff 	movzbl %fs:0xffffffffffffff20,%eax
  41440e:	ff ff 
  414410:	83 e0 01             	and    $0x1,%eax
  414413:	83 f8 01             	cmp    $0x1,%eax
  414416:	75 0e                	jne    414426 <dang_freeptr+0x36>
  414418:	64 c6 04 25 20 ff ff 	movb   $0x0,%fs:0xffffffffffffff20
  41441f:	ff 00 
  414421:	e9 23 03 00 00       	jmpq   414749 <dang_freeptr+0x359>
  414426:	4c 89 e5             	mov    %r12,%rbp
  414429:	48 c1 ed 0c          	shr    $0xc,%rbp
  41442d:	49 bf 00 00 00 00 00 	movabs $0x400000000000,%r15
  414434:	40 00 00 
  414437:	49 8b 0c ef          	mov    (%r15,%rbp,8),%rcx
  41443b:	45 31 ed             	xor    %r13d,%r13d
  41443e:	48 85 c9             	test   %rcx,%rcx
  414441:	74 1f                	je     414462 <dang_freeptr+0x72>
  414443:	48 89 c8             	mov    %rcx,%rax
  414446:	48 c1 e8 08          	shr    $0x8,%rax
  41444a:	48 89 ea             	mov    %rbp,%rdx
  41444d:	48 c1 e2 0c          	shl    $0xc,%rdx
  414451:	4c 89 e6             	mov    %r12,%rsi
  414454:	48 29 d6             	sub    %rdx,%rsi
  414457:	48 d3 ee             	shr    %cl,%rsi
  41445a:	48 c1 e6 04          	shl    $0x4,%rsi
  41445e:	4c 8b 2c 30          	mov    (%rax,%rsi,1),%r13
  414462:	48 c7 44 24 30 80 4b 	movq   $0x414b80,0x30(%rsp)
  414469:	41 00 
  41446b:	c7 84 24 b8 00 00 00 	movl   $0x4,0xb8(%rsp)
  414472:	04 00 00 00 
  414476:	48 8d 74 24 30       	lea    0x30(%rsp),%rsi
  41447b:	bf 0b 00 00 00       	mov    $0xb,%edi
  414480:	ba a0 1e e7 00       	mov    $0xe71ea0,%edx
  414485:	e8 f6 de fe ff       	callq  402380 <sigaction@plt>
  41448a:	64 8a 04 25 f0 ff ff 	mov    %fs:0xfffffffffffffff0,%al
  414491:	ff 
  414492:	0c 01                	or     $0x1,%al
  414494:	64 88 04 25 f0 ff ff 	mov    %al,%fs:0xfffffffffffffff0
  41449b:	ff 
  41449c:	4d 85 ed             	test   %r13,%r13
  41449f:	0f 84 d8 01 00 00    	je     41467d <dang_freeptr+0x28d>
  4144a5:	48 89 6c 24 20       	mov    %rbp,0x20(%rsp)
  4144aa:	4b 8d 04 26          	lea    (%r14,%r12,1),%rax
  4144ae:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  4144b3:	4c 89 74 24 18       	mov    %r14,0x18(%rsp)
  4144b8:	4c 89 64 24 28       	mov    %r12,0x28(%rsp)
  4144bd:	0f 1f 00             	nopl   (%rax)
  4144c0:	49 8b 45 08          	mov    0x8(%r13),%rax
  4144c4:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  4144c9:	4d 85 ed             	test   %r13,%r13
  4144cc:	0f 84 7c 01 00 00    	je     41464e <dang_freeptr+0x25e>
  4144d2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4144d9:	1f 84 00 00 00 00 00 
  4144e0:	4d 8b 65 20          	mov    0x20(%r13),%r12
  4144e4:	4d 85 e4             	test   %r12,%r12
  4144e7:	0f 8e 40 01 00 00    	jle    41462d <dang_freeptr+0x23d>
  4144ed:	49 8b 6d 18          	mov    0x18(%r13),%rbp
  4144f1:	49 ff c4             	inc    %r12
  4144f4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4144fb:	00 00 00 00 00 
  414500:	49 8b 44 ed 38       	mov    0x38(%r13,%rbp,8),%rax
  414505:	49 89 c6             	mov    %rax,%r14
  414508:	49 c1 ee 18          	shr    $0x18,%r14
  41450c:	0f 84 fe 00 00 00    	je     414610 <dang_freeptr+0x220>
  414512:	48 c1 e8 10          	shr    $0x10,%rax
  414516:	0f b6 d8             	movzbl %al,%ebx
  414519:	49 c1 e6 08          	shl    $0x8,%r14
  41451d:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  414524:	00 00 
  414526:	48 8d b8 28 ff ff ff 	lea    -0xd8(%rax),%rdi
  41452d:	e8 5e de fe ff       	callq  402390 <_setjmp@plt>
  414532:	85 c0                	test   %eax,%eax
  414534:	75 2a                	jne    414560 <dang_freeptr+0x170>
  414536:	4c 09 f3             	or     %r14,%rbx
  414539:	48 8b 03             	mov    (%rbx),%rax
  41453c:	48 3b 44 24 28       	cmp    0x28(%rsp),%rax
  414541:	72 1d                	jb     414560 <dang_freeptr+0x170>
  414543:	48 3b 44 24 08       	cmp    0x8(%rsp),%rax
  414548:	73 16                	jae    414560 <dang_freeptr+0x170>
  41454a:	48 89 c1             	mov    %rax,%rcx
  41454d:	48 ba 00 00 00 00 00 	movabs $0x8000000000000000,%rdx
  414554:	00 00 80 
  414557:	48 09 d1             	or     %rdx,%rcx
  41455a:	f0 48 0f b1 0b       	lock cmpxchg %rcx,(%rbx)
  41455f:	90                   	nop
  414560:	4d 8b 7c ed 38       	mov    0x38(%r13,%rbp,8),%r15
  414565:	49 c1 ef 08          	shr    $0x8,%r15
  414569:	49 81 e7 ff 00 00 00 	and    $0xff,%r15
  414570:	0f 84 9a 00 00 00    	je     414610 <dang_freeptr+0x220>
  414576:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  41457d:	00 00 
  41457f:	48 8d b8 28 ff ff ff 	lea    -0xd8(%rax),%rdi
  414586:	e8 05 de fe ff       	callq  402390 <_setjmp@plt>
  41458b:	85 c0                	test   %eax,%eax
  41458d:	75 31                	jne    4145c0 <dang_freeptr+0x1d0>
  41458f:	4d 09 f7             	or     %r14,%r15
  414592:	49 8b 07             	mov    (%r15),%rax
  414595:	48 3b 44 24 28       	cmp    0x28(%rsp),%rax
  41459a:	72 24                	jb     4145c0 <dang_freeptr+0x1d0>
  41459c:	48 3b 44 24 08       	cmp    0x8(%rsp),%rax
  4145a1:	73 1d                	jae    4145c0 <dang_freeptr+0x1d0>
  4145a3:	48 89 c1             	mov    %rax,%rcx
  4145a6:	48 ba 00 00 00 00 00 	movabs $0x8000000000000000,%rdx
  4145ad:	00 00 80 
  4145b0:	48 09 d1             	or     %rdx,%rcx
  4145b3:	f0 49 0f b1 0f       	lock cmpxchg %rcx,(%r15)
  4145b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4145bf:	00 
  4145c0:	41 0f b6 5c ed 38    	movzbl 0x38(%r13,%rbp,8),%ebx
  4145c6:	48 85 db             	test   %rbx,%rbx
  4145c9:	74 45                	je     414610 <dang_freeptr+0x220>
  4145cb:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  4145d2:	00 00 
  4145d4:	48 8d b8 28 ff ff ff 	lea    -0xd8(%rax),%rdi
  4145db:	e8 b0 dd fe ff       	callq  402390 <_setjmp@plt>
  4145e0:	85 c0                	test   %eax,%eax
  4145e2:	75 2c                	jne    414610 <dang_freeptr+0x220>
  4145e4:	4c 09 f3             	or     %r14,%rbx
  4145e7:	48 8b 03             	mov    (%rbx),%rax
  4145ea:	48 3b 44 24 28       	cmp    0x28(%rsp),%rax
  4145ef:	72 1f                	jb     414610 <dang_freeptr+0x220>
  4145f1:	48 3b 44 24 08       	cmp    0x8(%rsp),%rax
  4145f6:	73 18                	jae    414610 <dang_freeptr+0x220>
  4145f8:	48 89 c1             	mov    %rax,%rcx
  4145fb:	48 ba 00 00 00 00 00 	movabs $0x8000000000000000,%rdx
  414602:	00 00 80 
  414605:	48 09 d1             	or     %rdx,%rcx
  414608:	f0 48 0f b1 0b       	lock cmpxchg %rcx,(%rbx)
  41460d:	0f 1f 00             	nopl   (%rax)
  414610:	48 ff c5             	inc    %rbp
  414613:	49 8b 45 28          	mov    0x28(%r13),%rax
  414617:	48 ff c8             	dec    %rax
  41461a:	48 21 e8             	and    %rbp,%rax
  41461d:	49 ff cc             	dec    %r12
  414620:	49 83 fc 01          	cmp    $0x1,%r12
  414624:	48 89 c5             	mov    %rax,%rbp
  414627:	0f 8f d3 fe ff ff    	jg     414500 <dang_freeptr+0x110>
  41462d:	49 8b 5d 30          	mov    0x30(%r13),%rbx
  414631:	64 c6 04 25 20 ff ff 	movb   $0x1,%fs:0xffffffffffffff20
  414638:	ff 01 
  41463a:	4c 89 ef             	mov    %r13,%rdi
  41463d:	e8 8e dc fe ff       	callq  4022d0 <free@plt>
  414642:	48 85 db             	test   %rbx,%rbx
  414645:	49 89 dd             	mov    %rbx,%r13
  414648:	0f 85 92 fe ff ff    	jne    4144e0 <dang_freeptr+0xf0>
  41464e:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  414653:	4d 85 ed             	test   %r13,%r13
  414656:	0f 85 64 fe ff ff    	jne    4144c0 <dang_freeptr+0xd0>
  41465c:	64 8a 04 25 f0 ff ff 	mov    %fs:0xfffffffffffffff0,%al
  414663:	ff 
  414664:	4c 8b 64 24 28       	mov    0x28(%rsp),%r12
  414669:	48 8b 6c 24 20       	mov    0x20(%rsp),%rbp
  41466e:	4c 8b 74 24 18       	mov    0x18(%rsp),%r14
  414673:	49 bf 00 00 00 00 00 	movabs $0x400000000000,%r15
  41467a:	40 00 00 
  41467d:	24 fe                	and    $0xfe,%al
  41467f:	64 88 04 25 f0 ff ff 	mov    %al,%fs:0xfffffffffffffff0
  414686:	ff 
  414687:	bf 0b 00 00 00       	mov    $0xb,%edi
  41468c:	be a0 1e e7 00       	mov    $0xe71ea0,%esi
  414691:	31 d2                	xor    %edx,%edx
  414693:	e8 e8 dc fe ff       	callq  402380 <sigaction@plt>
  414698:	49 8b 14 ef          	mov    (%r15,%rbp,8),%rdx
  41469c:	0f b6 ca             	movzbl %dl,%ecx
  41469f:	b8 01 00 00 00       	mov    $0x1,%eax
  4146a4:	d3 e0                	shl    %cl,%eax
  4146a6:	48 98                	cltq   
  4146a8:	49 8d 74 06 ff       	lea    -0x1(%r14,%rax,1),%rsi
  4146ad:	48 d3 ee             	shr    %cl,%rsi
  4146b0:	48 85 f6             	test   %rsi,%rsi
  4146b3:	0f 84 90 00 00 00    	je     414749 <dang_freeptr+0x359>
  4146b9:	48 c1 ea 08          	shr    $0x8,%rdx
  4146bd:	48 c1 e5 0c          	shl    $0xc,%rbp
  4146c1:	49 29 ec             	sub    %rbp,%r12
  4146c4:	49 d3 ec             	shr    %cl,%r12
  4146c7:	4c 89 e1             	mov    %r12,%rcx
  4146ca:	48 c1 e1 04          	shl    $0x4,%rcx
  4146ce:	48 01 d1             	add    %rdx,%rcx
  4146d1:	48 8d 7e ff          	lea    -0x1(%rsi),%rdi
  4146d5:	48 89 f5             	mov    %rsi,%rbp
  4146d8:	48 83 e5 07          	and    $0x7,%rbp
  4146dc:	74 2a                	je     414708 <dang_freeptr+0x318>
  4146de:	49 01 ec             	add    %rbp,%r12
  4146e1:	89 f0                	mov    %esi,%eax
  4146e3:	83 e0 07             	and    $0x7,%eax
  4146e6:	48 f7 d8             	neg    %rax
  4146e9:	0f 57 c0             	xorps  %xmm0,%xmm0
  4146ec:	0f 1f 40 00          	nopl   0x0(%rax)
  4146f0:	0f 11 01             	movups %xmm0,(%rcx)
  4146f3:	48 83 c1 10          	add    $0x10,%rcx
  4146f7:	48 ff c0             	inc    %rax
  4146fa:	75 f4                	jne    4146f0 <dang_freeptr+0x300>
  4146fc:	49 c1 e4 04          	shl    $0x4,%r12
  414700:	4c 01 e2             	add    %r12,%rdx
  414703:	48 89 d1             	mov    %rdx,%rcx
  414706:	eb 02                	jmp    41470a <dang_freeptr+0x31a>
  414708:	31 ed                	xor    %ebp,%ebp
  41470a:	48 83 ff 07          	cmp    $0x7,%rdi
  41470e:	72 39                	jb     414749 <dang_freeptr+0x359>
  414710:	48 29 ee             	sub    %rbp,%rsi
  414713:	0f 57 c0             	xorps  %xmm0,%xmm0
  414716:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  41471d:	00 00 00 
  414720:	0f 11 41 70          	movups %xmm0,0x70(%rcx)
  414724:	0f 11 41 60          	movups %xmm0,0x60(%rcx)
  414728:	0f 11 41 50          	movups %xmm0,0x50(%rcx)
  41472c:	0f 11 41 40          	movups %xmm0,0x40(%rcx)
  414730:	0f 11 41 30          	movups %xmm0,0x30(%rcx)
  414734:	0f 11 41 20          	movups %xmm0,0x20(%rcx)
  414738:	0f 11 41 10          	movups %xmm0,0x10(%rcx)
  41473c:	0f 11 01             	movups %xmm0,(%rcx)
  41473f:	48 83 e9 80          	sub    $0xffffffffffffff80,%rcx
  414743:	48 83 c6 f8          	add    $0xfffffffffffffff8,%rsi
  414747:	75 d7                	jne    414720 <dang_freeptr+0x330>
  414749:	48 81 c4 c8 00 00 00 	add    $0xc8,%rsp
  414750:	5b                   	pop    %rbx
  414751:	41 5c                	pop    %r12
  414753:	41 5d                	pop    %r13
  414755:	41 5e                	pop    %r14
  414757:	41 5f                	pop    %r15
  414759:	5d                   	pop    %rbp
  41475a:	c3                   	retq   
  41475b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000414760 <inlinedang_registerptr>:
  414760:	55                   	push   %rbp
  414761:	41 57                	push   %r15
  414763:	41 56                	push   %r14
  414765:	41 55                	push   %r13
  414767:	41 54                	push   %r12
  414769:	53                   	push   %rbx
  41476a:	50                   	push   %rax
  41476b:	49 89 fc             	mov    %rdi,%r12
  41476e:	48 85 f6             	test   %rsi,%rsi
  414771:	0f 8e 36 03 00 00    	jle    414aad <inlinedang_registerptr+0x34d>
  414777:	48 39 35 d2 d7 a5 00 	cmp    %rsi,0xa5d7d2(%rip)        # e71f50 <dang_stack_start>
  41477e:	77 0d                	ja     41478d <inlinedang_registerptr+0x2d>
  414780:	48 39 35 c1 d7 a5 00 	cmp    %rsi,0xa5d7c1(%rip)        # e71f48 <dang_stack_end>
  414787:	0f 83 20 03 00 00    	jae    414aad <inlinedang_registerptr+0x34d>
  41478d:	48 39 35 ac d7 a5 00 	cmp    %rsi,0xa5d7ac(%rip)        # e71f40 <dang_global_start>
  414794:	77 0d                	ja     4147a3 <inlinedang_registerptr+0x43>
  414796:	48 39 35 9b d7 a5 00 	cmp    %rsi,0xa5d79b(%rip)        # e71f38 <dang_global_end>
  41479d:	0f 83 0a 03 00 00    	jae    414aad <inlinedang_registerptr+0x34d>
  4147a3:	48 89 f2             	mov    %rsi,%rdx
  4147a6:	48 c1 ea 0c          	shr    $0xc,%rdx
  4147aa:	48 b8 00 00 00 00 00 	movabs $0x400000000000,%rax
  4147b1:	40 00 00 
  4147b4:	48 8b 0c d0          	mov    (%rax,%rdx,8),%rcx
  4147b8:	48 85 c9             	test   %rcx,%rcx
  4147bb:	0f 84 ec 02 00 00    	je     414aad <inlinedang_registerptr+0x34d>
  4147c1:	48 89 c8             	mov    %rcx,%rax
  4147c4:	48 c1 e8 08          	shr    $0x8,%rax
  4147c8:	48 c1 e2 0c          	shl    $0xc,%rdx
  4147cc:	48 89 f7             	mov    %rsi,%rdi
  4147cf:	48 29 d7             	sub    %rdx,%rdi
  4147d2:	48 d3 ef             	shr    %cl,%rdi
  4147d5:	48 c1 e7 04          	shl    $0x4,%rdi
  4147d9:	48 8b 0c 38          	mov    (%rax,%rdi,1),%rcx
  4147dd:	48 85 c9             	test   %rcx,%rcx
  4147e0:	0f 84 c7 02 00 00    	je     414aad <inlinedang_registerptr+0x34d>
  4147e6:	4c 8b 6c 38 08       	mov    0x8(%rax,%rdi,1),%r13
  4147eb:	48 b8 00 00 00 00 ff 	movabs $0xffffffff00000000,%rax
  4147f2:	ff ff ff 
  4147f5:	48 21 c6             	and    %rax,%rsi
  4147f8:	4d 89 ef             	mov    %r13,%r15
  4147fb:	49 c1 ef 20          	shr    $0x20,%r15
  4147ff:	49 09 f7             	or     %rsi,%r15
  414802:	49 8b 04 24          	mov    (%r12),%rax
  414806:	4c 39 f8             	cmp    %r15,%rax
  414809:	72 0f                	jb     41481a <inlinedang_registerptr+0xba>
  41480b:	44 89 ea             	mov    %r13d,%edx
  41480e:	4c 01 fa             	add    %r15,%rdx
  414811:	48 39 d0             	cmp    %rdx,%rax
  414814:	0f 82 93 02 00 00    	jb     414aad <inlinedang_registerptr+0x34d>
  41481a:	64 4c 8b 34 25 18 ff 	mov    %fs:0xffffffffffffff18,%r14
  414821:	ff ff 
  414823:	4d 85 f6             	test   %r14,%r14
  414826:	75 1f                	jne    414847 <inlinedang_registerptr+0xe7>
  414828:	48 8b 05 69 d6 a5 00 	mov    0xa5d669(%rip),%rax        # e71e98 <threadglobal_id>
  41482f:	4c 8d 70 01          	lea    0x1(%rax),%r14
  414833:	f0 4c 0f b1 35 5c d6 	lock cmpxchg %r14,0xa5d65c(%rip)        # e71e98 <threadglobal_id>
  41483a:	a5 00 
  41483c:	75 f1                	jne    41482f <inlinedang_registerptr+0xcf>
  41483e:	64 4c 89 34 25 18 ff 	mov    %r14,%fs:0xffffffffffffff18
  414845:	ff ff 
  414847:	48 89 cb             	mov    %rcx,%rbx
  41484a:	4c 39 33             	cmp    %r14,(%rbx)
  41484d:	74 55                	je     4148a4 <inlinedang_registerptr+0x144>
  41484f:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
  414853:	48 85 c9             	test   %rcx,%rcx
  414856:	75 ef                	jne    414847 <inlinedang_registerptr+0xe7>
  414858:	48 83 c3 08          	add    $0x8,%rbx
  41485c:	64 c6 04 25 10 ff ff 	movb   $0x1,%fs:0xffffffffffffff10
  414863:	ff 01 
  414865:	bf 38 04 00 00       	mov    $0x438,%edi
  41486a:	e8 21 da fe ff       	callq  402290 <malloc@plt>
  41486f:	48 89 c1             	mov    %rax,%rcx
  414872:	4c 89 31             	mov    %r14,(%rcx)
  414875:	0f 57 c0             	xorps  %xmm0,%xmm0
  414878:	0f 11 41 18          	movups %xmm0,0x18(%rcx)
  41487c:	0f 11 41 08          	movups %xmm0,0x8(%rcx)
  414880:	48 c7 41 28 80 00 00 	movq   $0x80,0x28(%rcx)
  414887:	00 
  414888:	48 c7 41 30 00 00 00 	movq   $0x0,0x30(%rcx)
  41488f:	00 
  414890:	48 8b 13             	mov    (%rbx),%rdx
  414893:	48 89 d0             	mov    %rdx,%rax
  414896:	f0 48 0f b1 0b       	lock cmpxchg %rcx,(%rbx)
  41489b:	75 f3                	jne    414890 <inlinedang_registerptr+0x130>
  41489d:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  4148a1:	48 89 cb             	mov    %rcx,%rbx
  4148a4:	4c 8b 73 30          	mov    0x30(%rbx),%r14
  4148a8:	4d 85 f6             	test   %r14,%r14
  4148ab:	4c 0f 44 f3          	cmove  %rbx,%r14
  4148af:	f3 41 0f 7e 46 28    	movq   0x28(%r14),%xmm0
  4148b5:	66 0f 62 05 13 4a 00 	punpckldq 0x4a13(%rip),%xmm0        # 4192d0 <.LCPI56_0>
  4148bc:	00 
  4148bd:	66 0f 5c 05 1b 4a 00 	subpd  0x4a1b(%rip),%xmm0        # 4192e0 <.LCPI56_1>
  4148c4:	00 
  4148c5:	66 0f 70 c8 4e       	pshufd $0x4e,%xmm0,%xmm1
  4148ca:	66 0f 58 c8          	addpd  %xmm0,%xmm1
  4148ce:	f2 0f 59 0d 1a 4a 00 	mulsd  0x4a1a(%rip),%xmm1        # 4192f0 <.LCPI56_2>
  4148d5:	00 
  4148d6:	f2 0f 10 05 1a 4a 00 	movsd  0x4a1a(%rip),%xmm0        # 4192f8 <.LCPI56_3>
  4148dd:	00 
  4148de:	66 0f 28 d1          	movapd %xmm1,%xmm2
  4148e2:	f2 0f 5c d0          	subsd  %xmm0,%xmm2
  4148e6:	f2 48 0f 2c c2       	cvttsd2si %xmm2,%rax
  4148eb:	48 b9 00 00 00 00 00 	movabs $0x8000000000000000,%rcx
  4148f2:	00 00 80 
  4148f5:	48 31 c1             	xor    %rax,%rcx
  4148f8:	f2 48 0f 2c c1       	cvttsd2si %xmm1,%rax
  4148fd:	66 0f 2e c8          	ucomisd %xmm0,%xmm1
  414901:	48 0f 43 c1          	cmovae %rcx,%rax
  414905:	49 39 46 20          	cmp    %rax,0x20(%r14)
  414909:	0f 83 b2 01 00 00    	jae    414ac1 <inlinedang_registerptr+0x361>
  41490f:	4d 8b 46 10          	mov    0x10(%r14),%r8
  414913:	4c 89 e0             	mov    %r12,%rax
  414916:	48 c1 e8 08          	shr    $0x8,%rax
  41491a:	41 0f b6 fc          	movzbl %r12b,%edi
  41491e:	45 31 ed             	xor    %r13d,%r13d
  414921:	45 85 c0             	test   %r8d,%r8d
  414924:	0f 8e b5 00 00 00    	jle    4149df <inlinedang_registerptr+0x27f>
  41492a:	48 85 ff             	test   %rdi,%rdi
  41492d:	4d 63 e0             	movslq %r8d,%r12
  414930:	0f 84 b7 00 00 00    	je     4149ed <inlinedang_registerptr+0x28d>
  414936:	49 8d 70 ff          	lea    -0x1(%r8),%rsi
  41493a:	45 31 c9             	xor    %r9d,%r9d
  41493d:	b9 01 00 00 00       	mov    $0x1,%ecx
  414942:	4d 89 c7             	mov    %r8,%r15
  414945:	49 89 fa             	mov    %rdi,%r10
  414948:	45 31 ed             	xor    %r13d,%r13d
  41494b:	45 31 db             	xor    %r11d,%r11d
  41494e:	66 90                	xchg   %ax,%ax
  414950:	49 8b 54 f6 38       	mov    0x38(%r14,%rsi,8),%rdx
  414955:	48 89 d3             	mov    %rdx,%rbx
  414958:	48 c1 eb 18          	shr    $0x18,%rbx
  41495c:	48 39 d8             	cmp    %rbx,%rax
  41495f:	75 5f                	jne    4149c0 <inlinedang_registerptr+0x260>
  414961:	48 89 d3             	mov    %rdx,%rbx
  414964:	48 c1 eb 10          	shr    $0x10,%rbx
  414968:	0f b6 db             	movzbl %bl,%ebx
  41496b:	0f b6 ee             	movzbl %dh,%ebp
  41496e:	0f b6 d2             	movzbl %dl,%edx
  414971:	48 39 df             	cmp    %rbx,%rdi
  414974:	0f 84 19 01 00 00    	je     414a93 <inlinedang_registerptr+0x333>
  41497a:	48 39 ef             	cmp    %rbp,%rdi
  41497d:	0f 84 10 01 00 00    	je     414a93 <inlinedang_registerptr+0x333>
  414983:	48 85 ed             	test   %rbp,%rbp
  414986:	74 1e                	je     4149a6 <inlinedang_registerptr+0x246>
  414988:	48 39 d7             	cmp    %rdx,%rdi
  41498b:	0f 84 02 01 00 00    	je     414a93 <inlinedang_registerptr+0x333>
  414991:	48 85 d2             	test   %rdx,%rdx
  414994:	4c 0f 44 df          	cmove  %rdi,%r11
  414998:	4c 0f 44 ed          	cmove  %rbp,%r13
  41499c:	4c 0f 44 d3          	cmove  %rbx,%r10
  4149a0:	4c 0f 44 fe          	cmove  %rsi,%r15
  4149a4:	eb 1a                	jmp    4149c0 <inlinedang_registerptr+0x260>
  4149a6:	49 89 d3             	mov    %rdx,%r11
  4149a9:	49 89 fd             	mov    %rdi,%r13
  4149ac:	49 89 da             	mov    %rbx,%r10
  4149af:	49 89 f7             	mov    %rsi,%r15
  4149b2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  4149b9:	1f 84 00 00 00 00 00 
  4149c0:	48 83 f9 03          	cmp    $0x3,%rcx
  4149c4:	0f 8f a8 00 00 00    	jg     414a72 <inlinedang_registerptr+0x312>
  4149ca:	48 ff ce             	dec    %rsi
  4149cd:	49 39 cc             	cmp    %rcx,%r12
  4149d0:	48 8d 49 01          	lea    0x1(%rcx),%rcx
  4149d4:	0f 8f 76 ff ff ff    	jg     414950 <inlinedang_registerptr+0x1f0>
  4149da:	e9 93 00 00 00       	jmpq   414a72 <inlinedang_registerptr+0x312>
  4149df:	4d 89 c7             	mov    %r8,%r15
  4149e2:	49 89 fa             	mov    %rdi,%r10
  4149e5:	45 31 db             	xor    %r11d,%r11d
  4149e8:	e9 85 00 00 00       	jmpq   414a72 <inlinedang_registerptr+0x312>
  4149ed:	49 8d 48 ff          	lea    -0x1(%r8),%rcx
  4149f1:	45 31 d2             	xor    %r10d,%r10d
  4149f4:	be 01 00 00 00       	mov    $0x1,%esi
  4149f9:	4d 89 c7             	mov    %r8,%r15
  4149fc:	45 31 ed             	xor    %r13d,%r13d
  4149ff:	45 31 db             	xor    %r11d,%r11d
  414a02:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  414a09:	1f 84 00 00 00 00 00 
  414a10:	49 8b 54 ce 38       	mov    0x38(%r14,%rcx,8),%rdx
  414a15:	48 89 d7             	mov    %rdx,%rdi
  414a18:	48 c1 ef 18          	shr    $0x18,%rdi
  414a1c:	48 39 f8             	cmp    %rdi,%rax
  414a1f:	75 3f                	jne    414a60 <inlinedang_registerptr+0x300>
  414a21:	48 89 d7             	mov    %rdx,%rdi
  414a24:	48 c1 ef 10          	shr    $0x10,%rdi
  414a28:	48 81 e7 ff 00 00 00 	and    $0xff,%rdi
  414a2f:	0f b6 de             	movzbl %dh,%ebx
  414a32:	0f b6 d2             	movzbl %dl,%edx
  414a35:	0f 84 81 00 00 00    	je     414abc <inlinedang_registerptr+0x35c>
  414a3b:	48 85 db             	test   %rbx,%rbx
  414a3e:	74 11                	je     414a51 <inlinedang_registerptr+0x2f1>
  414a40:	48 85 d2             	test   %rdx,%rdx
  414a43:	4c 0f 44 df          	cmove  %rdi,%r11
  414a47:	4c 0f 44 eb          	cmove  %rbx,%r13
  414a4b:	4c 0f 44 f9          	cmove  %rcx,%r15
  414a4f:	eb 0f                	jmp    414a60 <inlinedang_registerptr+0x300>
  414a51:	49 89 d3             	mov    %rdx,%r11
  414a54:	49 89 fd             	mov    %rdi,%r13
  414a57:	49 89 cf             	mov    %rcx,%r15
  414a5a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  414a60:	48 83 fe 03          	cmp    $0x3,%rsi
  414a64:	7f 0c                	jg     414a72 <inlinedang_registerptr+0x312>
  414a66:	48 ff c9             	dec    %rcx
  414a69:	49 39 f4             	cmp    %rsi,%r12
  414a6c:	48 8d 76 01          	lea    0x1(%rsi),%rsi
  414a70:	7f 9e                	jg     414a10 <inlinedang_registerptr+0x2b0>
  414a72:	48 c1 e0 18          	shl    $0x18,%rax
  414a76:	49 c1 e2 10          	shl    $0x10,%r10
  414a7a:	49 c1 e5 08          	shl    $0x8,%r13
  414a7e:	4c 09 d8             	or     %r11,%rax
  414a81:	4c 09 e8             	or     %r13,%rax
  414a84:	4c 09 d0             	or     %r10,%rax
  414a87:	4b 89 44 fe 38       	mov    %rax,0x38(%r14,%r15,8)
  414a8c:	4d 63 cf             	movslq %r15d,%r9
  414a8f:	4d 8b 46 10          	mov    0x10(%r14),%r8
  414a93:	4d 39 c1             	cmp    %r8,%r9
  414a96:	75 15                	jne    414aad <inlinedang_registerptr+0x34d>
  414a98:	49 ff c0             	inc    %r8
  414a9b:	49 8b 46 28          	mov    0x28(%r14),%rax
  414a9f:	48 ff c8             	dec    %rax
  414aa2:	4c 21 c0             	and    %r8,%rax
  414aa5:	49 89 46 10          	mov    %rax,0x10(%r14)
  414aa9:	49 ff 46 20          	incq   0x20(%r14)
  414aad:	48 83 c4 08          	add    $0x8,%rsp
  414ab1:	5b                   	pop    %rbx
  414ab2:	41 5c                	pop    %r12
  414ab4:	41 5d                	pop    %r13
  414ab6:	41 5e                	pop    %r14
  414ab8:	41 5f                	pop    %r15
  414aba:	5d                   	pop    %rbp
  414abb:	c3                   	retq   
  414abc:	45 31 c9             	xor    %r9d,%r9d
  414abf:	eb d2                	jmp    414a93 <inlinedang_registerptr+0x333>
  414ac1:	44 89 ea             	mov    %r13d,%edx
  414ac4:	4c 01 fa             	add    %r15,%rdx
  414ac7:	4c 89 f7             	mov    %r14,%rdi
  414aca:	4c 89 fe             	mov    %r15,%rsi
  414acd:	e8 2e 01 00 00       	callq  414c00 <dang_clear_objlog>
  414ad2:	49 8b 76 28          	mov    0x28(%r14),%rsi
  414ad6:	49 39 76 20          	cmp    %rsi,0x20(%r14)
  414ada:	0f 82 2f fe ff ff    	jb     41490f <inlinedang_registerptr+0x1af>
  414ae0:	48 8b 43 30          	mov    0x30(%rbx),%rax
  414ae4:	64 c6 04 25 10 ff ff 	movb   $0x1,%fs:0xffffffffffffff10
  414aeb:	ff 01 
  414aed:	48 85 c0             	test   %rax,%rax
  414af0:	74 49                	je     414b3b <inlinedang_registerptr+0x3db>
  414af2:	64 c6 04 25 20 ff ff 	movb   $0x1,%fs:0xffffffffffffff20
  414af9:	ff 01 
  414afb:	48 c1 e6 04          	shl    $0x4,%rsi
  414aff:	48 83 c6 38          	add    $0x38,%rsi
  414b03:	4c 89 f7             	mov    %r14,%rdi
  414b06:	e8 95 d8 fe ff       	callq  4023a0 <realloc@plt>
  414b0b:	4c 39 f0             	cmp    %r14,%rax
  414b0e:	75 12                	jne    414b22 <inlinedang_registerptr+0x3c2>
  414b10:	64 c6 04 25 10 ff ff 	movb   $0x0,%fs:0xffffffffffffff10
  414b17:	ff 00 
  414b19:	64 c6 04 25 20 ff ff 	movb   $0x0,%fs:0xffffffffffffff20
  414b20:	ff 00 
  414b22:	48 8b 48 28          	mov    0x28(%rax),%rcx
  414b26:	48 89 48 10          	mov    %rcx,0x10(%rax)
  414b2a:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  414b31:	00 
  414b32:	48 01 c9             	add    %rcx,%rcx
  414b35:	48 89 48 28          	mov    %rcx,0x28(%rax)
  414b39:	eb 34                	jmp    414b6f <inlinedang_registerptr+0x40f>
  414b3b:	bf 38 04 00 00       	mov    $0x438,%edi
  414b40:	e8 4b d7 fe ff       	callq  402290 <malloc@plt>
  414b45:	64 48 8b 0c 25 18 ff 	mov    %fs:0xffffffffffffff18,%rcx
  414b4c:	ff ff 
  414b4e:	48 89 08             	mov    %rcx,(%rax)
  414b51:	66 0f 57 c0          	xorpd  %xmm0,%xmm0
  414b55:	66 0f 11 40 18       	movupd %xmm0,0x18(%rax)
  414b5a:	66 0f 11 40 08       	movupd %xmm0,0x8(%rax)
  414b5f:	48 c7 40 28 80 00 00 	movq   $0x80,0x28(%rax)
  414b66:	00 
  414b67:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  414b6e:	00 
  414b6f:	48 89 43 30          	mov    %rax,0x30(%rbx)
  414b73:	49 89 c6             	mov    %rax,%r14
  414b76:	e9 94 fd ff ff       	jmpq   41490f <inlinedang_registerptr+0x1af>
  414b7b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000414b80 <dang_segv_handler>:
  414b80:	53                   	push   %rbx
  414b81:	48 81 ec 80 00 00 00 	sub    $0x80,%rsp
  414b88:	48 8d 1c 24          	lea    (%rsp),%rbx
  414b8c:	48 89 df             	mov    %rbx,%rdi
  414b8f:	e8 1c d8 fe ff       	callq  4023b0 <sigemptyset@plt>
  414b94:	be 0b 00 00 00       	mov    $0xb,%esi
  414b99:	48 89 df             	mov    %rbx,%rdi
  414b9c:	e8 1f d8 fe ff       	callq  4023c0 <sigaddset@plt>
  414ba1:	bf 01 00 00 00       	mov    $0x1,%edi
  414ba6:	31 d2                	xor    %edx,%edx
  414ba8:	48 89 de             	mov    %rbx,%rsi
  414bab:	e8 20 d8 fe ff       	callq  4023d0 <pthread_sigmask@plt>
  414bb0:	64 f6 04 25 f0 ff ff 	testb  $0x1,%fs:0xfffffffffffffff0
  414bb7:	ff 01 
  414bb9:	75 24                	jne    414bdf <dang_segv_handler+0x5f>
  414bbb:	bf 0b 00 00 00       	mov    $0xb,%edi
  414bc0:	be a0 1e e7 00       	mov    $0xe71ea0,%esi
  414bc5:	31 d2                	xor    %edx,%edx
  414bc7:	e8 b4 d7 fe ff       	callq  402380 <sigaction@plt>
  414bcc:	bf 0b 00 00 00       	mov    $0xb,%edi
  414bd1:	e8 0a d8 fe ff       	callq  4023e0 <raise@plt>
  414bd6:	48 81 c4 80 00 00 00 	add    $0x80,%rsp
  414bdd:	5b                   	pop    %rbx
  414bde:	c3                   	retq   
  414bdf:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  414be6:	00 00 
  414be8:	48 8d b8 28 ff ff ff 	lea    -0xd8(%rax),%rdi
  414bef:	be 01 00 00 00       	mov    $0x1,%esi
  414bf4:	e8 f7 d7 fe ff       	callq  4023f0 <longjmp@plt>
  414bf9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000414c00 <dang_clear_objlog>:
  414c00:	55                   	push   %rbp
  414c01:	41 57                	push   %r15
  414c03:	41 56                	push   %r14
  414c05:	41 55                	push   %r13
  414c07:	41 54                	push   %r12
  414c09:	53                   	push   %rbx
  414c0a:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
  414c11:	49 89 d6             	mov    %rdx,%r14
  414c14:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  414c19:	49 89 fc             	mov    %rdi,%r12
  414c1c:	49 8b 5c 24 18       	mov    0x18(%r12),%rbx
  414c21:	4d 8b 6c 24 20       	mov    0x20(%r12),%r13
  414c26:	48 c7 44 24 10 80 4b 	movq   $0x414b80,0x10(%rsp)
  414c2d:	41 00 
  414c2f:	c7 84 24 98 00 00 00 	movl   $0x4,0x98(%rsp)
  414c36:	04 00 00 00 
  414c3a:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
  414c3f:	bf 0b 00 00 00       	mov    $0xb,%edi
  414c44:	ba a0 1e e7 00       	mov    $0xe71ea0,%edx
  414c49:	e8 32 d7 fe ff       	callq  402380 <sigaction@plt>
  414c4e:	64 8a 0c 25 f0 ff ff 	mov    %fs:0xfffffffffffffff0,%cl
  414c55:	ff 
  414c56:	80 c9 01             	or     $0x1,%cl
  414c59:	64 88 0c 25 f0 ff ff 	mov    %cl,%fs:0xfffffffffffffff0
  414c60:	ff 
  414c61:	4d 85 ed             	test   %r13,%r13
  414c64:	0f 8e 0f 01 00 00    	jle    414d79 <dang_clear_objlog+0x179>
  414c6a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  414c70:	49 8b 6c dc 38       	mov    0x38(%r12,%rbx,8),%rbp
  414c75:	49 89 ef             	mov    %rbp,%r15
  414c78:	49 c1 ef 18          	shr    $0x18,%r15
  414c7c:	0f 84 be 00 00 00    	je     414d40 <dang_clear_objlog+0x140>
  414c82:	49 c1 e7 08          	shl    $0x8,%r15
  414c86:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  414c8d:	00 00 
  414c8f:	48 8d b8 28 ff ff ff 	lea    -0xd8(%rax),%rdi
  414c96:	e8 f5 d6 fe ff       	callq  402390 <_setjmp@plt>
  414c9b:	85 c0                	test   %eax,%eax
  414c9d:	75 21                	jne    414cc0 <dang_clear_objlog+0xc0>
  414c9f:	48 c1 ed 10          	shr    $0x10,%rbp
  414ca3:	40 0f b6 c5          	movzbl %bpl,%eax
  414ca7:	4c 09 f8             	or     %r15,%rax
  414caa:	48 8b 00             	mov    (%rax),%rax
  414cad:	4c 39 f0             	cmp    %r14,%rax
  414cb0:	73 0e                	jae    414cc0 <dang_clear_objlog+0xc0>
  414cb2:	48 3b 44 24 08       	cmp    0x8(%rsp),%rax
  414cb7:	0f 83 a4 00 00 00    	jae    414d61 <dang_clear_objlog+0x161>
  414cbd:	0f 1f 00             	nopl   (%rax)
  414cc0:	49 8b 6c dc 38       	mov    0x38(%r12,%rbx,8),%rbp
  414cc5:	48 c1 ed 08          	shr    $0x8,%rbp
  414cc9:	48 81 e5 ff 00 00 00 	and    $0xff,%rbp
  414cd0:	74 6e                	je     414d40 <dang_clear_objlog+0x140>
  414cd2:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  414cd9:	00 00 
  414cdb:	48 8d b8 28 ff ff ff 	lea    -0xd8(%rax),%rdi
  414ce2:	e8 a9 d6 fe ff       	callq  402390 <_setjmp@plt>
  414ce7:	85 c0                	test   %eax,%eax
  414ce9:	75 15                	jne    414d00 <dang_clear_objlog+0x100>
  414ceb:	4c 09 fd             	or     %r15,%rbp
  414cee:	48 8b 45 00          	mov    0x0(%rbp),%rax
  414cf2:	4c 39 f0             	cmp    %r14,%rax
  414cf5:	73 09                	jae    414d00 <dang_clear_objlog+0x100>
  414cf7:	48 3b 44 24 08       	cmp    0x8(%rsp),%rax
  414cfc:	73 68                	jae    414d66 <dang_clear_objlog+0x166>
  414cfe:	66 90                	xchg   %ax,%ax
  414d00:	41 0f b6 6c dc 38    	movzbl 0x38(%r12,%rbx,8),%ebp
  414d06:	48 85 ed             	test   %rbp,%rbp
  414d09:	74 35                	je     414d40 <dang_clear_objlog+0x140>
  414d0b:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  414d12:	00 00 
  414d14:	48 8d b8 28 ff ff ff 	lea    -0xd8(%rax),%rdi
  414d1b:	e8 70 d6 fe ff       	callq  402390 <_setjmp@plt>
  414d20:	85 c0                	test   %eax,%eax
  414d22:	75 1c                	jne    414d40 <dang_clear_objlog+0x140>
  414d24:	4c 09 fd             	or     %r15,%rbp
  414d27:	48 8b 45 00          	mov    0x0(%rbp),%rax
  414d2b:	4c 39 f0             	cmp    %r14,%rax
  414d2e:	73 10                	jae    414d40 <dang_clear_objlog+0x140>
  414d30:	48 3b 44 24 08       	cmp    0x8(%rsp),%rax
  414d35:	73 34                	jae    414d6b <dang_clear_objlog+0x16b>
  414d37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  414d3e:	00 00 
  414d40:	48 ff c3             	inc    %rbx
  414d43:	49 8b 44 24 28       	mov    0x28(%r12),%rax
  414d48:	48 ff c8             	dec    %rax
  414d4b:	48 21 d8             	and    %rbx,%rax
  414d4e:	49 83 fd 01          	cmp    $0x1,%r13
  414d52:	4d 8d 6d ff          	lea    -0x1(%r13),%r13
  414d56:	48 89 c3             	mov    %rax,%rbx
  414d59:	0f 8f 11 ff ff ff    	jg     414c70 <dang_clear_objlog+0x70>
  414d5f:	eb 0d                	jmp    414d6e <dang_clear_objlog+0x16e>
  414d61:	48 89 d8             	mov    %rbx,%rax
  414d64:	eb 08                	jmp    414d6e <dang_clear_objlog+0x16e>
  414d66:	48 89 d8             	mov    %rbx,%rax
  414d69:	eb 03                	jmp    414d6e <dang_clear_objlog+0x16e>
  414d6b:	48 89 d8             	mov    %rbx,%rax
  414d6e:	64 8a 0c 25 f0 ff ff 	mov    %fs:0xfffffffffffffff0,%cl
  414d75:	ff 
  414d76:	48 89 c3             	mov    %rax,%rbx
  414d79:	80 e1 fe             	and    $0xfe,%cl
  414d7c:	64 88 0c 25 f0 ff ff 	mov    %cl,%fs:0xfffffffffffffff0
  414d83:	ff 
  414d84:	bf 0b 00 00 00       	mov    $0xb,%edi
  414d89:	be a0 1e e7 00       	mov    $0xe71ea0,%esi
  414d8e:	31 d2                	xor    %edx,%edx
  414d90:	e8 eb d5 fe ff       	callq  402380 <sigaction@plt>
  414d95:	4d 89 6c 24 20       	mov    %r13,0x20(%r12)
  414d9a:	49 89 5c 24 18       	mov    %rbx,0x18(%r12)
  414d9f:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
  414da6:	5b                   	pop    %rbx
  414da7:	41 5c                	pop    %r12
  414da9:	41 5d                	pop    %r13
  414dab:	41 5e                	pop    %r14
  414dad:	41 5f                	pop    %r15
  414daf:	5d                   	pop    %rbp
  414db0:	c3                   	retq   
  414db1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  414db8:	0f 1f 84 00 00 00 00 
  414dbf:	00 

0000000000414dc0 <__libc_csu_init>:
  414dc0:	41 57                	push   %r15
  414dc2:	41 89 ff             	mov    %edi,%r15d
  414dc5:	41 56                	push   %r14
  414dc7:	49 89 f6             	mov    %rsi,%r14
  414dca:	41 55                	push   %r13
  414dcc:	49 89 d5             	mov    %rdx,%r13
  414dcf:	41 54                	push   %r12
  414dd1:	4c 8d 25 18 bf 00 00 	lea    0xbf18(%rip),%r12        # 420cf0 <__frame_dummy_init_array_entry>
  414dd8:	55                   	push   %rbp
  414dd9:	48 8d 2d 20 bf 00 00 	lea    0xbf20(%rip),%rbp        # 420d00 <__init_array_end>
  414de0:	53                   	push   %rbx
  414de1:	4c 29 e5             	sub    %r12,%rbp
  414de4:	31 db                	xor    %ebx,%ebx
  414de6:	48 c1 fd 03          	sar    $0x3,%rbp
  414dea:	48 83 ec 08          	sub    $0x8,%rsp
  414dee:	e8 75 d3 fe ff       	callq  402168 <_init>
  414df3:	48 85 ed             	test   %rbp,%rbp
  414df6:	74 1e                	je     414e16 <__libc_csu_init+0x56>
  414df8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  414dff:	00 
  414e00:	4c 89 ea             	mov    %r13,%rdx
  414e03:	4c 89 f6             	mov    %r14,%rsi
  414e06:	44 89 ff             	mov    %r15d,%edi
  414e09:	41 ff 14 dc          	callq  *(%r12,%rbx,8)
  414e0d:	48 83 c3 01          	add    $0x1,%rbx
  414e11:	48 39 eb             	cmp    %rbp,%rbx
  414e14:	75 ea                	jne    414e00 <__libc_csu_init+0x40>
  414e16:	48 83 c4 08          	add    $0x8,%rsp
  414e1a:	5b                   	pop    %rbx
  414e1b:	5d                   	pop    %rbp
  414e1c:	41 5c                	pop    %r12
  414e1e:	41 5d                	pop    %r13
  414e20:	41 5e                	pop    %r14
  414e22:	41 5f                	pop    %r15
  414e24:	c3                   	retq   
  414e25:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  414e2c:	00 00 00 00 

0000000000414e30 <__libc_csu_fini>:
  414e30:	f3 c3                	repz retq 
  414e32:	66 90                	xchg   %ax,%ax

Disassembly of section .fini:

0000000000414e34 <_fini>:
  414e34:	48 83 ec 08          	sub    $0x8,%rsp
  414e38:	48 83 c4 08          	add    $0x8,%rsp
  414e3c:	c3                   	retq   
