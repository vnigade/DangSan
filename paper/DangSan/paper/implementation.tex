\section{Implementation}
We implemented \projectname{} on linux with \metalloc{} (metadata management) and \texttt{tcmalloc} ~\cite{ghemawat2009tcmalloc} (custom memory allocator). Static instrumentation is built using LLVM $3.8$. We do not instrument (malloc, calloc, realloc, new) and deallocation (free, delete) function calls. \metalloc{} provides a way to insert custom hook before and/or after allocation (deallocation) functions. We instrument only pointer store instruction. Run-time tracking functionality is provided in a static library. \\

\textbf{Application Compatibility.}
We found that following cases can break application compatibility. $1)$ \textbf{Pointer subtraction}: Subtracting two dangling pointers pointing to the same object is a valid code statement. It can break due to \projectname{}. Our system sets pointer value to \texttt{NULL} when object is freed. Therefore, subtracting two dangling pointers result into $0$ (i.e. incorrect value). To solve this problem, we invalidate pointer by setting the most significant bit of pointer value to $1$. On Linux $64$-bit, this invalid pointer value points into kernel address space. $2)$ \textbf{Off-by-One byte}: Some valid pointers can point out-of-bound by one byte. For example, STL vector has three fields, \texttt{start}, \texttt{next} and \texttt{end}. \texttt{start} points to start of the array memory. \texttt{next} points to next empty array location. \texttt{end} points to end of the array memory. \texttt{next} and \texttt{end} can point out-of-bound by one byte. Therefore, these pointers will get registered for wrong object. When wrong object is freed, \texttt{next} and \texttt{end} pointers will get invalidated. To solve this problem, we increase object allocation size by one. $3)$ \textbf{GCC issue}: We found one weird pointer usage in SPEC2006 \texttt{gcc}. \texttt{gcc} allocates a memory and stores allocated address minus some constant value into the pointer (i.e. no root address is stored). Registration of this pointer happens for wrong object. This pointer usage is wrong. Thus, we handled this issue as a special case during static instrumentation. For \texttt{GEP} LLVM instruction, when indices operand is negative constant or \texttt{SUB} LLVM instruction, we take root address of the object.

