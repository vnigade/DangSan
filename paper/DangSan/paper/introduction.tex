\section{Introduction}
%1) Problem, vulnerabilities and impact, 
Many system applications are written in unsafe languages like C/C++. These languages are mostly used to have explicit control over hardware interfaces for optimal performance. For example, pointers are used to have explicit control on memory management. However, incorrect use of explicit control can lead to security vulnerabilities. Pointers incorrect use may lead to memory corruption. Use of dangling pointer is one instance of incorrect behaviour. \\

%2)Use-After-Free vulnerability
% \textbf{Mention stats and impact of recently.}\\
Dangling pointer is a pointer that points to the freed object. Use of dangling pointers i.e. Use-after-Free or Double-Free affects application integrity, availability and confidentiality~\cite{CVEMitre}. Dangling pointer may write invalid data into newly allocated memory resulting into data corruption, thereby affecting integrity. Memory allocators consolidate two adjacent freed chunks into single big chunk. When Use-after-Free occurs after chunk consolidation, invalid data can be used as chunk information. This state results into free-list corruption that can lead to application crash, thereby affecting availability. Moreover, Use-after-Free before chunk consolidation is prone to arbitrary code execution, thereby affecting confidentiality. Segmentation fault due to Use-after-Free can leak memory addresses, thereby making Address Space Randomization (ASLR) protection weak ~\cite{serna2012info}. Also, Use-after-Free vulnerabilities are reported and exploited in widely used browsers~\cite{tutorial2010internet, IRCVE}. Most of the highly critical vulnerabilities can be exploited with low complexity. The impact includes unauthorized information disclosure/~modification or service disruption ~\cite{NVDNist}. \\

%3) mitigation techniques
%\textbf{Undangle, Cling and other.Add techquines that are used in the past to mitigate dangling pointers exploit.}
% WE should mention what is pointer-object relationship briefy. with common development practice is to set NULL.s 
Common defensive coding practice is to set dangling pointer to benign value \texttt{NULL}. Manually, this practice is not scalable in large code base when multiple pointer copies are present. Same technique can be used dynamically to track all pointers to the object and set pointer value to \texttt{NULL} when object is freed. State-of-the-art mitigation techniques like \dangnull{} ~\cite{lee2015dangnull}, \freesentry{}~\cite{younan2015freesentry} tracks pointer-object relationship dynamically (during run-time). Compiler infrastructure like CIL ~\cite{necula2002cil}, LLVM~\cite{lattner2004llvm} is used to insert run-time pointer tracking functions. \dangnull{} uses red-black tree data structure to store and retrieve metadata (i.e. pointer-object relationship). It provides thread-safety for data structure operations using mutexes. However, \dangnull{} incurs high average performance overhead of $80\%$. Also, it does not track stack and global pointers. \freesentry{} has an average performance overhead of $25\%$. This performance is reported using CIL for static instrumentation. Performance numbers with LLVM are higher than CIL~\cite{freesentrypppt}. \freesentry{} uses hash-table to store and retrieve metadata. However, thread-safety for data structure protection is missing in \freesentry{}. Thus, it can break multi-threaded (production) applications. Also, \freesentry{} has not evaluated throughput degradation of web-servers. Therefore, state-of-the-art mitigation techniques either incur high performance overhead or have limited applicability. \\% Should we write missing throughput numbers for webservers

%4) Brief about first design 
In dynamic analysis, pointer-object relationship is tracked. To store and retrieve relationship information, we need highly efficient and complete shadow memory management framework. It should have low lookup and memory overhead. \metalloc{} ~\cite{istvan2016metalloc} is an efficient metadata management scheme. We first evaluated effectiveness of metadata management framework, \metalloc{}. We implemented \freesentry{} scheme using \metalloc{}. We found that thread-safety (i.e. data structure protection) introduces huge performance overhead of $70\%$. Applications in production environment are highly multi-threaded. We have proposed simple and fast lock-less Use-after-Free detection scheme, called as \projectname{} to protect multi-threaded applications efficiently. \projectname{} maintains per-Thread and per-Object metadata, thereby it reduces thread synchronization. We implemented \projectname{} using \metalloc{}. \projectname{} has moderate run-time overhead of $43.9\%$ when only heap pointers are tracked. Moreover, it introduces only $4\%$ more overhead when all pointers are tracked (Stack, Heap and Global).
